"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/framer-motion";
exports.ids = ["vendor-chunks/framer-motion"];
exports.modules = {

/***/ "(ssr)/./node_modules/framer-motion/dist/cjs/index.js":
/*!******************************************************!*\
  !*** ./node_modules/framer-motion/dist/cjs/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar motionUtils = __webpack_require__(/*! motion-utils */ \"(ssr)/./node_modules/motion-utils/dist/cjs/index.js\");\nvar motionDom = __webpack_require__(/*! motion-dom */ \"(ssr)/./node_modules/motion-dom/dist/cjs/index.js\");\nvar jsxRuntime = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nfunction _interopNamespaceDefault(e) {\n    var n = Object.create(null);\n    if (e) {\n        Object.keys(e).forEach(function(k) {\n            if (k !== \"default\") {\n                var d = Object.getOwnPropertyDescriptor(e, k);\n                Object.defineProperty(n, k, d.get ? d : {\n                    enumerable: true,\n                    get: function() {\n                        return e[k];\n                    }\n                });\n            }\n        });\n    }\n    n.default = e;\n    return Object.freeze(n);\n}\nvar React__namespace = /*#__PURE__*/ _interopNamespaceDefault(React);\nconst warned = new Set();\nfunction warnOnce(condition, message, element) {\n    if (condition || warned.has(message)) return;\n    console.warn(message);\n    if (element) console.warn(element);\n    warned.add(message);\n}\nfunction createDOMMotionComponentProxy(componentFactory) {\n    if (typeof Proxy === \"undefined\") {\n        return componentFactory;\n    }\n    /**\n     * A cache of generated `motion` components, e.g `motion.div`, `motion.input` etc.\n     * Rather than generating them anew every render.\n     */ const componentCache = new Map();\n    const deprecatedFactoryFunction = (...args)=>{\n        if (true) {\n            warnOnce(false, \"motion() is deprecated. Use motion.create() instead.\");\n        }\n        return componentFactory(...args);\n    };\n    return new Proxy(deprecatedFactoryFunction, {\n        /**\n         * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.\n         * The prop name is passed through as `key` and we can use that to generate a `motion`\n         * DOM component with that name.\n         */ get: (_target, key)=>{\n            if (key === \"create\") return componentFactory;\n            /**\n             * If this element doesn't exist in the component cache, create it and cache.\n             */ if (!componentCache.has(key)) {\n                componentCache.set(key, componentFactory(key));\n            }\n            return componentCache.get(key);\n        }\n    });\n}\nfunction isAnimationControls(v) {\n    return v !== null && typeof v === \"object\" && typeof v.start === \"function\";\n}\nconst isKeyframesTarget = (v)=>{\n    return Array.isArray(v);\n};\nfunction shallowCompare(next, prev) {\n    if (!Array.isArray(prev)) return false;\n    const prevLength = prev.length;\n    if (prevLength !== next.length) return false;\n    for(let i = 0; i < prevLength; i++){\n        if (prev[i] !== next[i]) return false;\n    }\n    return true;\n}\n/**\n * Decides if the supplied variable is variant label\n */ function isVariantLabel(v) {\n    return typeof v === \"string\" || Array.isArray(v);\n}\nfunction getValueState(visualElement) {\n    const state = [\n        {},\n        {}\n    ];\n    visualElement === null || visualElement === void 0 ? void 0 : visualElement.values.forEach((value, key)=>{\n        state[0][key] = value.get();\n        state[1][key] = value.getVelocity();\n    });\n    return state;\n}\nfunction resolveVariantFromProps(props, definition, custom, visualElement) {\n    /**\n     * If the variant definition is a function, resolve.\n     */ if (typeof definition === \"function\") {\n        const [current, velocity] = getValueState(visualElement);\n        definition = definition(custom !== undefined ? custom : props.custom, current, velocity);\n    }\n    /**\n     * If the variant definition is a variant label, or\n     * the function returned a variant label, resolve.\n     */ if (typeof definition === \"string\") {\n        definition = props.variants && props.variants[definition];\n    }\n    /**\n     * At this point we've resolved both functions and variant labels,\n     * but the resolved variant label might itself have been a function.\n     * If so, resolve. This can only have returned a valid target object.\n     */ if (typeof definition === \"function\") {\n        const [current, velocity] = getValueState(visualElement);\n        definition = definition(custom !== undefined ? custom : props.custom, current, velocity);\n    }\n    return definition;\n}\nfunction resolveVariant(visualElement, definition, custom) {\n    const props = visualElement.getProps();\n    return resolveVariantFromProps(props, definition, custom !== undefined ? custom : props.custom, visualElement);\n}\nconst variantPriorityOrder = [\n    \"animate\",\n    \"whileInView\",\n    \"whileFocus\",\n    \"whileHover\",\n    \"whileTap\",\n    \"whileDrag\",\n    \"exit\"\n];\nconst variantProps = [\n    \"initial\",\n    ...variantPriorityOrder\n];\n/**\n * Generate a list of every possible transform key.\n */ const transformPropOrder = [\n    \"transformPerspective\",\n    \"x\",\n    \"y\",\n    \"z\",\n    \"translateX\",\n    \"translateY\",\n    \"translateZ\",\n    \"scale\",\n    \"scaleX\",\n    \"scaleY\",\n    \"rotate\",\n    \"rotateX\",\n    \"rotateY\",\n    \"rotateZ\",\n    \"skew\",\n    \"skewX\",\n    \"skewY\"\n];\n/**\n * A quick lookup for transform props.\n */ const transformProps = new Set(transformPropOrder);\n/**\n * Converts seconds to milliseconds\n *\n * @param seconds - Time in seconds.\n * @return milliseconds - Converted time in milliseconds.\n */ const secondsToMilliseconds = (seconds)=>seconds * 1000;\nconst millisecondsToSeconds = (milliseconds)=>milliseconds / 1000;\nconst underDampedSpring = {\n    type: \"spring\",\n    stiffness: 500,\n    damping: 25,\n    restSpeed: 10\n};\nconst criticallyDampedSpring = (target)=>({\n        type: \"spring\",\n        stiffness: 550,\n        damping: target === 0 ? 2 * Math.sqrt(550) : 30,\n        restSpeed: 10\n    });\nconst keyframesTransition = {\n    type: \"keyframes\",\n    duration: 0.8\n};\n/**\n * Default easing curve is a slightly shallower version of\n * the default browser easing curve.\n */ const ease = {\n    type: \"keyframes\",\n    ease: [\n        0.25,\n        0.1,\n        0.35,\n        1\n    ],\n    duration: 0.3\n};\nconst getDefaultTransition = (valueKey, { keyframes })=>{\n    if (keyframes.length > 2) {\n        return keyframesTransition;\n    } else if (transformProps.has(valueKey)) {\n        return valueKey.startsWith(\"scale\") ? criticallyDampedSpring(keyframes[1]) : underDampedSpring;\n    }\n    return ease;\n};\nfunction getValueTransition$1(transition, key) {\n    return transition ? transition[key] || transition[\"default\"] || transition : undefined;\n}\nconst MotionGlobalConfig = {\n    skipAnimations: false,\n    useManualTiming: false\n};\nconst instantAnimationState = {\n    current: false\n};\nconst isNotNull = (value)=>value !== null;\nfunction getFinalKeyframe(keyframes, { repeat, repeatType = \"loop\" }, finalKeyframe) {\n    const resolvedKeyframes = keyframes.filter(isNotNull);\n    const index = repeat && repeatType !== \"loop\" && repeat % 2 === 1 ? 0 : resolvedKeyframes.length - 1;\n    return !index || finalKeyframe === undefined ? resolvedKeyframes[index] : finalKeyframe;\n}\nfunction createRenderStep(runNextFrame) {\n    /**\n     * We create and reuse two queues, one to queue jobs for the current frame\n     * and one for the next. We reuse to avoid triggering GC after x frames.\n     */ let thisFrame = new Set();\n    let nextFrame = new Set();\n    /**\n     * Track whether we're currently processing jobs in this step. This way\n     * we can decide whether to schedule new jobs for this frame or next.\n     */ let isProcessing = false;\n    let flushNextFrame = false;\n    /**\n     * A set of processes which were marked keepAlive when scheduled.\n     */ const toKeepAlive = new WeakSet();\n    let latestFrameData = {\n        delta: 0.0,\n        timestamp: 0.0,\n        isProcessing: false\n    };\n    function triggerCallback(callback) {\n        if (toKeepAlive.has(callback)) {\n            step.schedule(callback);\n            runNextFrame();\n        }\n        callback(latestFrameData);\n    }\n    const step = {\n        /**\n         * Schedule a process to run on the next frame.\n         */ schedule: (callback, keepAlive = false, immediate = false)=>{\n            const addToCurrentFrame = immediate && isProcessing;\n            const queue = addToCurrentFrame ? thisFrame : nextFrame;\n            if (keepAlive) toKeepAlive.add(callback);\n            if (!queue.has(callback)) queue.add(callback);\n            return callback;\n        },\n        /**\n         * Cancel the provided callback from running on the next frame.\n         */ cancel: (callback)=>{\n            nextFrame.delete(callback);\n            toKeepAlive.delete(callback);\n        },\n        /**\n         * Execute all schedule callbacks.\n         */ process: (frameData)=>{\n            latestFrameData = frameData;\n            /**\n             * If we're already processing we've probably been triggered by a flushSync\n             * inside an existing process. Instead of executing, mark flushNextFrame\n             * as true and ensure we flush the following frame at the end of this one.\n             */ if (isProcessing) {\n                flushNextFrame = true;\n                return;\n            }\n            isProcessing = true;\n            [thisFrame, nextFrame] = [\n                nextFrame,\n                thisFrame\n            ];\n            // Execute this frame\n            thisFrame.forEach(triggerCallback);\n            // Clear the frame so no callbacks remain. This is to avoid\n            // memory leaks should this render step not run for a while.\n            thisFrame.clear();\n            isProcessing = false;\n            if (flushNextFrame) {\n                flushNextFrame = false;\n                step.process(frameData);\n            }\n        }\n    };\n    return step;\n}\nconst stepsOrder = [\n    \"read\",\n    \"resolveKeyframes\",\n    \"update\",\n    \"preRender\",\n    \"render\",\n    \"postRender\"\n];\nconst maxElapsed$1 = 40;\nfunction createRenderBatcher(scheduleNextBatch, allowKeepAlive) {\n    let runNextFrame = false;\n    let useDefaultElapsed = true;\n    const state = {\n        delta: 0.0,\n        timestamp: 0.0,\n        isProcessing: false\n    };\n    const flagRunNextFrame = ()=>runNextFrame = true;\n    const steps = stepsOrder.reduce((acc, key)=>{\n        acc[key] = createRenderStep(flagRunNextFrame);\n        return acc;\n    }, {});\n    const { read, resolveKeyframes, update, preRender, render, postRender } = steps;\n    const processBatch = ()=>{\n        const timestamp = MotionGlobalConfig.useManualTiming ? state.timestamp : performance.now();\n        runNextFrame = false;\n        state.delta = useDefaultElapsed ? 1000 / 60 : Math.max(Math.min(timestamp - state.timestamp, maxElapsed$1), 1);\n        state.timestamp = timestamp;\n        state.isProcessing = true;\n        // Unrolled render loop for better per-frame performance\n        read.process(state);\n        resolveKeyframes.process(state);\n        update.process(state);\n        preRender.process(state);\n        render.process(state);\n        postRender.process(state);\n        state.isProcessing = false;\n        if (runNextFrame && allowKeepAlive) {\n            useDefaultElapsed = false;\n            scheduleNextBatch(processBatch);\n        }\n    };\n    const wake = ()=>{\n        runNextFrame = true;\n        useDefaultElapsed = true;\n        if (!state.isProcessing) {\n            scheduleNextBatch(processBatch);\n        }\n    };\n    const schedule = stepsOrder.reduce((acc, key)=>{\n        const step = steps[key];\n        acc[key] = (process, keepAlive = false, immediate = false)=>{\n            if (!runNextFrame) wake();\n            return step.schedule(process, keepAlive, immediate);\n        };\n        return acc;\n    }, {});\n    const cancel = (process)=>{\n        for(let i = 0; i < stepsOrder.length; i++){\n            steps[stepsOrder[i]].cancel(process);\n        }\n    };\n    return {\n        schedule,\n        cancel,\n        state,\n        steps\n    };\n}\nconst { schedule: frame, cancel: cancelFrame, state: frameData, steps: frameSteps } = createRenderBatcher(typeof requestAnimationFrame !== \"undefined\" ? requestAnimationFrame : motionUtils.noop, true);\n/*\n  Bezier function generator\n  This has been modified from Gaëtan Renaudeau's BezierEasing\n  https://github.com/gre/bezier-easing/blob/master/src/index.js\n  https://github.com/gre/bezier-easing/blob/master/LICENSE\n  \n  I've removed the newtonRaphsonIterate algo because in benchmarking it\n  wasn't noticiably faster than binarySubdivision, indeed removing it\n  usually improved times, depending on the curve.\n  I also removed the lookup table, as for the added bundle size and loop we're\n  only cutting ~4 or so subdivision iterations. I bumped the max iterations up\n  to 12 to compensate and this still tended to be faster for no perceivable\n  loss in accuracy.\n  Usage\n    const easeOut = cubicBezier(.17,.67,.83,.67);\n    const x = easeOut(0.5); // returns 0.627...\n*/ // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\nconst calcBezier = (t, a1, a2)=>(((1.0 - 3.0 * a2 + 3.0 * a1) * t + (3.0 * a2 - 6.0 * a1)) * t + 3.0 * a1) * t;\nconst subdivisionPrecision = 0.0000001;\nconst subdivisionMaxIterations = 12;\nfunction binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {\n    let currentX;\n    let currentT;\n    let i = 0;\n    do {\n        currentT = lowerBound + (upperBound - lowerBound) / 2.0;\n        currentX = calcBezier(currentT, mX1, mX2) - x;\n        if (currentX > 0.0) {\n            upperBound = currentT;\n        } else {\n            lowerBound = currentT;\n        }\n    }while (Math.abs(currentX) > subdivisionPrecision && ++i < subdivisionMaxIterations);\n    return currentT;\n}\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\n    // If this is a linear gradient, return linear easing\n    if (mX1 === mY1 && mX2 === mY2) return motionUtils.noop;\n    const getTForX = (aX)=>binarySubdivide(aX, 0, 1, mX1, mX2);\n    // If animation is at start/end, return t without easing\n    return (t)=>t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);\n}\n// Accepts an easing function and returns a new one that outputs mirrored values for\n// the second half of the animation. Turns easeIn into easeInOut.\nconst mirrorEasing = (easing)=>(p)=>p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;\n// Accepts an easing function and returns a new one that outputs reversed values.\n// Turns easeIn into easeOut.\nconst reverseEasing = (easing)=>(p)=>1 - easing(1 - p);\nconst backOut = /*@__PURE__*/ cubicBezier(0.33, 1.53, 0.69, 0.99);\nconst backIn = /*@__PURE__*/ reverseEasing(backOut);\nconst backInOut = /*@__PURE__*/ mirrorEasing(backIn);\nconst anticipate = (p)=>(p *= 2) < 1 ? 0.5 * backIn(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));\nconst circIn = (p)=>1 - Math.sin(Math.acos(p));\nconst circOut = reverseEasing(circIn);\nconst circInOut = mirrorEasing(circIn);\n/**\n * Check if the value is a zero value string like \"0px\" or \"0%\"\n */ const isZeroValueString = (v)=>/^0[^.\\s]+$/u.test(v);\nfunction isNone(value) {\n    if (typeof value === \"number\") {\n        return value === 0;\n    } else if (value !== null) {\n        return value === \"none\" || value === \"0\" || isZeroValueString(value);\n    } else {\n        return true;\n    }\n}\n/**\n * Check if value is a numerical string, ie a string that is purely a number eg \"100\" or \"-100.1\"\n */ const isNumericalString = (v)=>/^-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)$/u.test(v);\nconst checkStringStartsWith = (token)=>(key)=>typeof key === \"string\" && key.startsWith(token);\nconst isCSSVariableName = /*@__PURE__*/ checkStringStartsWith(\"--\");\nconst startsAsVariableToken = /*@__PURE__*/ checkStringStartsWith(\"var(--\");\nconst isCSSVariableToken = (value)=>{\n    const startsWithToken = startsAsVariableToken(value);\n    if (!startsWithToken) return false;\n    // Ensure any comments are stripped from the value as this can harm performance of the regex.\n    return singleCssVariableRegex.test(value.split(\"/*\")[0].trim());\n};\nconst singleCssVariableRegex = /var\\(--(?:[\\w-]+\\s*|[\\w-]+\\s*,(?:\\s*[^)(\\s]|\\s*\\((?:[^)(]|\\([^)(]*\\))*\\))+\\s*)\\)$/iu;\n/**\n * Parse Framer's special CSS variable format into a CSS token and a fallback.\n *\n * ```\n * `var(--foo, #fff)` => [`--foo`, '#fff']\n * ```\n *\n * @param current\n */ const splitCSSVariableRegex = // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words\n/^var\\(--(?:([\\w-]+)|([\\w-]+), ?([a-zA-Z\\d ()%#.,-]+))\\)/u;\nfunction parseCSSVariable(current) {\n    const match = splitCSSVariableRegex.exec(current);\n    if (!match) return [\n        , \n    ];\n    const [, token1, token2, fallback] = match;\n    return [\n        `--${token1 !== null && token1 !== void 0 ? token1 : token2}`,\n        fallback\n    ];\n}\nconst maxDepth = 4;\nfunction getVariableValue(current, element, depth = 1) {\n    motionUtils.invariant(depth <= maxDepth, `Max CSS variable fallback depth detected in property \"${current}\". This may indicate a circular fallback dependency.`);\n    const [token, fallback] = parseCSSVariable(current);\n    // No CSS variable detected\n    if (!token) return;\n    // Attempt to read this CSS variable off the element\n    const resolved = window.getComputedStyle(element).getPropertyValue(token);\n    if (resolved) {\n        const trimmed = resolved.trim();\n        return isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;\n    }\n    return isCSSVariableToken(fallback) ? getVariableValue(fallback, element, depth + 1) : fallback;\n}\nconst clamp = (min, max, v)=>{\n    if (v > max) return max;\n    if (v < min) return min;\n    return v;\n};\nconst number = {\n    test: (v)=>typeof v === \"number\",\n    parse: parseFloat,\n    transform: (v)=>v\n};\nconst alpha = {\n    ...number,\n    transform: (v)=>clamp(0, 1, v)\n};\nconst scale = {\n    ...number,\n    default: 1\n};\nconst createUnitType = (unit)=>({\n        test: (v)=>typeof v === \"string\" && v.endsWith(unit) && v.split(\" \").length === 1,\n        parse: parseFloat,\n        transform: (v)=>`${v}${unit}`\n    });\nconst degrees = /*@__PURE__*/ createUnitType(\"deg\");\nconst percent = /*@__PURE__*/ createUnitType(\"%\");\nconst px = /*@__PURE__*/ createUnitType(\"px\");\nconst vh = /*@__PURE__*/ createUnitType(\"vh\");\nconst vw = /*@__PURE__*/ createUnitType(\"vw\");\nconst progressPercentage = {\n    ...percent,\n    parse: (v)=>percent.parse(v) / 100,\n    transform: (v)=>percent.transform(v * 100)\n};\nconst positionalKeys = new Set([\n    \"width\",\n    \"height\",\n    \"top\",\n    \"left\",\n    \"right\",\n    \"bottom\",\n    \"x\",\n    \"y\",\n    \"translateX\",\n    \"translateY\"\n]);\nconst isNumOrPxType = (v)=>v === number || v === px;\nconst getPosFromMatrix = (matrix, pos)=>parseFloat(matrix.split(\", \")[pos]);\nconst getTranslateFromMatrix = (pos2, pos3)=>(_bbox, { transform })=>{\n        if (transform === \"none\" || !transform) return 0;\n        const matrix3d = transform.match(/^matrix3d\\((.+)\\)$/u);\n        if (matrix3d) {\n            return getPosFromMatrix(matrix3d[1], pos3);\n        } else {\n            const matrix = transform.match(/^matrix\\((.+)\\)$/u);\n            if (matrix) {\n                return getPosFromMatrix(matrix[1], pos2);\n            } else {\n                return 0;\n            }\n        }\n    };\nconst transformKeys = new Set([\n    \"x\",\n    \"y\",\n    \"z\"\n]);\nconst nonTranslationalTransformKeys = transformPropOrder.filter((key)=>!transformKeys.has(key));\nfunction removeNonTranslationalTransform(visualElement) {\n    const removedTransforms = [];\n    nonTranslationalTransformKeys.forEach((key)=>{\n        const value = visualElement.getValue(key);\n        if (value !== undefined) {\n            removedTransforms.push([\n                key,\n                value.get()\n            ]);\n            value.set(key.startsWith(\"scale\") ? 1 : 0);\n        }\n    });\n    return removedTransforms;\n}\nconst positionalValues = {\n    // Dimensions\n    width: ({ x }, { paddingLeft = \"0\", paddingRight = \"0\" })=>x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight),\n    height: ({ y }, { paddingTop = \"0\", paddingBottom = \"0\" })=>y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom),\n    top: (_bbox, { top })=>parseFloat(top),\n    left: (_bbox, { left })=>parseFloat(left),\n    bottom: ({ y }, { top })=>parseFloat(top) + (y.max - y.min),\n    right: ({ x }, { left })=>parseFloat(left) + (x.max - x.min),\n    // Transform\n    x: getTranslateFromMatrix(4, 13),\n    y: getTranslateFromMatrix(5, 14)\n};\n// Alias translate longform names\npositionalValues.translateX = positionalValues.x;\npositionalValues.translateY = positionalValues.y;\n/**\n * Tests a provided value against a ValueType\n */ const testValueType = (v)=>(type)=>type.test(v);\n/**\n * ValueType for \"auto\"\n */ const auto = {\n    test: (v)=>v === \"auto\",\n    parse: (v)=>v\n};\n/**\n * A list of value types commonly used for dimensions\n */ const dimensionValueTypes = [\n    number,\n    px,\n    percent,\n    degrees,\n    vw,\n    vh,\n    auto\n];\n/**\n * Tests a dimensional value against the list of dimension ValueTypes\n */ const findDimensionValueType = (v)=>dimensionValueTypes.find(testValueType(v));\nconst toResolve = new Set();\nlet isScheduled = false;\nlet anyNeedsMeasurement = false;\nfunction measureAllKeyframes() {\n    if (anyNeedsMeasurement) {\n        const resolversToMeasure = Array.from(toResolve).filter((resolver)=>resolver.needsMeasurement);\n        const elementsToMeasure = new Set(resolversToMeasure.map((resolver)=>resolver.element));\n        const transformsToRestore = new Map();\n        /**\n         * Write pass\n         * If we're measuring elements we want to remove bounding box-changing transforms.\n         */ elementsToMeasure.forEach((element)=>{\n            const removedTransforms = removeNonTranslationalTransform(element);\n            if (!removedTransforms.length) return;\n            transformsToRestore.set(element, removedTransforms);\n            element.render();\n        });\n        // Read\n        resolversToMeasure.forEach((resolver)=>resolver.measureInitialState());\n        // Write\n        elementsToMeasure.forEach((element)=>{\n            element.render();\n            const restore = transformsToRestore.get(element);\n            if (restore) {\n                restore.forEach(([key, value])=>{\n                    var _a;\n                    (_a = element.getValue(key)) === null || _a === void 0 ? void 0 : _a.set(value);\n                });\n            }\n        });\n        // Read\n        resolversToMeasure.forEach((resolver)=>resolver.measureEndState());\n        // Write\n        resolversToMeasure.forEach((resolver)=>{\n            if (resolver.suspendedScrollY !== undefined) {\n                window.scrollTo(0, resolver.suspendedScrollY);\n            }\n        });\n    }\n    anyNeedsMeasurement = false;\n    isScheduled = false;\n    toResolve.forEach((resolver)=>resolver.complete());\n    toResolve.clear();\n}\nfunction readAllKeyframes() {\n    toResolve.forEach((resolver)=>{\n        resolver.readKeyframes();\n        if (resolver.needsMeasurement) {\n            anyNeedsMeasurement = true;\n        }\n    });\n}\nfunction flushKeyframeResolvers() {\n    readAllKeyframes();\n    measureAllKeyframes();\n}\nclass KeyframeResolver {\n    constructor(unresolvedKeyframes, onComplete, name, motionValue, element, isAsync = false){\n        /**\n         * Track whether this resolver has completed. Once complete, it never\n         * needs to attempt keyframe resolution again.\n         */ this.isComplete = false;\n        /**\n         * Track whether this resolver is async. If it is, it'll be added to the\n         * resolver queue and flushed in the next frame. Resolvers that aren't going\n         * to trigger read/write thrashing don't need to be async.\n         */ this.isAsync = false;\n        /**\n         * Track whether this resolver needs to perform a measurement\n         * to resolve its keyframes.\n         */ this.needsMeasurement = false;\n        /**\n         * Track whether this resolver is currently scheduled to resolve\n         * to allow it to be cancelled and resumed externally.\n         */ this.isScheduled = false;\n        this.unresolvedKeyframes = [\n            ...unresolvedKeyframes\n        ];\n        this.onComplete = onComplete;\n        this.name = name;\n        this.motionValue = motionValue;\n        this.element = element;\n        this.isAsync = isAsync;\n    }\n    scheduleResolve() {\n        this.isScheduled = true;\n        if (this.isAsync) {\n            toResolve.add(this);\n            if (!isScheduled) {\n                isScheduled = true;\n                frame.read(readAllKeyframes);\n                frame.resolveKeyframes(measureAllKeyframes);\n            }\n        } else {\n            this.readKeyframes();\n            this.complete();\n        }\n    }\n    readKeyframes() {\n        const { unresolvedKeyframes, name, element, motionValue } = this;\n        /**\n         * If a keyframe is null, we hydrate it either by reading it from\n         * the instance, or propagating from previous keyframes.\n         */ for(let i = 0; i < unresolvedKeyframes.length; i++){\n            if (unresolvedKeyframes[i] === null) {\n                /**\n                 * If the first keyframe is null, we need to find its value by sampling the element\n                 */ if (i === 0) {\n                    const currentValue = motionValue === null || motionValue === void 0 ? void 0 : motionValue.get();\n                    const finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\n                    if (currentValue !== undefined) {\n                        unresolvedKeyframes[0] = currentValue;\n                    } else if (element && name) {\n                        const valueAsRead = element.readValue(name, finalKeyframe);\n                        if (valueAsRead !== undefined && valueAsRead !== null) {\n                            unresolvedKeyframes[0] = valueAsRead;\n                        }\n                    }\n                    if (unresolvedKeyframes[0] === undefined) {\n                        unresolvedKeyframes[0] = finalKeyframe;\n                    }\n                    if (motionValue && currentValue === undefined) {\n                        motionValue.set(unresolvedKeyframes[0]);\n                    }\n                } else {\n                    unresolvedKeyframes[i] = unresolvedKeyframes[i - 1];\n                }\n            }\n        }\n    }\n    setFinalKeyframe() {}\n    measureInitialState() {}\n    renderEndStyles() {}\n    measureEndState() {}\n    complete() {\n        this.isComplete = true;\n        this.onComplete(this.unresolvedKeyframes, this.finalKeyframe);\n        toResolve.delete(this);\n    }\n    cancel() {\n        if (!this.isComplete) {\n            this.isScheduled = false;\n            toResolve.delete(this);\n        }\n    }\n    resume() {\n        if (!this.isComplete) this.scheduleResolve();\n    }\n}\n// If this number is a decimal, make it just five decimal places\n// to avoid exponents\nconst sanitize = (v)=>Math.round(v * 100000) / 100000;\nconst floatRegex = /-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)/gu;\nfunction isNullish(v) {\n    return v == null;\n}\nconst singleColorRegex = /^(?:#[\\da-f]{3,8}|(?:rgb|hsl)a?\\((?:-?[\\d.]+%?[,\\s]+){2}-?[\\d.]+%?\\s*(?:[,/]\\s*)?(?:\\b\\d+(?:\\.\\d+)?|\\.\\d+)?%?\\))$/iu;\n/**\n * Returns true if the provided string is a color, ie rgba(0,0,0,0) or #000,\n * but false if a number or multiple colors\n */ const isColorString = (type, testProp)=>(v)=>{\n        return Boolean(typeof v === \"string\" && singleColorRegex.test(v) && v.startsWith(type) || testProp && !isNullish(v) && Object.prototype.hasOwnProperty.call(v, testProp));\n    };\nconst splitColor = (aName, bName, cName)=>(v)=>{\n        if (typeof v !== \"string\") return v;\n        const [a, b, c, alpha] = v.match(floatRegex);\n        return {\n            [aName]: parseFloat(a),\n            [bName]: parseFloat(b),\n            [cName]: parseFloat(c),\n            alpha: alpha !== undefined ? parseFloat(alpha) : 1\n        };\n    };\nconst clampRgbUnit = (v)=>clamp(0, 255, v);\nconst rgbUnit = {\n    ...number,\n    transform: (v)=>Math.round(clampRgbUnit(v))\n};\nconst rgba = {\n    test: /*@__PURE__*/ isColorString(\"rgb\", \"red\"),\n    parse: /*@__PURE__*/ splitColor(\"red\", \"green\", \"blue\"),\n    transform: ({ red, green, blue, alpha: alpha$1 = 1 })=>\"rgba(\" + rgbUnit.transform(red) + \", \" + rgbUnit.transform(green) + \", \" + rgbUnit.transform(blue) + \", \" + sanitize(alpha.transform(alpha$1)) + \")\"\n};\nfunction parseHex(v) {\n    let r = \"\";\n    let g = \"\";\n    let b = \"\";\n    let a = \"\";\n    // If we have 6 characters, ie #FF0000\n    if (v.length > 5) {\n        r = v.substring(1, 3);\n        g = v.substring(3, 5);\n        b = v.substring(5, 7);\n        a = v.substring(7, 9);\n    // Or we have 3 characters, ie #F00\n    } else {\n        r = v.substring(1, 2);\n        g = v.substring(2, 3);\n        b = v.substring(3, 4);\n        a = v.substring(4, 5);\n        r += r;\n        g += g;\n        b += b;\n        a += a;\n    }\n    return {\n        red: parseInt(r, 16),\n        green: parseInt(g, 16),\n        blue: parseInt(b, 16),\n        alpha: a ? parseInt(a, 16) / 255 : 1\n    };\n}\nconst hex = {\n    test: /*@__PURE__*/ isColorString(\"#\"),\n    parse: parseHex,\n    transform: rgba.transform\n};\nconst hsla = {\n    test: /*@__PURE__*/ isColorString(\"hsl\", \"hue\"),\n    parse: /*@__PURE__*/ splitColor(\"hue\", \"saturation\", \"lightness\"),\n    transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 })=>{\n        return \"hsla(\" + Math.round(hue) + \", \" + percent.transform(sanitize(saturation)) + \", \" + percent.transform(sanitize(lightness)) + \", \" + sanitize(alpha.transform(alpha$1)) + \")\";\n    }\n};\nconst color = {\n    test: (v)=>rgba.test(v) || hex.test(v) || hsla.test(v),\n    parse: (v)=>{\n        if (rgba.test(v)) {\n            return rgba.parse(v);\n        } else if (hsla.test(v)) {\n            return hsla.parse(v);\n        } else {\n            return hex.parse(v);\n        }\n    },\n    transform: (v)=>{\n        return typeof v === \"string\" ? v : v.hasOwnProperty(\"red\") ? rgba.transform(v) : hsla.transform(v);\n    }\n};\nconst colorRegex = /(?:#[\\da-f]{3,8}|(?:rgb|hsl)a?\\((?:-?[\\d.]+%?[,\\s]+){2}-?[\\d.]+%?\\s*(?:[,/]\\s*)?(?:\\b\\d+(?:\\.\\d+)?|\\.\\d+)?%?\\))/giu;\nfunction test(v) {\n    var _a, _b;\n    return isNaN(v) && typeof v === \"string\" && (((_a = v.match(floatRegex)) === null || _a === void 0 ? void 0 : _a.length) || 0) + (((_b = v.match(colorRegex)) === null || _b === void 0 ? void 0 : _b.length) || 0) > 0;\n}\nconst NUMBER_TOKEN = \"number\";\nconst COLOR_TOKEN = \"color\";\nconst VAR_TOKEN = \"var\";\nconst VAR_FUNCTION_TOKEN = \"var(\";\nconst SPLIT_TOKEN = \"${}\";\n// this regex consists of the `singleCssVariableRegex|rgbHSLValueRegex|digitRegex`\nconst complexRegex = /var\\s*\\(\\s*--(?:[\\w-]+\\s*|[\\w-]+\\s*,(?:\\s*[^)(\\s]|\\s*\\((?:[^)(]|\\([^)(]*\\))*\\))+\\s*)\\)|#[\\da-f]{3,8}|(?:rgb|hsl)a?\\((?:-?[\\d.]+%?[,\\s]+){2}-?[\\d.]+%?\\s*(?:[,/]\\s*)?(?:\\b\\d+(?:\\.\\d+)?|\\.\\d+)?%?\\)|-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)/giu;\nfunction analyseComplexValue(value) {\n    const originalValue = value.toString();\n    const values = [];\n    const indexes = {\n        color: [],\n        number: [],\n        var: []\n    };\n    const types = [];\n    let i = 0;\n    const tokenised = originalValue.replace(complexRegex, (parsedValue)=>{\n        if (color.test(parsedValue)) {\n            indexes.color.push(i);\n            types.push(COLOR_TOKEN);\n            values.push(color.parse(parsedValue));\n        } else if (parsedValue.startsWith(VAR_FUNCTION_TOKEN)) {\n            indexes.var.push(i);\n            types.push(VAR_TOKEN);\n            values.push(parsedValue);\n        } else {\n            indexes.number.push(i);\n            types.push(NUMBER_TOKEN);\n            values.push(parseFloat(parsedValue));\n        }\n        ++i;\n        return SPLIT_TOKEN;\n    });\n    const split = tokenised.split(SPLIT_TOKEN);\n    return {\n        values,\n        split,\n        indexes,\n        types\n    };\n}\nfunction parseComplexValue(v) {\n    return analyseComplexValue(v).values;\n}\nfunction createTransformer(source) {\n    const { split, types } = analyseComplexValue(source);\n    const numSections = split.length;\n    return (v)=>{\n        let output = \"\";\n        for(let i = 0; i < numSections; i++){\n            output += split[i];\n            if (v[i] !== undefined) {\n                const type = types[i];\n                if (type === NUMBER_TOKEN) {\n                    output += sanitize(v[i]);\n                } else if (type === COLOR_TOKEN) {\n                    output += color.transform(v[i]);\n                } else {\n                    output += v[i];\n                }\n            }\n        }\n        return output;\n    };\n}\nconst convertNumbersToZero = (v)=>typeof v === \"number\" ? 0 : v;\nfunction getAnimatableNone$1(v) {\n    const parsed = parseComplexValue(v);\n    const transformer = createTransformer(v);\n    return transformer(parsed.map(convertNumbersToZero));\n}\nconst complex = {\n    test,\n    parse: parseComplexValue,\n    createTransformer,\n    getAnimatableNone: getAnimatableNone$1\n};\n/**\n * Properties that should default to 1 or 100%\n */ const maxDefaults = new Set([\n    \"brightness\",\n    \"contrast\",\n    \"saturate\",\n    \"opacity\"\n]);\nfunction applyDefaultFilter(v) {\n    const [name, value] = v.slice(0, -1).split(\"(\");\n    if (name === \"drop-shadow\") return v;\n    const [number] = value.match(floatRegex) || [];\n    if (!number) return v;\n    const unit = value.replace(number, \"\");\n    let defaultValue = maxDefaults.has(name) ? 1 : 0;\n    if (number !== value) defaultValue *= 100;\n    return name + \"(\" + defaultValue + unit + \")\";\n}\nconst functionRegex = /\\b([a-z-]*)\\(.*?\\)/gu;\nconst filter = {\n    ...complex,\n    getAnimatableNone: (v)=>{\n        const functions = v.match(functionRegex);\n        return functions ? functions.map(applyDefaultFilter).join(\" \") : v;\n    }\n};\nconst browserNumberValueTypes = {\n    // Border props\n    borderWidth: px,\n    borderTopWidth: px,\n    borderRightWidth: px,\n    borderBottomWidth: px,\n    borderLeftWidth: px,\n    borderRadius: px,\n    radius: px,\n    borderTopLeftRadius: px,\n    borderTopRightRadius: px,\n    borderBottomRightRadius: px,\n    borderBottomLeftRadius: px,\n    // Positioning props\n    width: px,\n    maxWidth: px,\n    height: px,\n    maxHeight: px,\n    top: px,\n    right: px,\n    bottom: px,\n    left: px,\n    // Spacing props\n    padding: px,\n    paddingTop: px,\n    paddingRight: px,\n    paddingBottom: px,\n    paddingLeft: px,\n    margin: px,\n    marginTop: px,\n    marginRight: px,\n    marginBottom: px,\n    marginLeft: px,\n    // Misc\n    backgroundPositionX: px,\n    backgroundPositionY: px\n};\nconst transformValueTypes = {\n    rotate: degrees,\n    rotateX: degrees,\n    rotateY: degrees,\n    rotateZ: degrees,\n    scale,\n    scaleX: scale,\n    scaleY: scale,\n    scaleZ: scale,\n    skew: degrees,\n    skewX: degrees,\n    skewY: degrees,\n    distance: px,\n    translateX: px,\n    translateY: px,\n    translateZ: px,\n    x: px,\n    y: px,\n    z: px,\n    perspective: px,\n    transformPerspective: px,\n    opacity: alpha,\n    originX: progressPercentage,\n    originY: progressPercentage,\n    originZ: px\n};\nconst int = {\n    ...number,\n    transform: Math.round\n};\nconst numberValueTypes = {\n    ...browserNumberValueTypes,\n    ...transformValueTypes,\n    zIndex: int,\n    size: px,\n    // SVG\n    fillOpacity: alpha,\n    strokeOpacity: alpha,\n    numOctaves: int\n};\n/**\n * A map of default value types for common values\n */ const defaultValueTypes = {\n    ...numberValueTypes,\n    // Color props\n    color,\n    backgroundColor: color,\n    outlineColor: color,\n    fill: color,\n    stroke: color,\n    // Border props\n    borderColor: color,\n    borderTopColor: color,\n    borderRightColor: color,\n    borderBottomColor: color,\n    borderLeftColor: color,\n    filter,\n    WebkitFilter: filter\n};\n/**\n * Gets the default ValueType for the provided value key\n */ const getDefaultValueType = (key)=>defaultValueTypes[key];\nfunction getAnimatableNone(key, value) {\n    let defaultValueType = getDefaultValueType(key);\n    if (defaultValueType !== filter) defaultValueType = complex;\n    // If value is not recognised as animatable, ie \"none\", create an animatable version origin based on the target\n    return defaultValueType.getAnimatableNone ? defaultValueType.getAnimatableNone(value) : undefined;\n}\n/**\n * If we encounter keyframes like \"none\" or \"0\" and we also have keyframes like\n * \"#fff\" or \"200px 200px\" we want to find a keyframe to serve as a template for\n * the \"none\" keyframes. In this case \"#fff\" or \"200px 200px\" - then these get turned into\n * zero equivalents, i.e. \"#fff0\" or \"0px 0px\".\n */ const invalidTemplates = new Set([\n    \"auto\",\n    \"none\",\n    \"0\"\n]);\nfunction makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name) {\n    let i = 0;\n    let animatableTemplate = undefined;\n    while(i < unresolvedKeyframes.length && !animatableTemplate){\n        const keyframe = unresolvedKeyframes[i];\n        if (typeof keyframe === \"string\" && !invalidTemplates.has(keyframe) && analyseComplexValue(keyframe).values.length) {\n            animatableTemplate = unresolvedKeyframes[i];\n        }\n        i++;\n    }\n    if (animatableTemplate && name) {\n        for (const noneIndex of noneKeyframeIndexes){\n            unresolvedKeyframes[noneIndex] = getAnimatableNone(name, animatableTemplate);\n        }\n    }\n}\nclass DOMKeyframesResolver extends KeyframeResolver {\n    constructor(unresolvedKeyframes, onComplete, name, motionValue, element){\n        super(unresolvedKeyframes, onComplete, name, motionValue, element, true);\n    }\n    readKeyframes() {\n        const { unresolvedKeyframes, element, name } = this;\n        if (!element || !element.current) return;\n        super.readKeyframes();\n        /**\n         * If any keyframe is a CSS variable, we need to find its value by sampling the element\n         */ for(let i = 0; i < unresolvedKeyframes.length; i++){\n            let keyframe = unresolvedKeyframes[i];\n            if (typeof keyframe === \"string\") {\n                keyframe = keyframe.trim();\n                if (isCSSVariableToken(keyframe)) {\n                    const resolved = getVariableValue(keyframe, element.current);\n                    if (resolved !== undefined) {\n                        unresolvedKeyframes[i] = resolved;\n                    }\n                    if (i === unresolvedKeyframes.length - 1) {\n                        this.finalKeyframe = keyframe;\n                    }\n                }\n            }\n        }\n        /**\n         * Resolve \"none\" values. We do this potentially twice - once before and once after measuring keyframes.\n         * This could be seen as inefficient but it's a trade-off to avoid measurements in more situations, which\n         * have a far bigger performance impact.\n         */ this.resolveNoneKeyframes();\n        /**\n         * Check to see if unit type has changed. If so schedule jobs that will\n         * temporarily set styles to the destination keyframes.\n         * Skip if we have more than two keyframes or this isn't a positional value.\n         * TODO: We can throw if there are multiple keyframes and the value type changes.\n         */ if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {\n            return;\n        }\n        const [origin, target] = unresolvedKeyframes;\n        const originType = findDimensionValueType(origin);\n        const targetType = findDimensionValueType(target);\n        /**\n         * Either we don't recognise these value types or we can animate between them.\n         */ if (originType === targetType) return;\n        /**\n         * If both values are numbers or pixels, we can animate between them by\n         * converting them to numbers.\n         */ if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {\n            for(let i = 0; i < unresolvedKeyframes.length; i++){\n                const value = unresolvedKeyframes[i];\n                if (typeof value === \"string\") {\n                    unresolvedKeyframes[i] = parseFloat(value);\n                }\n            }\n        } else {\n            /**\n             * Else, the only way to resolve this is by measuring the element.\n             */ this.needsMeasurement = true;\n        }\n    }\n    resolveNoneKeyframes() {\n        const { unresolvedKeyframes, name } = this;\n        const noneKeyframeIndexes = [];\n        for(let i = 0; i < unresolvedKeyframes.length; i++){\n            if (isNone(unresolvedKeyframes[i])) {\n                noneKeyframeIndexes.push(i);\n            }\n        }\n        if (noneKeyframeIndexes.length) {\n            makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);\n        }\n    }\n    measureInitialState() {\n        const { element, unresolvedKeyframes, name } = this;\n        if (!element || !element.current) return;\n        if (name === \"height\") {\n            this.suspendedScrollY = window.pageYOffset;\n        }\n        this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\n        unresolvedKeyframes[0] = this.measuredOrigin;\n        // Set final key frame to measure after next render\n        const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\n        if (measureKeyframe !== undefined) {\n            element.getValue(name, measureKeyframe).jump(measureKeyframe, false);\n        }\n    }\n    measureEndState() {\n        var _a;\n        const { element, name, unresolvedKeyframes } = this;\n        if (!element || !element.current) return;\n        const value = element.getValue(name);\n        value && value.jump(this.measuredOrigin, false);\n        const finalKeyframeIndex = unresolvedKeyframes.length - 1;\n        const finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];\n        unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\n        if (finalKeyframe !== null && this.finalKeyframe === undefined) {\n            this.finalKeyframe = finalKeyframe;\n        }\n        // If we removed transform values, reapply them before the next render\n        if ((_a = this.removedTransforms) === null || _a === void 0 ? void 0 : _a.length) {\n            this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue])=>{\n                element.getValue(unsetTransformName).set(unsetTransformValue);\n            });\n        }\n        this.resolveNoneKeyframes();\n    }\n}\nfunction isGenerator(type) {\n    return typeof type === \"function\";\n}\nlet now;\nfunction clearTime() {\n    now = undefined;\n}\n/**\n * An eventloop-synchronous alternative to performance.now().\n *\n * Ensures that time measurements remain consistent within a synchronous context.\n * Usually calling performance.now() twice within the same synchronous context\n * will return different values which isn't useful for animations when we're usually\n * trying to sync animations to the same frame.\n */ const time = {\n    now: ()=>{\n        if (now === undefined) {\n            time.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming ? frameData.timestamp : performance.now());\n        }\n        return now;\n    },\n    set: (newTime)=>{\n        now = newTime;\n        queueMicrotask(clearTime);\n    }\n};\n/**\n * Check if a value is animatable. Examples:\n *\n * ✅: 100, \"100px\", \"#fff\"\n * ❌: \"block\", \"url(2.jpg)\"\n * @param value\n *\n * @internal\n */ const isAnimatable = (value, name)=>{\n    // If the list of keys tat might be non-animatable grows, replace with Set\n    if (name === \"zIndex\") return false;\n    // If it's a number or a keyframes array, we can animate it. We might at some point\n    // need to do a deep isAnimatable check of keyframes, or let Popmotion handle this,\n    // but for now lets leave it like this for performance reasons\n    if (typeof value === \"number\" || Array.isArray(value)) return true;\n    if (typeof value === \"string\" && // It's animatable if we have a string\n    (complex.test(value) || value === \"0\") && // And it contains numbers and/or colors\n    !value.startsWith(\"url(\") // Unless it starts with \"url(\"\n    ) {\n        return true;\n    }\n    return false;\n};\nfunction hasKeyframesChanged(keyframes) {\n    const current = keyframes[0];\n    if (keyframes.length === 1) return true;\n    for(let i = 0; i < keyframes.length; i++){\n        if (keyframes[i] !== current) return true;\n    }\n}\nfunction canAnimate(keyframes, name, type, velocity) {\n    /**\n     * Check if we're able to animate between the start and end keyframes,\n     * and throw a warning if we're attempting to animate between one that's\n     * animatable and another that isn't.\n     */ const originKeyframe = keyframes[0];\n    if (originKeyframe === null) return false;\n    /**\n     * These aren't traditionally animatable but we do support them.\n     * In future we could look into making this more generic or replacing\n     * this function with mix() === mixImmediate\n     */ if (name === \"display\" || name === \"visibility\") return true;\n    const targetKeyframe = keyframes[keyframes.length - 1];\n    const isOriginAnimatable = isAnimatable(originKeyframe, name);\n    const isTargetAnimatable = isAnimatable(targetKeyframe, name);\n    motionUtils.warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${name} from \"${originKeyframe}\" to \"${targetKeyframe}\". ${originKeyframe} is not an animatable value - to enable this animation set ${originKeyframe} to a value animatable to ${targetKeyframe} via the \\`style\\` property.`);\n    // Always skip if any of these are true\n    if (!isOriginAnimatable || !isTargetAnimatable) {\n        return false;\n    }\n    return hasKeyframesChanged(keyframes) || (type === \"spring\" || isGenerator(type)) && velocity;\n}\n/**\n * Maximum time allowed between an animation being created and it being\n * resolved for us to use the latter as the start time.\n *\n * This is to ensure that while we prefer to \"start\" an animation as soon\n * as it's triggered, we also want to avoid a visual jump if there's a big delay\n * between these two moments.\n */ const MAX_RESOLVE_DELAY = 40;\nclass BaseAnimation {\n    constructor({ autoplay = true, delay = 0, type = \"keyframes\", repeat = 0, repeatDelay = 0, repeatType = \"loop\", ...options }){\n        // Track whether the animation has been stopped. Stopped animations won't restart.\n        this.isStopped = false;\n        this.hasAttemptedResolve = false;\n        this.createdAt = time.now();\n        this.options = {\n            autoplay,\n            delay,\n            type,\n            repeat,\n            repeatDelay,\n            repeatType,\n            ...options\n        };\n        this.updateFinishedPromise();\n    }\n    /**\n     * This method uses the createdAt and resolvedAt to calculate the\n     * animation startTime. *Ideally*, we would use the createdAt time as t=0\n     * as the following frame would then be the first frame of the animation in\n     * progress, which would feel snappier.\n     *\n     * However, if there's a delay (main thread work) between the creation of\n     * the animation and the first commited frame, we prefer to use resolvedAt\n     * to avoid a sudden jump into the animation.\n     */ calcStartTime() {\n        if (!this.resolvedAt) return this.createdAt;\n        return this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY ? this.resolvedAt : this.createdAt;\n    }\n    /**\n     * A getter for resolved data. If keyframes are not yet resolved, accessing\n     * this.resolved will synchronously flush all pending keyframe resolvers.\n     * This is a deoptimisation, but at its worst still batches read/writes.\n     */ get resolved() {\n        if (!this._resolved && !this.hasAttemptedResolve) {\n            flushKeyframeResolvers();\n        }\n        return this._resolved;\n    }\n    /**\n     * A method to be called when the keyframes resolver completes. This method\n     * will check if its possible to run the animation and, if not, skip it.\n     * Otherwise, it will call initPlayback on the implementing class.\n     */ onKeyframesResolved(keyframes, finalKeyframe) {\n        this.resolvedAt = time.now();\n        this.hasAttemptedResolve = true;\n        const { name, type, velocity, delay, onComplete, onUpdate, isGenerator } = this.options;\n        /**\n         * If we can't animate this value with the resolved keyframes\n         * then we should complete it immediately.\n         */ if (!isGenerator && !canAnimate(keyframes, name, type, velocity)) {\n            // Finish immediately\n            if (instantAnimationState.current || !delay) {\n                onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(getFinalKeyframe(keyframes, this.options, finalKeyframe));\n                onComplete === null || onComplete === void 0 ? void 0 : onComplete();\n                this.resolveFinishedPromise();\n                return;\n            } else {\n                this.options.duration = 0;\n            }\n        }\n        const resolvedAnimation = this.initPlayback(keyframes, finalKeyframe);\n        if (resolvedAnimation === false) return;\n        this._resolved = {\n            keyframes,\n            finalKeyframe,\n            ...resolvedAnimation\n        };\n        this.onPostResolved();\n    }\n    onPostResolved() {}\n    /**\n     * Allows the returned animation to be awaited or promise-chained. Currently\n     * resolves when the animation finishes at all but in a future update could/should\n     * reject if its cancels.\n     */ then(resolve, reject) {\n        return this.currentFinishedPromise.then(resolve, reject);\n    }\n    flatten() {\n        this.options.type = \"keyframes\";\n        this.options.ease = \"linear\";\n    }\n    updateFinishedPromise() {\n        this.currentFinishedPromise = new Promise((resolve)=>{\n            this.resolveFinishedPromise = resolve;\n        });\n    }\n}\n/*\n  Progress within given range\n\n  Given a lower limit and an upper limit, we return the progress\n  (expressed as a number 0-1) represented by the given value, and\n  limit that progress to within 0-1.\n\n  @param [number]: Lower limit\n  @param [number]: Upper limit\n  @param [number]: Value to find progress within given range\n  @return [number]: Progress of value within range as expressed 0-1\n*/ const progress = (from, to, value)=>{\n    const toFromDifference = to - from;\n    return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;\n};\nconst generateLinearEasing = (easing, duration, resolution = 10 // as milliseconds\n)=>{\n    let points = \"\";\n    const numPoints = Math.max(Math.round(duration / resolution), 2);\n    for(let i = 0; i < numPoints; i++){\n        points += easing(progress(0, numPoints - 1, i)) + \", \";\n    }\n    return `linear(${points.substring(0, points.length - 2)})`;\n};\n/*\n  Convert velocity into velocity per second\n\n  @param [number]: Unit per frame\n  @param [number]: Frame duration in ms\n*/ function velocityPerSecond(velocity, frameDuration) {\n    return frameDuration ? velocity * (1000 / frameDuration) : 0;\n}\nconst velocitySampleDuration = 5; // ms\nfunction calcGeneratorVelocity(resolveValue, t, current) {\n    const prevT = Math.max(t - velocitySampleDuration, 0);\n    return velocityPerSecond(current - resolveValue(prevT), t - prevT);\n}\nconst springDefaults = {\n    // Default spring physics\n    stiffness: 100,\n    damping: 10,\n    mass: 1.0,\n    velocity: 0.0,\n    // Default duration/bounce-based options\n    duration: 800,\n    bounce: 0.3,\n    visualDuration: 0.3,\n    // Rest thresholds\n    restSpeed: {\n        granular: 0.01,\n        default: 2\n    },\n    restDelta: {\n        granular: 0.005,\n        default: 0.5\n    },\n    // Limits\n    minDuration: 0.01,\n    maxDuration: 10.0,\n    minDamping: 0.05,\n    maxDamping: 1\n};\nconst safeMin = 0.001;\nfunction findSpring({ duration = springDefaults.duration, bounce = springDefaults.bounce, velocity = springDefaults.velocity, mass = springDefaults.mass }) {\n    let envelope;\n    let derivative;\n    motionUtils.warning(duration <= secondsToMilliseconds(springDefaults.maxDuration), \"Spring duration must be 10 seconds or less\");\n    let dampingRatio = 1 - bounce;\n    /**\n     * Restrict dampingRatio and duration to within acceptable ranges.\n     */ dampingRatio = clamp(springDefaults.minDamping, springDefaults.maxDamping, dampingRatio);\n    duration = clamp(springDefaults.minDuration, springDefaults.maxDuration, millisecondsToSeconds(duration));\n    if (dampingRatio < 1) {\n        /**\n         * Underdamped spring\n         */ envelope = (undampedFreq)=>{\n            const exponentialDecay = undampedFreq * dampingRatio;\n            const delta = exponentialDecay * duration;\n            const a = exponentialDecay - velocity;\n            const b = calcAngularFreq(undampedFreq, dampingRatio);\n            const c = Math.exp(-delta);\n            return safeMin - a / b * c;\n        };\n        derivative = (undampedFreq)=>{\n            const exponentialDecay = undampedFreq * dampingRatio;\n            const delta = exponentialDecay * duration;\n            const d = delta * velocity + velocity;\n            const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq, 2) * duration;\n            const f = Math.exp(-delta);\n            const g = calcAngularFreq(Math.pow(undampedFreq, 2), dampingRatio);\n            const factor = -envelope(undampedFreq) + safeMin > 0 ? -1 : 1;\n            return factor * ((d - e) * f) / g;\n        };\n    } else {\n        /**\n         * Critically-damped spring\n         */ envelope = (undampedFreq)=>{\n            const a = Math.exp(-undampedFreq * duration);\n            const b = (undampedFreq - velocity) * duration + 1;\n            return -safeMin + a * b;\n        };\n        derivative = (undampedFreq)=>{\n            const a = Math.exp(-undampedFreq * duration);\n            const b = (velocity - undampedFreq) * (duration * duration);\n            return a * b;\n        };\n    }\n    const initialGuess = 5 / duration;\n    const undampedFreq = approximateRoot(envelope, derivative, initialGuess);\n    duration = secondsToMilliseconds(duration);\n    if (isNaN(undampedFreq)) {\n        return {\n            stiffness: springDefaults.stiffness,\n            damping: springDefaults.damping,\n            duration\n        };\n    } else {\n        const stiffness = Math.pow(undampedFreq, 2) * mass;\n        return {\n            stiffness,\n            damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),\n            duration\n        };\n    }\n}\nconst rootIterations = 12;\nfunction approximateRoot(envelope, derivative, initialGuess) {\n    let result = initialGuess;\n    for(let i = 1; i < rootIterations; i++){\n        result = result - envelope(result) / derivative(result);\n    }\n    return result;\n}\nfunction calcAngularFreq(undampedFreq, dampingRatio) {\n    return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);\n}\n/**\n * Implement a practical max duration for keyframe generation\n * to prevent infinite loops\n */ const maxGeneratorDuration = 20000;\nfunction calcGeneratorDuration(generator) {\n    let duration = 0;\n    const timeStep = 50;\n    let state = generator.next(duration);\n    while(!state.done && duration < maxGeneratorDuration){\n        duration += timeStep;\n        state = generator.next(duration);\n    }\n    return duration >= maxGeneratorDuration ? Infinity : duration;\n}\nconst durationKeys = [\n    \"duration\",\n    \"bounce\"\n];\nconst physicsKeys = [\n    \"stiffness\",\n    \"damping\",\n    \"mass\"\n];\nfunction isSpringType(options, keys) {\n    return keys.some((key)=>options[key] !== undefined);\n}\nfunction getSpringOptions(options) {\n    let springOptions = {\n        velocity: springDefaults.velocity,\n        stiffness: springDefaults.stiffness,\n        damping: springDefaults.damping,\n        mass: springDefaults.mass,\n        isResolvedFromDuration: false,\n        ...options\n    };\n    // stiffness/damping/mass overrides duration/bounce\n    if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {\n        if (options.visualDuration) {\n            const visualDuration = options.visualDuration;\n            const root = 2 * Math.PI / (visualDuration * 1.2);\n            const stiffness = root * root;\n            const damping = 2 * clamp(0.05, 1, 1 - options.bounce) * Math.sqrt(stiffness);\n            springOptions = {\n                ...springOptions,\n                mass: springDefaults.mass,\n                stiffness,\n                damping\n            };\n        } else {\n            const derived = findSpring(options);\n            springOptions = {\n                ...springOptions,\n                ...derived,\n                mass: springDefaults.mass\n            };\n            springOptions.isResolvedFromDuration = true;\n        }\n    }\n    return springOptions;\n}\nfunction spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce = springDefaults.bounce) {\n    const options = typeof optionsOrVisualDuration !== \"object\" ? {\n        visualDuration: optionsOrVisualDuration,\n        keyframes: [\n            0,\n            1\n        ],\n        bounce\n    } : optionsOrVisualDuration;\n    let { restSpeed, restDelta } = options;\n    const origin = options.keyframes[0];\n    const target = options.keyframes[options.keyframes.length - 1];\n    /**\n     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\n     * to reduce GC during animation.\n     */ const state = {\n        done: false,\n        value: origin\n    };\n    const { stiffness, damping, mass, duration, velocity, isResolvedFromDuration } = getSpringOptions({\n        ...options,\n        velocity: -millisecondsToSeconds(options.velocity || 0)\n    });\n    const initialVelocity = velocity || 0.0;\n    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n    const initialDelta = target - origin;\n    const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));\n    /**\n     * If we're working on a granular scale, use smaller defaults for determining\n     * when the spring is finished.\n     *\n     * These defaults have been selected emprically based on what strikes a good\n     * ratio between feeling good and finishing as soon as changes are imperceptible.\n     */ const isGranularScale = Math.abs(initialDelta) < 5;\n    restSpeed || (restSpeed = isGranularScale ? springDefaults.restSpeed.granular : springDefaults.restSpeed.default);\n    restDelta || (restDelta = isGranularScale ? springDefaults.restDelta.granular : springDefaults.restDelta.default);\n    let resolveSpring;\n    if (dampingRatio < 1) {\n        const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);\n        // Underdamped spring\n        resolveSpring = (t)=>{\n            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n            return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t) + initialDelta * Math.cos(angularFreq * t));\n        };\n    } else if (dampingRatio === 1) {\n        // Critically damped spring\n        resolveSpring = (t)=>target - Math.exp(-undampedAngularFreq * t) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t);\n    } else {\n        // Overdamped spring\n        const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\n        resolveSpring = (t)=>{\n            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n            // When performing sinh or cosh values can hit Infinity so we cap them here\n            const freqForT = Math.min(dampedAngularFreq * t, 300);\n            return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;\n        };\n    }\n    const generator = {\n        calculatedDuration: isResolvedFromDuration ? duration || null : null,\n        next: (t)=>{\n            const current = resolveSpring(t);\n            if (!isResolvedFromDuration) {\n                let currentVelocity = 0.0;\n                /**\n                 * We only need to calculate velocity for under-damped springs\n                 * as over- and critically-damped springs can't overshoot, so\n                 * checking only for displacement is enough.\n                 */ if (dampingRatio < 1) {\n                    currentVelocity = t === 0 ? secondsToMilliseconds(initialVelocity) : calcGeneratorVelocity(resolveSpring, t, current);\n                }\n                const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n                const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;\n                state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;\n            } else {\n                state.done = t >= duration;\n            }\n            state.value = state.done ? target : current;\n            return state;\n        },\n        toString: ()=>{\n            const calculatedDuration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);\n            const easing = generateLinearEasing((progress)=>generator.next(calculatedDuration * progress).value, calculatedDuration, 30);\n            return calculatedDuration + \"ms \" + easing;\n        }\n    };\n    return generator;\n}\nfunction inertia({ keyframes, velocity = 0.0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min, max, restDelta = 0.5, restSpeed }) {\n    const origin = keyframes[0];\n    const state = {\n        done: false,\n        value: origin\n    };\n    const isOutOfBounds = (v)=>min !== undefined && v < min || max !== undefined && v > max;\n    const nearestBoundary = (v)=>{\n        if (min === undefined) return max;\n        if (max === undefined) return min;\n        return Math.abs(min - v) < Math.abs(max - v) ? min : max;\n    };\n    let amplitude = power * velocity;\n    const ideal = origin + amplitude;\n    const target = modifyTarget === undefined ? ideal : modifyTarget(ideal);\n    /**\n     * If the target has changed we need to re-calculate the amplitude, otherwise\n     * the animation will start from the wrong position.\n     */ if (target !== ideal) amplitude = target - origin;\n    const calcDelta = (t)=>-amplitude * Math.exp(-t / timeConstant);\n    const calcLatest = (t)=>target + calcDelta(t);\n    const applyFriction = (t)=>{\n        const delta = calcDelta(t);\n        const latest = calcLatest(t);\n        state.done = Math.abs(delta) <= restDelta;\n        state.value = state.done ? target : latest;\n    };\n    /**\n     * Ideally this would resolve for t in a stateless way, we could\n     * do that by always precalculating the animation but as we know\n     * this will be done anyway we can assume that spring will\n     * be discovered during that.\n     */ let timeReachedBoundary;\n    let spring$1;\n    const checkCatchBoundary = (t)=>{\n        if (!isOutOfBounds(state.value)) return;\n        timeReachedBoundary = t;\n        spring$1 = spring({\n            keyframes: [\n                state.value,\n                nearestBoundary(state.value)\n            ],\n            velocity: calcGeneratorVelocity(calcLatest, t, state.value),\n            damping: bounceDamping,\n            stiffness: bounceStiffness,\n            restDelta,\n            restSpeed\n        });\n    };\n    checkCatchBoundary(0);\n    return {\n        calculatedDuration: null,\n        next: (t)=>{\n            /**\n             * We need to resolve the friction to figure out if we need a\n             * spring but we don't want to do this twice per frame. So here\n             * we flag if we updated for this frame and later if we did\n             * we can skip doing it again.\n             */ let hasUpdatedFrame = false;\n            if (!spring$1 && timeReachedBoundary === undefined) {\n                hasUpdatedFrame = true;\n                applyFriction(t);\n                checkCatchBoundary(t);\n            }\n            /**\n             * If we have a spring and the provided t is beyond the moment the friction\n             * animation crossed the min/max boundary, use the spring.\n             */ if (timeReachedBoundary !== undefined && t >= timeReachedBoundary) {\n                return spring$1.next(t - timeReachedBoundary);\n            } else {\n                !hasUpdatedFrame && applyFriction(t);\n                return state;\n            }\n        }\n    };\n}\nconst easeIn = /*@__PURE__*/ cubicBezier(0.42, 0, 1, 1);\nconst easeOut = /*@__PURE__*/ cubicBezier(0, 0, 0.58, 1);\nconst easeInOut = /*@__PURE__*/ cubicBezier(0.42, 0, 0.58, 1);\nconst isEasingArray = (ease)=>{\n    return Array.isArray(ease) && typeof ease[0] !== \"number\";\n};\nconst isBezierDefinition = (easing)=>Array.isArray(easing) && typeof easing[0] === \"number\";\nconst easingLookup = {\n    linear: motionUtils.noop,\n    easeIn,\n    easeInOut,\n    easeOut,\n    circIn,\n    circInOut,\n    circOut,\n    backIn,\n    backInOut,\n    backOut,\n    anticipate\n};\nconst easingDefinitionToFunction = (definition)=>{\n    if (isBezierDefinition(definition)) {\n        // If cubic bezier definition, create bezier curve\n        motionUtils.invariant(definition.length === 4, `Cubic bezier arrays must contain four numerical values.`);\n        const [x1, y1, x2, y2] = definition;\n        return cubicBezier(x1, y1, x2, y2);\n    } else if (typeof definition === \"string\") {\n        // Else lookup from table\n        motionUtils.invariant(easingLookup[definition] !== undefined, `Invalid easing type '${definition}'`);\n        return easingLookup[definition];\n    }\n    return definition;\n};\n/**\n * Pipe\n * Compose other transformers to run linearily\n * pipe(min(20), max(40))\n * @param  {...functions} transformers\n * @return {function}\n */ const combineFunctions = (a, b)=>(v)=>b(a(v));\nconst pipe = (...transformers)=>transformers.reduce(combineFunctions);\n/*\n  Value in range from progress\n\n  Given a lower limit and an upper limit, we return the value within\n  that range as expressed by progress (usually a number from 0 to 1)\n\n  So progress = 0.5 would change\n\n  from -------- to\n\n  to\n\n  from ---- to\n\n  E.g. from = 10, to = 20, progress = 0.5 => 15\n\n  @param [number]: Lower limit of range\n  @param [number]: Upper limit of range\n  @param [number]: The progress between lower and upper limits expressed 0-1\n  @return [number]: Value as calculated from progress within range (not limited within range)\n*/ const mixNumber$1 = (from, to, progress)=>{\n    return from + (to - from) * progress;\n};\n// Adapted from https://gist.github.com/mjackson/5311256\nfunction hueToRgb(p, q, t) {\n    if (t < 0) t += 1;\n    if (t > 1) t -= 1;\n    if (t < 1 / 6) return p + (q - p) * 6 * t;\n    if (t < 1 / 2) return q;\n    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n    return p;\n}\nfunction hslaToRgba({ hue, saturation, lightness, alpha }) {\n    hue /= 360;\n    saturation /= 100;\n    lightness /= 100;\n    let red = 0;\n    let green = 0;\n    let blue = 0;\n    if (!saturation) {\n        red = green = blue = lightness;\n    } else {\n        const q = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;\n        const p = 2 * lightness - q;\n        red = hueToRgb(p, q, hue + 1 / 3);\n        green = hueToRgb(p, q, hue);\n        blue = hueToRgb(p, q, hue - 1 / 3);\n    }\n    return {\n        red: Math.round(red * 255),\n        green: Math.round(green * 255),\n        blue: Math.round(blue * 255),\n        alpha\n    };\n}\nfunction mixImmediate(a, b) {\n    return (p)=>p > 0 ? b : a;\n}\n// Linear color space blending\n// Explained https://www.youtube.com/watch?v=LKnqECcg6Gw\n// Demonstrated http://codepen.io/osublake/pen/xGVVaN\nconst mixLinearColor = (from, to, v)=>{\n    const fromExpo = from * from;\n    const expo = v * (to * to - fromExpo) + fromExpo;\n    return expo < 0 ? 0 : Math.sqrt(expo);\n};\nconst colorTypes = [\n    hex,\n    rgba,\n    hsla\n];\nconst getColorType = (v)=>colorTypes.find((type)=>type.test(v));\nfunction asRGBA(color) {\n    const type = getColorType(color);\n    motionUtils.warning(Boolean(type), `'${color}' is not an animatable color. Use the equivalent color code instead.`);\n    if (!Boolean(type)) return false;\n    let model = type.parse(color);\n    if (type === hsla) {\n        // TODO Remove this cast - needed since Motion's stricter typing\n        model = hslaToRgba(model);\n    }\n    return model;\n}\nconst mixColor = (from, to)=>{\n    const fromRGBA = asRGBA(from);\n    const toRGBA = asRGBA(to);\n    if (!fromRGBA || !toRGBA) {\n        return mixImmediate(from, to);\n    }\n    const blended = {\n        ...fromRGBA\n    };\n    return (v)=>{\n        blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v);\n        blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v);\n        blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v);\n        blended.alpha = mixNumber$1(fromRGBA.alpha, toRGBA.alpha, v);\n        return rgba.transform(blended);\n    };\n};\nconst invisibleValues = new Set([\n    \"none\",\n    \"hidden\"\n]);\n/**\n * Returns a function that, when provided a progress value between 0 and 1,\n * will return the \"none\" or \"hidden\" string only when the progress is that of\n * the origin or target.\n */ function mixVisibility(origin, target) {\n    if (invisibleValues.has(origin)) {\n        return (p)=>p <= 0 ? origin : target;\n    } else {\n        return (p)=>p >= 1 ? target : origin;\n    }\n}\nfunction mixNumber(a, b) {\n    return (p)=>mixNumber$1(a, b, p);\n}\nfunction getMixer$1(a) {\n    if (typeof a === \"number\") {\n        return mixNumber;\n    } else if (typeof a === \"string\") {\n        return isCSSVariableToken(a) ? mixImmediate : color.test(a) ? mixColor : mixComplex;\n    } else if (Array.isArray(a)) {\n        return mixArray;\n    } else if (typeof a === \"object\") {\n        return color.test(a) ? mixColor : mixObject;\n    }\n    return mixImmediate;\n}\nfunction mixArray(a, b) {\n    const output = [\n        ...a\n    ];\n    const numValues = output.length;\n    const blendValue = a.map((v, i)=>getMixer$1(v)(v, b[i]));\n    return (p)=>{\n        for(let i = 0; i < numValues; i++){\n            output[i] = blendValue[i](p);\n        }\n        return output;\n    };\n}\nfunction mixObject(a, b) {\n    const output = {\n        ...a,\n        ...b\n    };\n    const blendValue = {};\n    for(const key in output){\n        if (a[key] !== undefined && b[key] !== undefined) {\n            blendValue[key] = getMixer$1(a[key])(a[key], b[key]);\n        }\n    }\n    return (v)=>{\n        for(const key in blendValue){\n            output[key] = blendValue[key](v);\n        }\n        return output;\n    };\n}\nfunction matchOrder(origin, target) {\n    var _a;\n    const orderedOrigin = [];\n    const pointers = {\n        color: 0,\n        var: 0,\n        number: 0\n    };\n    for(let i = 0; i < target.values.length; i++){\n        const type = target.types[i];\n        const originIndex = origin.indexes[type][pointers[type]];\n        const originValue = (_a = origin.values[originIndex]) !== null && _a !== void 0 ? _a : 0;\n        orderedOrigin[i] = originValue;\n        pointers[type]++;\n    }\n    return orderedOrigin;\n}\nconst mixComplex = (origin, target)=>{\n    const template = complex.createTransformer(target);\n    const originStats = analyseComplexValue(origin);\n    const targetStats = analyseComplexValue(target);\n    const canInterpolate = originStats.indexes.var.length === targetStats.indexes.var.length && originStats.indexes.color.length === targetStats.indexes.color.length && originStats.indexes.number.length >= targetStats.indexes.number.length;\n    if (canInterpolate) {\n        if (invisibleValues.has(origin) && !targetStats.values.length || invisibleValues.has(target) && !originStats.values.length) {\n            return mixVisibility(origin, target);\n        }\n        return pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);\n    } else {\n        motionUtils.warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);\n        return mixImmediate(origin, target);\n    }\n};\nfunction mix(from, to, p) {\n    if (typeof from === \"number\" && typeof to === \"number\" && typeof p === \"number\") {\n        return mixNumber$1(from, to, p);\n    }\n    const mixer = getMixer$1(from);\n    return mixer(from, to);\n}\nfunction createMixers(output, ease, customMixer) {\n    const mixers = [];\n    const mixerFactory = customMixer || mix;\n    const numMixers = output.length - 1;\n    for(let i = 0; i < numMixers; i++){\n        let mixer = mixerFactory(output[i], output[i + 1]);\n        if (ease) {\n            const easingFunction = Array.isArray(ease) ? ease[i] || motionUtils.noop : ease;\n            mixer = pipe(easingFunction, mixer);\n        }\n        mixers.push(mixer);\n    }\n    return mixers;\n}\n/**\n * Create a function that maps from a numerical input array to a generic output array.\n *\n * Accepts:\n *   - Numbers\n *   - Colors (hex, hsl, hsla, rgb, rgba)\n *   - Complex (combinations of one or more numbers or strings)\n *\n * ```jsx\n * const mixColor = interpolate([0, 1], ['#fff', '#000'])\n *\n * mixColor(0.5) // 'rgba(128, 128, 128, 1)'\n * ```\n *\n * TODO Revist this approach once we've moved to data models for values,\n * probably not needed to pregenerate mixer functions.\n *\n * @public\n */ function interpolate(input, output, { clamp: isClamp = true, ease, mixer } = {}) {\n    const inputLength = input.length;\n    motionUtils.invariant(inputLength === output.length, \"Both input and output ranges must be the same length\");\n    /**\n     * If we're only provided a single input, we can just make a function\n     * that returns the output.\n     */ if (inputLength === 1) return ()=>output[0];\n    if (inputLength === 2 && input[0] === input[1]) return ()=>output[1];\n    // If input runs highest -> lowest, reverse both arrays\n    if (input[0] > input[inputLength - 1]) {\n        input = [\n            ...input\n        ].reverse();\n        output = [\n            ...output\n        ].reverse();\n    }\n    const mixers = createMixers(output, ease, mixer);\n    const numMixers = mixers.length;\n    const interpolator = (v)=>{\n        let i = 0;\n        if (numMixers > 1) {\n            for(; i < input.length - 2; i++){\n                if (v < input[i + 1]) break;\n            }\n        }\n        const progressInRange = progress(input[i], input[i + 1], v);\n        return mixers[i](progressInRange);\n    };\n    return isClamp ? (v)=>interpolator(clamp(input[0], input[inputLength - 1], v)) : interpolator;\n}\nfunction fillOffset(offset, remaining) {\n    const min = offset[offset.length - 1];\n    for(let i = 1; i <= remaining; i++){\n        const offsetProgress = progress(0, remaining, i);\n        offset.push(mixNumber$1(min, 1, offsetProgress));\n    }\n}\nfunction defaultOffset$1(arr) {\n    const offset = [\n        0\n    ];\n    fillOffset(offset, arr.length - 1);\n    return offset;\n}\nfunction convertOffsetToTimes(offset, duration) {\n    return offset.map((o)=>o * duration);\n}\nfunction defaultEasing$1(values, easing) {\n    return values.map(()=>easing || easeInOut).splice(0, values.length - 1);\n}\nfunction keyframes({ duration = 300, keyframes: keyframeValues, times, ease = \"easeInOut\" }) {\n    /**\n     * Easing functions can be externally defined as strings. Here we convert them\n     * into actual functions.\n     */ const easingFunctions = isEasingArray(ease) ? ease.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease);\n    /**\n     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\n     * to reduce GC during animation.\n     */ const state = {\n        done: false,\n        value: keyframeValues[0]\n    };\n    /**\n     * Create a times array based on the provided 0-1 offsets\n     */ const absoluteTimes = convertOffsetToTimes(// Only use the provided offsets if they're the correct length\n    // TODO Maybe we should warn here if there's a length mismatch\n    times && times.length === keyframeValues.length ? times : defaultOffset$1(keyframeValues), duration);\n    const mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {\n        ease: Array.isArray(easingFunctions) ? easingFunctions : defaultEasing$1(keyframeValues, easingFunctions)\n    });\n    return {\n        calculatedDuration: duration,\n        next: (t)=>{\n            state.value = mapTimeToKeyframe(t);\n            state.done = t >= duration;\n            return state;\n        }\n    };\n}\nconst frameloopDriver = (update)=>{\n    const passTimestamp = ({ timestamp })=>update(timestamp);\n    return {\n        start: ()=>frame.update(passTimestamp, true),\n        stop: ()=>cancelFrame(passTimestamp),\n        /**\n         * If we're processing this frame we can use the\n         * framelocked timestamp to keep things in sync.\n         */ now: ()=>frameData.isProcessing ? frameData.timestamp : time.now()\n    };\n};\nconst generators = {\n    decay: inertia,\n    inertia,\n    tween: keyframes,\n    keyframes: keyframes,\n    spring\n};\nconst percentToProgress = (percent)=>percent / 100;\n/**\n * Animation that runs on the main thread. Designed to be WAAPI-spec in the subset of\n * features we expose publically. Mostly the compatibility is to ensure visual identity\n * between both WAAPI and main thread animations.\n */ class MainThreadAnimation extends BaseAnimation {\n    constructor(options){\n        super(options);\n        /**\n         * The time at which the animation was paused.\n         */ this.holdTime = null;\n        /**\n         * The time at which the animation was cancelled.\n         */ this.cancelTime = null;\n        /**\n         * The current time of the animation.\n         */ this.currentTime = 0;\n        /**\n         * Playback speed as a factor. 0 would be stopped, -1 reverse and 2 double speed.\n         */ this.playbackSpeed = 1;\n        /**\n         * The state of the animation to apply when the animation is resolved. This\n         * allows calls to the public API to control the animation before it is resolved,\n         * without us having to resolve it first.\n         */ this.pendingPlayState = \"running\";\n        /**\n         * The time at which the animation was started.\n         */ this.startTime = null;\n        this.state = \"idle\";\n        /**\n         * This method is bound to the instance to fix a pattern where\n         * animation.stop is returned as a reference from a useEffect.\n         */ this.stop = ()=>{\n            this.resolver.cancel();\n            this.isStopped = true;\n            if (this.state === \"idle\") return;\n            this.teardown();\n            const { onStop } = this.options;\n            onStop && onStop();\n        };\n        const { name, motionValue, element, keyframes } = this.options;\n        const KeyframeResolver$1 = (element === null || element === void 0 ? void 0 : element.KeyframeResolver) || KeyframeResolver;\n        const onResolved = (resolvedKeyframes, finalKeyframe)=>this.onKeyframesResolved(resolvedKeyframes, finalKeyframe);\n        this.resolver = new KeyframeResolver$1(keyframes, onResolved, name, motionValue, element);\n        this.resolver.scheduleResolve();\n    }\n    flatten() {\n        super.flatten();\n        // If we've already resolved the animation, re-initialise it\n        if (this._resolved) {\n            Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes));\n        }\n    }\n    initPlayback(keyframes$1) {\n        const { type = \"keyframes\", repeat = 0, repeatDelay = 0, repeatType, velocity = 0 } = this.options;\n        const generatorFactory = isGenerator(type) ? type : generators[type] || keyframes;\n        /**\n         * If our generator doesn't support mixing numbers, we need to replace keyframes with\n         * [0, 100] and then make a function that maps that to the actual keyframes.\n         *\n         * 100 is chosen instead of 1 as it works nicer with spring animations.\n         */ let mapPercentToKeyframes;\n        let mirroredGenerator;\n        if (generatorFactory !== keyframes && typeof keyframes$1[0] !== \"number\") {\n            if (true) {\n                motionUtils.invariant(keyframes$1.length === 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${keyframes$1}`);\n            }\n            mapPercentToKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));\n            keyframes$1 = [\n                0,\n                100\n            ];\n        }\n        const generator = generatorFactory({\n            ...this.options,\n            keyframes: keyframes$1\n        });\n        /**\n         * If we have a mirror repeat type we need to create a second generator that outputs the\n         * mirrored (not reversed) animation and later ping pong between the two generators.\n         */ if (repeatType === \"mirror\") {\n            mirroredGenerator = generatorFactory({\n                ...this.options,\n                keyframes: [\n                    ...keyframes$1\n                ].reverse(),\n                velocity: -velocity\n            });\n        }\n        /**\n         * If duration is undefined and we have repeat options,\n         * we need to calculate a duration from the generator.\n         *\n         * We set it to the generator itself to cache the duration.\n         * Any timeline resolver will need to have already precalculated\n         * the duration by this step.\n         */ if (generator.calculatedDuration === null) {\n            generator.calculatedDuration = calcGeneratorDuration(generator);\n        }\n        const { calculatedDuration } = generator;\n        const resolvedDuration = calculatedDuration + repeatDelay;\n        const totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;\n        return {\n            generator,\n            mirroredGenerator,\n            mapPercentToKeyframes,\n            calculatedDuration,\n            resolvedDuration,\n            totalDuration\n        };\n    }\n    onPostResolved() {\n        const { autoplay = true } = this.options;\n        this.play();\n        if (this.pendingPlayState === \"paused\" || !autoplay) {\n            this.pause();\n        } else {\n            this.state = this.pendingPlayState;\n        }\n    }\n    tick(timestamp, sample = false) {\n        const { resolved } = this;\n        // If the animations has failed to resolve, return the final keyframe.\n        if (!resolved) {\n            const { keyframes } = this.options;\n            return {\n                done: true,\n                value: keyframes[keyframes.length - 1]\n            };\n        }\n        const { finalKeyframe, generator, mirroredGenerator, mapPercentToKeyframes, keyframes, calculatedDuration, totalDuration, resolvedDuration } = resolved;\n        if (this.startTime === null) return generator.next(0);\n        const { delay, repeat, repeatType, repeatDelay, onUpdate } = this.options;\n        /**\n         * requestAnimationFrame timestamps can come through as lower than\n         * the startTime as set by performance.now(). Here we prevent this,\n         * though in the future it could be possible to make setting startTime\n         * a pending operation that gets resolved here.\n         */ if (this.speed > 0) {\n            this.startTime = Math.min(this.startTime, timestamp);\n        } else if (this.speed < 0) {\n            this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);\n        }\n        // Update currentTime\n        if (sample) {\n            this.currentTime = timestamp;\n        } else if (this.holdTime !== null) {\n            this.currentTime = this.holdTime;\n        } else {\n            // Rounding the time because floating point arithmetic is not always accurate, e.g. 3000.367 - 1000.367 =\n            // 2000.0000000000002. This is a problem when we are comparing the currentTime with the duration, for\n            // example.\n            this.currentTime = Math.round(timestamp - this.startTime) * this.speed;\n        }\n        // Rebase on delay\n        const timeWithoutDelay = this.currentTime - delay * (this.speed >= 0 ? 1 : -1);\n        const isInDelayPhase = this.speed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;\n        this.currentTime = Math.max(timeWithoutDelay, 0);\n        // If this animation has finished, set the current time  to the total duration.\n        if (this.state === \"finished\" && this.holdTime === null) {\n            this.currentTime = totalDuration;\n        }\n        let elapsed = this.currentTime;\n        let frameGenerator = generator;\n        if (repeat) {\n            /**\n             * Get the current progress (0-1) of the animation. If t is >\n             * than duration we'll get values like 2.5 (midway through the\n             * third iteration)\n             */ const progress = Math.min(this.currentTime, totalDuration) / resolvedDuration;\n            /**\n             * Get the current iteration (0 indexed). For instance the floor of\n             * 2.5 is 2.\n             */ let currentIteration = Math.floor(progress);\n            /**\n             * Get the current progress of the iteration by taking the remainder\n             * so 2.5 is 0.5 through iteration 2\n             */ let iterationProgress = progress % 1.0;\n            /**\n             * If iteration progress is 1 we count that as the end\n             * of the previous iteration.\n             */ if (!iterationProgress && progress >= 1) {\n                iterationProgress = 1;\n            }\n            iterationProgress === 1 && currentIteration--;\n            currentIteration = Math.min(currentIteration, repeat + 1);\n            /**\n             * Reverse progress if we're not running in \"normal\" direction\n             */ const isOddIteration = Boolean(currentIteration % 2);\n            if (isOddIteration) {\n                if (repeatType === \"reverse\") {\n                    iterationProgress = 1 - iterationProgress;\n                    if (repeatDelay) {\n                        iterationProgress -= repeatDelay / resolvedDuration;\n                    }\n                } else if (repeatType === \"mirror\") {\n                    frameGenerator = mirroredGenerator;\n                }\n            }\n            elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;\n        }\n        /**\n         * If we're in negative time, set state as the initial keyframe.\n         * This prevents delay: x, duration: 0 animations from finishing\n         * instantly.\n         */ const state = isInDelayPhase ? {\n            done: false,\n            value: keyframes[0]\n        } : frameGenerator.next(elapsed);\n        if (mapPercentToKeyframes) {\n            state.value = mapPercentToKeyframes(state.value);\n        }\n        let { done } = state;\n        if (!isInDelayPhase && calculatedDuration !== null) {\n            done = this.speed >= 0 ? this.currentTime >= totalDuration : this.currentTime <= 0;\n        }\n        const isAnimationFinished = this.holdTime === null && (this.state === \"finished\" || this.state === \"running\" && done);\n        if (isAnimationFinished && finalKeyframe !== undefined) {\n            state.value = getFinalKeyframe(keyframes, this.options, finalKeyframe);\n        }\n        if (onUpdate) {\n            onUpdate(state.value);\n        }\n        if (isAnimationFinished) {\n            this.finish();\n        }\n        return state;\n    }\n    get duration() {\n        const { resolved } = this;\n        return resolved ? millisecondsToSeconds(resolved.calculatedDuration) : 0;\n    }\n    get time() {\n        return millisecondsToSeconds(this.currentTime);\n    }\n    set time(newTime) {\n        newTime = secondsToMilliseconds(newTime);\n        this.currentTime = newTime;\n        if (this.holdTime !== null || this.speed === 0) {\n            this.holdTime = newTime;\n        } else if (this.driver) {\n            this.startTime = this.driver.now() - newTime / this.speed;\n        }\n    }\n    get speed() {\n        return this.playbackSpeed;\n    }\n    set speed(newSpeed) {\n        const hasChanged = this.playbackSpeed !== newSpeed;\n        this.playbackSpeed = newSpeed;\n        if (hasChanged) {\n            this.time = millisecondsToSeconds(this.currentTime);\n        }\n    }\n    play() {\n        if (!this.resolver.isScheduled) {\n            this.resolver.resume();\n        }\n        if (!this._resolved) {\n            this.pendingPlayState = \"running\";\n            return;\n        }\n        if (this.isStopped) return;\n        const { driver = frameloopDriver, onPlay, startTime } = this.options;\n        if (!this.driver) {\n            this.driver = driver((timestamp)=>this.tick(timestamp));\n        }\n        onPlay && onPlay();\n        const now = this.driver.now();\n        if (this.holdTime !== null) {\n            this.startTime = now - this.holdTime;\n        } else if (!this.startTime) {\n            this.startTime = startTime !== null && startTime !== void 0 ? startTime : this.calcStartTime();\n        } else if (this.state === \"finished\") {\n            this.startTime = now;\n        }\n        if (this.state === \"finished\") {\n            this.updateFinishedPromise();\n        }\n        this.cancelTime = this.startTime;\n        this.holdTime = null;\n        /**\n         * Set playState to running only after we've used it in\n         * the previous logic.\n         */ this.state = \"running\";\n        this.driver.start();\n    }\n    pause() {\n        var _a;\n        if (!this._resolved) {\n            this.pendingPlayState = \"paused\";\n            return;\n        }\n        this.state = \"paused\";\n        this.holdTime = (_a = this.currentTime) !== null && _a !== void 0 ? _a : 0;\n    }\n    complete() {\n        if (this.state !== \"running\") {\n            this.play();\n        }\n        this.pendingPlayState = this.state = \"finished\";\n        this.holdTime = null;\n    }\n    finish() {\n        this.teardown();\n        this.state = \"finished\";\n        const { onComplete } = this.options;\n        onComplete && onComplete();\n    }\n    cancel() {\n        if (this.cancelTime !== null) {\n            this.tick(this.cancelTime);\n        }\n        this.teardown();\n        this.updateFinishedPromise();\n    }\n    teardown() {\n        this.state = \"idle\";\n        this.stopDriver();\n        this.resolveFinishedPromise();\n        this.updateFinishedPromise();\n        this.startTime = this.cancelTime = null;\n        this.resolver.cancel();\n    }\n    stopDriver() {\n        if (!this.driver) return;\n        this.driver.stop();\n        this.driver = undefined;\n    }\n    sample(time) {\n        this.startTime = 0;\n        return this.tick(time, true);\n    }\n}\n// Legacy interface\nfunction animateValue(options) {\n    return new MainThreadAnimation(options);\n}\n/**\n * A list of values that can be hardware-accelerated.\n */ const acceleratedValues = new Set([\n    \"opacity\",\n    \"clipPath\",\n    \"filter\",\n    \"transform\"\n]);\nfunction memo(callback) {\n    let result;\n    return ()=>{\n        if (result === undefined) result = callback();\n        return result;\n    };\n}\n/**\n * Add the ability for test suites to manually set support flags\n * to better test more environments.\n */ const supportsFlags = {\n    linearEasing: undefined\n};\nfunction memoSupports(callback, supportsFlag) {\n    const memoized = memo(callback);\n    return ()=>{\n        var _a;\n        return (_a = supportsFlags[supportsFlag]) !== null && _a !== void 0 ? _a : memoized();\n    };\n}\nconst supportsLinearEasing = /*@__PURE__*/ memoSupports(()=>{\n    try {\n        document.createElement(\"div\").animate({\n            opacity: 0\n        }, {\n            easing: \"linear(0, 1)\"\n        });\n    } catch (e) {\n        return false;\n    }\n    return true;\n}, \"linearEasing\");\nfunction isWaapiSupportedEasing(easing) {\n    return Boolean(typeof easing === \"function\" && supportsLinearEasing() || !easing || typeof easing === \"string\" && (easing in supportedWaapiEasing || supportsLinearEasing()) || isBezierDefinition(easing) || Array.isArray(easing) && easing.every(isWaapiSupportedEasing));\n}\nconst cubicBezierAsString = ([a, b, c, d])=>`cubic-bezier(${a}, ${b}, ${c}, ${d})`;\nconst supportedWaapiEasing = {\n    linear: \"linear\",\n    ease: \"ease\",\n    easeIn: \"ease-in\",\n    easeOut: \"ease-out\",\n    easeInOut: \"ease-in-out\",\n    circIn: /*@__PURE__*/ cubicBezierAsString([\n        0,\n        0.65,\n        0.55,\n        1\n    ]),\n    circOut: /*@__PURE__*/ cubicBezierAsString([\n        0.55,\n        0,\n        1,\n        0.45\n    ]),\n    backIn: /*@__PURE__*/ cubicBezierAsString([\n        0.31,\n        0.01,\n        0.66,\n        -0.59\n    ]),\n    backOut: /*@__PURE__*/ cubicBezierAsString([\n        0.33,\n        1.53,\n        0.69,\n        0.99\n    ])\n};\nfunction mapEasingToNativeEasing(easing, duration) {\n    if (!easing) {\n        return undefined;\n    } else if (typeof easing === \"function\" && supportsLinearEasing()) {\n        return generateLinearEasing(easing, duration);\n    } else if (isBezierDefinition(easing)) {\n        return cubicBezierAsString(easing);\n    } else if (Array.isArray(easing)) {\n        return easing.map((segmentEasing)=>mapEasingToNativeEasing(segmentEasing, duration) || supportedWaapiEasing.easeOut);\n    } else {\n        return supportedWaapiEasing[easing];\n    }\n}\nfunction startWaapiAnimation(element, valueName, keyframes, { delay = 0, duration = 300, repeat = 0, repeatType = \"loop\", ease = \"easeInOut\", times } = {}) {\n    const keyframeOptions = {\n        [valueName]: keyframes\n    };\n    if (times) keyframeOptions.offset = times;\n    const easing = mapEasingToNativeEasing(ease, duration);\n    /**\n     * If this is an easing array, apply to keyframes, not animation as a whole\n     */ if (Array.isArray(easing)) keyframeOptions.easing = easing;\n    return element.animate(keyframeOptions, {\n        delay,\n        duration,\n        easing: !Array.isArray(easing) ? easing : \"linear\",\n        fill: \"both\",\n        iterations: repeat + 1,\n        direction: repeatType === \"reverse\" ? \"alternate\" : \"normal\"\n    });\n}\nfunction attachTimeline(animation, timeline) {\n    animation.timeline = timeline;\n    animation.onfinish = null;\n}\nconst supportsWaapi = /*@__PURE__*/ memo(()=>Object.hasOwnProperty.call(Element.prototype, \"animate\"));\n/**\n * 10ms is chosen here as it strikes a balance between smooth\n * results (more than one keyframe per frame at 60fps) and\n * keyframe quantity.\n */ const sampleDelta = 10; //ms\n/**\n * Implement a practical max duration for keyframe generation\n * to prevent infinite loops\n */ const maxDuration = 20000;\n/**\n * Check if an animation can run natively via WAAPI or requires pregenerated keyframes.\n * WAAPI doesn't support spring or function easings so we run these as JS animation before\n * handing off.\n */ function requiresPregeneratedKeyframes(options) {\n    return isGenerator(options.type) || options.type === \"spring\" || !isWaapiSupportedEasing(options.ease);\n}\nfunction pregenerateKeyframes(keyframes, options) {\n    /**\n     * Create a main-thread animation to pregenerate keyframes.\n     * We sample this at regular intervals to generate keyframes that we then\n     * linearly interpolate between.\n     */ const sampleAnimation = new MainThreadAnimation({\n        ...options,\n        keyframes,\n        repeat: 0,\n        delay: 0,\n        isGenerator: true\n    });\n    let state = {\n        done: false,\n        value: keyframes[0]\n    };\n    const pregeneratedKeyframes = [];\n    /**\n     * Bail after 20 seconds of pre-generated keyframes as it's likely\n     * we're heading for an infinite loop.\n     */ let t = 0;\n    while(!state.done && t < maxDuration){\n        state = sampleAnimation.sample(t);\n        pregeneratedKeyframes.push(state.value);\n        t += sampleDelta;\n    }\n    return {\n        times: undefined,\n        keyframes: pregeneratedKeyframes,\n        duration: t - sampleDelta,\n        ease: \"linear\"\n    };\n}\nconst unsupportedEasingFunctions = {\n    anticipate,\n    backInOut,\n    circInOut\n};\nfunction isUnsupportedEase(key) {\n    return key in unsupportedEasingFunctions;\n}\nclass AcceleratedAnimation extends BaseAnimation {\n    constructor(options){\n        super(options);\n        const { name, motionValue, element, keyframes } = this.options;\n        this.resolver = new DOMKeyframesResolver(keyframes, (resolvedKeyframes, finalKeyframe)=>this.onKeyframesResolved(resolvedKeyframes, finalKeyframe), name, motionValue, element);\n        this.resolver.scheduleResolve();\n    }\n    initPlayback(keyframes, finalKeyframe) {\n        var _a;\n        let { duration = 300, times, ease, type, motionValue, name, startTime } = this.options;\n        /**\n         * If element has since been unmounted, return false to indicate\n         * the animation failed to initialised.\n         */ if (!((_a = motionValue.owner) === null || _a === void 0 ? void 0 : _a.current)) {\n            return false;\n        }\n        /**\n         * If the user has provided an easing function name that isn't supported\n         * by WAAPI (like \"anticipate\"), we need to provide the corressponding\n         * function. This will later get converted to a linear() easing function.\n         */ if (typeof ease === \"string\" && supportsLinearEasing() && isUnsupportedEase(ease)) {\n            ease = unsupportedEasingFunctions[ease];\n        }\n        /**\n         * If this animation needs pre-generated keyframes then generate.\n         */ if (requiresPregeneratedKeyframes(this.options)) {\n            const { onComplete, onUpdate, motionValue, element, ...options } = this.options;\n            const pregeneratedAnimation = pregenerateKeyframes(keyframes, options);\n            keyframes = pregeneratedAnimation.keyframes;\n            // If this is a very short animation, ensure we have\n            // at least two keyframes to animate between as older browsers\n            // can't animate between a single keyframe.\n            if (keyframes.length === 1) {\n                keyframes[1] = keyframes[0];\n            }\n            duration = pregeneratedAnimation.duration;\n            times = pregeneratedAnimation.times;\n            ease = pregeneratedAnimation.ease;\n            type = \"keyframes\";\n        }\n        const animation = startWaapiAnimation(motionValue.owner.current, name, keyframes, {\n            ...this.options,\n            duration,\n            times,\n            ease\n        });\n        // Override the browser calculated startTime with one synchronised to other JS\n        // and WAAPI animations starting this event loop.\n        animation.startTime = startTime !== null && startTime !== void 0 ? startTime : this.calcStartTime();\n        if (this.pendingTimeline) {\n            attachTimeline(animation, this.pendingTimeline);\n            this.pendingTimeline = undefined;\n        } else {\n            /**\n             * Prefer the `onfinish` prop as it's more widely supported than\n             * the `finished` promise.\n             *\n             * Here, we synchronously set the provided MotionValue to the end\n             * keyframe. If we didn't, when the WAAPI animation is finished it would\n             * be removed from the element which would then revert to its old styles.\n             */ animation.onfinish = ()=>{\n                const { onComplete } = this.options;\n                motionValue.set(getFinalKeyframe(keyframes, this.options, finalKeyframe));\n                onComplete && onComplete();\n                this.cancel();\n                this.resolveFinishedPromise();\n            };\n        }\n        return {\n            animation,\n            duration,\n            times,\n            type,\n            ease,\n            keyframes: keyframes\n        };\n    }\n    get duration() {\n        const { resolved } = this;\n        if (!resolved) return 0;\n        const { duration } = resolved;\n        return millisecondsToSeconds(duration);\n    }\n    get time() {\n        const { resolved } = this;\n        if (!resolved) return 0;\n        const { animation } = resolved;\n        return millisecondsToSeconds(animation.currentTime || 0);\n    }\n    set time(newTime) {\n        const { resolved } = this;\n        if (!resolved) return;\n        const { animation } = resolved;\n        animation.currentTime = secondsToMilliseconds(newTime);\n    }\n    get speed() {\n        const { resolved } = this;\n        if (!resolved) return 1;\n        const { animation } = resolved;\n        return animation.playbackRate;\n    }\n    set speed(newSpeed) {\n        const { resolved } = this;\n        if (!resolved) return;\n        const { animation } = resolved;\n        animation.playbackRate = newSpeed;\n    }\n    get state() {\n        const { resolved } = this;\n        if (!resolved) return \"idle\";\n        const { animation } = resolved;\n        return animation.playState;\n    }\n    get startTime() {\n        const { resolved } = this;\n        if (!resolved) return null;\n        const { animation } = resolved;\n        // Coerce to number as TypeScript incorrectly types this\n        // as CSSNumberish\n        return animation.startTime;\n    }\n    /**\n     * Replace the default DocumentTimeline with another AnimationTimeline.\n     * Currently used for scroll animations.\n     */ attachTimeline(timeline) {\n        if (!this._resolved) {\n            this.pendingTimeline = timeline;\n        } else {\n            const { resolved } = this;\n            if (!resolved) return motionUtils.noop;\n            const { animation } = resolved;\n            attachTimeline(animation, timeline);\n        }\n        return motionUtils.noop;\n    }\n    play() {\n        if (this.isStopped) return;\n        const { resolved } = this;\n        if (!resolved) return;\n        const { animation } = resolved;\n        if (animation.playState === \"finished\") {\n            this.updateFinishedPromise();\n        }\n        animation.play();\n    }\n    pause() {\n        const { resolved } = this;\n        if (!resolved) return;\n        const { animation } = resolved;\n        animation.pause();\n    }\n    stop() {\n        this.resolver.cancel();\n        this.isStopped = true;\n        if (this.state === \"idle\") return;\n        this.resolveFinishedPromise();\n        this.updateFinishedPromise();\n        const { resolved } = this;\n        if (!resolved) return;\n        const { animation, keyframes, duration, type, ease, times } = resolved;\n        if (animation.playState === \"idle\" || animation.playState === \"finished\") {\n            return;\n        }\n        /**\n         * WAAPI doesn't natively have any interruption capabilities.\n         *\n         * Rather than read commited styles back out of the DOM, we can\n         * create a renderless JS animation and sample it twice to calculate\n         * its current value, \"previous\" value, and therefore allow\n         * Motion to calculate velocity for any subsequent animation.\n         */ if (this.time) {\n            const { motionValue, onUpdate, onComplete, element, ...options } = this.options;\n            const sampleAnimation = new MainThreadAnimation({\n                ...options,\n                keyframes,\n                duration,\n                type,\n                ease,\n                times,\n                isGenerator: true\n            });\n            const sampleTime = secondsToMilliseconds(this.time);\n            motionValue.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);\n        }\n        const { onStop } = this.options;\n        onStop && onStop();\n        this.cancel();\n    }\n    complete() {\n        const { resolved } = this;\n        if (!resolved) return;\n        resolved.animation.finish();\n    }\n    cancel() {\n        const { resolved } = this;\n        if (!resolved) return;\n        resolved.animation.cancel();\n    }\n    static supports(options) {\n        const { motionValue, name, repeatDelay, repeatType, damping, type } = options;\n        return supportsWaapi() && name && acceleratedValues.has(name) && motionValue && motionValue.owner && motionValue.owner.current instanceof HTMLElement && /**\n             * If we're outputting values to onUpdate then we can't use WAAPI as there's\n             * no way to read the value from WAAPI every frame.\n             */ !motionValue.owner.getProps().onUpdate && !repeatDelay && repeatType !== \"mirror\" && damping !== 0 && type !== \"inertia\";\n    }\n}\nconst supportsScrollTimeline = memo(()=>window.ScrollTimeline !== undefined);\nclass GroupPlaybackControls {\n    constructor(animations){\n        // Bound to accomodate common `return animation.stop` pattern\n        this.stop = ()=>this.runAll(\"stop\");\n        this.animations = animations.filter(Boolean);\n    }\n    then(onResolve, onReject) {\n        return Promise.all(this.animations).then(onResolve).catch(onReject);\n    }\n    /**\n     * TODO: Filter out cancelled or stopped animations before returning\n     */ getAll(propName) {\n        return this.animations[0][propName];\n    }\n    setAll(propName, newValue) {\n        for(let i = 0; i < this.animations.length; i++){\n            this.animations[i][propName] = newValue;\n        }\n    }\n    attachTimeline(timeline, fallback) {\n        const subscriptions = this.animations.map((animation)=>{\n            if (supportsScrollTimeline() && animation.attachTimeline) {\n                return animation.attachTimeline(timeline);\n            } else {\n                return fallback(animation);\n            }\n        });\n        return ()=>{\n            subscriptions.forEach((cancel, i)=>{\n                cancel && cancel();\n                this.animations[i].stop();\n            });\n        };\n    }\n    get time() {\n        return this.getAll(\"time\");\n    }\n    set time(time) {\n        this.setAll(\"time\", time);\n    }\n    get speed() {\n        return this.getAll(\"speed\");\n    }\n    set speed(speed) {\n        this.setAll(\"speed\", speed);\n    }\n    get startTime() {\n        return this.getAll(\"startTime\");\n    }\n    get duration() {\n        let max = 0;\n        for(let i = 0; i < this.animations.length; i++){\n            max = Math.max(max, this.animations[i].duration);\n        }\n        return max;\n    }\n    runAll(methodName) {\n        this.animations.forEach((controls)=>controls[methodName]());\n    }\n    flatten() {\n        this.runAll(\"flatten\");\n    }\n    play() {\n        this.runAll(\"play\");\n    }\n    pause() {\n        this.runAll(\"pause\");\n    }\n    cancel() {\n        this.runAll(\"cancel\");\n    }\n    complete() {\n        this.runAll(\"complete\");\n    }\n}\n/**\n * Decide whether a transition is defined on a given Transition.\n * This filters out orchestration options and returns true\n * if any options are left.\n */ function isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from, elapsed, ...transition }) {\n    return !!Object.keys(transition).length;\n}\nconst animateMotionValue = (name, value, target, transition = {}, element, isHandoff)=>(onComplete)=>{\n        const valueTransition = getValueTransition$1(transition, name) || {};\n        /**\n     * Most transition values are currently completely overwritten by value-specific\n     * transitions. In the future it'd be nicer to blend these transitions. But for now\n     * delay actually does inherit from the root transition if not value-specific.\n     */ const delay = valueTransition.delay || transition.delay || 0;\n        /**\n     * Elapsed isn't a public transition option but can be passed through from\n     * optimized appear effects in milliseconds.\n     */ let { elapsed = 0 } = transition;\n        elapsed = elapsed - secondsToMilliseconds(delay);\n        let options = {\n            keyframes: Array.isArray(target) ? target : [\n                null,\n                target\n            ],\n            ease: \"easeOut\",\n            velocity: value.getVelocity(),\n            ...valueTransition,\n            delay: -elapsed,\n            onUpdate: (v)=>{\n                value.set(v);\n                valueTransition.onUpdate && valueTransition.onUpdate(v);\n            },\n            onComplete: ()=>{\n                onComplete();\n                valueTransition.onComplete && valueTransition.onComplete();\n            },\n            name,\n            motionValue: value,\n            element: isHandoff ? undefined : element\n        };\n        /**\n     * If there's no transition defined for this value, we can generate\n     * unqiue transition settings for this value.\n     */ if (!isTransitionDefined(valueTransition)) {\n            options = {\n                ...options,\n                ...getDefaultTransition(name, options)\n            };\n        }\n        /**\n     * Both WAAPI and our internal animation functions use durations\n     * as defined by milliseconds, while our external API defines them\n     * as seconds.\n     */ if (options.duration) {\n            options.duration = secondsToMilliseconds(options.duration);\n        }\n        if (options.repeatDelay) {\n            options.repeatDelay = secondsToMilliseconds(options.repeatDelay);\n        }\n        if (options.from !== undefined) {\n            options.keyframes[0] = options.from;\n        }\n        let shouldSkip = false;\n        if (options.type === false || options.duration === 0 && !options.repeatDelay) {\n            options.duration = 0;\n            if (options.delay === 0) {\n                shouldSkip = true;\n            }\n        }\n        if (instantAnimationState.current || MotionGlobalConfig.skipAnimations) {\n            shouldSkip = true;\n            options.duration = 0;\n            options.delay = 0;\n        }\n        /**\n     * If we can or must skip creating the animation, and apply only\n     * the final keyframe, do so. We also check once keyframes are resolved but\n     * this early check prevents the need to create an animation at all.\n     */ if (shouldSkip && !isHandoff && value.get() !== undefined) {\n            const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);\n            if (finalKeyframe !== undefined) {\n                frame.update(()=>{\n                    options.onUpdate(finalKeyframe);\n                    options.onComplete();\n                });\n                // We still want to return some animation controls here rather\n                // than returning undefined\n                return new GroupPlaybackControls([]);\n            }\n        }\n        /**\n     * Animate via WAAPI if possible. If this is a handoff animation, the optimised animation will be running via\n     * WAAPI. Therefore, this animation must be JS to ensure it runs \"under\" the\n     * optimised animation.\n     */ if (!isHandoff && AcceleratedAnimation.supports(options)) {\n            return new AcceleratedAnimation(options);\n        } else {\n            return new MainThreadAnimation(options);\n        }\n    };\nconst isCustomValue = (v)=>{\n    return Boolean(v && typeof v === \"object\" && v.mix && v.toValue);\n};\nconst resolveFinalValueInKeyframes = (v)=>{\n    // TODO maybe throw if v.length - 1 is placeholder token?\n    return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;\n};\nfunction addUniqueItem(arr, item) {\n    if (arr.indexOf(item) === -1) arr.push(item);\n}\nfunction removeItem(arr, item) {\n    const index = arr.indexOf(item);\n    if (index > -1) arr.splice(index, 1);\n}\n// Adapted from array-move\nfunction moveItem([...arr], fromIndex, toIndex) {\n    const startIndex = fromIndex < 0 ? arr.length + fromIndex : fromIndex;\n    if (startIndex >= 0 && startIndex < arr.length) {\n        const endIndex = toIndex < 0 ? arr.length + toIndex : toIndex;\n        const [item] = arr.splice(fromIndex, 1);\n        arr.splice(endIndex, 0, item);\n    }\n    return arr;\n}\nclass SubscriptionManager {\n    constructor(){\n        this.subscriptions = [];\n    }\n    add(handler) {\n        addUniqueItem(this.subscriptions, handler);\n        return ()=>removeItem(this.subscriptions, handler);\n    }\n    notify(a, b, c) {\n        const numSubscriptions = this.subscriptions.length;\n        if (!numSubscriptions) return;\n        if (numSubscriptions === 1) {\n            /**\n             * If there's only a single handler we can just call it without invoking a loop.\n             */ this.subscriptions[0](a, b, c);\n        } else {\n            for(let i = 0; i < numSubscriptions; i++){\n                /**\n                 * Check whether the handler exists before firing as it's possible\n                 * the subscriptions were modified during this loop running.\n                 */ const handler = this.subscriptions[i];\n                handler && handler(a, b, c);\n            }\n        }\n    }\n    getSize() {\n        return this.subscriptions.length;\n    }\n    clear() {\n        this.subscriptions.length = 0;\n    }\n}\n/**\n * Maximum time between the value of two frames, beyond which we\n * assume the velocity has since been 0.\n */ const MAX_VELOCITY_DELTA = 30;\nconst isFloat = (value)=>{\n    return !isNaN(parseFloat(value));\n};\nconst collectMotionValues = {\n    current: undefined\n};\n/**\n * `MotionValue` is used to track the state and velocity of motion values.\n *\n * @public\n */ class MotionValue {\n    /**\n     * @param init - The initiating value\n     * @param config - Optional configuration options\n     *\n     * -  `transformer`: A function to transform incoming values with.\n     *\n     * @internal\n     */ constructor(init, options = {}){\n        /**\n         * This will be replaced by the build step with the latest version number.\n         * When MotionValues are provided to motion components, warn if versions are mixed.\n         */ this.version = \"11.15.0\";\n        /**\n         * Tracks whether this value can output a velocity. Currently this is only true\n         * if the value is numerical, but we might be able to widen the scope here and support\n         * other value types.\n         *\n         * @internal\n         */ this.canTrackVelocity = null;\n        /**\n         * An object containing a SubscriptionManager for each active event.\n         */ this.events = {};\n        this.updateAndNotify = (v, render = true)=>{\n            const currentTime = time.now();\n            /**\n             * If we're updating the value during another frame or eventloop\n             * than the previous frame, then the we set the previous frame value\n             * to current.\n             */ if (this.updatedAt !== currentTime) {\n                this.setPrevFrameValue();\n            }\n            this.prev = this.current;\n            this.setCurrent(v);\n            // Update update subscribers\n            if (this.current !== this.prev && this.events.change) {\n                this.events.change.notify(this.current);\n            }\n            // Update render subscribers\n            if (render && this.events.renderRequest) {\n                this.events.renderRequest.notify(this.current);\n            }\n        };\n        this.hasAnimated = false;\n        this.setCurrent(init);\n        this.owner = options.owner;\n    }\n    setCurrent(current) {\n        this.current = current;\n        this.updatedAt = time.now();\n        if (this.canTrackVelocity === null && current !== undefined) {\n            this.canTrackVelocity = isFloat(this.current);\n        }\n    }\n    setPrevFrameValue(prevFrameValue = this.current) {\n        this.prevFrameValue = prevFrameValue;\n        this.prevUpdatedAt = this.updatedAt;\n    }\n    /**\n     * Adds a function that will be notified when the `MotionValue` is updated.\n     *\n     * It returns a function that, when called, will cancel the subscription.\n     *\n     * When calling `onChange` inside a React component, it should be wrapped with the\n     * `useEffect` hook. As it returns an unsubscribe function, this should be returned\n     * from the `useEffect` function to ensure you don't add duplicate subscribers..\n     *\n     * ```jsx\n     * export const MyComponent = () => {\n     *   const x = useMotionValue(0)\n     *   const y = useMotionValue(0)\n     *   const opacity = useMotionValue(1)\n     *\n     *   useEffect(() => {\n     *     function updateOpacity() {\n     *       const maxXY = Math.max(x.get(), y.get())\n     *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\n     *       opacity.set(newOpacity)\n     *     }\n     *\n     *     const unsubscribeX = x.on(\"change\", updateOpacity)\n     *     const unsubscribeY = y.on(\"change\", updateOpacity)\n     *\n     *     return () => {\n     *       unsubscribeX()\n     *       unsubscribeY()\n     *     }\n     *   }, [])\n     *\n     *   return <motion.div style={{ x }} />\n     * }\n     * ```\n     *\n     * @param subscriber - A function that receives the latest value.\n     * @returns A function that, when called, will cancel this subscription.\n     *\n     * @deprecated\n     */ onChange(subscription) {\n        if (true) {\n            warnOnce(false, `value.onChange(callback) is deprecated. Switch to value.on(\"change\", callback).`);\n        }\n        return this.on(\"change\", subscription);\n    }\n    on(eventName, callback) {\n        if (!this.events[eventName]) {\n            this.events[eventName] = new SubscriptionManager();\n        }\n        const unsubscribe = this.events[eventName].add(callback);\n        if (eventName === \"change\") {\n            return ()=>{\n                unsubscribe();\n                /**\n                 * If we have no more change listeners by the start\n                 * of the next frame, stop active animations.\n                 */ frame.read(()=>{\n                    if (!this.events.change.getSize()) {\n                        this.stop();\n                    }\n                });\n            };\n        }\n        return unsubscribe;\n    }\n    clearListeners() {\n        for(const eventManagers in this.events){\n            this.events[eventManagers].clear();\n        }\n    }\n    /**\n     * Attaches a passive effect to the `MotionValue`.\n     *\n     * @internal\n     */ attach(passiveEffect, stopPassiveEffect) {\n        this.passiveEffect = passiveEffect;\n        this.stopPassiveEffect = stopPassiveEffect;\n    }\n    /**\n     * Sets the state of the `MotionValue`.\n     *\n     * @remarks\n     *\n     * ```jsx\n     * const x = useMotionValue(0)\n     * x.set(10)\n     * ```\n     *\n     * @param latest - Latest value to set.\n     * @param render - Whether to notify render subscribers. Defaults to `true`\n     *\n     * @public\n     */ set(v, render = true) {\n        if (!render || !this.passiveEffect) {\n            this.updateAndNotify(v, render);\n        } else {\n            this.passiveEffect(v, this.updateAndNotify);\n        }\n    }\n    setWithVelocity(prev, current, delta) {\n        this.set(current);\n        this.prev = undefined;\n        this.prevFrameValue = prev;\n        this.prevUpdatedAt = this.updatedAt - delta;\n    }\n    /**\n     * Set the state of the `MotionValue`, stopping any active animations,\n     * effects, and resets velocity to `0`.\n     */ jump(v, endAnimation = true) {\n        this.updateAndNotify(v);\n        this.prev = v;\n        this.prevUpdatedAt = this.prevFrameValue = undefined;\n        endAnimation && this.stop();\n        if (this.stopPassiveEffect) this.stopPassiveEffect();\n    }\n    /**\n     * Returns the latest state of `MotionValue`\n     *\n     * @returns - The latest state of `MotionValue`\n     *\n     * @public\n     */ get() {\n        if (collectMotionValues.current) {\n            collectMotionValues.current.push(this);\n        }\n        return this.current;\n    }\n    /**\n     * @public\n     */ getPrevious() {\n        return this.prev;\n    }\n    /**\n     * Returns the latest velocity of `MotionValue`\n     *\n     * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.\n     *\n     * @public\n     */ getVelocity() {\n        const currentTime = time.now();\n        if (!this.canTrackVelocity || this.prevFrameValue === undefined || currentTime - this.updatedAt > MAX_VELOCITY_DELTA) {\n            return 0;\n        }\n        const delta = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA);\n        // Casts because of parseFloat's poor typing\n        return velocityPerSecond(parseFloat(this.current) - parseFloat(this.prevFrameValue), delta);\n    }\n    /**\n     * Registers a new animation to control this `MotionValue`. Only one\n     * animation can drive a `MotionValue` at one time.\n     *\n     * ```jsx\n     * value.start()\n     * ```\n     *\n     * @param animation - A function that starts the provided animation\n     *\n     * @internal\n     */ start(startAnimation) {\n        this.stop();\n        return new Promise((resolve)=>{\n            this.hasAnimated = true;\n            this.animation = startAnimation(resolve);\n            if (this.events.animationStart) {\n                this.events.animationStart.notify();\n            }\n        }).then(()=>{\n            if (this.events.animationComplete) {\n                this.events.animationComplete.notify();\n            }\n            this.clearAnimation();\n        });\n    }\n    /**\n     * Stop the currently active animation.\n     *\n     * @public\n     */ stop() {\n        if (this.animation) {\n            this.animation.stop();\n            if (this.events.animationCancel) {\n                this.events.animationCancel.notify();\n            }\n        }\n        this.clearAnimation();\n    }\n    /**\n     * Returns `true` if this value is currently animating.\n     *\n     * @public\n     */ isAnimating() {\n        return !!this.animation;\n    }\n    clearAnimation() {\n        delete this.animation;\n    }\n    /**\n     * Destroy and clean up subscribers to this `MotionValue`.\n     *\n     * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically\n     * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually\n     * created a `MotionValue` via the `motionValue` function.\n     *\n     * @public\n     */ destroy() {\n        this.clearListeners();\n        this.stop();\n        if (this.stopPassiveEffect) {\n            this.stopPassiveEffect();\n        }\n    }\n}\nfunction motionValue(init, options) {\n    return new MotionValue(init, options);\n}\n/**\n * Set VisualElement's MotionValue, creating a new MotionValue for it if\n * it doesn't exist.\n */ function setMotionValue(visualElement, key, value) {\n    if (visualElement.hasValue(key)) {\n        visualElement.getValue(key).set(value);\n    } else {\n        visualElement.addValue(key, motionValue(value));\n    }\n}\nfunction setTarget(visualElement, definition) {\n    const resolved = resolveVariant(visualElement, definition);\n    let { transitionEnd = {}, transition = {}, ...target } = resolved || {};\n    target = {\n        ...target,\n        ...transitionEnd\n    };\n    for(const key in target){\n        const value = resolveFinalValueInKeyframes(target[key]);\n        setMotionValue(visualElement, key, value);\n    }\n}\n/**\n * Convert camelCase to dash-case properties.\n */ const camelToDash = (str)=>str.replace(/([a-z])([A-Z])/gu, \"$1-$2\").toLowerCase();\nconst optimizedAppearDataId = \"framerAppearId\";\nconst optimizedAppearDataAttribute = \"data-\" + camelToDash(optimizedAppearDataId);\nfunction getOptimisedAppearId(visualElement) {\n    return visualElement.props[optimizedAppearDataAttribute];\n}\nconst isMotionValue = (value)=>Boolean(value && value.getVelocity);\nfunction isWillChangeMotionValue(value) {\n    return Boolean(isMotionValue(value) && value.add);\n}\nfunction addValueToWillChange(visualElement, key) {\n    const willChange = visualElement.getValue(\"willChange\");\n    /**\n     * It could be that a user has set willChange to a regular MotionValue,\n     * in which case we can't add the value to it.\n     */ if (isWillChangeMotionValue(willChange)) {\n        return willChange.add(key);\n    }\n}\n/**\n * Decide whether we should block this animation. Previously, we achieved this\n * just by checking whether the key was listed in protectedKeys, but this\n * posed problems if an animation was triggered by afterChildren and protectedKeys\n * had been set to true in the meantime.\n */ function shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {\n    const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;\n    needsAnimating[key] = false;\n    return shouldBlock;\n}\nfunction animateTarget(visualElement, targetAndTransition, { delay = 0, transitionOverride, type } = {}) {\n    var _a;\n    let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = targetAndTransition;\n    if (transitionOverride) transition = transitionOverride;\n    const animations = [];\n    const animationTypeState = type && visualElement.animationState && visualElement.animationState.getState()[type];\n    for(const key in target){\n        const value = visualElement.getValue(key, (_a = visualElement.latestValues[key]) !== null && _a !== void 0 ? _a : null);\n        const valueTarget = target[key];\n        if (valueTarget === undefined || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {\n            continue;\n        }\n        const valueTransition = {\n            delay,\n            ...getValueTransition$1(transition || {}, key)\n        };\n        /**\n         * If this is the first time a value is being animated, check\n         * to see if we're handling off from an existing animation.\n         */ let isHandoff = false;\n        if (window.MotionHandoffAnimation) {\n            const appearId = getOptimisedAppearId(visualElement);\n            if (appearId) {\n                const startTime = window.MotionHandoffAnimation(appearId, key, frame);\n                if (startTime !== null) {\n                    valueTransition.startTime = startTime;\n                    isHandoff = true;\n                }\n            }\n        }\n        addValueToWillChange(visualElement, key);\n        value.start(animateMotionValue(key, value, valueTarget, visualElement.shouldReduceMotion && transformProps.has(key) ? {\n            type: false\n        } : valueTransition, visualElement, isHandoff));\n        const animation = value.animation;\n        if (animation) {\n            animations.push(animation);\n        }\n    }\n    if (transitionEnd) {\n        Promise.all(animations).then(()=>{\n            frame.update(()=>{\n                transitionEnd && setTarget(visualElement, transitionEnd);\n            });\n        });\n    }\n    return animations;\n}\nfunction animateVariant(visualElement, variant, options = {}) {\n    var _a;\n    const resolved = resolveVariant(visualElement, variant, options.type === \"exit\" ? (_a = visualElement.presenceContext) === null || _a === void 0 ? void 0 : _a.custom : undefined);\n    let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};\n    if (options.transitionOverride) {\n        transition = options.transitionOverride;\n    }\n    /**\n     * If we have a variant, create a callback that runs it as an animation.\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\n     */ const getAnimation = resolved ? ()=>Promise.all(animateTarget(visualElement, resolved, options)) : ()=>Promise.resolve();\n    /**\n     * If we have children, create a callback that runs all their animations.\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\n     */ const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size ? (forwardDelay = 0)=>{\n        const { delayChildren = 0, staggerChildren, staggerDirection } = transition;\n        return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);\n    } : ()=>Promise.resolve();\n    /**\n     * If the transition explicitly defines a \"when\" option, we need to resolve either\n     * this animation or all children animations before playing the other.\n     */ const { when } = transition;\n    if (when) {\n        const [first, last] = when === \"beforeChildren\" ? [\n            getAnimation,\n            getChildAnimations\n        ] : [\n            getChildAnimations,\n            getAnimation\n        ];\n        return first().then(()=>last());\n    } else {\n        return Promise.all([\n            getAnimation(),\n            getChildAnimations(options.delay)\n        ]);\n    }\n}\nfunction animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {\n    const animations = [];\n    const maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;\n    const generateStaggerDuration = staggerDirection === 1 ? (i = 0)=>i * staggerChildren : (i = 0)=>maxStaggerDuration - i * staggerChildren;\n    Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach((child, i)=>{\n        child.notify(\"AnimationStart\", variant);\n        animations.push(animateVariant(child, variant, {\n            ...options,\n            delay: delayChildren + generateStaggerDuration(i)\n        }).then(()=>child.notify(\"AnimationComplete\", variant)));\n    });\n    return Promise.all(animations);\n}\nfunction sortByTreeOrder(a, b) {\n    return a.sortNodePosition(b);\n}\nfunction animateVisualElement(visualElement, definition, options = {}) {\n    visualElement.notify(\"AnimationStart\", definition);\n    let animation;\n    if (Array.isArray(definition)) {\n        const animations = definition.map((variant)=>animateVariant(visualElement, variant, options));\n        animation = Promise.all(animations);\n    } else if (typeof definition === \"string\") {\n        animation = animateVariant(visualElement, definition, options);\n    } else {\n        const resolvedDefinition = typeof definition === \"function\" ? resolveVariant(visualElement, definition, options.custom) : definition;\n        animation = Promise.all(animateTarget(visualElement, resolvedDefinition, options));\n    }\n    return animation.then(()=>{\n        visualElement.notify(\"AnimationComplete\", definition);\n    });\n}\nconst numVariantProps = variantProps.length;\nfunction getVariantContext(visualElement) {\n    if (!visualElement) return undefined;\n    if (!visualElement.isControllingVariants) {\n        const context = visualElement.parent ? getVariantContext(visualElement.parent) || {} : {};\n        if (visualElement.props.initial !== undefined) {\n            context.initial = visualElement.props.initial;\n        }\n        return context;\n    }\n    const context = {};\n    for(let i = 0; i < numVariantProps; i++){\n        const name = variantProps[i];\n        const prop = visualElement.props[name];\n        if (isVariantLabel(prop) || prop === false) {\n            context[name] = prop;\n        }\n    }\n    return context;\n}\nconst reversePriorityOrder = [\n    ...variantPriorityOrder\n].reverse();\nconst numAnimationTypes = variantPriorityOrder.length;\nfunction animateList(visualElement) {\n    return (animations)=>Promise.all(animations.map(({ animation, options })=>animateVisualElement(visualElement, animation, options)));\n}\nfunction createAnimationState(visualElement) {\n    let animate = animateList(visualElement);\n    let state = createState();\n    let isInitialRender = true;\n    /**\n     * This function will be used to reduce the animation definitions for\n     * each active animation type into an object of resolved values for it.\n     */ const buildResolvedTypeValues = (type)=>(acc, definition)=>{\n            var _a;\n            const resolved = resolveVariant(visualElement, definition, type === \"exit\" ? (_a = visualElement.presenceContext) === null || _a === void 0 ? void 0 : _a.custom : undefined);\n            if (resolved) {\n                const { transition, transitionEnd, ...target } = resolved;\n                acc = {\n                    ...acc,\n                    ...target,\n                    ...transitionEnd\n                };\n            }\n            return acc;\n        };\n    /**\n     * This just allows us to inject mocked animation functions\n     * @internal\n     */ function setAnimateFunction(makeAnimator) {\n        animate = makeAnimator(visualElement);\n    }\n    /**\n     * When we receive new props, we need to:\n     * 1. Create a list of protected keys for each type. This is a directory of\n     *    value keys that are currently being \"handled\" by types of a higher priority\n     *    so that whenever an animation is played of a given type, these values are\n     *    protected from being animated.\n     * 2. Determine if an animation type needs animating.\n     * 3. Determine if any values have been removed from a type and figure out\n     *    what to animate those to.\n     */ function animateChanges(changedActiveType) {\n        const { props } = visualElement;\n        const context = getVariantContext(visualElement.parent) || {};\n        /**\n         * A list of animations that we'll build into as we iterate through the animation\n         * types. This will get executed at the end of the function.\n         */ const animations = [];\n        /**\n         * Keep track of which values have been removed. Then, as we hit lower priority\n         * animation types, we can check if they contain removed values and animate to that.\n         */ const removedKeys = new Set();\n        /**\n         * A dictionary of all encountered keys. This is an object to let us build into and\n         * copy it without iteration. Each time we hit an animation type we set its protected\n         * keys - the keys its not allowed to animate - to the latest version of this object.\n         */ let encounteredKeys = {};\n        /**\n         * If a variant has been removed at a given index, and this component is controlling\n         * variant animations, we want to ensure lower-priority variants are forced to animate.\n         */ let removedVariantIndex = Infinity;\n        /**\n         * Iterate through all animation types in reverse priority order. For each, we want to\n         * detect which values it's handling and whether or not they've changed (and therefore\n         * need to be animated). If any values have been removed, we want to detect those in\n         * lower priority props and flag for animation.\n         */ for(let i = 0; i < numAnimationTypes; i++){\n            const type = reversePriorityOrder[i];\n            const typeState = state[type];\n            const prop = props[type] !== undefined ? props[type] : context[type];\n            const propIsVariant = isVariantLabel(prop);\n            /**\n             * If this type has *just* changed isActive status, set activeDelta\n             * to that status. Otherwise set to null.\n             */ const activeDelta = type === changedActiveType ? typeState.isActive : null;\n            if (activeDelta === false) removedVariantIndex = i;\n            /**\n             * If this prop is an inherited variant, rather than been set directly on the\n             * component itself, we want to make sure we allow the parent to trigger animations.\n             *\n             * TODO: Can probably change this to a !isControllingVariants check\n             */ let isInherited = prop === context[type] && prop !== props[type] && propIsVariant;\n            /**\n             *\n             */ if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {\n                isInherited = false;\n            }\n            /**\n             * Set all encountered keys so far as the protected keys for this type. This will\n             * be any key that has been animated or otherwise handled by active, higher-priortiy types.\n             */ typeState.protectedKeys = {\n                ...encounteredKeys\n            };\n            // Check if we can skip analysing this prop early\n            if (// If it isn't active and hasn't *just* been set as inactive\n            !typeState.isActive && activeDelta === null || // If we didn't and don't have any defined prop for this animation type\n            !prop && !typeState.prevProp || // Or if the prop doesn't define an animation\n            isAnimationControls(prop) || typeof prop === \"boolean\") {\n                continue;\n            }\n            /**\n             * As we go look through the values defined on this type, if we detect\n             * a changed value or a value that was removed in a higher priority, we set\n             * this to true and add this prop to the animation list.\n             */ const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);\n            let shouldAnimateType = variantDidChange || // If we're making this variant active, we want to always make it active\n            type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || // If we removed a higher-priority variant (i is in reverse order)\n            i > removedVariantIndex && propIsVariant;\n            let handledRemovedValues = false;\n            /**\n             * As animations can be set as variant lists, variants or target objects, we\n             * coerce everything to an array if it isn't one already\n             */ const definitionList = Array.isArray(prop) ? prop : [\n                prop\n            ];\n            /**\n             * Build an object of all the resolved values. We'll use this in the subsequent\n             * animateChanges calls to determine whether a value has changed.\n             */ let resolvedValues = definitionList.reduce(buildResolvedTypeValues(type), {});\n            if (activeDelta === false) resolvedValues = {};\n            /**\n             * Now we need to loop through all the keys in the prev prop and this prop,\n             * and decide:\n             * 1. If the value has changed, and needs animating\n             * 2. If it has been removed, and needs adding to the removedKeys set\n             * 3. If it has been removed in a higher priority type and needs animating\n             * 4. If it hasn't been removed in a higher priority but hasn't changed, and\n             *    needs adding to the type's protectedKeys list.\n             */ const { prevResolvedValues = {} } = typeState;\n            const allKeys = {\n                ...prevResolvedValues,\n                ...resolvedValues\n            };\n            const markToAnimate = (key)=>{\n                shouldAnimateType = true;\n                if (removedKeys.has(key)) {\n                    handledRemovedValues = true;\n                    removedKeys.delete(key);\n                }\n                typeState.needsAnimating[key] = true;\n                const motionValue = visualElement.getValue(key);\n                if (motionValue) motionValue.liveStyle = false;\n            };\n            for(const key in allKeys){\n                const next = resolvedValues[key];\n                const prev = prevResolvedValues[key];\n                // If we've already handled this we can just skip ahead\n                if (encounteredKeys.hasOwnProperty(key)) continue;\n                /**\n                 * If the value has changed, we probably want to animate it.\n                 */ let valueHasChanged = false;\n                if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {\n                    valueHasChanged = !shallowCompare(next, prev);\n                } else {\n                    valueHasChanged = next !== prev;\n                }\n                if (valueHasChanged) {\n                    if (next !== undefined && next !== null) {\n                        // If next is defined and doesn't equal prev, it needs animating\n                        markToAnimate(key);\n                    } else {\n                        // If it's undefined, it's been removed.\n                        removedKeys.add(key);\n                    }\n                } else if (next !== undefined && removedKeys.has(key)) {\n                    /**\n                     * If next hasn't changed and it isn't undefined, we want to check if it's\n                     * been removed by a higher priority\n                     */ markToAnimate(key);\n                } else {\n                    /**\n                     * If it hasn't changed, we add it to the list of protected values\n                     * to ensure it doesn't get animated.\n                     */ typeState.protectedKeys[key] = true;\n                }\n            }\n            /**\n             * Update the typeState so next time animateChanges is called we can compare the\n             * latest prop and resolvedValues to these.\n             */ typeState.prevProp = prop;\n            typeState.prevResolvedValues = resolvedValues;\n            /**\n             *\n             */ if (typeState.isActive) {\n                encounteredKeys = {\n                    ...encounteredKeys,\n                    ...resolvedValues\n                };\n            }\n            if (isInitialRender && visualElement.blockInitialAnimation) {\n                shouldAnimateType = false;\n            }\n            /**\n             * If this is an inherited prop we want to skip this animation\n             * unless the inherited variants haven't changed on this render.\n             */ const willAnimateViaParent = isInherited && variantDidChange;\n            const needsAnimating = !willAnimateViaParent || handledRemovedValues;\n            if (shouldAnimateType && needsAnimating) {\n                animations.push(...definitionList.map((animation)=>({\n                        animation: animation,\n                        options: {\n                            type\n                        }\n                    })));\n            }\n        }\n        /**\n         * If there are some removed value that haven't been dealt with,\n         * we need to create a new animation that falls back either to the value\n         * defined in the style prop, or the last read value.\n         */ if (removedKeys.size) {\n            const fallbackAnimation = {};\n            removedKeys.forEach((key)=>{\n                const fallbackTarget = visualElement.getBaseTarget(key);\n                const motionValue = visualElement.getValue(key);\n                if (motionValue) motionValue.liveStyle = true;\n                // @ts-expect-error - @mattgperry to figure if we should do something here\n                fallbackAnimation[key] = fallbackTarget !== null && fallbackTarget !== void 0 ? fallbackTarget : null;\n            });\n            animations.push({\n                animation: fallbackAnimation\n            });\n        }\n        let shouldAnimate = Boolean(animations.length);\n        if (isInitialRender && (props.initial === false || props.initial === props.animate) && !visualElement.manuallyAnimateOnMount) {\n            shouldAnimate = false;\n        }\n        isInitialRender = false;\n        return shouldAnimate ? animate(animations) : Promise.resolve();\n    }\n    /**\n     * Change whether a certain animation type is active.\n     */ function setActive(type, isActive) {\n        var _a;\n        // If the active state hasn't changed, we can safely do nothing here\n        if (state[type].isActive === isActive) return Promise.resolve();\n        // Propagate active change to children\n        (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach((child)=>{\n            var _a;\n            return (_a = child.animationState) === null || _a === void 0 ? void 0 : _a.setActive(type, isActive);\n        });\n        state[type].isActive = isActive;\n        const animations = animateChanges(type);\n        for(const key in state){\n            state[key].protectedKeys = {};\n        }\n        return animations;\n    }\n    return {\n        animateChanges,\n        setActive,\n        setAnimateFunction,\n        getState: ()=>state,\n        reset: ()=>{\n            state = createState();\n            isInitialRender = true;\n        }\n    };\n}\nfunction checkVariantsDidChange(prev, next) {\n    if (typeof next === \"string\") {\n        return next !== prev;\n    } else if (Array.isArray(next)) {\n        return !shallowCompare(next, prev);\n    }\n    return false;\n}\nfunction createTypeState(isActive = false) {\n    return {\n        isActive,\n        protectedKeys: {},\n        needsAnimating: {},\n        prevResolvedValues: {}\n    };\n}\nfunction createState() {\n    return {\n        animate: createTypeState(true),\n        whileInView: createTypeState(),\n        whileHover: createTypeState(),\n        whileTap: createTypeState(),\n        whileDrag: createTypeState(),\n        whileFocus: createTypeState(),\n        exit: createTypeState()\n    };\n}\nclass Feature {\n    constructor(node){\n        this.isMounted = false;\n        this.node = node;\n    }\n    update() {}\n}\nclass AnimationFeature extends Feature {\n    /**\n     * We dynamically generate the AnimationState manager as it contains a reference\n     * to the underlying animation library. We only want to load that if we load this,\n     * so people can optionally code split it out using the `m` component.\n     */ constructor(node){\n        super(node);\n        node.animationState || (node.animationState = createAnimationState(node));\n    }\n    updateAnimationControlsSubscription() {\n        const { animate } = this.node.getProps();\n        if (isAnimationControls(animate)) {\n            this.unmountControls = animate.subscribe(this.node);\n        }\n    }\n    /**\n     * Subscribe any provided AnimationControls to the component's VisualElement\n     */ mount() {\n        this.updateAnimationControlsSubscription();\n    }\n    update() {\n        const { animate } = this.node.getProps();\n        const { animate: prevAnimate } = this.node.prevProps || {};\n        if (animate !== prevAnimate) {\n            this.updateAnimationControlsSubscription();\n        }\n    }\n    unmount() {\n        var _a;\n        this.node.animationState.reset();\n        (_a = this.unmountControls) === null || _a === void 0 ? void 0 : _a.call(this);\n    }\n}\nlet id$2 = 0;\nclass ExitAnimationFeature extends Feature {\n    constructor(){\n        super(...arguments);\n        this.id = id$2++;\n    }\n    update() {\n        if (!this.node.presenceContext) return;\n        const { isPresent, onExitComplete } = this.node.presenceContext;\n        const { isPresent: prevIsPresent } = this.node.prevPresenceContext || {};\n        if (!this.node.animationState || isPresent === prevIsPresent) {\n            return;\n        }\n        const exitAnimation = this.node.animationState.setActive(\"exit\", !isPresent);\n        if (onExitComplete && !isPresent) {\n            exitAnimation.then(()=>onExitComplete(this.id));\n        }\n    }\n    mount() {\n        const { register } = this.node.presenceContext || {};\n        if (register) {\n            this.unmount = register(this.id);\n        }\n    }\n    unmount() {}\n}\nconst animations = {\n    animation: {\n        Feature: AnimationFeature\n    },\n    exit: {\n        Feature: ExitAnimationFeature\n    }\n};\nfunction extractEventInfo(event) {\n    return {\n        point: {\n            x: event.pageX,\n            y: event.pageY\n        }\n    };\n}\nconst addPointerInfo = (handler)=>{\n    return (event)=>motionDom.isPrimaryPointer(event) && handler(event, extractEventInfo(event));\n};\nfunction addDomEvent(target, eventName, handler, options = {\n    passive: true\n}) {\n    target.addEventListener(eventName, handler, options);\n    return ()=>target.removeEventListener(eventName, handler);\n}\nfunction addPointerEvent(target, eventName, handler, options) {\n    return addDomEvent(target, eventName, addPointerInfo(handler), options);\n}\nconst distance = (a, b)=>Math.abs(a - b);\nfunction distance2D(a, b) {\n    // Multi-dimensional\n    const xDelta = distance(a.x, b.x);\n    const yDelta = distance(a.y, b.y);\n    return Math.sqrt(xDelta ** 2 + yDelta ** 2);\n}\n/**\n * @internal\n */ class PanSession {\n    constructor(event, handlers, { transformPagePoint, contextWindow, dragSnapToOrigin = false } = {}){\n        /**\n         * @internal\n         */ this.startEvent = null;\n        /**\n         * @internal\n         */ this.lastMoveEvent = null;\n        /**\n         * @internal\n         */ this.lastMoveEventInfo = null;\n        /**\n         * @internal\n         */ this.handlers = {};\n        /**\n         * @internal\n         */ this.contextWindow = window;\n        this.updatePoint = ()=>{\n            if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;\n            const info = getPanInfo(this.lastMoveEventInfo, this.history);\n            const isPanStarted = this.startEvent !== null;\n            // Only start panning if the offset is larger than 3 pixels. If we make it\n            // any larger than this we'll want to reset the pointer history\n            // on the first update to avoid visual snapping to the cursoe.\n            const isDistancePastThreshold = distance2D(info.offset, {\n                x: 0,\n                y: 0\n            }) >= 3;\n            if (!isPanStarted && !isDistancePastThreshold) return;\n            const { point } = info;\n            const { timestamp } = frameData;\n            this.history.push({\n                ...point,\n                timestamp\n            });\n            const { onStart, onMove } = this.handlers;\n            if (!isPanStarted) {\n                onStart && onStart(this.lastMoveEvent, info);\n                this.startEvent = this.lastMoveEvent;\n            }\n            onMove && onMove(this.lastMoveEvent, info);\n        };\n        this.handlePointerMove = (event, info)=>{\n            this.lastMoveEvent = event;\n            this.lastMoveEventInfo = transformPoint(info, this.transformPagePoint);\n            // Throttle mouse move event to once per frame\n            frame.update(this.updatePoint, true);\n        };\n        this.handlePointerUp = (event, info)=>{\n            this.end();\n            const { onEnd, onSessionEnd, resumeAnimation } = this.handlers;\n            if (this.dragSnapToOrigin) resumeAnimation && resumeAnimation();\n            if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;\n            const panInfo = getPanInfo(event.type === \"pointercancel\" ? this.lastMoveEventInfo : transformPoint(info, this.transformPagePoint), this.history);\n            if (this.startEvent && onEnd) {\n                onEnd(event, panInfo);\n            }\n            onSessionEnd && onSessionEnd(event, panInfo);\n        };\n        // If we have more than one touch, don't start detecting this gesture\n        if (!motionDom.isPrimaryPointer(event)) return;\n        this.dragSnapToOrigin = dragSnapToOrigin;\n        this.handlers = handlers;\n        this.transformPagePoint = transformPagePoint;\n        this.contextWindow = contextWindow || window;\n        const info = extractEventInfo(event);\n        const initialInfo = transformPoint(info, this.transformPagePoint);\n        const { point } = initialInfo;\n        const { timestamp } = frameData;\n        this.history = [\n            {\n                ...point,\n                timestamp\n            }\n        ];\n        const { onSessionStart } = handlers;\n        onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));\n        this.removeListeners = pipe(addPointerEvent(this.contextWindow, \"pointermove\", this.handlePointerMove), addPointerEvent(this.contextWindow, \"pointerup\", this.handlePointerUp), addPointerEvent(this.contextWindow, \"pointercancel\", this.handlePointerUp));\n    }\n    updateHandlers(handlers) {\n        this.handlers = handlers;\n    }\n    end() {\n        this.removeListeners && this.removeListeners();\n        cancelFrame(this.updatePoint);\n    }\n}\nfunction transformPoint(info, transformPagePoint) {\n    return transformPagePoint ? {\n        point: transformPagePoint(info.point)\n    } : info;\n}\nfunction subtractPoint(a, b) {\n    return {\n        x: a.x - b.x,\n        y: a.y - b.y\n    };\n}\nfunction getPanInfo({ point }, history) {\n    return {\n        point,\n        delta: subtractPoint(point, lastDevicePoint(history)),\n        offset: subtractPoint(point, startDevicePoint(history)),\n        velocity: getVelocity(history, 0.1)\n    };\n}\nfunction startDevicePoint(history) {\n    return history[0];\n}\nfunction lastDevicePoint(history) {\n    return history[history.length - 1];\n}\nfunction getVelocity(history, timeDelta) {\n    if (history.length < 2) {\n        return {\n            x: 0,\n            y: 0\n        };\n    }\n    let i = history.length - 1;\n    let timestampedPoint = null;\n    const lastPoint = lastDevicePoint(history);\n    while(i >= 0){\n        timestampedPoint = history[i];\n        if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {\n            break;\n        }\n        i--;\n    }\n    if (!timestampedPoint) {\n        return {\n            x: 0,\n            y: 0\n        };\n    }\n    const time = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);\n    if (time === 0) {\n        return {\n            x: 0,\n            y: 0\n        };\n    }\n    const currentVelocity = {\n        x: (lastPoint.x - timestampedPoint.x) / time,\n        y: (lastPoint.y - timestampedPoint.y) / time\n    };\n    if (currentVelocity.x === Infinity) {\n        currentVelocity.x = 0;\n    }\n    if (currentVelocity.y === Infinity) {\n        currentVelocity.y = 0;\n    }\n    return currentVelocity;\n}\nfunction isRefObject(ref) {\n    return ref && typeof ref === \"object\" && Object.prototype.hasOwnProperty.call(ref, \"current\");\n}\nconst SCALE_PRECISION = 0.0001;\nconst SCALE_MIN = 1 - SCALE_PRECISION;\nconst SCALE_MAX = 1 + SCALE_PRECISION;\nconst TRANSLATE_PRECISION = 0.01;\nconst TRANSLATE_MIN = 0 - TRANSLATE_PRECISION;\nconst TRANSLATE_MAX = 0 + TRANSLATE_PRECISION;\nfunction calcLength(axis) {\n    return axis.max - axis.min;\n}\nfunction isNear(value, target, maxDistance) {\n    return Math.abs(value - target) <= maxDistance;\n}\nfunction calcAxisDelta(delta, source, target, origin = 0.5) {\n    delta.origin = origin;\n    delta.originPoint = mixNumber$1(source.min, source.max, delta.origin);\n    delta.scale = calcLength(target) / calcLength(source);\n    delta.translate = mixNumber$1(target.min, target.max, delta.origin) - delta.originPoint;\n    if (delta.scale >= SCALE_MIN && delta.scale <= SCALE_MAX || isNaN(delta.scale)) {\n        delta.scale = 1.0;\n    }\n    if (delta.translate >= TRANSLATE_MIN && delta.translate <= TRANSLATE_MAX || isNaN(delta.translate)) {\n        delta.translate = 0.0;\n    }\n}\nfunction calcBoxDelta(delta, source, target, origin) {\n    calcAxisDelta(delta.x, source.x, target.x, origin ? origin.originX : undefined);\n    calcAxisDelta(delta.y, source.y, target.y, origin ? origin.originY : undefined);\n}\nfunction calcRelativeAxis(target, relative, parent) {\n    target.min = parent.min + relative.min;\n    target.max = target.min + calcLength(relative);\n}\nfunction calcRelativeBox(target, relative, parent) {\n    calcRelativeAxis(target.x, relative.x, parent.x);\n    calcRelativeAxis(target.y, relative.y, parent.y);\n}\nfunction calcRelativeAxisPosition(target, layout, parent) {\n    target.min = layout.min - parent.min;\n    target.max = target.min + calcLength(layout);\n}\nfunction calcRelativePosition(target, layout, parent) {\n    calcRelativeAxisPosition(target.x, layout.x, parent.x);\n    calcRelativeAxisPosition(target.y, layout.y, parent.y);\n}\n/**\n * Apply constraints to a point. These constraints are both physical along an\n * axis, and an elastic factor that determines how much to constrain the point\n * by if it does lie outside the defined parameters.\n */ function applyConstraints(point, { min, max }, elastic) {\n    if (min !== undefined && point < min) {\n        // If we have a min point defined, and this is outside of that, constrain\n        point = elastic ? mixNumber$1(min, point, elastic.min) : Math.max(point, min);\n    } else if (max !== undefined && point > max) {\n        // If we have a max point defined, and this is outside of that, constrain\n        point = elastic ? mixNumber$1(max, point, elastic.max) : Math.min(point, max);\n    }\n    return point;\n}\n/**\n * Calculate constraints in terms of the viewport when defined relatively to the\n * measured axis. This is measured from the nearest edge, so a max constraint of 200\n * on an axis with a max value of 300 would return a constraint of 500 - axis length\n */ function calcRelativeAxisConstraints(axis, min, max) {\n    return {\n        min: min !== undefined ? axis.min + min : undefined,\n        max: max !== undefined ? axis.max + max - (axis.max - axis.min) : undefined\n    };\n}\n/**\n * Calculate constraints in terms of the viewport when\n * defined relatively to the measured bounding box.\n */ function calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {\n    return {\n        x: calcRelativeAxisConstraints(layoutBox.x, left, right),\n        y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)\n    };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative axis\n */ function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {\n    let min = constraintsAxis.min - layoutAxis.min;\n    let max = constraintsAxis.max - layoutAxis.max;\n    // If the constraints axis is actually smaller than the layout axis then we can\n    // flip the constraints\n    if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {\n        [min, max] = [\n            max,\n            min\n        ];\n    }\n    return {\n        min,\n        max\n    };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative box\n */ function calcViewportConstraints(layoutBox, constraintsBox) {\n    return {\n        x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),\n        y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)\n    };\n}\n/**\n * Calculate a transform origin relative to the source axis, between 0-1, that results\n * in an asthetically pleasing scale/transform needed to project from source to target.\n */ function calcOrigin$1(source, target) {\n    let origin = 0.5;\n    const sourceLength = calcLength(source);\n    const targetLength = calcLength(target);\n    if (targetLength > sourceLength) {\n        origin = progress(target.min, target.max - sourceLength, source.min);\n    } else if (sourceLength > targetLength) {\n        origin = progress(source.min, source.max - targetLength, target.min);\n    }\n    return clamp(0, 1, origin);\n}\n/**\n * Rebase the calculated viewport constraints relative to the layout.min point.\n */ function rebaseAxisConstraints(layout, constraints) {\n    const relativeConstraints = {};\n    if (constraints.min !== undefined) {\n        relativeConstraints.min = constraints.min - layout.min;\n    }\n    if (constraints.max !== undefined) {\n        relativeConstraints.max = constraints.max - layout.min;\n    }\n    return relativeConstraints;\n}\nconst defaultElastic = 0.35;\n/**\n * Accepts a dragElastic prop and returns resolved elastic values for each axis.\n */ function resolveDragElastic(dragElastic = defaultElastic) {\n    if (dragElastic === false) {\n        dragElastic = 0;\n    } else if (dragElastic === true) {\n        dragElastic = defaultElastic;\n    }\n    return {\n        x: resolveAxisElastic(dragElastic, \"left\", \"right\"),\n        y: resolveAxisElastic(dragElastic, \"top\", \"bottom\")\n    };\n}\nfunction resolveAxisElastic(dragElastic, minLabel, maxLabel) {\n    return {\n        min: resolvePointElastic(dragElastic, minLabel),\n        max: resolvePointElastic(dragElastic, maxLabel)\n    };\n}\nfunction resolvePointElastic(dragElastic, label) {\n    return typeof dragElastic === \"number\" ? dragElastic : dragElastic[label] || 0;\n}\nconst createAxisDelta = ()=>({\n        translate: 0,\n        scale: 1,\n        origin: 0,\n        originPoint: 0\n    });\nconst createDelta = ()=>({\n        x: createAxisDelta(),\n        y: createAxisDelta()\n    });\nconst createAxis = ()=>({\n        min: 0,\n        max: 0\n    });\nconst createBox = ()=>({\n        x: createAxis(),\n        y: createAxis()\n    });\nfunction eachAxis(callback) {\n    return [\n        callback(\"x\"),\n        callback(\"y\")\n    ];\n}\n/**\n * Bounding boxes tend to be defined as top, left, right, bottom. For various operations\n * it's easier to consider each axis individually. This function returns a bounding box\n * as a map of single-axis min/max values.\n */ function convertBoundingBoxToBox({ top, left, right, bottom }) {\n    return {\n        x: {\n            min: left,\n            max: right\n        },\n        y: {\n            min: top,\n            max: bottom\n        }\n    };\n}\nfunction convertBoxToBoundingBox({ x, y }) {\n    return {\n        top: y.min,\n        right: x.max,\n        bottom: y.max,\n        left: x.min\n    };\n}\n/**\n * Applies a TransformPoint function to a bounding box. TransformPoint is usually a function\n * provided by Framer to allow measured points to be corrected for device scaling. This is used\n * when measuring DOM elements and DOM event points.\n */ function transformBoxPoints(point, transformPoint) {\n    if (!transformPoint) return point;\n    const topLeft = transformPoint({\n        x: point.left,\n        y: point.top\n    });\n    const bottomRight = transformPoint({\n        x: point.right,\n        y: point.bottom\n    });\n    return {\n        top: topLeft.y,\n        left: topLeft.x,\n        bottom: bottomRight.y,\n        right: bottomRight.x\n    };\n}\nfunction isIdentityScale(scale) {\n    return scale === undefined || scale === 1;\n}\nfunction hasScale({ scale, scaleX, scaleY }) {\n    return !isIdentityScale(scale) || !isIdentityScale(scaleX) || !isIdentityScale(scaleY);\n}\nfunction hasTransform(values) {\n    return hasScale(values) || has2DTranslate(values) || values.z || values.rotate || values.rotateX || values.rotateY || values.skewX || values.skewY;\n}\nfunction has2DTranslate(values) {\n    return is2DTranslate(values.x) || is2DTranslate(values.y);\n}\nfunction is2DTranslate(value) {\n    return value && value !== \"0%\";\n}\n/**\n * Scales a point based on a factor and an originPoint\n */ function scalePoint(point, scale, originPoint) {\n    const distanceFromOrigin = point - originPoint;\n    const scaled = scale * distanceFromOrigin;\n    return originPoint + scaled;\n}\n/**\n * Applies a translate/scale delta to a point\n */ function applyPointDelta(point, translate, scale, originPoint, boxScale) {\n    if (boxScale !== undefined) {\n        point = scalePoint(point, boxScale, originPoint);\n    }\n    return scalePoint(point, scale, originPoint) + translate;\n}\n/**\n * Applies a translate/scale delta to an axis\n */ function applyAxisDelta(axis, translate = 0, scale = 1, originPoint, boxScale) {\n    axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\n    axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Applies a translate/scale delta to a box\n */ function applyBoxDelta(box, { x, y }) {\n    applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\n    applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\n}\nconst TREE_SCALE_SNAP_MIN = 0.999999999999;\nconst TREE_SCALE_SNAP_MAX = 1.0000000000001;\n/**\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\n *\n * This is the final nested loop within updateLayoutDelta for future refactoring\n */ function applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {\n    const treeLength = treePath.length;\n    if (!treeLength) return;\n    // Reset the treeScale\n    treeScale.x = treeScale.y = 1;\n    let node;\n    let delta;\n    for(let i = 0; i < treeLength; i++){\n        node = treePath[i];\n        delta = node.projectionDelta;\n        /**\n         * TODO: Prefer to remove this, but currently we have motion components with\n         * display: contents in Framer.\n         */ const { visualElement } = node.options;\n        if (visualElement && visualElement.props.style && visualElement.props.style.display === \"contents\") {\n            continue;\n        }\n        if (isSharedTransition && node.options.layoutScroll && node.scroll && node !== node.root) {\n            transformBox(box, {\n                x: -node.scroll.offset.x,\n                y: -node.scroll.offset.y\n            });\n        }\n        if (delta) {\n            // Incoporate each ancestor's scale into a culmulative treeScale for this component\n            treeScale.x *= delta.x.scale;\n            treeScale.y *= delta.y.scale;\n            // Apply each ancestor's calculated delta into this component's recorded layout box\n            applyBoxDelta(box, delta);\n        }\n        if (isSharedTransition && hasTransform(node.latestValues)) {\n            transformBox(box, node.latestValues);\n        }\n    }\n    /**\n     * Snap tree scale back to 1 if it's within a non-perceivable threshold.\n     * This will help reduce useless scales getting rendered.\n     */ if (treeScale.x < TREE_SCALE_SNAP_MAX && treeScale.x > TREE_SCALE_SNAP_MIN) {\n        treeScale.x = 1.0;\n    }\n    if (treeScale.y < TREE_SCALE_SNAP_MAX && treeScale.y > TREE_SCALE_SNAP_MIN) {\n        treeScale.y = 1.0;\n    }\n}\nfunction translateAxis(axis, distance) {\n    axis.min = axis.min + distance;\n    axis.max = axis.max + distance;\n}\n/**\n * Apply a transform to an axis from the latest resolved motion values.\n * This function basically acts as a bridge between a flat motion value map\n * and applyAxisDelta\n */ function transformAxis(axis, axisTranslate, axisScale, boxScale, axisOrigin = 0.5) {\n    const originPoint = mixNumber$1(axis.min, axis.max, axisOrigin);\n    // Apply the axis delta to the final axis\n    applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);\n}\n/**\n * Apply a transform to a box from the latest resolved motion values.\n */ function transformBox(box, transform) {\n    transformAxis(box.x, transform.x, transform.scaleX, transform.scale, transform.originX);\n    transformAxis(box.y, transform.y, transform.scaleY, transform.scale, transform.originY);\n}\nfunction measureViewportBox(instance, transformPoint) {\n    return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint));\n}\nfunction measurePageBox(element, rootProjectionNode, transformPagePoint) {\n    const viewportBox = measureViewportBox(element, transformPagePoint);\n    const { scroll } = rootProjectionNode;\n    if (scroll) {\n        translateAxis(viewportBox.x, scroll.offset.x);\n        translateAxis(viewportBox.y, scroll.offset.y);\n    }\n    return viewportBox;\n}\n// Fixes https://github.com/motiondivision/motion/issues/2270\nconst getContextWindow = ({ current })=>{\n    return current ? current.ownerDocument.defaultView : null;\n};\nconst elementDragControls = new WeakMap();\n/**\n *\n */ // let latestPointerEvent: PointerEvent\nclass VisualElementDragControls {\n    constructor(visualElement){\n        this.openDragLock = null;\n        this.isDragging = false;\n        this.currentDirection = null;\n        this.originPoint = {\n            x: 0,\n            y: 0\n        };\n        /**\n         * The permitted boundaries of travel, in pixels.\n         */ this.constraints = false;\n        this.hasMutatedConstraints = false;\n        /**\n         * The per-axis resolved elastic values.\n         */ this.elastic = createBox();\n        this.visualElement = visualElement;\n    }\n    start(originEvent, { snapToCursor = false } = {}) {\n        /**\n         * Don't start dragging if this component is exiting\n         */ const { presenceContext } = this.visualElement;\n        if (presenceContext && presenceContext.isPresent === false) return;\n        const onSessionStart = (event)=>{\n            const { dragSnapToOrigin } = this.getProps();\n            // Stop or pause any animations on both axis values immediately. This allows the user to throw and catch\n            // the component.\n            dragSnapToOrigin ? this.pauseAnimation() : this.stopAnimation();\n            if (snapToCursor) {\n                this.snapToCursor(extractEventInfo(event).point);\n            }\n        };\n        const onStart = (event, info)=>{\n            // Attempt to grab the global drag gesture lock - maybe make this part of PanSession\n            const { drag, dragPropagation, onDragStart } = this.getProps();\n            if (drag && !dragPropagation) {\n                if (this.openDragLock) this.openDragLock();\n                this.openDragLock = motionDom.setDragLock(drag);\n                // If we don 't have the lock, don't start dragging\n                if (!this.openDragLock) return;\n            }\n            this.isDragging = true;\n            this.currentDirection = null;\n            this.resolveConstraints();\n            if (this.visualElement.projection) {\n                this.visualElement.projection.isAnimationBlocked = true;\n                this.visualElement.projection.target = undefined;\n            }\n            /**\n             * Record gesture origin\n             */ eachAxis((axis)=>{\n                let current = this.getAxisMotionValue(axis).get() || 0;\n                /**\n                 * If the MotionValue is a percentage value convert to px\n                 */ if (percent.test(current)) {\n                    const { projection } = this.visualElement;\n                    if (projection && projection.layout) {\n                        const measuredAxis = projection.layout.layoutBox[axis];\n                        if (measuredAxis) {\n                            const length = calcLength(measuredAxis);\n                            current = length * (parseFloat(current) / 100);\n                        }\n                    }\n                }\n                this.originPoint[axis] = current;\n            });\n            // Fire onDragStart event\n            if (onDragStart) {\n                frame.postRender(()=>onDragStart(event, info));\n            }\n            addValueToWillChange(this.visualElement, \"transform\");\n            const { animationState } = this.visualElement;\n            animationState && animationState.setActive(\"whileDrag\", true);\n        };\n        const onMove = (event, info)=>{\n            // latestPointerEvent = event\n            const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag } = this.getProps();\n            // If we didn't successfully receive the gesture lock, early return.\n            if (!dragPropagation && !this.openDragLock) return;\n            const { offset } = info;\n            // Attempt to detect drag direction if directionLock is true\n            if (dragDirectionLock && this.currentDirection === null) {\n                this.currentDirection = getCurrentDirection(offset);\n                // If we've successfully set a direction, notify listener\n                if (this.currentDirection !== null) {\n                    onDirectionLock && onDirectionLock(this.currentDirection);\n                }\n                return;\n            }\n            // Update each point with the latest position\n            this.updateAxis(\"x\", info.point, offset);\n            this.updateAxis(\"y\", info.point, offset);\n            /**\n             * Ideally we would leave the renderer to fire naturally at the end of\n             * this frame but if the element is about to change layout as the result\n             * of a re-render we want to ensure the browser can read the latest\n             * bounding box to ensure the pointer and element don't fall out of sync.\n             */ this.visualElement.render();\n            /**\n             * This must fire after the render call as it might trigger a state\n             * change which itself might trigger a layout update.\n             */ onDrag && onDrag(event, info);\n        };\n        const onSessionEnd = (event, info)=>this.stop(event, info);\n        const resumeAnimation = ()=>eachAxis((axis)=>{\n                var _a;\n                return this.getAnimationState(axis) === \"paused\" && ((_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.play());\n            });\n        const { dragSnapToOrigin } = this.getProps();\n        this.panSession = new PanSession(originEvent, {\n            onSessionStart,\n            onStart,\n            onMove,\n            onSessionEnd,\n            resumeAnimation\n        }, {\n            transformPagePoint: this.visualElement.getTransformPagePoint(),\n            dragSnapToOrigin,\n            contextWindow: getContextWindow(this.visualElement)\n        });\n    }\n    stop(event, info) {\n        const isDragging = this.isDragging;\n        this.cancel();\n        if (!isDragging) return;\n        const { velocity } = info;\n        this.startAnimation(velocity);\n        const { onDragEnd } = this.getProps();\n        if (onDragEnd) {\n            frame.postRender(()=>onDragEnd(event, info));\n        }\n    }\n    cancel() {\n        this.isDragging = false;\n        const { projection, animationState } = this.visualElement;\n        if (projection) {\n            projection.isAnimationBlocked = false;\n        }\n        this.panSession && this.panSession.end();\n        this.panSession = undefined;\n        const { dragPropagation } = this.getProps();\n        if (!dragPropagation && this.openDragLock) {\n            this.openDragLock();\n            this.openDragLock = null;\n        }\n        animationState && animationState.setActive(\"whileDrag\", false);\n    }\n    updateAxis(axis, _point, offset) {\n        const { drag } = this.getProps();\n        // If we're not dragging this axis, do an early return.\n        if (!offset || !shouldDrag(axis, drag, this.currentDirection)) return;\n        const axisValue = this.getAxisMotionValue(axis);\n        let next = this.originPoint[axis] + offset[axis];\n        // Apply constraints\n        if (this.constraints && this.constraints[axis]) {\n            next = applyConstraints(next, this.constraints[axis], this.elastic[axis]);\n        }\n        axisValue.set(next);\n    }\n    resolveConstraints() {\n        var _a;\n        const { dragConstraints, dragElastic } = this.getProps();\n        const layout = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(false) : (_a = this.visualElement.projection) === null || _a === void 0 ? void 0 : _a.layout;\n        const prevConstraints = this.constraints;\n        if (dragConstraints && isRefObject(dragConstraints)) {\n            if (!this.constraints) {\n                this.constraints = this.resolveRefConstraints();\n            }\n        } else {\n            if (dragConstraints && layout) {\n                this.constraints = calcRelativeConstraints(layout.layoutBox, dragConstraints);\n            } else {\n                this.constraints = false;\n            }\n        }\n        this.elastic = resolveDragElastic(dragElastic);\n        /**\n         * If we're outputting to external MotionValues, we want to rebase the measured constraints\n         * from viewport-relative to component-relative.\n         */ if (prevConstraints !== this.constraints && layout && this.constraints && !this.hasMutatedConstraints) {\n            eachAxis((axis)=>{\n                if (this.constraints !== false && this.getAxisMotionValue(axis)) {\n                    this.constraints[axis] = rebaseAxisConstraints(layout.layoutBox[axis], this.constraints[axis]);\n                }\n            });\n        }\n    }\n    resolveRefConstraints() {\n        const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();\n        if (!constraints || !isRefObject(constraints)) return false;\n        const constraintsElement = constraints.current;\n        motionUtils.invariant(constraintsElement !== null, \"If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.\");\n        const { projection } = this.visualElement;\n        // TODO\n        if (!projection || !projection.layout) return false;\n        const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());\n        let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);\n        /**\n         * If there's an onMeasureDragConstraints listener we call it and\n         * if different constraints are returned, set constraints to that\n         */ if (onMeasureDragConstraints) {\n            const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));\n            this.hasMutatedConstraints = !!userConstraints;\n            if (userConstraints) {\n                measuredConstraints = convertBoundingBoxToBox(userConstraints);\n            }\n        }\n        return measuredConstraints;\n    }\n    startAnimation(velocity) {\n        const { drag, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd } = this.getProps();\n        const constraints = this.constraints || {};\n        const momentumAnimations = eachAxis((axis)=>{\n            if (!shouldDrag(axis, drag, this.currentDirection)) {\n                return;\n            }\n            let transition = constraints && constraints[axis] || {};\n            if (dragSnapToOrigin) transition = {\n                min: 0,\n                max: 0\n            };\n            /**\n             * Overdamp the boundary spring if `dragElastic` is disabled. There's still a frame\n             * of spring animations so we should look into adding a disable spring option to `inertia`.\n             * We could do something here where we affect the `bounceStiffness` and `bounceDamping`\n             * using the value of `dragElastic`.\n             */ const bounceStiffness = dragElastic ? 200 : 1000000;\n            const bounceDamping = dragElastic ? 40 : 10000000;\n            const inertia = {\n                type: \"inertia\",\n                velocity: dragMomentum ? velocity[axis] : 0,\n                bounceStiffness,\n                bounceDamping,\n                timeConstant: 750,\n                restDelta: 1,\n                restSpeed: 10,\n                ...dragTransition,\n                ...transition\n            };\n            // If we're not animating on an externally-provided `MotionValue` we can use the\n            // component's animation controls which will handle interactions with whileHover (etc),\n            // otherwise we just have to animate the `MotionValue` itself.\n            return this.startAxisValueAnimation(axis, inertia);\n        });\n        // Run all animations and then resolve the new drag constraints.\n        return Promise.all(momentumAnimations).then(onDragTransitionEnd);\n    }\n    startAxisValueAnimation(axis, transition) {\n        const axisValue = this.getAxisMotionValue(axis);\n        addValueToWillChange(this.visualElement, axis);\n        return axisValue.start(animateMotionValue(axis, axisValue, 0, transition, this.visualElement, false));\n    }\n    stopAnimation() {\n        eachAxis((axis)=>this.getAxisMotionValue(axis).stop());\n    }\n    pauseAnimation() {\n        eachAxis((axis)=>{\n            var _a;\n            return (_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.pause();\n        });\n    }\n    getAnimationState(axis) {\n        var _a;\n        return (_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.state;\n    }\n    /**\n     * Drag works differently depending on which props are provided.\n     *\n     * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.\n     * - Otherwise, we apply the delta to the x/y motion values.\n     */ getAxisMotionValue(axis) {\n        const dragKey = `_drag${axis.toUpperCase()}`;\n        const props = this.visualElement.getProps();\n        const externalMotionValue = props[dragKey];\n        return externalMotionValue ? externalMotionValue : this.visualElement.getValue(axis, (props.initial ? props.initial[axis] : undefined) || 0);\n    }\n    snapToCursor(point) {\n        eachAxis((axis)=>{\n            const { drag } = this.getProps();\n            // If we're not dragging this axis, do an early return.\n            if (!shouldDrag(axis, drag, this.currentDirection)) return;\n            const { projection } = this.visualElement;\n            const axisValue = this.getAxisMotionValue(axis);\n            if (projection && projection.layout) {\n                const { min, max } = projection.layout.layoutBox[axis];\n                axisValue.set(point[axis] - mixNumber$1(min, max, 0.5));\n            }\n        });\n    }\n    /**\n     * When the viewport resizes we want to check if the measured constraints\n     * have changed and, if so, reposition the element within those new constraints\n     * relative to where it was before the resize.\n     */ scalePositionWithinConstraints() {\n        if (!this.visualElement.current) return;\n        const { drag, dragConstraints } = this.getProps();\n        const { projection } = this.visualElement;\n        if (!isRefObject(dragConstraints) || !projection || !this.constraints) return;\n        /**\n         * Stop current animations as there can be visual glitching if we try to do\n         * this mid-animation\n         */ this.stopAnimation();\n        /**\n         * Record the relative position of the dragged element relative to the\n         * constraints box and save as a progress value.\n         */ const boxProgress = {\n            x: 0,\n            y: 0\n        };\n        eachAxis((axis)=>{\n            const axisValue = this.getAxisMotionValue(axis);\n            if (axisValue && this.constraints !== false) {\n                const latest = axisValue.get();\n                boxProgress[axis] = calcOrigin$1({\n                    min: latest,\n                    max: latest\n                }, this.constraints[axis]);\n            }\n        });\n        /**\n         * Update the layout of this element and resolve the latest drag constraints\n         */ const { transformTemplate } = this.visualElement.getProps();\n        this.visualElement.current.style.transform = transformTemplate ? transformTemplate({}, \"\") : \"none\";\n        projection.root && projection.root.updateScroll();\n        projection.updateLayout();\n        this.resolveConstraints();\n        /**\n         * For each axis, calculate the current progress of the layout axis\n         * within the new constraints.\n         */ eachAxis((axis)=>{\n            if (!shouldDrag(axis, drag, null)) return;\n            /**\n             * Calculate a new transform based on the previous box progress\n             */ const axisValue = this.getAxisMotionValue(axis);\n            const { min, max } = this.constraints[axis];\n            axisValue.set(mixNumber$1(min, max, boxProgress[axis]));\n        });\n    }\n    addListeners() {\n        if (!this.visualElement.current) return;\n        elementDragControls.set(this.visualElement, this);\n        const element = this.visualElement.current;\n        /**\n         * Attach a pointerdown event listener on this DOM element to initiate drag tracking.\n         */ const stopPointerListener = addPointerEvent(element, \"pointerdown\", (event)=>{\n            const { drag, dragListener = true } = this.getProps();\n            drag && dragListener && this.start(event);\n        });\n        const measureDragConstraints = ()=>{\n            const { dragConstraints } = this.getProps();\n            if (isRefObject(dragConstraints) && dragConstraints.current) {\n                this.constraints = this.resolveRefConstraints();\n            }\n        };\n        const { projection } = this.visualElement;\n        const stopMeasureLayoutListener = projection.addEventListener(\"measure\", measureDragConstraints);\n        if (projection && !projection.layout) {\n            projection.root && projection.root.updateScroll();\n            projection.updateLayout();\n        }\n        frame.read(measureDragConstraints);\n        /**\n         * Attach a window resize listener to scale the draggable target within its defined\n         * constraints as the window resizes.\n         */ const stopResizeListener = addDomEvent(window, \"resize\", ()=>this.scalePositionWithinConstraints());\n        /**\n         * If the element's layout changes, calculate the delta and apply that to\n         * the drag gesture's origin point.\n         */ const stopLayoutUpdateListener = projection.addEventListener(\"didUpdate\", ({ delta, hasLayoutChanged })=>{\n            if (this.isDragging && hasLayoutChanged) {\n                eachAxis((axis)=>{\n                    const motionValue = this.getAxisMotionValue(axis);\n                    if (!motionValue) return;\n                    this.originPoint[axis] += delta[axis].translate;\n                    motionValue.set(motionValue.get() + delta[axis].translate);\n                });\n                this.visualElement.render();\n            }\n        });\n        return ()=>{\n            stopResizeListener();\n            stopPointerListener();\n            stopMeasureLayoutListener();\n            stopLayoutUpdateListener && stopLayoutUpdateListener();\n        };\n    }\n    getProps() {\n        const props = this.visualElement.getProps();\n        const { drag = false, dragDirectionLock = false, dragPropagation = false, dragConstraints = false, dragElastic = defaultElastic, dragMomentum = true } = props;\n        return {\n            ...props,\n            drag,\n            dragDirectionLock,\n            dragPropagation,\n            dragConstraints,\n            dragElastic,\n            dragMomentum\n        };\n    }\n}\nfunction shouldDrag(direction, drag, currentDirection) {\n    return (drag === true || drag === direction) && (currentDirection === null || currentDirection === direction);\n}\n/**\n * Based on an x/y offset determine the current drag direction. If both axis' offsets are lower\n * than the provided threshold, return `null`.\n *\n * @param offset - The x/y offset from origin.\n * @param lockThreshold - (Optional) - the minimum absolute offset before we can determine a drag direction.\n */ function getCurrentDirection(offset, lockThreshold = 10) {\n    let direction = null;\n    if (Math.abs(offset.y) > lockThreshold) {\n        direction = \"y\";\n    } else if (Math.abs(offset.x) > lockThreshold) {\n        direction = \"x\";\n    }\n    return direction;\n}\nclass DragGesture extends Feature {\n    constructor(node){\n        super(node);\n        this.removeGroupControls = motionUtils.noop;\n        this.removeListeners = motionUtils.noop;\n        this.controls = new VisualElementDragControls(node);\n    }\n    mount() {\n        // If we've been provided a DragControls for manual control over the drag gesture,\n        // subscribe this component to it on mount.\n        const { dragControls } = this.node.getProps();\n        if (dragControls) {\n            this.removeGroupControls = dragControls.subscribe(this.controls);\n        }\n        this.removeListeners = this.controls.addListeners() || motionUtils.noop;\n    }\n    unmount() {\n        this.removeGroupControls();\n        this.removeListeners();\n    }\n}\nconst asyncHandler = (handler)=>(event, info)=>{\n        if (handler) {\n            frame.postRender(()=>handler(event, info));\n        }\n    };\nclass PanGesture extends Feature {\n    constructor(){\n        super(...arguments);\n        this.removePointerDownListener = motionUtils.noop;\n    }\n    onPointerDown(pointerDownEvent) {\n        this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), {\n            transformPagePoint: this.node.getTransformPagePoint(),\n            contextWindow: getContextWindow(this.node)\n        });\n    }\n    createPanHandlers() {\n        const { onPanSessionStart, onPanStart, onPan, onPanEnd } = this.node.getProps();\n        return {\n            onSessionStart: asyncHandler(onPanSessionStart),\n            onStart: asyncHandler(onPanStart),\n            onMove: onPan,\n            onEnd: (event, info)=>{\n                delete this.session;\n                if (onPanEnd) {\n                    frame.postRender(()=>onPanEnd(event, info));\n                }\n            }\n        };\n    }\n    mount() {\n        this.removePointerDownListener = addPointerEvent(this.node.current, \"pointerdown\", (event)=>this.onPointerDown(event));\n    }\n    update() {\n        this.session && this.session.updateHandlers(this.createPanHandlers());\n    }\n    unmount() {\n        this.removePointerDownListener();\n        this.session && this.session.end();\n    }\n}\nconst borders = [\n    \"TopLeft\",\n    \"TopRight\",\n    \"BottomLeft\",\n    \"BottomRight\"\n];\nconst numBorders = borders.length;\nconst asNumber = (value)=>typeof value === \"string\" ? parseFloat(value) : value;\nconst isPx = (value)=>typeof value === \"number\" || px.test(value);\nfunction mixValues(target, follow, lead, progress, shouldCrossfadeOpacity, isOnlyMember) {\n    if (shouldCrossfadeOpacity) {\n        target.opacity = mixNumber$1(0, // TODO Reinstate this if only child\n        lead.opacity !== undefined ? lead.opacity : 1, easeCrossfadeIn(progress));\n        target.opacityExit = mixNumber$1(follow.opacity !== undefined ? follow.opacity : 1, 0, easeCrossfadeOut(progress));\n    } else if (isOnlyMember) {\n        target.opacity = mixNumber$1(follow.opacity !== undefined ? follow.opacity : 1, lead.opacity !== undefined ? lead.opacity : 1, progress);\n    }\n    /**\n     * Mix border radius\n     */ for(let i = 0; i < numBorders; i++){\n        const borderLabel = `border${borders[i]}Radius`;\n        let followRadius = getRadius(follow, borderLabel);\n        let leadRadius = getRadius(lead, borderLabel);\n        if (followRadius === undefined && leadRadius === undefined) continue;\n        followRadius || (followRadius = 0);\n        leadRadius || (leadRadius = 0);\n        const canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);\n        if (canMix) {\n            target[borderLabel] = Math.max(mixNumber$1(asNumber(followRadius), asNumber(leadRadius), progress), 0);\n            if (percent.test(leadRadius) || percent.test(followRadius)) {\n                target[borderLabel] += \"%\";\n            }\n        } else {\n            target[borderLabel] = leadRadius;\n        }\n    }\n    /**\n     * Mix rotation\n     */ if (follow.rotate || lead.rotate) {\n        target.rotate = mixNumber$1(follow.rotate || 0, lead.rotate || 0, progress);\n    }\n}\nfunction getRadius(values, radiusName) {\n    return values[radiusName] !== undefined ? values[radiusName] : values.borderRadius;\n}\n// /**\n//  * We only want to mix the background color if there's a follow element\n//  * that we're not crossfading opacity between. For instance with switch\n//  * AnimateSharedLayout animations, this helps the illusion of a continuous\n//  * element being animated but also cuts down on the number of paints triggered\n//  * for elements where opacity is doing that work for us.\n//  */\n// if (\n//     !hasFollowElement &&\n//     latestLeadValues.backgroundColor &&\n//     latestFollowValues.backgroundColor\n// ) {\n//     /**\n//      * This isn't ideal performance-wise as mixColor is creating a new function every frame.\n//      * We could probably create a mixer that runs at the start of the animation but\n//      * the idea behind the crossfader is that it runs dynamically between two potentially\n//      * changing targets (ie opacity or borderRadius may be animating independently via variants)\n//      */\n//     leadState.backgroundColor = followState.backgroundColor = mixColor(\n//         latestFollowValues.backgroundColor as string,\n//         latestLeadValues.backgroundColor as string\n//     )(p)\n// }\nconst easeCrossfadeIn = /*@__PURE__*/ compress(0, 0.5, circOut);\nconst easeCrossfadeOut = /*@__PURE__*/ compress(0.5, 0.95, motionUtils.noop);\nfunction compress(min, max, easing) {\n    return (p)=>{\n        // Could replace ifs with clamp\n        if (p < min) return 0;\n        if (p > max) return 1;\n        return easing(progress(min, max, p));\n    };\n}\n/**\n * Reset an axis to the provided origin box.\n *\n * This is a mutative operation.\n */ function copyAxisInto(axis, originAxis) {\n    axis.min = originAxis.min;\n    axis.max = originAxis.max;\n}\n/**\n * Reset a box to the provided origin box.\n *\n * This is a mutative operation.\n */ function copyBoxInto(box, originBox) {\n    copyAxisInto(box.x, originBox.x);\n    copyAxisInto(box.y, originBox.y);\n}\n/**\n * Reset a delta to the provided origin box.\n *\n * This is a mutative operation.\n */ function copyAxisDeltaInto(delta, originDelta) {\n    delta.translate = originDelta.translate;\n    delta.scale = originDelta.scale;\n    delta.originPoint = originDelta.originPoint;\n    delta.origin = originDelta.origin;\n}\n/**\n * Remove a delta from a point. This is essentially the steps of applyPointDelta in reverse\n */ function removePointDelta(point, translate, scale, originPoint, boxScale) {\n    point -= translate;\n    point = scalePoint(point, 1 / scale, originPoint);\n    if (boxScale !== undefined) {\n        point = scalePoint(point, 1 / boxScale, originPoint);\n    }\n    return point;\n}\n/**\n * Remove a delta from an axis. This is essentially the steps of applyAxisDelta in reverse\n */ function removeAxisDelta(axis, translate = 0, scale = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {\n    if (percent.test(translate)) {\n        translate = parseFloat(translate);\n        const relativeProgress = mixNumber$1(sourceAxis.min, sourceAxis.max, translate / 100);\n        translate = relativeProgress - sourceAxis.min;\n    }\n    if (typeof translate !== \"number\") return;\n    let originPoint = mixNumber$1(originAxis.min, originAxis.max, origin);\n    if (axis === originAxis) originPoint -= translate;\n    axis.min = removePointDelta(axis.min, translate, scale, originPoint, boxScale);\n    axis.max = removePointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Remove a transforms from an axis. This is essentially the steps of applyAxisTransforms in reverse\n * and acts as a bridge between motion values and removeAxisDelta\n */ function removeAxisTransforms(axis, transforms, [key, scaleKey, originKey], origin, sourceAxis) {\n    removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);\n}\n/**\n * The names of the motion values we want to apply as translation, scale and origin.\n */ const xKeys = [\n    \"x\",\n    \"scaleX\",\n    \"originX\"\n];\nconst yKeys = [\n    \"y\",\n    \"scaleY\",\n    \"originY\"\n];\n/**\n * Remove a transforms from an box. This is essentially the steps of applyAxisBox in reverse\n * and acts as a bridge between motion values and removeAxisDelta\n */ function removeBoxTransforms(box, transforms, originBox, sourceBox) {\n    removeAxisTransforms(box.x, transforms, xKeys, originBox ? originBox.x : undefined, sourceBox ? sourceBox.x : undefined);\n    removeAxisTransforms(box.y, transforms, yKeys, originBox ? originBox.y : undefined, sourceBox ? sourceBox.y : undefined);\n}\nfunction isAxisDeltaZero(delta) {\n    return delta.translate === 0 && delta.scale === 1;\n}\nfunction isDeltaZero(delta) {\n    return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);\n}\nfunction axisEquals(a, b) {\n    return a.min === b.min && a.max === b.max;\n}\nfunction boxEquals(a, b) {\n    return axisEquals(a.x, b.x) && axisEquals(a.y, b.y);\n}\nfunction axisEqualsRounded(a, b) {\n    return Math.round(a.min) === Math.round(b.min) && Math.round(a.max) === Math.round(b.max);\n}\nfunction boxEqualsRounded(a, b) {\n    return axisEqualsRounded(a.x, b.x) && axisEqualsRounded(a.y, b.y);\n}\nfunction aspectRatio(box) {\n    return calcLength(box.x) / calcLength(box.y);\n}\nfunction axisDeltaEquals(a, b) {\n    return a.translate === b.translate && a.scale === b.scale && a.originPoint === b.originPoint;\n}\nclass NodeStack {\n    constructor(){\n        this.members = [];\n    }\n    add(node) {\n        addUniqueItem(this.members, node);\n        node.scheduleRender();\n    }\n    remove(node) {\n        removeItem(this.members, node);\n        if (node === this.prevLead) {\n            this.prevLead = undefined;\n        }\n        if (node === this.lead) {\n            const prevLead = this.members[this.members.length - 1];\n            if (prevLead) {\n                this.promote(prevLead);\n            }\n        }\n    }\n    relegate(node) {\n        const indexOfNode = this.members.findIndex((member)=>node === member);\n        if (indexOfNode === 0) return false;\n        /**\n         * Find the next projection node that is present\n         */ let prevLead;\n        for(let i = indexOfNode; i >= 0; i--){\n            const member = this.members[i];\n            if (member.isPresent !== false) {\n                prevLead = member;\n                break;\n            }\n        }\n        if (prevLead) {\n            this.promote(prevLead);\n            return true;\n        } else {\n            return false;\n        }\n    }\n    promote(node, preserveFollowOpacity) {\n        const prevLead = this.lead;\n        if (node === prevLead) return;\n        this.prevLead = prevLead;\n        this.lead = node;\n        node.show();\n        if (prevLead) {\n            prevLead.instance && prevLead.scheduleRender();\n            node.scheduleRender();\n            node.resumeFrom = prevLead;\n            if (preserveFollowOpacity) {\n                node.resumeFrom.preserveOpacity = true;\n            }\n            if (prevLead.snapshot) {\n                node.snapshot = prevLead.snapshot;\n                node.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues;\n            }\n            if (node.root && node.root.isUpdating) {\n                node.isLayoutDirty = true;\n            }\n            const { crossfade } = node.options;\n            if (crossfade === false) {\n                prevLead.hide();\n            }\n        /**\n             * TODO:\n             *   - Test border radius when previous node was deleted\n             *   - boxShadow mixing\n             *   - Shared between element A in scrolled container and element B (scroll stays the same or changes)\n             *   - Shared between element A in transformed container and element B (transform stays the same or changes)\n             *   - Shared between element A in scrolled page and element B (scroll stays the same or changes)\n             * ---\n             *   - Crossfade opacity of root nodes\n             *   - layoutId changes after animation\n             *   - layoutId changes mid animation\n             */ }\n    }\n    exitAnimationComplete() {\n        this.members.forEach((node)=>{\n            const { options, resumingFrom } = node;\n            options.onExitComplete && options.onExitComplete();\n            if (resumingFrom) {\n                resumingFrom.options.onExitComplete && resumingFrom.options.onExitComplete();\n            }\n        });\n    }\n    scheduleRender() {\n        this.members.forEach((node)=>{\n            node.instance && node.scheduleRender(false);\n        });\n    }\n    /**\n     * Clear any leads that have been removed this render to prevent them from being\n     * used in future animations and to prevent memory leaks\n     */ removeLeadSnapshot() {\n        if (this.lead && this.lead.snapshot) {\n            this.lead.snapshot = undefined;\n        }\n    }\n}\nconst scaleCorrectors = {};\nfunction addScaleCorrector(correctors) {\n    Object.assign(scaleCorrectors, correctors);\n}\nfunction buildProjectionTransform(delta, treeScale, latestTransform) {\n    let transform = \"\";\n    /**\n     * The translations we use to calculate are always relative to the viewport coordinate space.\n     * But when we apply scales, we also scale the coordinate space of an element and its children.\n     * For instance if we have a treeScale (the culmination of all parent scales) of 0.5 and we need\n     * to move an element 100 pixels, we actually need to move it 200 in within that scaled space.\n     */ const xTranslate = delta.x.translate / treeScale.x;\n    const yTranslate = delta.y.translate / treeScale.y;\n    const zTranslate = (latestTransform === null || latestTransform === void 0 ? void 0 : latestTransform.z) || 0;\n    if (xTranslate || yTranslate || zTranslate) {\n        transform = `translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `;\n    }\n    /**\n     * Apply scale correction for the tree transform.\n     * This will apply scale to the screen-orientated axes.\n     */ if (treeScale.x !== 1 || treeScale.y !== 1) {\n        transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;\n    }\n    if (latestTransform) {\n        const { transformPerspective, rotate, rotateX, rotateY, skewX, skewY } = latestTransform;\n        if (transformPerspective) transform = `perspective(${transformPerspective}px) ${transform}`;\n        if (rotate) transform += `rotate(${rotate}deg) `;\n        if (rotateX) transform += `rotateX(${rotateX}deg) `;\n        if (rotateY) transform += `rotateY(${rotateY}deg) `;\n        if (skewX) transform += `skewX(${skewX}deg) `;\n        if (skewY) transform += `skewY(${skewY}deg) `;\n    }\n    /**\n     * Apply scale to match the size of the element to the size we want it.\n     * This will apply scale to the element-orientated axes.\n     */ const elementScaleX = delta.x.scale * treeScale.x;\n    const elementScaleY = delta.y.scale * treeScale.y;\n    if (elementScaleX !== 1 || elementScaleY !== 1) {\n        transform += `scale(${elementScaleX}, ${elementScaleY})`;\n    }\n    return transform || \"none\";\n}\nconst compareByDepth = (a, b)=>a.depth - b.depth;\nclass FlatTree {\n    constructor(){\n        this.children = [];\n        this.isDirty = false;\n    }\n    add(child) {\n        addUniqueItem(this.children, child);\n        this.isDirty = true;\n    }\n    remove(child) {\n        removeItem(this.children, child);\n        this.isDirty = true;\n    }\n    forEach(callback) {\n        this.isDirty && this.children.sort(compareByDepth);\n        this.isDirty = false;\n        this.children.forEach(callback);\n    }\n}\n/**\n * If the provided value is a MotionValue, this returns the actual value, otherwise just the value itself\n *\n * TODO: Remove and move to library\n */ function resolveMotionValue(value) {\n    const unwrappedValue = isMotionValue(value) ? value.get() : value;\n    return isCustomValue(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;\n}\n/**\n * This should only ever be modified on the client otherwise it'll\n * persist through server requests. If we need instanced states we\n * could lazy-init via root.\n */ const globalProjectionState = {\n    /**\n     * Global flag as to whether the tree has animated since the last time\n     * we resized the window\n     */ hasAnimatedSinceResize: true,\n    /**\n     * We set this to true once, on the first update. Any nodes added to the tree beyond that\n     * update will be given a `data-projection-id` attribute.\n     */ hasEverUpdated: false\n};\n/**\n * Timeout defined in ms\n */ function delay(callback, timeout) {\n    const start = time.now();\n    const checkElapsed = ({ timestamp })=>{\n        const elapsed = timestamp - start;\n        if (elapsed >= timeout) {\n            cancelFrame(checkElapsed);\n            callback(elapsed - timeout);\n        }\n    };\n    frame.read(checkElapsed, true);\n    return ()=>cancelFrame(checkElapsed);\n}\n/**\n * Create a progress => progress easing function from a generator.\n */ function createGeneratorEasing(options, scale = 100, createGenerator) {\n    const generator = createGenerator({\n        ...options,\n        keyframes: [\n            0,\n            scale\n        ]\n    });\n    const duration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);\n    return {\n        type: \"keyframes\",\n        ease: (progress)=>generator.next(duration * progress).value / scale,\n        duration: millisecondsToSeconds(duration)\n    };\n}\nfunction isDOMKeyframes(keyframes) {\n    return typeof keyframes === \"object\" && !Array.isArray(keyframes);\n}\nfunction resolveSubjects(subject, keyframes, scope, selectorCache) {\n    if (typeof subject === \"string\" && isDOMKeyframes(keyframes)) {\n        return motionDom.resolveElements(subject, scope, selectorCache);\n    } else if (subject instanceof NodeList) {\n        return Array.from(subject);\n    } else if (Array.isArray(subject)) {\n        return subject;\n    } else {\n        return [\n            subject\n        ];\n    }\n}\n/**\n * Given a absolute or relative time definition and current/prev time state of the sequence,\n * calculate an absolute time for the next keyframes.\n */ function calcNextTime(current, next, prev, labels) {\n    var _a;\n    if (typeof next === \"number\") {\n        return next;\n    } else if (next.startsWith(\"-\") || next.startsWith(\"+\")) {\n        return Math.max(0, current + parseFloat(next));\n    } else if (next === \"<\") {\n        return prev;\n    } else {\n        return (_a = labels.get(next)) !== null && _a !== void 0 ? _a : current;\n    }\n}\nconst wrap = (min, max, v)=>{\n    const rangeSize = max - min;\n    return ((v - min) % rangeSize + rangeSize) % rangeSize + min;\n};\nfunction getEasingForSegment(easing, i) {\n    return isEasingArray(easing) ? easing[wrap(0, easing.length, i)] : easing;\n}\nfunction eraseKeyframes(sequence, startTime, endTime) {\n    for(let i = 0; i < sequence.length; i++){\n        const keyframe = sequence[i];\n        if (keyframe.at > startTime && keyframe.at < endTime) {\n            removeItem(sequence, keyframe);\n            // If we remove this item we have to push the pointer back one\n            i--;\n        }\n    }\n}\nfunction addKeyframes(sequence, keyframes, easing, offset, startTime, endTime) {\n    /**\n     * Erase every existing value between currentTime and targetTime,\n     * this will essentially splice this timeline into any currently\n     * defined ones.\n     */ eraseKeyframes(sequence, startTime, endTime);\n    for(let i = 0; i < keyframes.length; i++){\n        sequence.push({\n            value: keyframes[i],\n            at: mixNumber$1(startTime, endTime, offset[i]),\n            easing: getEasingForSegment(easing, i)\n        });\n    }\n}\nfunction compareByTime(a, b) {\n    if (a.at === b.at) {\n        if (a.value === null) return 1;\n        if (b.value === null) return -1;\n        return 0;\n    } else {\n        return a.at - b.at;\n    }\n}\n/**\n * Take an array of times that represent repeated keyframes. For instance\n * if we have original times of [0, 0.5, 1] then our repeated times will\n * be [0, 0.5, 1, 1, 1.5, 2]. Loop over the times and scale them back\n * down to a 0-1 scale.\n */ function normalizeTimes(times, repeat) {\n    for(let i = 0; i < times.length; i++){\n        times[i] = times[i] / (repeat + 1);\n    }\n}\nfunction calculateRepeatDuration(duration, repeat, _repeatDelay) {\n    return duration * (repeat + 1);\n}\nconst defaultSegmentEasing = \"easeInOut\";\nconst MAX_REPEAT = 20;\nfunction createAnimationsFromSequence(sequence, { defaultTransition = {}, ...sequenceTransition } = {}, scope, generators) {\n    const defaultDuration = defaultTransition.duration || 0.3;\n    const animationDefinitions = new Map();\n    const sequences = new Map();\n    const elementCache = {};\n    const timeLabels = new Map();\n    let prevTime = 0;\n    let currentTime = 0;\n    let totalDuration = 0;\n    /**\n     * Build the timeline by mapping over the sequence array and converting\n     * the definitions into keyframes and offsets with absolute time values.\n     * These will later get converted into relative offsets in a second pass.\n     */ for(let i = 0; i < sequence.length; i++){\n        const segment = sequence[i];\n        /**\n         * If this is a timeline label, mark it and skip the rest of this iteration.\n         */ if (typeof segment === \"string\") {\n            timeLabels.set(segment, currentTime);\n            continue;\n        } else if (!Array.isArray(segment)) {\n            timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels));\n            continue;\n        }\n        let [subject, keyframes, transition = {}] = segment;\n        /**\n         * If a relative or absolute time value has been specified we need to resolve\n         * it in relation to the currentTime.\n         */ if (transition.at !== undefined) {\n            currentTime = calcNextTime(currentTime, transition.at, prevTime, timeLabels);\n        }\n        /**\n         * Keep track of the maximum duration in this definition. This will be\n         * applied to currentTime once the definition has been parsed.\n         */ let maxDuration = 0;\n        const resolveValueSequence = (valueKeyframes, valueTransition, valueSequence, elementIndex = 0, numSubjects = 0)=>{\n            const valueKeyframesAsList = keyframesAsList(valueKeyframes);\n            const { delay = 0, times = defaultOffset$1(valueKeyframesAsList), type = \"keyframes\", repeat, repeatType, repeatDelay = 0, ...remainingTransition } = valueTransition;\n            let { ease = defaultTransition.ease || \"easeOut\", duration } = valueTransition;\n            /**\n             * Resolve stagger() if defined.\n             */ const calculatedDelay = typeof delay === \"function\" ? delay(elementIndex, numSubjects) : delay;\n            /**\n             * If this animation should and can use a spring, generate a spring easing function.\n             */ const numKeyframes = valueKeyframesAsList.length;\n            const createGenerator = isGenerator(type) ? type : generators === null || generators === void 0 ? void 0 : generators[type];\n            if (numKeyframes <= 2 && createGenerator) {\n                /**\n                 * As we're creating an easing function from a spring,\n                 * ideally we want to generate it using the real distance\n                 * between the two keyframes. However this isn't always\n                 * possible - in these situations we use 0-100.\n                 */ let absoluteDelta = 100;\n                if (numKeyframes === 2 && isNumberKeyframesArray(valueKeyframesAsList)) {\n                    const delta = valueKeyframesAsList[1] - valueKeyframesAsList[0];\n                    absoluteDelta = Math.abs(delta);\n                }\n                const springTransition = {\n                    ...remainingTransition\n                };\n                if (duration !== undefined) {\n                    springTransition.duration = secondsToMilliseconds(duration);\n                }\n                const springEasing = createGeneratorEasing(springTransition, absoluteDelta, createGenerator);\n                ease = springEasing.ease;\n                duration = springEasing.duration;\n            }\n            duration !== null && duration !== void 0 ? duration : duration = defaultDuration;\n            const startTime = currentTime + calculatedDelay;\n            /**\n             * If there's only one time offset of 0, fill in a second with length 1\n             */ if (times.length === 1 && times[0] === 0) {\n                times[1] = 1;\n            }\n            /**\n             * Fill out if offset if fewer offsets than keyframes\n             */ const remainder = times.length - valueKeyframesAsList.length;\n            remainder > 0 && fillOffset(times, remainder);\n            /**\n             * If only one value has been set, ie [1], push a null to the start of\n             * the keyframe array. This will let us mark a keyframe at this point\n             * that will later be hydrated with the previous value.\n             */ valueKeyframesAsList.length === 1 && valueKeyframesAsList.unshift(null);\n            /**\n             * Handle repeat options\n             */ if (repeat) {\n                motionUtils.invariant(repeat < MAX_REPEAT, \"Repeat count too high, must be less than 20\");\n                duration = calculateRepeatDuration(duration, repeat);\n                const originalKeyframes = [\n                    ...valueKeyframesAsList\n                ];\n                const originalTimes = [\n                    ...times\n                ];\n                ease = Array.isArray(ease) ? [\n                    ...ease\n                ] : [\n                    ease\n                ];\n                const originalEase = [\n                    ...ease\n                ];\n                for(let repeatIndex = 0; repeatIndex < repeat; repeatIndex++){\n                    valueKeyframesAsList.push(...originalKeyframes);\n                    for(let keyframeIndex = 0; keyframeIndex < originalKeyframes.length; keyframeIndex++){\n                        times.push(originalTimes[keyframeIndex] + (repeatIndex + 1));\n                        ease.push(keyframeIndex === 0 ? \"linear\" : getEasingForSegment(originalEase, keyframeIndex - 1));\n                    }\n                }\n                normalizeTimes(times, repeat);\n            }\n            const targetTime = startTime + duration;\n            /**\n             * Add keyframes, mapping offsets to absolute time.\n             */ addKeyframes(valueSequence, valueKeyframesAsList, ease, times, startTime, targetTime);\n            maxDuration = Math.max(calculatedDelay + duration, maxDuration);\n            totalDuration = Math.max(targetTime, totalDuration);\n        };\n        if (isMotionValue(subject)) {\n            const subjectSequence = getSubjectSequence(subject, sequences);\n            resolveValueSequence(keyframes, transition, getValueSequence(\"default\", subjectSequence));\n        } else {\n            const subjects = resolveSubjects(subject, keyframes, scope, elementCache);\n            const numSubjects = subjects.length;\n            /**\n             * For every element in this segment, process the defined values.\n             */ for(let subjectIndex = 0; subjectIndex < numSubjects; subjectIndex++){\n                /**\n                 * Cast necessary, but we know these are of this type\n                 */ keyframes = keyframes;\n                transition = transition;\n                const thisSubject = subjects[subjectIndex];\n                const subjectSequence = getSubjectSequence(thisSubject, sequences);\n                for(const key in keyframes){\n                    resolveValueSequence(keyframes[key], getValueTransition(transition, key), getValueSequence(key, subjectSequence), subjectIndex, numSubjects);\n                }\n            }\n        }\n        prevTime = currentTime;\n        currentTime += maxDuration;\n    }\n    /**\n     * For every element and value combination create a new animation.\n     */ sequences.forEach((valueSequences, element)=>{\n        for(const key in valueSequences){\n            const valueSequence = valueSequences[key];\n            /**\n             * Arrange all the keyframes in ascending time order.\n             */ valueSequence.sort(compareByTime);\n            const keyframes = [];\n            const valueOffset = [];\n            const valueEasing = [];\n            /**\n             * For each keyframe, translate absolute times into\n             * relative offsets based on the total duration of the timeline.\n             */ for(let i = 0; i < valueSequence.length; i++){\n                const { at, value, easing } = valueSequence[i];\n                keyframes.push(value);\n                valueOffset.push(progress(0, totalDuration, at));\n                valueEasing.push(easing || \"easeOut\");\n            }\n            /**\n             * If the first keyframe doesn't land on offset: 0\n             * provide one by duplicating the initial keyframe. This ensures\n             * it snaps to the first keyframe when the animation starts.\n             */ if (valueOffset[0] !== 0) {\n                valueOffset.unshift(0);\n                keyframes.unshift(keyframes[0]);\n                valueEasing.unshift(defaultSegmentEasing);\n            }\n            /**\n             * If the last keyframe doesn't land on offset: 1\n             * provide one with a null wildcard value. This will ensure it\n             * stays static until the end of the animation.\n             */ if (valueOffset[valueOffset.length - 1] !== 1) {\n                valueOffset.push(1);\n                keyframes.push(null);\n            }\n            if (!animationDefinitions.has(element)) {\n                animationDefinitions.set(element, {\n                    keyframes: {},\n                    transition: {}\n                });\n            }\n            const definition = animationDefinitions.get(element);\n            definition.keyframes[key] = keyframes;\n            definition.transition[key] = {\n                ...defaultTransition,\n                duration: totalDuration,\n                ease: valueEasing,\n                times: valueOffset,\n                ...sequenceTransition\n            };\n        }\n    });\n    return animationDefinitions;\n}\nfunction getSubjectSequence(subject, sequences) {\n    !sequences.has(subject) && sequences.set(subject, {});\n    return sequences.get(subject);\n}\nfunction getValueSequence(name, sequences) {\n    if (!sequences[name]) sequences[name] = [];\n    return sequences[name];\n}\nfunction keyframesAsList(keyframes) {\n    return Array.isArray(keyframes) ? keyframes : [\n        keyframes\n    ];\n}\nfunction getValueTransition(transition, key) {\n    return transition && transition[key] ? {\n        ...transition,\n        ...transition[key]\n    } : {\n        ...transition\n    };\n}\nconst isNumber = (keyframe)=>typeof keyframe === \"number\";\nconst isNumberKeyframesArray = (keyframes)=>keyframes.every(isNumber);\nconst visualElementStore = new WeakMap();\nfunction isSVGElement(element) {\n    return element instanceof SVGElement && element.tagName !== \"svg\";\n}\nfunction isForcedMotionValue(key, { layout, layoutId }) {\n    return transformProps.has(key) || key.startsWith(\"origin\") || (layout || layoutId !== undefined) && (!!scaleCorrectors[key] || key === \"opacity\");\n}\nfunction scrapeMotionValuesFromProps$1(props, prevProps, visualElement) {\n    var _a;\n    const { style } = props;\n    const newValues = {};\n    for(const key in style){\n        if (isMotionValue(style[key]) || prevProps.style && isMotionValue(prevProps.style[key]) || isForcedMotionValue(key, props) || ((_a = visualElement === null || visualElement === void 0 ? void 0 : visualElement.getValue(key)) === null || _a === void 0 ? void 0 : _a.liveStyle) !== undefined) {\n            newValues[key] = style[key];\n        }\n    }\n    return newValues;\n}\nfunction scrapeMotionValuesFromProps(props, prevProps, visualElement) {\n    const newValues = scrapeMotionValuesFromProps$1(props, prevProps, visualElement);\n    for(const key in props){\n        if (isMotionValue(props[key]) || isMotionValue(prevProps[key])) {\n            const targetKey = transformPropOrder.indexOf(key) !== -1 ? \"attr\" + key.charAt(0).toUpperCase() + key.substring(1) : key;\n            newValues[targetKey] = props[key];\n        }\n    }\n    return newValues;\n}\nconst isBrowser = \"undefined\" !== \"undefined\";\n// Does this device prefer reduced motion? Returns `null` server-side.\nconst prefersReducedMotion = {\n    current: null\n};\nconst hasReducedMotionListener = {\n    current: false\n};\nfunction initPrefersReducedMotion() {\n    hasReducedMotionListener.current = true;\n    if (!isBrowser) return;\n    if (window.matchMedia) {\n        const motionMediaQuery = window.matchMedia(\"(prefers-reduced-motion)\");\n        const setReducedMotionPreferences = ()=>prefersReducedMotion.current = motionMediaQuery.matches;\n        motionMediaQuery.addListener(setReducedMotionPreferences);\n        setReducedMotionPreferences();\n    } else {\n        prefersReducedMotion.current = false;\n    }\n}\nfunction isControllingVariants(props) {\n    return isAnimationControls(props.animate) || variantProps.some((name)=>isVariantLabel(props[name]));\n}\nfunction isVariantNode(props) {\n    return Boolean(isControllingVariants(props) || props.variants);\n}\nfunction updateMotionValuesFromProps(element, next, prev) {\n    for(const key in next){\n        const nextValue = next[key];\n        const prevValue = prev[key];\n        if (isMotionValue(nextValue)) {\n            /**\n             * If this is a motion value found in props or style, we want to add it\n             * to our visual element's motion value map.\n             */ element.addValue(key, nextValue);\n            /**\n             * Check the version of the incoming motion value with this version\n             * and warn against mismatches.\n             */ if (true) {\n                warnOnce(nextValue.version === \"11.15.0\", `Attempting to mix Motion versions ${nextValue.version} with 11.15.0 may not work as expected.`);\n            }\n        } else if (isMotionValue(prevValue)) {\n            /**\n             * If we're swapping from a motion value to a static value,\n             * create a new motion value from that\n             */ element.addValue(key, motionValue(nextValue, {\n                owner: element\n            }));\n        } else if (prevValue !== nextValue) {\n            /**\n             * If this is a flat value that has changed, update the motion value\n             * or create one if it doesn't exist. We only want to do this if we're\n             * not handling the value with our animation state.\n             */ if (element.hasValue(key)) {\n                const existingValue = element.getValue(key);\n                if (existingValue.liveStyle === true) {\n                    existingValue.jump(nextValue);\n                } else if (!existingValue.hasAnimated) {\n                    existingValue.set(nextValue);\n                }\n            } else {\n                const latestValue = element.getStaticValue(key);\n                element.addValue(key, motionValue(latestValue !== undefined ? latestValue : nextValue, {\n                    owner: element\n                }));\n            }\n        }\n    }\n    // Handle removed values\n    for(const key in prev){\n        if (next[key] === undefined) element.removeValue(key);\n    }\n    return next;\n}\nconst featureProps = {\n    animation: [\n        \"animate\",\n        \"variants\",\n        \"whileHover\",\n        \"whileTap\",\n        \"exit\",\n        \"whileInView\",\n        \"whileFocus\",\n        \"whileDrag\"\n    ],\n    exit: [\n        \"exit\"\n    ],\n    drag: [\n        \"drag\",\n        \"dragControls\"\n    ],\n    focus: [\n        \"whileFocus\"\n    ],\n    hover: [\n        \"whileHover\",\n        \"onHoverStart\",\n        \"onHoverEnd\"\n    ],\n    tap: [\n        \"whileTap\",\n        \"onTap\",\n        \"onTapStart\",\n        \"onTapCancel\"\n    ],\n    pan: [\n        \"onPan\",\n        \"onPanStart\",\n        \"onPanSessionStart\",\n        \"onPanEnd\"\n    ],\n    inView: [\n        \"whileInView\",\n        \"onViewportEnter\",\n        \"onViewportLeave\"\n    ],\n    layout: [\n        \"layout\",\n        \"layoutId\"\n    ]\n};\nconst featureDefinitions = {};\nfor(const key in featureProps){\n    featureDefinitions[key] = {\n        isEnabled: (props)=>featureProps[key].some((name)=>!!props[name])\n    };\n}\n/**\n * A list of all ValueTypes\n */ const valueTypes = [\n    ...dimensionValueTypes,\n    color,\n    complex\n];\n/**\n * Tests a value against the list of ValueTypes\n */ const findValueType = (v)=>valueTypes.find(testValueType(v));\nconst propEventHandlers = [\n    \"AnimationStart\",\n    \"AnimationComplete\",\n    \"Update\",\n    \"BeforeLayoutMeasure\",\n    \"LayoutMeasure\",\n    \"LayoutAnimationStart\",\n    \"LayoutAnimationComplete\"\n];\n/**\n * A VisualElement is an imperative abstraction around UI elements such as\n * HTMLElement, SVGElement, Three.Object3D etc.\n */ class VisualElement {\n    /**\n     * This method takes React props and returns found MotionValues. For example, HTML\n     * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.\n     *\n     * This isn't an abstract method as it needs calling in the constructor, but it is\n     * intended to be one.\n     */ scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {\n        return {};\n    }\n    constructor({ parent, props, presenceContext, reducedMotionConfig, blockInitialAnimation, visualState }, options = {}){\n        /**\n         * A reference to the current underlying Instance, e.g. a HTMLElement\n         * or Three.Mesh etc.\n         */ this.current = null;\n        /**\n         * A set containing references to this VisualElement's children.\n         */ this.children = new Set();\n        /**\n         * Determine what role this visual element should take in the variant tree.\n         */ this.isVariantNode = false;\n        this.isControllingVariants = false;\n        /**\n         * Decides whether this VisualElement should animate in reduced motion\n         * mode.\n         *\n         * TODO: This is currently set on every individual VisualElement but feels\n         * like it could be set globally.\n         */ this.shouldReduceMotion = null;\n        /**\n         * A map of all motion values attached to this visual element. Motion\n         * values are source of truth for any given animated value. A motion\n         * value might be provided externally by the component via props.\n         */ this.values = new Map();\n        this.KeyframeResolver = KeyframeResolver;\n        /**\n         * Cleanup functions for active features (hover/tap/exit etc)\n         */ this.features = {};\n        /**\n         * A map of every subscription that binds the provided or generated\n         * motion values onChange listeners to this visual element.\n         */ this.valueSubscriptions = new Map();\n        /**\n         * A reference to the previously-provided motion values as returned\n         * from scrapeMotionValuesFromProps. We use the keys in here to determine\n         * if any motion values need to be removed after props are updated.\n         */ this.prevMotionValues = {};\n        /**\n         * An object containing a SubscriptionManager for each active event.\n         */ this.events = {};\n        /**\n         * An object containing an unsubscribe function for each prop event subscription.\n         * For example, every \"Update\" event can have multiple subscribers via\n         * VisualElement.on(), but only one of those can be defined via the onUpdate prop.\n         */ this.propEventSubscriptions = {};\n        this.notifyUpdate = ()=>this.notify(\"Update\", this.latestValues);\n        this.render = ()=>{\n            if (!this.current) return;\n            this.triggerBuild();\n            this.renderInstance(this.current, this.renderState, this.props.style, this.projection);\n        };\n        this.renderScheduledAt = 0.0;\n        this.scheduleRender = ()=>{\n            const now = time.now();\n            if (this.renderScheduledAt < now) {\n                this.renderScheduledAt = now;\n                frame.render(this.render, false, true);\n            }\n        };\n        const { latestValues, renderState } = visualState;\n        this.latestValues = latestValues;\n        this.baseTarget = {\n            ...latestValues\n        };\n        this.initialValues = props.initial ? {\n            ...latestValues\n        } : {};\n        this.renderState = renderState;\n        this.parent = parent;\n        this.props = props;\n        this.presenceContext = presenceContext;\n        this.depth = parent ? parent.depth + 1 : 0;\n        this.reducedMotionConfig = reducedMotionConfig;\n        this.options = options;\n        this.blockInitialAnimation = Boolean(blockInitialAnimation);\n        this.isControllingVariants = isControllingVariants(props);\n        this.isVariantNode = isVariantNode(props);\n        if (this.isVariantNode) {\n            this.variantChildren = new Set();\n        }\n        this.manuallyAnimateOnMount = Boolean(parent && parent.current);\n        /**\n         * Any motion values that are provided to the element when created\n         * aren't yet bound to the element, as this would technically be impure.\n         * However, we iterate through the motion values and set them to the\n         * initial values for this component.\n         *\n         * TODO: This is impure and we should look at changing this to run on mount.\n         * Doing so will break some tests but this isn't necessarily a breaking change,\n         * more a reflection of the test.\n         */ const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {}, this);\n        for(const key in initialMotionValues){\n            const value = initialMotionValues[key];\n            if (latestValues[key] !== undefined && isMotionValue(value)) {\n                value.set(latestValues[key], false);\n            }\n        }\n    }\n    mount(instance) {\n        this.current = instance;\n        visualElementStore.set(instance, this);\n        if (this.projection && !this.projection.instance) {\n            this.projection.mount(instance);\n        }\n        if (this.parent && this.isVariantNode && !this.isControllingVariants) {\n            this.removeFromVariantTree = this.parent.addVariantChild(this);\n        }\n        this.values.forEach((value, key)=>this.bindToMotionValue(key, value));\n        if (!hasReducedMotionListener.current) {\n            initPrefersReducedMotion();\n        }\n        this.shouldReduceMotion = this.reducedMotionConfig === \"never\" ? false : this.reducedMotionConfig === \"always\" ? true : prefersReducedMotion.current;\n        if (true) {\n            warnOnce(this.shouldReduceMotion !== true, \"You have Reduced Motion enabled on your device. Animations may not appear as expected.\");\n        }\n        if (this.parent) this.parent.children.add(this);\n        this.update(this.props, this.presenceContext);\n    }\n    unmount() {\n        visualElementStore.delete(this.current);\n        this.projection && this.projection.unmount();\n        cancelFrame(this.notifyUpdate);\n        cancelFrame(this.render);\n        this.valueSubscriptions.forEach((remove)=>remove());\n        this.valueSubscriptions.clear();\n        this.removeFromVariantTree && this.removeFromVariantTree();\n        this.parent && this.parent.children.delete(this);\n        for(const key in this.events){\n            this.events[key].clear();\n        }\n        for(const key in this.features){\n            const feature = this.features[key];\n            if (feature) {\n                feature.unmount();\n                feature.isMounted = false;\n            }\n        }\n        this.current = null;\n    }\n    bindToMotionValue(key, value) {\n        if (this.valueSubscriptions.has(key)) {\n            this.valueSubscriptions.get(key)();\n        }\n        const valueIsTransform = transformProps.has(key);\n        const removeOnChange = value.on(\"change\", (latestValue)=>{\n            this.latestValues[key] = latestValue;\n            this.props.onUpdate && frame.preRender(this.notifyUpdate);\n            if (valueIsTransform && this.projection) {\n                this.projection.isTransformDirty = true;\n            }\n        });\n        const removeOnRenderRequest = value.on(\"renderRequest\", this.scheduleRender);\n        let removeSyncCheck;\n        if (window.MotionCheckAppearSync) {\n            removeSyncCheck = window.MotionCheckAppearSync(this, key, value);\n        }\n        this.valueSubscriptions.set(key, ()=>{\n            removeOnChange();\n            removeOnRenderRequest();\n            if (removeSyncCheck) removeSyncCheck();\n            if (value.owner) value.stop();\n        });\n    }\n    sortNodePosition(other) {\n        /**\n         * If these nodes aren't even of the same type we can't compare their depth.\n         */ if (!this.current || !this.sortInstanceNodePosition || this.type !== other.type) {\n            return 0;\n        }\n        return this.sortInstanceNodePosition(this.current, other.current);\n    }\n    updateFeatures() {\n        let key = \"animation\";\n        for(key in featureDefinitions){\n            const featureDefinition = featureDefinitions[key];\n            if (!featureDefinition) continue;\n            const { isEnabled, Feature: FeatureConstructor } = featureDefinition;\n            /**\n             * If this feature is enabled but not active, make a new instance.\n             */ if (!this.features[key] && FeatureConstructor && isEnabled(this.props)) {\n                this.features[key] = new FeatureConstructor(this);\n            }\n            /**\n             * If we have a feature, mount or update it.\n             */ if (this.features[key]) {\n                const feature = this.features[key];\n                if (feature.isMounted) {\n                    feature.update();\n                } else {\n                    feature.mount();\n                    feature.isMounted = true;\n                }\n            }\n        }\n    }\n    triggerBuild() {\n        this.build(this.renderState, this.latestValues, this.props);\n    }\n    /**\n     * Measure the current viewport box with or without transforms.\n     * Only measures axis-aligned boxes, rotate and skew must be manually\n     * removed with a re-render to work.\n     */ measureViewportBox() {\n        return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();\n    }\n    getStaticValue(key) {\n        return this.latestValues[key];\n    }\n    setStaticValue(key, value) {\n        this.latestValues[key] = value;\n    }\n    /**\n     * Update the provided props. Ensure any newly-added motion values are\n     * added to our map, old ones removed, and listeners updated.\n     */ update(props, presenceContext) {\n        if (props.transformTemplate || this.props.transformTemplate) {\n            this.scheduleRender();\n        }\n        this.prevProps = this.props;\n        this.props = props;\n        this.prevPresenceContext = this.presenceContext;\n        this.presenceContext = presenceContext;\n        /**\n         * Update prop event handlers ie onAnimationStart, onAnimationComplete\n         */ for(let i = 0; i < propEventHandlers.length; i++){\n            const key = propEventHandlers[i];\n            if (this.propEventSubscriptions[key]) {\n                this.propEventSubscriptions[key]();\n                delete this.propEventSubscriptions[key];\n            }\n            const listenerName = \"on\" + key;\n            const listener = props[listenerName];\n            if (listener) {\n                this.propEventSubscriptions[key] = this.on(key, listener);\n            }\n        }\n        this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps, this), this.prevMotionValues);\n        if (this.handleChildMotionValue) {\n            this.handleChildMotionValue();\n        }\n    }\n    getProps() {\n        return this.props;\n    }\n    /**\n     * Returns the variant definition with a given name.\n     */ getVariant(name) {\n        return this.props.variants ? this.props.variants[name] : undefined;\n    }\n    /**\n     * Returns the defined default transition on this component.\n     */ getDefaultTransition() {\n        return this.props.transition;\n    }\n    getTransformPagePoint() {\n        return this.props.transformPagePoint;\n    }\n    getClosestVariantNode() {\n        return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : undefined;\n    }\n    /**\n     * Add a child visual element to our set of children.\n     */ addVariantChild(child) {\n        const closestVariantNode = this.getClosestVariantNode();\n        if (closestVariantNode) {\n            closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child);\n            return ()=>closestVariantNode.variantChildren.delete(child);\n        }\n    }\n    /**\n     * Add a motion value and bind it to this visual element.\n     */ addValue(key, value) {\n        // Remove existing value if it exists\n        const existingValue = this.values.get(key);\n        if (value !== existingValue) {\n            if (existingValue) this.removeValue(key);\n            this.bindToMotionValue(key, value);\n            this.values.set(key, value);\n            this.latestValues[key] = value.get();\n        }\n    }\n    /**\n     * Remove a motion value and unbind any active subscriptions.\n     */ removeValue(key) {\n        this.values.delete(key);\n        const unsubscribe = this.valueSubscriptions.get(key);\n        if (unsubscribe) {\n            unsubscribe();\n            this.valueSubscriptions.delete(key);\n        }\n        delete this.latestValues[key];\n        this.removeValueFromRenderState(key, this.renderState);\n    }\n    /**\n     * Check whether we have a motion value for this key\n     */ hasValue(key) {\n        return this.values.has(key);\n    }\n    getValue(key, defaultValue) {\n        if (this.props.values && this.props.values[key]) {\n            return this.props.values[key];\n        }\n        let value = this.values.get(key);\n        if (value === undefined && defaultValue !== undefined) {\n            value = motionValue(defaultValue === null ? undefined : defaultValue, {\n                owner: this\n            });\n            this.addValue(key, value);\n        }\n        return value;\n    }\n    /**\n     * If we're trying to animate to a previously unencountered value,\n     * we need to check for it in our state and as a last resort read it\n     * directly from the instance (which might have performance implications).\n     */ readValue(key, target) {\n        var _a;\n        let value = this.latestValues[key] !== undefined || !this.current ? this.latestValues[key] : (_a = this.getBaseTargetFromProps(this.props, key)) !== null && _a !== void 0 ? _a : this.readValueFromInstance(this.current, key, this.options);\n        if (value !== undefined && value !== null) {\n            if (typeof value === \"string\" && (isNumericalString(value) || isZeroValueString(value))) {\n                // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\n                value = parseFloat(value);\n            } else if (!findValueType(value) && complex.test(target)) {\n                value = getAnimatableNone(key, target);\n            }\n            this.setBaseTarget(key, isMotionValue(value) ? value.get() : value);\n        }\n        return isMotionValue(value) ? value.get() : value;\n    }\n    /**\n     * Set the base target to later animate back to. This is currently\n     * only hydrated on creation and when we first read a value.\n     */ setBaseTarget(key, value) {\n        this.baseTarget[key] = value;\n    }\n    /**\n     * Find the base target for a value thats been removed from all animation\n     * props.\n     */ getBaseTarget(key) {\n        var _a;\n        const { initial } = this.props;\n        let valueFromInitial;\n        if (typeof initial === \"string\" || typeof initial === \"object\") {\n            const variant = resolveVariantFromProps(this.props, initial, (_a = this.presenceContext) === null || _a === void 0 ? void 0 : _a.custom);\n            if (variant) {\n                valueFromInitial = variant[key];\n            }\n        }\n        /**\n         * If this value still exists in the current initial variant, read that.\n         */ if (initial && valueFromInitial !== undefined) {\n            return valueFromInitial;\n        }\n        /**\n         * Alternatively, if this VisualElement config has defined a getBaseTarget\n         * so we can read the value from an alternative source, try that.\n         */ const target = this.getBaseTargetFromProps(this.props, key);\n        if (target !== undefined && !isMotionValue(target)) return target;\n        /**\n         * If the value was initially defined on initial, but it doesn't any more,\n         * return undefined. Otherwise return the value as initially read from the DOM.\n         */ return this.initialValues[key] !== undefined && valueFromInitial === undefined ? undefined : this.baseTarget[key];\n    }\n    on(eventName, callback) {\n        if (!this.events[eventName]) {\n            this.events[eventName] = new SubscriptionManager();\n        }\n        return this.events[eventName].add(callback);\n    }\n    notify(eventName, ...args) {\n        if (this.events[eventName]) {\n            this.events[eventName].notify(...args);\n        }\n    }\n}\nclass DOMVisualElement extends VisualElement {\n    constructor(){\n        super(...arguments);\n        this.KeyframeResolver = DOMKeyframesResolver;\n    }\n    sortInstanceNodePosition(a, b) {\n        /**\n         * compareDocumentPosition returns a bitmask, by using the bitwise &\n         * we're returning true if 2 in that bitmask is set to true. 2 is set\n         * to true if b preceeds a.\n         */ return a.compareDocumentPosition(b) & 2 ? 1 : -1;\n    }\n    getBaseTargetFromProps(props, key) {\n        return props.style ? props.style[key] : undefined;\n    }\n    removeValueFromRenderState(key, { vars, style }) {\n        delete vars[key];\n        delete style[key];\n    }\n    handleChildMotionValue() {\n        if (this.childSubscription) {\n            this.childSubscription();\n            delete this.childSubscription;\n        }\n        const { children } = this.props;\n        if (isMotionValue(children)) {\n            this.childSubscription = children.on(\"change\", (latest)=>{\n                if (this.current) {\n                    this.current.textContent = `${latest}`;\n                }\n            });\n        }\n    }\n}\n/**\n * Provided a value and a ValueType, returns the value as that value type.\n */ const getValueAsType = (value, type)=>{\n    return type && typeof value === \"number\" ? type.transform(value) : value;\n};\nconst translateAlias = {\n    x: \"translateX\",\n    y: \"translateY\",\n    z: \"translateZ\",\n    transformPerspective: \"perspective\"\n};\nconst numTransforms = transformPropOrder.length;\n/**\n * Build a CSS transform style from individual x/y/scale etc properties.\n *\n * This outputs with a default order of transforms/scales/rotations, this can be customised by\n * providing a transformTemplate function.\n */ function buildTransform(latestValues, transform, transformTemplate) {\n    // The transform string we're going to build into.\n    let transformString = \"\";\n    let transformIsDefault = true;\n    /**\n     * Loop over all possible transforms in order, adding the ones that\n     * are present to the transform string.\n     */ for(let i = 0; i < numTransforms; i++){\n        const key = transformPropOrder[i];\n        const value = latestValues[key];\n        if (value === undefined) continue;\n        let valueIsDefault = true;\n        if (typeof value === \"number\") {\n            valueIsDefault = value === (key.startsWith(\"scale\") ? 1 : 0);\n        } else {\n            valueIsDefault = parseFloat(value) === 0;\n        }\n        if (!valueIsDefault || transformTemplate) {\n            const valueAsType = getValueAsType(value, numberValueTypes[key]);\n            if (!valueIsDefault) {\n                transformIsDefault = false;\n                const transformName = translateAlias[key] || key;\n                transformString += `${transformName}(${valueAsType}) `;\n            }\n            if (transformTemplate) {\n                transform[key] = valueAsType;\n            }\n        }\n    }\n    transformString = transformString.trim();\n    // If we have a custom `transform` template, pass our transform values and\n    // generated transformString to that before returning\n    if (transformTemplate) {\n        transformString = transformTemplate(transform, transformIsDefault ? \"\" : transformString);\n    } else if (transformIsDefault) {\n        transformString = \"none\";\n    }\n    return transformString;\n}\nfunction buildHTMLStyles(state, latestValues, transformTemplate) {\n    const { style, vars, transformOrigin } = state;\n    // Track whether we encounter any transform or transformOrigin values.\n    let hasTransform = false;\n    let hasTransformOrigin = false;\n    /**\n     * Loop over all our latest animated values and decide whether to handle them\n     * as a style or CSS variable.\n     *\n     * Transforms and transform origins are kept separately for further processing.\n     */ for(const key in latestValues){\n        const value = latestValues[key];\n        if (transformProps.has(key)) {\n            // If this is a transform, flag to enable further transform processing\n            hasTransform = true;\n            continue;\n        } else if (isCSSVariableName(key)) {\n            vars[key] = value;\n            continue;\n        } else {\n            // Convert the value to its default value type, ie 0 -> \"0px\"\n            const valueAsType = getValueAsType(value, numberValueTypes[key]);\n            if (key.startsWith(\"origin\")) {\n                // If this is a transform origin, flag and enable further transform-origin processing\n                hasTransformOrigin = true;\n                transformOrigin[key] = valueAsType;\n            } else {\n                style[key] = valueAsType;\n            }\n        }\n    }\n    if (!latestValues.transform) {\n        if (hasTransform || transformTemplate) {\n            style.transform = buildTransform(latestValues, state.transform, transformTemplate);\n        } else if (style.transform) {\n            /**\n             * If we have previously created a transform but currently don't have any,\n             * reset transform style to none.\n             */ style.transform = \"none\";\n        }\n    }\n    /**\n     * Build a transformOrigin style. Uses the same defaults as the browser for\n     * undefined origins.\n     */ if (hasTransformOrigin) {\n        const { originX = \"50%\", originY = \"50%\", originZ = 0 } = transformOrigin;\n        style.transformOrigin = `${originX} ${originY} ${originZ}`;\n    }\n}\nfunction calcOrigin(origin, offset, size) {\n    return typeof origin === \"string\" ? origin : px.transform(offset + size * origin);\n}\n/**\n * The SVG transform origin defaults are different to CSS and is less intuitive,\n * so we use the measured dimensions of the SVG to reconcile these.\n */ function calcSVGTransformOrigin(dimensions, originX, originY) {\n    const pxOriginX = calcOrigin(originX, dimensions.x, dimensions.width);\n    const pxOriginY = calcOrigin(originY, dimensions.y, dimensions.height);\n    return `${pxOriginX} ${pxOriginY}`;\n}\nconst dashKeys = {\n    offset: \"stroke-dashoffset\",\n    array: \"stroke-dasharray\"\n};\nconst camelKeys = {\n    offset: \"strokeDashoffset\",\n    array: \"strokeDasharray\"\n};\n/**\n * Build SVG path properties. Uses the path's measured length to convert\n * our custom pathLength, pathSpacing and pathOffset into stroke-dashoffset\n * and stroke-dasharray attributes.\n *\n * This function is mutative to reduce per-frame GC.\n */ function buildSVGPath(attrs, length, spacing = 1, offset = 0, useDashCase = true) {\n    // Normalise path length by setting SVG attribute pathLength to 1\n    attrs.pathLength = 1;\n    // We use dash case when setting attributes directly to the DOM node and camel case\n    // when defining props on a React component.\n    const keys = useDashCase ? dashKeys : camelKeys;\n    // Build the dash offset\n    attrs[keys.offset] = px.transform(-offset);\n    // Build the dash array\n    const pathLength = px.transform(length);\n    const pathSpacing = px.transform(spacing);\n    attrs[keys.array] = `${pathLength} ${pathSpacing}`;\n}\n/**\n * Build SVG visual attrbutes, like cx and style.transform\n */ function buildSVGAttrs(state, { attrX, attrY, attrScale, originX, originY, pathLength, pathSpacing = 1, pathOffset = 0, // This is object creation, which we try to avoid per-frame.\n...latest }, isSVGTag, transformTemplate) {\n    buildHTMLStyles(state, latest, transformTemplate);\n    /**\n     * For svg tags we just want to make sure viewBox is animatable and treat all the styles\n     * as normal HTML tags.\n     */ if (isSVGTag) {\n        if (state.style.viewBox) {\n            state.attrs.viewBox = state.style.viewBox;\n        }\n        return;\n    }\n    state.attrs = state.style;\n    state.style = {};\n    const { attrs, style, dimensions } = state;\n    /**\n     * However, we apply transforms as CSS transforms. So if we detect a transform we take it from attrs\n     * and copy it into style.\n     */ if (attrs.transform) {\n        if (dimensions) style.transform = attrs.transform;\n        delete attrs.transform;\n    }\n    // Parse transformOrigin\n    if (dimensions && (originX !== undefined || originY !== undefined || style.transform)) {\n        style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== undefined ? originX : 0.5, originY !== undefined ? originY : 0.5);\n    }\n    // Render attrX/attrY/attrScale as attributes\n    if (attrX !== undefined) attrs.x = attrX;\n    if (attrY !== undefined) attrs.y = attrY;\n    if (attrScale !== undefined) attrs.scale = attrScale;\n    // Build SVG path if one has been defined\n    if (pathLength !== undefined) {\n        buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);\n    }\n}\n/**\n * A set of attribute names that are always read/written as camel case.\n */ const camelCaseAttributes = new Set([\n    \"baseFrequency\",\n    \"diffuseConstant\",\n    \"kernelMatrix\",\n    \"kernelUnitLength\",\n    \"keySplines\",\n    \"keyTimes\",\n    \"limitingConeAngle\",\n    \"markerHeight\",\n    \"markerWidth\",\n    \"numOctaves\",\n    \"targetX\",\n    \"targetY\",\n    \"surfaceScale\",\n    \"specularConstant\",\n    \"specularExponent\",\n    \"stdDeviation\",\n    \"tableValues\",\n    \"viewBox\",\n    \"gradientTransform\",\n    \"pathLength\",\n    \"startOffset\",\n    \"textLength\",\n    \"lengthAdjust\"\n]);\nfunction renderHTML(element, { style, vars }, styleProp, projection) {\n    Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp));\n    // Loop over any CSS variables and assign those.\n    for(const key in vars){\n        element.style.setProperty(key, vars[key]);\n    }\n}\nfunction renderSVG(element, renderState, _styleProp, projection) {\n    renderHTML(element, renderState, undefined, projection);\n    for(const key in renderState.attrs){\n        element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);\n    }\n}\nconst isSVGTag = (tag)=>typeof tag === \"string\" && tag.toLowerCase() === \"svg\";\nclass SVGVisualElement extends DOMVisualElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"svg\";\n        this.isSVGTag = false;\n        this.measureInstanceViewportBox = createBox;\n    }\n    getBaseTargetFromProps(props, key) {\n        return props[key];\n    }\n    readValueFromInstance(instance, key) {\n        if (transformProps.has(key)) {\n            const defaultType = getDefaultValueType(key);\n            return defaultType ? defaultType.default || 0 : 0;\n        }\n        key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;\n        return instance.getAttribute(key);\n    }\n    scrapeMotionValuesFromProps(props, prevProps, visualElement) {\n        return scrapeMotionValuesFromProps(props, prevProps, visualElement);\n    }\n    build(renderState, latestValues, props) {\n        buildSVGAttrs(renderState, latestValues, this.isSVGTag, props.transformTemplate);\n    }\n    renderInstance(instance, renderState, styleProp, projection) {\n        renderSVG(instance, renderState, styleProp, projection);\n    }\n    mount(instance) {\n        this.isSVGTag = isSVGTag(instance.tagName);\n        super.mount(instance);\n    }\n}\nfunction getComputedStyle$1(element) {\n    return window.getComputedStyle(element);\n}\nclass HTMLVisualElement extends DOMVisualElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"html\";\n        this.renderInstance = renderHTML;\n    }\n    readValueFromInstance(instance, key) {\n        if (transformProps.has(key)) {\n            const defaultType = getDefaultValueType(key);\n            return defaultType ? defaultType.default || 0 : 0;\n        } else {\n            const computedStyle = getComputedStyle$1(instance);\n            const value = (isCSSVariableName(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;\n            return typeof value === \"string\" ? value.trim() : value;\n        }\n    }\n    measureInstanceViewportBox(instance, { transformPagePoint }) {\n        return measureViewportBox(instance, transformPagePoint);\n    }\n    build(renderState, latestValues, props) {\n        buildHTMLStyles(renderState, latestValues, props.transformTemplate);\n    }\n    scrapeMotionValuesFromProps(props, prevProps, visualElement) {\n        return scrapeMotionValuesFromProps$1(props, prevProps, visualElement);\n    }\n}\nfunction isObjectKey(key, object) {\n    return key in object;\n}\nclass ObjectVisualElement extends VisualElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"object\";\n    }\n    readValueFromInstance(instance, key) {\n        if (isObjectKey(key, instance)) {\n            const value = instance[key];\n            if (typeof value === \"string\" || typeof value === \"number\") {\n                return value;\n            }\n        }\n        return undefined;\n    }\n    getBaseTargetFromProps() {\n        return undefined;\n    }\n    removeValueFromRenderState(key, renderState) {\n        delete renderState.output[key];\n    }\n    measureInstanceViewportBox() {\n        return createBox();\n    }\n    build(renderState, latestValues) {\n        Object.assign(renderState.output, latestValues);\n    }\n    renderInstance(instance, { output }) {\n        Object.assign(instance, output);\n    }\n    sortInstanceNodePosition() {\n        return 0;\n    }\n}\nfunction createDOMVisualElement(element) {\n    const options = {\n        presenceContext: null,\n        props: {},\n        visualState: {\n            renderState: {\n                transform: {},\n                transformOrigin: {},\n                style: {},\n                vars: {},\n                attrs: {}\n            },\n            latestValues: {}\n        }\n    };\n    const node = isSVGElement(element) ? new SVGVisualElement(options) : new HTMLVisualElement(options);\n    node.mount(element);\n    visualElementStore.set(element, node);\n}\nfunction createObjectVisualElement(subject) {\n    const options = {\n        presenceContext: null,\n        props: {},\n        visualState: {\n            renderState: {\n                output: {}\n            },\n            latestValues: {}\n        }\n    };\n    const node = new ObjectVisualElement(options);\n    node.mount(subject);\n    visualElementStore.set(subject, node);\n}\nfunction animateSingleValue(value, keyframes, options) {\n    const motionValue$1 = isMotionValue(value) ? value : motionValue(value);\n    motionValue$1.start(animateMotionValue(\"\", motionValue$1, keyframes, options));\n    return motionValue$1.animation;\n}\nfunction isSingleValue(subject, keyframes) {\n    return isMotionValue(subject) || typeof subject === \"number\" || typeof subject === \"string\" && !isDOMKeyframes(keyframes);\n}\n/**\n * Implementation\n */ function animateSubject(subject, keyframes, options, scope) {\n    const animations = [];\n    if (isSingleValue(subject, keyframes)) {\n        animations.push(animateSingleValue(subject, isDOMKeyframes(keyframes) ? keyframes.default || keyframes : keyframes, options ? options.default || options : options));\n    } else {\n        const subjects = resolveSubjects(subject, keyframes, scope);\n        const numSubjects = subjects.length;\n        motionUtils.invariant(Boolean(numSubjects), \"No valid elements provided.\");\n        for(let i = 0; i < numSubjects; i++){\n            const thisSubject = subjects[i];\n            const createVisualElement = thisSubject instanceof Element ? createDOMVisualElement : createObjectVisualElement;\n            if (!visualElementStore.has(thisSubject)) {\n                createVisualElement(thisSubject);\n            }\n            const visualElement = visualElementStore.get(thisSubject);\n            const transition = {\n                ...options\n            };\n            /**\n             * Resolve stagger function if provided.\n             */ if (\"delay\" in transition && typeof transition.delay === \"function\") {\n                transition.delay = transition.delay(i, numSubjects);\n            }\n            animations.push(...animateTarget(visualElement, {\n                ...keyframes,\n                transition\n            }, {}));\n        }\n    }\n    return animations;\n}\nfunction animateSequence(sequence, options, scope) {\n    const animations = [];\n    const animationDefinitions = createAnimationsFromSequence(sequence, options, scope, {\n        spring\n    });\n    animationDefinitions.forEach(({ keyframes, transition }, subject)=>{\n        animations.push(...animateSubject(subject, keyframes, transition));\n    });\n    return animations;\n}\nfunction isSequence(value) {\n    return Array.isArray(value) && Array.isArray(value[0]);\n}\n/**\n * Creates an animation function that is optionally scoped\n * to a specific element.\n */ function createScopedAnimate(scope) {\n    /**\n     * Implementation\n     */ function scopedAnimate(subjectOrSequence, optionsOrKeyframes, options) {\n        let animations = [];\n        if (isSequence(subjectOrSequence)) {\n            animations = animateSequence(subjectOrSequence, optionsOrKeyframes, scope);\n        } else {\n            animations = animateSubject(subjectOrSequence, optionsOrKeyframes, options, scope);\n        }\n        const animation = new GroupPlaybackControls(animations);\n        if (scope) {\n            scope.animations.push(animation);\n        }\n        return animation;\n    }\n    return scopedAnimate;\n}\nconst animate = createScopedAnimate();\nfunction setCSSVar(element, name, value) {\n    element.style.setProperty(`--${name}`, value);\n}\nfunction setStyle(element, name, value) {\n    element.style[name] = value;\n}\nconst supportsPartialKeyframes = /*@__PURE__*/ memo(()=>{\n    try {\n        document.createElement(\"div\").animate({\n            opacity: [\n                1\n            ]\n        });\n    } catch (e) {\n        return false;\n    }\n    return true;\n});\nconst state = new WeakMap();\nfunction hydrateKeyframes(valueName, keyframes, read) {\n    for(let i = 0; i < keyframes.length; i++){\n        if (keyframes[i] === null) {\n            keyframes[i] = i === 0 ? read() : keyframes[i - 1];\n        }\n        if (typeof keyframes[i] === \"number\" && browserNumberValueTypes[valueName]) {\n            keyframes[i] = browserNumberValueTypes[valueName].transform(keyframes[i]);\n        }\n    }\n    if (!supportsPartialKeyframes() && keyframes.length < 2) {\n        keyframes.unshift(read());\n    }\n}\nconst defaultEasing = \"easeOut\";\nfunction getElementAnimationState(element) {\n    const animationState = state.get(element) || new Map();\n    state.set(element, animationState);\n    return state.get(element);\n}\nclass NativeAnimation {\n    constructor(element, valueName, valueKeyframes, options){\n        const isCSSVar = valueName.startsWith(\"--\");\n        this.setValue = isCSSVar ? setCSSVar : setStyle;\n        this.options = options;\n        this.updateFinishedPromise();\n        motionUtils.invariant(typeof options.type !== \"string\", `animateMini doesn't support \"type\" as a string. Did you mean to import { spring } from \"framer-motion\"?`);\n        const existingAnimation = getElementAnimationState(element).get(valueName);\n        existingAnimation && existingAnimation.stop();\n        const readInitialKeyframe = ()=>{\n            return valueName.startsWith(\"--\") ? element.style.getPropertyValue(valueName) : window.getComputedStyle(element)[valueName];\n        };\n        if (!Array.isArray(valueKeyframes)) {\n            valueKeyframes = [\n                valueKeyframes\n            ];\n        }\n        hydrateKeyframes(valueName, valueKeyframes, readInitialKeyframe);\n        // TODO: Replace this with toString()?\n        if (isGenerator(options.type)) {\n            const generatorOptions = createGeneratorEasing(options, 100, options.type);\n            options.ease = supportsLinearEasing() ? generatorOptions.ease : defaultEasing;\n            options.duration = secondsToMilliseconds(generatorOptions.duration);\n            options.type = \"keyframes\";\n        } else {\n            options.ease = options.ease || defaultEasing;\n        }\n        this.removeAnimation = ()=>{\n            var _a;\n            return (_a = state.get(element)) === null || _a === void 0 ? void 0 : _a.delete(valueName);\n        };\n        const onFinish = ()=>{\n            this.setValue(element, valueName, getFinalKeyframe(valueKeyframes, this.options));\n            this.cancel();\n            this.resolveFinishedPromise();\n        };\n        if (!supportsWaapi()) {\n            onFinish();\n        } else {\n            this.animation = startWaapiAnimation(element, valueName, valueKeyframes, options);\n            if (options.autoplay === false) {\n                this.animation.pause();\n            }\n            this.animation.onfinish = onFinish;\n            if (this.pendingTimeline) {\n                attachTimeline(this.animation, this.pendingTimeline);\n            }\n            getElementAnimationState(element).set(valueName, this);\n        }\n    }\n    get duration() {\n        return millisecondsToSeconds(this.options.duration || 300);\n    }\n    get time() {\n        var _a;\n        if (this.animation) {\n            return millisecondsToSeconds(((_a = this.animation) === null || _a === void 0 ? void 0 : _a.currentTime) || 0);\n        }\n        return 0;\n    }\n    set time(newTime) {\n        if (this.animation) {\n            this.animation.currentTime = secondsToMilliseconds(newTime);\n        }\n    }\n    get speed() {\n        return this.animation ? this.animation.playbackRate : 1;\n    }\n    set speed(newSpeed) {\n        if (this.animation) {\n            this.animation.playbackRate = newSpeed;\n        }\n    }\n    get state() {\n        return this.animation ? this.animation.playState : \"finished\";\n    }\n    get startTime() {\n        return this.animation ? this.animation.startTime : null;\n    }\n    flatten() {\n        var _a;\n        if (!this.animation) return;\n        (_a = this.animation.effect) === null || _a === void 0 ? void 0 : _a.updateTiming({\n            easing: \"linear\"\n        });\n    }\n    play() {\n        if (this.state === \"finished\") {\n            this.updateFinishedPromise();\n        }\n        this.animation && this.animation.play();\n    }\n    pause() {\n        this.animation && this.animation.pause();\n    }\n    stop() {\n        if (!this.animation || this.state === \"idle\" || this.state === \"finished\") {\n            return;\n        }\n        if (this.animation.commitStyles) {\n            this.animation.commitStyles();\n        }\n        this.cancel();\n    }\n    complete() {\n        this.animation && this.animation.finish();\n    }\n    cancel() {\n        this.removeAnimation();\n        try {\n            this.animation && this.animation.cancel();\n        } catch (e) {}\n    }\n    /**\n     * Allows the returned animation to be awaited or promise-chained. Currently\n     * resolves when the animation finishes at all but in a future update could/should\n     * reject if its cancels.\n     */ then(resolve, reject) {\n        return this.currentFinishedPromise.then(resolve, reject);\n    }\n    updateFinishedPromise() {\n        this.currentFinishedPromise = new Promise((resolve)=>{\n            this.resolveFinishedPromise = resolve;\n        });\n    }\n    attachTimeline(timeline) {\n        if (!this.animation) {\n            this.pendingTimeline = timeline;\n        } else {\n            attachTimeline(this.animation, timeline);\n        }\n        return motionUtils.noop;\n    }\n}\nfunction animateElements(elementOrSelector, keyframes, options, scope) {\n    const elements = motionDom.resolveElements(elementOrSelector, scope);\n    const numElements = elements.length;\n    motionUtils.invariant(Boolean(numElements), \"No valid element provided.\");\n    const animations = [];\n    for(let i = 0; i < numElements; i++){\n        const element = elements[i];\n        const elementTransition = {\n            ...options\n        };\n        /**\n         * Resolve stagger function if provided.\n         */ if (typeof elementTransition.delay === \"function\") {\n            elementTransition.delay = elementTransition.delay(i, numElements);\n        }\n        for(const valueName in keyframes){\n            const valueKeyframes = keyframes[valueName];\n            const valueOptions = {\n                ...getValueTransition$1(elementTransition, valueName)\n            };\n            valueOptions.duration = valueOptions.duration ? secondsToMilliseconds(valueOptions.duration) : valueOptions.duration;\n            valueOptions.delay = secondsToMilliseconds(valueOptions.delay || 0);\n            animations.push(new NativeAnimation(element, valueName, valueKeyframes, valueOptions));\n        }\n    }\n    return animations;\n}\nconst createScopedWaapiAnimate = (scope)=>{\n    function scopedAnimate(elementOrSelector, keyframes, options) {\n        return new GroupPlaybackControls(animateElements(elementOrSelector, keyframes, options, scope));\n    }\n    return scopedAnimate;\n};\nconst animateMini = /*@__PURE__*/ createScopedWaapiAnimate();\nconst resizeHandlers = new WeakMap();\nlet observer;\nfunction getElementSize(target, borderBoxSize) {\n    if (borderBoxSize) {\n        const { inlineSize, blockSize } = borderBoxSize[0];\n        return {\n            width: inlineSize,\n            height: blockSize\n        };\n    } else if (target instanceof SVGElement && \"getBBox\" in target) {\n        return target.getBBox();\n    } else {\n        return {\n            width: target.offsetWidth,\n            height: target.offsetHeight\n        };\n    }\n}\nfunction notifyTarget({ target, contentRect, borderBoxSize }) {\n    var _a;\n    (_a = resizeHandlers.get(target)) === null || _a === void 0 ? void 0 : _a.forEach((handler)=>{\n        handler({\n            target,\n            contentSize: contentRect,\n            get size () {\n                return getElementSize(target, borderBoxSize);\n            }\n        });\n    });\n}\nfunction notifyAll(entries) {\n    entries.forEach(notifyTarget);\n}\nfunction createResizeObserver() {\n    if (typeof ResizeObserver === \"undefined\") return;\n    observer = new ResizeObserver(notifyAll);\n}\nfunction resizeElement(target, handler) {\n    if (!observer) createResizeObserver();\n    const elements = motionDom.resolveElements(target);\n    elements.forEach((element)=>{\n        let elementHandlers = resizeHandlers.get(element);\n        if (!elementHandlers) {\n            elementHandlers = new Set();\n            resizeHandlers.set(element, elementHandlers);\n        }\n        elementHandlers.add(handler);\n        observer === null || observer === void 0 ? void 0 : observer.observe(element);\n    });\n    return ()=>{\n        elements.forEach((element)=>{\n            const elementHandlers = resizeHandlers.get(element);\n            elementHandlers === null || elementHandlers === void 0 ? void 0 : elementHandlers.delete(handler);\n            if (!(elementHandlers === null || elementHandlers === void 0 ? void 0 : elementHandlers.size)) {\n                observer === null || observer === void 0 ? void 0 : observer.unobserve(element);\n            }\n        });\n    };\n}\nconst windowCallbacks = new Set();\nlet windowResizeHandler;\nfunction createWindowResizeHandler() {\n    windowResizeHandler = ()=>{\n        const size = {\n            width: window.innerWidth,\n            height: window.innerHeight\n        };\n        const info = {\n            target: window,\n            size,\n            contentSize: size\n        };\n        windowCallbacks.forEach((callback)=>callback(info));\n    };\n    window.addEventListener(\"resize\", windowResizeHandler);\n}\nfunction resizeWindow(callback) {\n    windowCallbacks.add(callback);\n    if (!windowResizeHandler) createWindowResizeHandler();\n    return ()=>{\n        windowCallbacks.delete(callback);\n        if (!windowCallbacks.size && windowResizeHandler) {\n            windowResizeHandler = undefined;\n        }\n    };\n}\nfunction resize(a, b) {\n    return typeof a === \"function\" ? resizeWindow(a) : resizeElement(a, b);\n}\n/**\n * A time in milliseconds, beyond which we consider the scroll velocity to be 0.\n */ const maxElapsed = 50;\nconst createAxisInfo = ()=>({\n        current: 0,\n        offset: [],\n        progress: 0,\n        scrollLength: 0,\n        targetOffset: 0,\n        targetLength: 0,\n        containerLength: 0,\n        velocity: 0\n    });\nconst createScrollInfo = ()=>({\n        time: 0,\n        x: createAxisInfo(),\n        y: createAxisInfo()\n    });\nconst keys = {\n    x: {\n        length: \"Width\",\n        position: \"Left\"\n    },\n    y: {\n        length: \"Height\",\n        position: \"Top\"\n    }\n};\nfunction updateAxisInfo(element, axisName, info, time) {\n    const axis = info[axisName];\n    const { length, position } = keys[axisName];\n    const prev = axis.current;\n    const prevTime = info.time;\n    axis.current = element[`scroll${position}`];\n    axis.scrollLength = element[`scroll${length}`] - element[`client${length}`];\n    axis.offset.length = 0;\n    axis.offset[0] = 0;\n    axis.offset[1] = axis.scrollLength;\n    axis.progress = progress(0, axis.scrollLength, axis.current);\n    const elapsed = time - prevTime;\n    axis.velocity = elapsed > maxElapsed ? 0 : velocityPerSecond(axis.current - prev, elapsed);\n}\nfunction updateScrollInfo(element, info, time) {\n    updateAxisInfo(element, \"x\", info, time);\n    updateAxisInfo(element, \"y\", info, time);\n    info.time = time;\n}\nfunction calcInset(element, container) {\n    const inset = {\n        x: 0,\n        y: 0\n    };\n    let current = element;\n    while(current && current !== container){\n        if (current instanceof HTMLElement) {\n            inset.x += current.offsetLeft;\n            inset.y += current.offsetTop;\n            current = current.offsetParent;\n        } else if (current.tagName === \"svg\") {\n            /**\n             * This isn't an ideal approach to measuring the offset of <svg /> tags.\n             * It would be preferable, given they behave like HTMLElements in most ways\n             * to use offsetLeft/Top. But these don't exist on <svg />. Likewise we\n             * can't use .getBBox() like most SVG elements as these provide the offset\n             * relative to the SVG itself, which for <svg /> is usually 0x0.\n             */ const svgBoundingBox = current.getBoundingClientRect();\n            current = current.parentElement;\n            const parentBoundingBox = current.getBoundingClientRect();\n            inset.x += svgBoundingBox.left - parentBoundingBox.left;\n            inset.y += svgBoundingBox.top - parentBoundingBox.top;\n        } else if (current instanceof SVGGraphicsElement) {\n            const { x, y } = current.getBBox();\n            inset.x += x;\n            inset.y += y;\n            let svg = null;\n            let parent = current.parentNode;\n            while(!svg){\n                if (parent.tagName === \"svg\") {\n                    svg = parent;\n                }\n                parent = current.parentNode;\n            }\n            current = svg;\n        } else {\n            break;\n        }\n    }\n    return inset;\n}\nconst ScrollOffset = {\n    Enter: [\n        [\n            0,\n            1\n        ],\n        [\n            1,\n            1\n        ]\n    ],\n    Exit: [\n        [\n            0,\n            0\n        ],\n        [\n            1,\n            0\n        ]\n    ],\n    Any: [\n        [\n            1,\n            0\n        ],\n        [\n            0,\n            1\n        ]\n    ],\n    All: [\n        [\n            0,\n            0\n        ],\n        [\n            1,\n            1\n        ]\n    ]\n};\nconst namedEdges = {\n    start: 0,\n    center: 0.5,\n    end: 1\n};\nfunction resolveEdge(edge, length, inset = 0) {\n    let delta = 0;\n    /**\n     * If we have this edge defined as a preset, replace the definition\n     * with the numerical value.\n     */ if (edge in namedEdges) {\n        edge = namedEdges[edge];\n    }\n    /**\n     * Handle unit values\n     */ if (typeof edge === \"string\") {\n        const asNumber = parseFloat(edge);\n        if (edge.endsWith(\"px\")) {\n            delta = asNumber;\n        } else if (edge.endsWith(\"%\")) {\n            edge = asNumber / 100;\n        } else if (edge.endsWith(\"vw\")) {\n            delta = asNumber / 100 * document.documentElement.clientWidth;\n        } else if (edge.endsWith(\"vh\")) {\n            delta = asNumber / 100 * document.documentElement.clientHeight;\n        } else {\n            edge = asNumber;\n        }\n    }\n    /**\n     * If the edge is defined as a number, handle as a progress value.\n     */ if (typeof edge === \"number\") {\n        delta = length * edge;\n    }\n    return inset + delta;\n}\nconst defaultOffset = [\n    0,\n    0\n];\nfunction resolveOffset(offset, containerLength, targetLength, targetInset) {\n    let offsetDefinition = Array.isArray(offset) ? offset : defaultOffset;\n    let targetPoint = 0;\n    let containerPoint = 0;\n    if (typeof offset === \"number\") {\n        /**\n         * If we're provided offset: [0, 0.5, 1] then each number x should become\n         * [x, x], so we default to the behaviour of mapping 0 => 0 of both target\n         * and container etc.\n         */ offsetDefinition = [\n            offset,\n            offset\n        ];\n    } else if (typeof offset === \"string\") {\n        offset = offset.trim();\n        if (offset.includes(\" \")) {\n            offsetDefinition = offset.split(\" \");\n        } else {\n            /**\n             * If we're provided a definition like \"100px\" then we want to apply\n             * that only to the top of the target point, leaving the container at 0.\n             * Whereas a named offset like \"end\" should be applied to both.\n             */ offsetDefinition = [\n                offset,\n                namedEdges[offset] ? offset : `0`\n            ];\n        }\n    }\n    targetPoint = resolveEdge(offsetDefinition[0], targetLength, targetInset);\n    containerPoint = resolveEdge(offsetDefinition[1], containerLength);\n    return targetPoint - containerPoint;\n}\nconst point = {\n    x: 0,\n    y: 0\n};\nfunction getTargetSize(target) {\n    return \"getBBox\" in target && target.tagName !== \"svg\" ? target.getBBox() : {\n        width: target.clientWidth,\n        height: target.clientHeight\n    };\n}\nfunction resolveOffsets(container, info, options) {\n    const { offset: offsetDefinition = ScrollOffset.All } = options;\n    const { target = container, axis = \"y\" } = options;\n    const lengthLabel = axis === \"y\" ? \"height\" : \"width\";\n    const inset = target !== container ? calcInset(target, container) : point;\n    /**\n     * Measure the target and container. If they're the same thing then we\n     * use the container's scrollWidth/Height as the target, from there\n     * all other calculations can remain the same.\n     */ const targetSize = target === container ? {\n        width: container.scrollWidth,\n        height: container.scrollHeight\n    } : getTargetSize(target);\n    const containerSize = {\n        width: container.clientWidth,\n        height: container.clientHeight\n    };\n    /**\n     * Reset the length of the resolved offset array rather than creating a new one.\n     * TODO: More reusable data structures for targetSize/containerSize would also be good.\n     */ info[axis].offset.length = 0;\n    /**\n     * Populate the offset array by resolving the user's offset definition into\n     * a list of pixel scroll offets.\n     */ let hasChanged = !info[axis].interpolate;\n    const numOffsets = offsetDefinition.length;\n    for(let i = 0; i < numOffsets; i++){\n        const offset = resolveOffset(offsetDefinition[i], containerSize[lengthLabel], targetSize[lengthLabel], inset[axis]);\n        if (!hasChanged && offset !== info[axis].interpolatorOffsets[i]) {\n            hasChanged = true;\n        }\n        info[axis].offset[i] = offset;\n    }\n    /**\n     * If the pixel scroll offsets have changed, create a new interpolator function\n     * to map scroll value into a progress.\n     */ if (hasChanged) {\n        info[axis].interpolate = interpolate(info[axis].offset, defaultOffset$1(offsetDefinition));\n        info[axis].interpolatorOffsets = [\n            ...info[axis].offset\n        ];\n    }\n    info[axis].progress = info[axis].interpolate(info[axis].current);\n}\nfunction measure(container, target = container, info) {\n    /**\n     * Find inset of target within scrollable container\n     */ info.x.targetOffset = 0;\n    info.y.targetOffset = 0;\n    if (target !== container) {\n        let node = target;\n        while(node && node !== container){\n            info.x.targetOffset += node.offsetLeft;\n            info.y.targetOffset += node.offsetTop;\n            node = node.offsetParent;\n        }\n    }\n    info.x.targetLength = target === container ? target.scrollWidth : target.clientWidth;\n    info.y.targetLength = target === container ? target.scrollHeight : target.clientHeight;\n    info.x.containerLength = container.clientWidth;\n    info.y.containerLength = container.clientHeight;\n    /**\n     * In development mode ensure scroll containers aren't position: static as this makes\n     * it difficult to measure their relative positions.\n     */ if (true) {\n        if (container && target && target !== container) {\n            warnOnce(getComputedStyle(container).position !== \"static\", \"Please ensure that the container has a non-static position, like 'relative', 'fixed', or 'absolute' to ensure scroll offset is calculated correctly.\");\n        }\n    }\n}\nfunction createOnScrollHandler(element, onScroll, info, options = {}) {\n    return {\n        measure: ()=>measure(element, options.target, info),\n        update: (time)=>{\n            updateScrollInfo(element, info, time);\n            if (options.offset || options.target) {\n                resolveOffsets(element, info, options);\n            }\n        },\n        notify: ()=>onScroll(info)\n    };\n}\nconst scrollListeners = new WeakMap();\nconst resizeListeners = new WeakMap();\nconst onScrollHandlers = new WeakMap();\nconst getEventTarget = (element)=>element === document.documentElement ? window : element;\nfunction scrollInfo(onScroll, { container = document.documentElement, ...options } = {}) {\n    let containerHandlers = onScrollHandlers.get(container);\n    /**\n     * Get the onScroll handlers for this container.\n     * If one isn't found, create a new one.\n     */ if (!containerHandlers) {\n        containerHandlers = new Set();\n        onScrollHandlers.set(container, containerHandlers);\n    }\n    /**\n     * Create a new onScroll handler for the provided callback.\n     */ const info = createScrollInfo();\n    const containerHandler = createOnScrollHandler(container, onScroll, info, options);\n    containerHandlers.add(containerHandler);\n    /**\n     * Check if there's a scroll event listener for this container.\n     * If not, create one.\n     */ if (!scrollListeners.has(container)) {\n        const measureAll = ()=>{\n            for (const handler of containerHandlers)handler.measure();\n        };\n        const updateAll = ()=>{\n            for (const handler of containerHandlers){\n                handler.update(frameData.timestamp);\n            }\n        };\n        const notifyAll = ()=>{\n            for (const handler of containerHandlers)handler.notify();\n        };\n        const listener = ()=>{\n            frame.read(measureAll, false, true);\n            frame.read(updateAll, false, true);\n            frame.update(notifyAll, false, true);\n        };\n        scrollListeners.set(container, listener);\n        const target = getEventTarget(container);\n        window.addEventListener(\"resize\", listener, {\n            passive: true\n        });\n        if (container !== document.documentElement) {\n            resizeListeners.set(container, resize(container, listener));\n        }\n        target.addEventListener(\"scroll\", listener, {\n            passive: true\n        });\n    }\n    const listener = scrollListeners.get(container);\n    frame.read(listener, false, true);\n    return ()=>{\n        var _a;\n        cancelFrame(listener);\n        /**\n         * Check if we even have any handlers for this container.\n         */ const currentHandlers = onScrollHandlers.get(container);\n        if (!currentHandlers) return;\n        currentHandlers.delete(containerHandler);\n        if (currentHandlers.size) return;\n        /**\n         * If no more handlers, remove the scroll listener too.\n         */ const scrollListener = scrollListeners.get(container);\n        scrollListeners.delete(container);\n        if (scrollListener) {\n            getEventTarget(container).removeEventListener(\"scroll\", scrollListener);\n            (_a = resizeListeners.get(container)) === null || _a === void 0 ? void 0 : _a();\n            window.removeEventListener(\"resize\", scrollListener);\n        }\n    };\n}\nfunction observeTimeline(update, timeline) {\n    let prevProgress;\n    const onFrame = ()=>{\n        const { currentTime } = timeline;\n        const percentage = currentTime === null ? 0 : currentTime.value;\n        const progress = percentage / 100;\n        if (prevProgress !== progress) {\n            update(progress);\n        }\n        prevProgress = progress;\n    };\n    frame.update(onFrame, true);\n    return ()=>cancelFrame(onFrame);\n}\nfunction scrollTimelineFallback({ source, container, axis = \"y\" }) {\n    // Support legacy source argument. Deprecate later.\n    if (source) container = source;\n    // ScrollTimeline records progress as a percentage CSSUnitValue\n    const currentTime = {\n        value: 0\n    };\n    const cancel = scrollInfo((info)=>{\n        currentTime.value = info[axis].progress * 100;\n    }, {\n        container,\n        axis\n    });\n    return {\n        currentTime,\n        cancel\n    };\n}\nconst timelineCache = new Map();\nfunction getTimeline({ source, container = document.documentElement, axis = \"y\" } = {}) {\n    // Support legacy source argument. Deprecate later.\n    if (source) container = source;\n    if (!timelineCache.has(container)) {\n        timelineCache.set(container, {});\n    }\n    const elementCache = timelineCache.get(container);\n    if (!elementCache[axis]) {\n        elementCache[axis] = supportsScrollTimeline() ? new ScrollTimeline({\n            source: container,\n            axis\n        }) : scrollTimelineFallback({\n            source: container,\n            axis\n        });\n    }\n    return elementCache[axis];\n}\n/**\n * If the onScroll function has two arguments, it's expecting\n * more specific information about the scroll from scrollInfo.\n */ function isOnScrollWithInfo(onScroll) {\n    return onScroll.length === 2;\n}\n/**\n * Currently, we only support element tracking with `scrollInfo`, though in\n * the future we can also offer ViewTimeline support.\n */ function needsElementTracking(options) {\n    return options && (options.target || options.offset);\n}\nfunction scrollFunction(onScroll, options) {\n    if (isOnScrollWithInfo(onScroll) || needsElementTracking(options)) {\n        return scrollInfo((info)=>{\n            onScroll(info[options.axis].progress, info);\n        }, options);\n    } else {\n        return observeTimeline(onScroll, getTimeline(options));\n    }\n}\nfunction scrollAnimation(animation, options) {\n    animation.flatten();\n    if (needsElementTracking(options)) {\n        animation.pause();\n        return scrollInfo((info)=>{\n            animation.time = animation.duration * info[options.axis].progress;\n        }, options);\n    } else {\n        const timeline = getTimeline(options);\n        if (animation.attachTimeline) {\n            return animation.attachTimeline(timeline, (valueAnimation)=>{\n                valueAnimation.pause();\n                return observeTimeline((progress)=>{\n                    valueAnimation.time = valueAnimation.duration * progress;\n                }, timeline);\n            });\n        } else {\n            return motionUtils.noop;\n        }\n    }\n}\nfunction scroll(onScroll, { axis = \"y\", ...options } = {}) {\n    const optionsWithDefaults = {\n        axis,\n        ...options\n    };\n    return typeof onScroll === \"function\" ? scrollFunction(onScroll, optionsWithDefaults) : scrollAnimation(onScroll, optionsWithDefaults);\n}\nconst thresholds = {\n    some: 0,\n    all: 1\n};\nfunction inView(elementOrSelector, onStart, { root, margin: rootMargin, amount = \"some\" } = {}) {\n    const elements = motionDom.resolveElements(elementOrSelector);\n    const activeIntersections = new WeakMap();\n    const onIntersectionChange = (entries)=>{\n        entries.forEach((entry)=>{\n            const onEnd = activeIntersections.get(entry.target);\n            /**\n             * If there's no change to the intersection, we don't need to\n             * do anything here.\n             */ if (entry.isIntersecting === Boolean(onEnd)) return;\n            if (entry.isIntersecting) {\n                const newOnEnd = onStart(entry);\n                if (typeof newOnEnd === \"function\") {\n                    activeIntersections.set(entry.target, newOnEnd);\n                } else {\n                    observer.unobserve(entry.target);\n                }\n            } else if (onEnd) {\n                onEnd(entry);\n                activeIntersections.delete(entry.target);\n            }\n        });\n    };\n    const observer = new IntersectionObserver(onIntersectionChange, {\n        root,\n        rootMargin,\n        threshold: typeof amount === \"number\" ? amount : thresholds[amount]\n    });\n    elements.forEach((element)=>observer.observe(element));\n    return ()=>observer.disconnect();\n}\nfunction steps(numSteps, direction = \"end\") {\n    return (progress)=>{\n        progress = direction === \"end\" ? Math.min(progress, 0.999) : Math.max(progress, 0.001);\n        const expanded = progress * numSteps;\n        const rounded = direction === \"end\" ? Math.floor(expanded) : Math.ceil(expanded);\n        return clamp(0, 1, rounded / numSteps);\n    };\n}\nfunction getOriginIndex(from, total) {\n    if (from === \"first\") {\n        return 0;\n    } else {\n        const lastIndex = total - 1;\n        return from === \"last\" ? lastIndex : lastIndex / 2;\n    }\n}\nfunction stagger(duration = 0.1, { startDelay = 0, from = 0, ease } = {}) {\n    return (i, total)=>{\n        const fromIndex = typeof from === \"number\" ? from : getOriginIndex(from, total);\n        const distance = Math.abs(fromIndex - i);\n        let delay = duration * distance;\n        if (ease) {\n            const maxDelay = total * duration;\n            const easingFunction = easingDefinitionToFunction(ease);\n            delay = easingFunction(delay / maxDelay) * maxDelay;\n        }\n        return startDelay + delay;\n    };\n}\nconst isCustomValueType = (v)=>{\n    return v && typeof v === \"object\" && v.mix;\n};\nconst getMixer = (v)=>isCustomValueType(v) ? v.mix : undefined;\nfunction transform(...args) {\n    const useImmediate = !Array.isArray(args[0]);\n    const argOffset = useImmediate ? 0 : -1;\n    const inputValue = args[0 + argOffset];\n    const inputRange = args[1 + argOffset];\n    const outputRange = args[2 + argOffset];\n    const options = args[3 + argOffset];\n    const interpolator = interpolate(inputRange, outputRange, {\n        mixer: getMixer(outputRange[0]),\n        ...options\n    });\n    return useImmediate ? interpolator(inputValue) : interpolator;\n}\n/**\n * @deprecated\n *\n * Import as `frame` instead.\n */ const sync = frame;\n/**\n * @deprecated\n *\n * Use cancelFrame(callback) instead.\n */ const cancelSync = stepsOrder.reduce((acc, key)=>{\n    acc[key] = (process)=>cancelFrame(process);\n    return acc;\n}, {});\nconst { schedule: microtask, cancel: cancelMicrotask } = createRenderBatcher(queueMicrotask, false);\nconst metrics = {\n    type: \"projectionFrame\",\n    totalNodes: 0,\n    resolvedTargetDeltas: 0,\n    recalculatedProjection: 0\n};\nconst isDebug =  false && 0;\nconst transformAxes = [\n    \"\",\n    \"X\",\n    \"Y\",\n    \"Z\"\n];\nconst hiddenVisibility = {\n    visibility: \"hidden\"\n};\n/**\n * We use 1000 as the animation target as 0-1000 maps better to pixels than 0-1\n * which has a noticeable difference in spring animations\n */ const animationTarget = 1000;\nlet id$1 = 0;\nfunction resetDistortingTransform(key, visualElement, values, sharedAnimationValues) {\n    const { latestValues } = visualElement;\n    // Record the distorting transform and then temporarily set it to 0\n    if (latestValues[key]) {\n        values[key] = latestValues[key];\n        visualElement.setStaticValue(key, 0);\n        if (sharedAnimationValues) {\n            sharedAnimationValues[key] = 0;\n        }\n    }\n}\nfunction cancelTreeOptimisedTransformAnimations(projectionNode) {\n    projectionNode.hasCheckedOptimisedAppear = true;\n    if (projectionNode.root === projectionNode) return;\n    const { visualElement } = projectionNode.options;\n    if (!visualElement) return;\n    const appearId = getOptimisedAppearId(visualElement);\n    if (window.MotionHasOptimisedAnimation(appearId, \"transform\")) {\n        const { layout, layoutId } = projectionNode.options;\n        window.MotionCancelOptimisedAnimation(appearId, \"transform\", frame, !(layout || layoutId));\n    }\n    const { parent } = projectionNode;\n    if (parent && !parent.hasCheckedOptimisedAppear) {\n        cancelTreeOptimisedTransformAnimations(parent);\n    }\n}\nfunction createProjectionNode$1({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform }) {\n    return class ProjectionNode {\n        constructor(latestValues = {}, parent = defaultParent === null || defaultParent === void 0 ? void 0 : defaultParent()){\n            /**\n             * A unique ID generated for every projection node.\n             */ this.id = id$1++;\n            /**\n             * An id that represents a unique session instigated by startUpdate.\n             */ this.animationId = 0;\n            /**\n             * A Set containing all this component's children. This is used to iterate\n             * through the children.\n             *\n             * TODO: This could be faster to iterate as a flat array stored on the root node.\n             */ this.children = new Set();\n            /**\n             * Options for the node. We use this to configure what kind of layout animations\n             * we should perform (if any).\n             */ this.options = {};\n            /**\n             * We use this to detect when its safe to shut down part of a projection tree.\n             * We have to keep projecting children for scale correction and relative projection\n             * until all their parents stop performing layout animations.\n             */ this.isTreeAnimating = false;\n            this.isAnimationBlocked = false;\n            /**\n             * Flag to true if we think this layout has been changed. We can't always know this,\n             * currently we set it to true every time a component renders, or if it has a layoutDependency\n             * if that has changed between renders. Additionally, components can be grouped by LayoutGroup\n             * and if one node is dirtied, they all are.\n             */ this.isLayoutDirty = false;\n            /**\n             * Flag to true if we think the projection calculations for this node needs\n             * recalculating as a result of an updated transform or layout animation.\n             */ this.isProjectionDirty = false;\n            /**\n             * Flag to true if the layout *or* transform has changed. This then gets propagated\n             * throughout the projection tree, forcing any element below to recalculate on the next frame.\n             */ this.isSharedProjectionDirty = false;\n            /**\n             * Flag transform dirty. This gets propagated throughout the whole tree but is only\n             * respected by shared nodes.\n             */ this.isTransformDirty = false;\n            /**\n             * Block layout updates for instant layout transitions throughout the tree.\n             */ this.updateManuallyBlocked = false;\n            this.updateBlockedByResize = false;\n            /**\n             * Set to true between the start of the first `willUpdate` call and the end of the `didUpdate`\n             * call.\n             */ this.isUpdating = false;\n            /**\n             * If this is an SVG element we currently disable projection transforms\n             */ this.isSVG = false;\n            /**\n             * Flag to true (during promotion) if a node doing an instant layout transition needs to reset\n             * its projection styles.\n             */ this.needsReset = false;\n            /**\n             * Flags whether this node should have its transform reset prior to measuring.\n             */ this.shouldResetTransform = false;\n            /**\n             * Store whether this node has been checked for optimised appear animations. As\n             * effects fire bottom-up, and we want to look up the tree for appear animations,\n             * this makes sure we only check each path once, stopping at nodes that\n             * have already been checked.\n             */ this.hasCheckedOptimisedAppear = false;\n            /**\n             * An object representing the calculated contextual/accumulated/tree scale.\n             * This will be used to scale calculcated projection transforms, as these are\n             * calculated in screen-space but need to be scaled for elements to layoutly\n             * make it to their calculated destinations.\n             *\n             * TODO: Lazy-init\n             */ this.treeScale = {\n                x: 1,\n                y: 1\n            };\n            /**\n             *\n             */ this.eventHandlers = new Map();\n            this.hasTreeAnimated = false;\n            // Note: Currently only running on root node\n            this.updateScheduled = false;\n            this.scheduleUpdate = ()=>this.update();\n            this.projectionUpdateScheduled = false;\n            this.checkUpdateFailed = ()=>{\n                if (this.isUpdating) {\n                    this.isUpdating = false;\n                    this.clearAllSnapshots();\n                }\n            };\n            /**\n             * This is a multi-step process as shared nodes might be of different depths. Nodes\n             * are sorted by depth order, so we need to resolve the entire tree before moving to\n             * the next step.\n             */ this.updateProjection = ()=>{\n                this.projectionUpdateScheduled = false;\n                /**\n                 * Reset debug counts. Manually resetting rather than creating a new\n                 * object each frame.\n                 */ if (isDebug) {\n                    metrics.totalNodes = metrics.resolvedTargetDeltas = metrics.recalculatedProjection = 0;\n                }\n                this.nodes.forEach(propagateDirtyNodes);\n                this.nodes.forEach(resolveTargetDelta);\n                this.nodes.forEach(calcProjection);\n                this.nodes.forEach(cleanDirtyNodes);\n                if (isDebug) {\n                    window.MotionDebug.record(metrics);\n                }\n            };\n            /**\n             * Frame calculations\n             */ this.resolvedRelativeTargetAt = 0.0;\n            this.hasProjected = false;\n            this.isVisible = true;\n            this.animationProgress = 0;\n            /**\n             * Shared layout\n             */ // TODO Only running on root node\n            this.sharedNodes = new Map();\n            this.latestValues = latestValues;\n            this.root = parent ? parent.root || parent : this;\n            this.path = parent ? [\n                ...parent.path,\n                parent\n            ] : [];\n            this.parent = parent;\n            this.depth = parent ? parent.depth + 1 : 0;\n            for(let i = 0; i < this.path.length; i++){\n                this.path[i].shouldResetTransform = true;\n            }\n            if (this.root === this) this.nodes = new FlatTree();\n        }\n        addEventListener(name, handler) {\n            if (!this.eventHandlers.has(name)) {\n                this.eventHandlers.set(name, new SubscriptionManager());\n            }\n            return this.eventHandlers.get(name).add(handler);\n        }\n        notifyListeners(name, ...args) {\n            const subscriptionManager = this.eventHandlers.get(name);\n            subscriptionManager && subscriptionManager.notify(...args);\n        }\n        hasListeners(name) {\n            return this.eventHandlers.has(name);\n        }\n        /**\n         * Lifecycles\n         */ mount(instance, isLayoutDirty = this.root.hasTreeAnimated) {\n            if (this.instance) return;\n            this.isSVG = isSVGElement(instance);\n            this.instance = instance;\n            const { layoutId, layout, visualElement } = this.options;\n            if (visualElement && !visualElement.current) {\n                visualElement.mount(instance);\n            }\n            this.root.nodes.add(this);\n            this.parent && this.parent.children.add(this);\n            if (isLayoutDirty && (layout || layoutId)) {\n                this.isLayoutDirty = true;\n            }\n            if (attachResizeListener) {\n                let cancelDelay;\n                const resizeUnblockUpdate = ()=>this.root.updateBlockedByResize = false;\n                attachResizeListener(instance, ()=>{\n                    this.root.updateBlockedByResize = true;\n                    cancelDelay && cancelDelay();\n                    cancelDelay = delay(resizeUnblockUpdate, 250);\n                    if (globalProjectionState.hasAnimatedSinceResize) {\n                        globalProjectionState.hasAnimatedSinceResize = false;\n                        this.nodes.forEach(finishAnimation);\n                    }\n                });\n            }\n            if (layoutId) {\n                this.root.registerSharedNode(layoutId, this);\n            }\n            // Only register the handler if it requires layout animation\n            if (this.options.animate !== false && visualElement && (layoutId || layout)) {\n                this.addEventListener(\"didUpdate\", ({ delta, hasLayoutChanged, hasRelativeTargetChanged, layout: newLayout })=>{\n                    if (this.isTreeAnimationBlocked()) {\n                        this.target = undefined;\n                        this.relativeTarget = undefined;\n                        return;\n                    }\n                    // TODO: Check here if an animation exists\n                    const layoutTransition = this.options.transition || visualElement.getDefaultTransition() || defaultLayoutTransition;\n                    const { onLayoutAnimationStart, onLayoutAnimationComplete } = visualElement.getProps();\n                    /**\n                     * The target layout of the element might stay the same,\n                     * but its position relative to its parent has changed.\n                     */ const targetChanged = !this.targetLayout || !boxEqualsRounded(this.targetLayout, newLayout) || hasRelativeTargetChanged;\n                    /**\n                     * If the layout hasn't seemed to have changed, it might be that the\n                     * element is visually in the same place in the document but its position\n                     * relative to its parent has indeed changed. So here we check for that.\n                     */ const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeTargetChanged;\n                    if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || hasOnlyRelativeTargetChanged || hasLayoutChanged && (targetChanged || !this.currentAnimation)) {\n                        if (this.resumeFrom) {\n                            this.resumingFrom = this.resumeFrom;\n                            this.resumingFrom.resumingFrom = undefined;\n                        }\n                        this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);\n                        const animationOptions = {\n                            ...getValueTransition$1(layoutTransition, \"layout\"),\n                            onPlay: onLayoutAnimationStart,\n                            onComplete: onLayoutAnimationComplete\n                        };\n                        if (visualElement.shouldReduceMotion || this.options.layoutRoot) {\n                            animationOptions.delay = 0;\n                            animationOptions.type = false;\n                        }\n                        this.startAnimation(animationOptions);\n                    } else {\n                        /**\n                         * If the layout hasn't changed and we have an animation that hasn't started yet,\n                         * finish it immediately. Otherwise it will be animating from a location\n                         * that was probably never commited to screen and look like a jumpy box.\n                         */ if (!hasLayoutChanged) {\n                            finishAnimation(this);\n                        }\n                        if (this.isLead() && this.options.onExitComplete) {\n                            this.options.onExitComplete();\n                        }\n                    }\n                    this.targetLayout = newLayout;\n                });\n            }\n        }\n        unmount() {\n            this.options.layoutId && this.willUpdate();\n            this.root.nodes.remove(this);\n            const stack = this.getStack();\n            stack && stack.remove(this);\n            this.parent && this.parent.children.delete(this);\n            this.instance = undefined;\n            cancelFrame(this.updateProjection);\n        }\n        // only on the root\n        blockUpdate() {\n            this.updateManuallyBlocked = true;\n        }\n        unblockUpdate() {\n            this.updateManuallyBlocked = false;\n        }\n        isUpdateBlocked() {\n            return this.updateManuallyBlocked || this.updateBlockedByResize;\n        }\n        isTreeAnimationBlocked() {\n            return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || false;\n        }\n        // Note: currently only running on root node\n        startUpdate() {\n            if (this.isUpdateBlocked()) return;\n            this.isUpdating = true;\n            this.nodes && this.nodes.forEach(resetSkewAndRotation);\n            this.animationId++;\n        }\n        getTransformTemplate() {\n            const { visualElement } = this.options;\n            return visualElement && visualElement.getProps().transformTemplate;\n        }\n        willUpdate(shouldNotifyListeners = true) {\n            this.root.hasTreeAnimated = true;\n            if (this.root.isUpdateBlocked()) {\n                this.options.onExitComplete && this.options.onExitComplete();\n                return;\n            }\n            /**\n             * If we're running optimised appear animations then these must be\n             * cancelled before measuring the DOM. This is so we can measure\n             * the true layout of the element rather than the WAAPI animation\n             * which will be unaffected by the resetSkewAndRotate step.\n             *\n             * Note: This is a DOM write. Worst case scenario is this is sandwiched\n             * between other snapshot reads which will cause unnecessary style recalculations.\n             * This has to happen here though, as we don't yet know which nodes will need\n             * snapshots in startUpdate(), but we only want to cancel optimised animations\n             * if a layout animation measurement is actually going to be affected by them.\n             */ if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear) {\n                cancelTreeOptimisedTransformAnimations(this);\n            }\n            !this.root.isUpdating && this.root.startUpdate();\n            if (this.isLayoutDirty) return;\n            this.isLayoutDirty = true;\n            for(let i = 0; i < this.path.length; i++){\n                const node = this.path[i];\n                node.shouldResetTransform = true;\n                node.updateScroll(\"snapshot\");\n                if (node.options.layoutRoot) {\n                    node.willUpdate(false);\n                }\n            }\n            const { layoutId, layout } = this.options;\n            if (layoutId === undefined && !layout) return;\n            const transformTemplate = this.getTransformTemplate();\n            this.prevTransformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, \"\") : undefined;\n            this.updateSnapshot();\n            shouldNotifyListeners && this.notifyListeners(\"willUpdate\");\n        }\n        update() {\n            this.updateScheduled = false;\n            const updateWasBlocked = this.isUpdateBlocked();\n            // When doing an instant transition, we skip the layout update,\n            // but should still clean up the measurements so that the next\n            // snapshot could be taken correctly.\n            if (updateWasBlocked) {\n                this.unblockUpdate();\n                this.clearAllSnapshots();\n                this.nodes.forEach(clearMeasurements);\n                return;\n            }\n            if (!this.isUpdating) {\n                this.nodes.forEach(clearIsLayoutDirty);\n            }\n            this.isUpdating = false;\n            /**\n             * Write\n             */ this.nodes.forEach(resetTransformStyle);\n            /**\n             * Read ==================\n             */ // Update layout measurements of updated children\n            this.nodes.forEach(updateLayout);\n            /**\n             * Write\n             */ // Notify listeners that the layout is updated\n            this.nodes.forEach(notifyLayoutUpdate);\n            this.clearAllSnapshots();\n            /**\n             * Manually flush any pending updates. Ideally\n             * we could leave this to the following requestAnimationFrame but this seems\n             * to leave a flash of incorrectly styled content.\n             */ const now = time.now();\n            frameData.delta = clamp(0, 1000 / 60, now - frameData.timestamp);\n            frameData.timestamp = now;\n            frameData.isProcessing = true;\n            frameSteps.update.process(frameData);\n            frameSteps.preRender.process(frameData);\n            frameSteps.render.process(frameData);\n            frameData.isProcessing = false;\n        }\n        didUpdate() {\n            if (!this.updateScheduled) {\n                this.updateScheduled = true;\n                microtask.read(this.scheduleUpdate);\n            }\n        }\n        clearAllSnapshots() {\n            this.nodes.forEach(clearSnapshot);\n            this.sharedNodes.forEach(removeLeadSnapshots);\n        }\n        scheduleUpdateProjection() {\n            if (!this.projectionUpdateScheduled) {\n                this.projectionUpdateScheduled = true;\n                frame.preRender(this.updateProjection, false, true);\n            }\n        }\n        scheduleCheckAfterUnmount() {\n            /**\n             * If the unmounting node is in a layoutGroup and did trigger a willUpdate,\n             * we manually call didUpdate to give a chance to the siblings to animate.\n             * Otherwise, cleanup all snapshots to prevents future nodes from reusing them.\n             */ frame.postRender(()=>{\n                if (this.isLayoutDirty) {\n                    this.root.didUpdate();\n                } else {\n                    this.root.checkUpdateFailed();\n                }\n            });\n        }\n        /**\n         * Update measurements\n         */ updateSnapshot() {\n            if (this.snapshot || !this.instance) return;\n            this.snapshot = this.measure();\n        }\n        updateLayout() {\n            if (!this.instance) return;\n            // TODO: Incorporate into a forwarded scroll offset\n            this.updateScroll();\n            if (!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty) {\n                return;\n            }\n            /**\n             * When a node is mounted, it simply resumes from the prevLead's\n             * snapshot instead of taking a new one, but the ancestors scroll\n             * might have updated while the prevLead is unmounted. We need to\n             * update the scroll again to make sure the layout we measure is\n             * up to date.\n             */ if (this.resumeFrom && !this.resumeFrom.instance) {\n                for(let i = 0; i < this.path.length; i++){\n                    const node = this.path[i];\n                    node.updateScroll();\n                }\n            }\n            const prevLayout = this.layout;\n            this.layout = this.measure(false);\n            this.layoutCorrected = createBox();\n            this.isLayoutDirty = false;\n            this.projectionDelta = undefined;\n            this.notifyListeners(\"measure\", this.layout.layoutBox);\n            const { visualElement } = this.options;\n            visualElement && visualElement.notify(\"LayoutMeasure\", this.layout.layoutBox, prevLayout ? prevLayout.layoutBox : undefined);\n        }\n        updateScroll(phase = \"measure\") {\n            let needsMeasurement = Boolean(this.options.layoutScroll && this.instance);\n            if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === phase) {\n                needsMeasurement = false;\n            }\n            if (needsMeasurement) {\n                const isRoot = checkIsScrollRoot(this.instance);\n                this.scroll = {\n                    animationId: this.root.animationId,\n                    phase,\n                    isRoot,\n                    offset: measureScroll(this.instance),\n                    wasRoot: this.scroll ? this.scroll.isRoot : isRoot\n                };\n            }\n        }\n        resetTransform() {\n            if (!resetTransform) return;\n            const isResetRequested = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout;\n            const hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);\n            const transformTemplate = this.getTransformTemplate();\n            const transformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, \"\") : undefined;\n            const transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;\n            if (isResetRequested && (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged)) {\n                resetTransform(this.instance, transformTemplateValue);\n                this.shouldResetTransform = false;\n                this.scheduleRender();\n            }\n        }\n        measure(removeTransform = true) {\n            const pageBox = this.measurePageBox();\n            let layoutBox = this.removeElementScroll(pageBox);\n            /**\n             * Measurements taken during the pre-render stage\n             * still have transforms applied so we remove them\n             * via calculation.\n             */ if (removeTransform) {\n                layoutBox = this.removeTransform(layoutBox);\n            }\n            roundBox(layoutBox);\n            return {\n                animationId: this.root.animationId,\n                measuredBox: pageBox,\n                layoutBox,\n                latestValues: {},\n                source: this.id\n            };\n        }\n        measurePageBox() {\n            var _a;\n            const { visualElement } = this.options;\n            if (!visualElement) return createBox();\n            const box = visualElement.measureViewportBox();\n            const wasInScrollRoot = ((_a = this.scroll) === null || _a === void 0 ? void 0 : _a.wasRoot) || this.path.some(checkNodeWasScrollRoot);\n            if (!wasInScrollRoot) {\n                // Remove viewport scroll to give page-relative coordinates\n                const { scroll } = this.root;\n                if (scroll) {\n                    translateAxis(box.x, scroll.offset.x);\n                    translateAxis(box.y, scroll.offset.y);\n                }\n            }\n            return box;\n        }\n        removeElementScroll(box) {\n            var _a;\n            const boxWithoutScroll = createBox();\n            copyBoxInto(boxWithoutScroll, box);\n            if ((_a = this.scroll) === null || _a === void 0 ? void 0 : _a.wasRoot) {\n                return boxWithoutScroll;\n            }\n            /**\n             * Performance TODO: Keep a cumulative scroll offset down the tree\n             * rather than loop back up the path.\n             */ for(let i = 0; i < this.path.length; i++){\n                const node = this.path[i];\n                const { scroll, options } = node;\n                if (node !== this.root && scroll && options.layoutScroll) {\n                    /**\n                     * If this is a new scroll root, we want to remove all previous scrolls\n                     * from the viewport box.\n                     */ if (scroll.wasRoot) {\n                        copyBoxInto(boxWithoutScroll, box);\n                    }\n                    translateAxis(boxWithoutScroll.x, scroll.offset.x);\n                    translateAxis(boxWithoutScroll.y, scroll.offset.y);\n                }\n            }\n            return boxWithoutScroll;\n        }\n        applyTransform(box, transformOnly = false) {\n            const withTransforms = createBox();\n            copyBoxInto(withTransforms, box);\n            for(let i = 0; i < this.path.length; i++){\n                const node = this.path[i];\n                if (!transformOnly && node.options.layoutScroll && node.scroll && node !== node.root) {\n                    transformBox(withTransforms, {\n                        x: -node.scroll.offset.x,\n                        y: -node.scroll.offset.y\n                    });\n                }\n                if (!hasTransform(node.latestValues)) continue;\n                transformBox(withTransforms, node.latestValues);\n            }\n            if (hasTransform(this.latestValues)) {\n                transformBox(withTransforms, this.latestValues);\n            }\n            return withTransforms;\n        }\n        removeTransform(box) {\n            const boxWithoutTransform = createBox();\n            copyBoxInto(boxWithoutTransform, box);\n            for(let i = 0; i < this.path.length; i++){\n                const node = this.path[i];\n                if (!node.instance) continue;\n                if (!hasTransform(node.latestValues)) continue;\n                hasScale(node.latestValues) && node.updateSnapshot();\n                const sourceBox = createBox();\n                const nodeBox = node.measurePageBox();\n                copyBoxInto(sourceBox, nodeBox);\n                removeBoxTransforms(boxWithoutTransform, node.latestValues, node.snapshot ? node.snapshot.layoutBox : undefined, sourceBox);\n            }\n            if (hasTransform(this.latestValues)) {\n                removeBoxTransforms(boxWithoutTransform, this.latestValues);\n            }\n            return boxWithoutTransform;\n        }\n        setTargetDelta(delta) {\n            this.targetDelta = delta;\n            this.root.scheduleUpdateProjection();\n            this.isProjectionDirty = true;\n        }\n        setOptions(options) {\n            this.options = {\n                ...this.options,\n                ...options,\n                crossfade: options.crossfade !== undefined ? options.crossfade : true\n            };\n        }\n        clearMeasurements() {\n            this.scroll = undefined;\n            this.layout = undefined;\n            this.snapshot = undefined;\n            this.prevTransformTemplateValue = undefined;\n            this.targetDelta = undefined;\n            this.target = undefined;\n            this.isLayoutDirty = false;\n        }\n        forceRelativeParentToResolveTarget() {\n            if (!this.relativeParent) return;\n            /**\n             * If the parent target isn't up-to-date, force it to update.\n             * This is an unfortunate de-optimisation as it means any updating relative\n             * projection will cause all the relative parents to recalculate back\n             * up the tree.\n             */ if (this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp) {\n                this.relativeParent.resolveTargetDelta(true);\n            }\n        }\n        resolveTargetDelta(forceRecalculation = false) {\n            var _a;\n            /**\n             * Once the dirty status of nodes has been spread through the tree, we also\n             * need to check if we have a shared node of a different depth that has itself\n             * been dirtied.\n             */ const lead = this.getLead();\n            this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty);\n            this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty);\n            this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);\n            const isShared = Boolean(this.resumingFrom) || this !== lead;\n            /**\n             * We don't use transform for this step of processing so we don't\n             * need to check whether any nodes have changed transform.\n             */ const canSkip = !(forceRecalculation || isShared && this.isSharedProjectionDirty || this.isProjectionDirty || ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isProjectionDirty) || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize);\n            if (canSkip) return;\n            const { layout, layoutId } = this.options;\n            /**\n             * If we have no layout, we can't perform projection, so early return\n             */ if (!this.layout || !(layout || layoutId)) return;\n            this.resolvedRelativeTargetAt = frameData.timestamp;\n            /**\n             * If we don't have a targetDelta but do have a layout, we can attempt to resolve\n             * a relativeParent. This will allow a component to perform scale correction\n             * even if no animation has started.\n             */ if (!this.targetDelta && !this.relativeTarget) {\n                const relativeParent = this.getClosestProjectingParent();\n                if (relativeParent && relativeParent.layout && this.animationProgress !== 1) {\n                    this.relativeParent = relativeParent;\n                    this.forceRelativeParentToResolveTarget();\n                    this.relativeTarget = createBox();\n                    this.relativeTargetOrigin = createBox();\n                    calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, relativeParent.layout.layoutBox);\n                    copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);\n                } else {\n                    this.relativeParent = this.relativeTarget = undefined;\n                }\n            }\n            /**\n             * If we have no relative target or no target delta our target isn't valid\n             * for this frame.\n             */ if (!this.relativeTarget && !this.targetDelta) return;\n            /**\n             * Lazy-init target data structure\n             */ if (!this.target) {\n                this.target = createBox();\n                this.targetWithTransforms = createBox();\n            }\n            /**\n             * If we've got a relative box for this component, resolve it into a target relative to the parent.\n             */ if (this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target) {\n                this.forceRelativeParentToResolveTarget();\n                calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);\n            /**\n                 * If we've only got a targetDelta, resolve it into a target\n                 */ } else if (this.targetDelta) {\n                if (Boolean(this.resumingFrom)) {\n                    // TODO: This is creating a new object every frame\n                    this.target = this.applyTransform(this.layout.layoutBox);\n                } else {\n                    copyBoxInto(this.target, this.layout.layoutBox);\n                }\n                applyBoxDelta(this.target, this.targetDelta);\n            } else {\n                /**\n                 * If no target, use own layout as target\n                 */ copyBoxInto(this.target, this.layout.layoutBox);\n            }\n            /**\n             * If we've been told to attempt to resolve a relative target, do so.\n             */ if (this.attemptToResolveRelativeTarget) {\n                this.attemptToResolveRelativeTarget = false;\n                const relativeParent = this.getClosestProjectingParent();\n                if (relativeParent && Boolean(relativeParent.resumingFrom) === Boolean(this.resumingFrom) && !relativeParent.options.layoutScroll && relativeParent.target && this.animationProgress !== 1) {\n                    this.relativeParent = relativeParent;\n                    this.forceRelativeParentToResolveTarget();\n                    this.relativeTarget = createBox();\n                    this.relativeTargetOrigin = createBox();\n                    calcRelativePosition(this.relativeTargetOrigin, this.target, relativeParent.target);\n                    copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);\n                } else {\n                    this.relativeParent = this.relativeTarget = undefined;\n                }\n            }\n            /**\n             * Increase debug counter for resolved target deltas\n             */ if (isDebug) {\n                metrics.resolvedTargetDeltas++;\n            }\n        }\n        getClosestProjectingParent() {\n            if (!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues)) {\n                return undefined;\n            }\n            if (this.parent.isProjecting()) {\n                return this.parent;\n            } else {\n                return this.parent.getClosestProjectingParent();\n            }\n        }\n        isProjecting() {\n            return Boolean((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);\n        }\n        calcProjection() {\n            var _a;\n            const lead = this.getLead();\n            const isShared = Boolean(this.resumingFrom) || this !== lead;\n            let canSkip = true;\n            /**\n             * If this is a normal layout animation and neither this node nor its nearest projecting\n             * is dirty then we can't skip.\n             */ if (this.isProjectionDirty || ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isProjectionDirty)) {\n                canSkip = false;\n            }\n            /**\n             * If this is a shared layout animation and this node's shared projection is dirty then\n             * we can't skip.\n             */ if (isShared && (this.isSharedProjectionDirty || this.isTransformDirty)) {\n                canSkip = false;\n            }\n            /**\n             * If we have resolved the target this frame we must recalculate the\n             * projection to ensure it visually represents the internal calculations.\n             */ if (this.resolvedRelativeTargetAt === frameData.timestamp) {\n                canSkip = false;\n            }\n            if (canSkip) return;\n            const { layout, layoutId } = this.options;\n            /**\n             * If this section of the tree isn't animating we can\n             * delete our target sources for the following frame.\n             */ this.isTreeAnimating = Boolean(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation);\n            if (!this.isTreeAnimating) {\n                this.targetDelta = this.relativeTarget = undefined;\n            }\n            if (!this.layout || !(layout || layoutId)) return;\n            /**\n             * Reset the corrected box with the latest values from box, as we're then going\n             * to perform mutative operations on it.\n             */ copyBoxInto(this.layoutCorrected, this.layout.layoutBox);\n            /**\n             * Record previous tree scales before updating.\n             */ const prevTreeScaleX = this.treeScale.x;\n            const prevTreeScaleY = this.treeScale.y;\n            /**\n             * Apply all the parent deltas to this box to produce the corrected box. This\n             * is the layout box, as it will appear on screen as a result of the transforms of its parents.\n             */ applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared);\n            /**\n             * If this layer needs to perform scale correction but doesn't have a target,\n             * use the layout as the target.\n             */ if (lead.layout && !lead.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1)) {\n                lead.target = lead.layout.layoutBox;\n                lead.targetWithTransforms = createBox();\n            }\n            const { target } = lead;\n            if (!target) {\n                /**\n                 * If we don't have a target to project into, but we were previously\n                 * projecting, we want to remove the stored transform and schedule\n                 * a render to ensure the elements reflect the removed transform.\n                 */ if (this.prevProjectionDelta) {\n                    this.createProjectionDeltas();\n                    this.scheduleRender();\n                }\n                return;\n            }\n            if (!this.projectionDelta || !this.prevProjectionDelta) {\n                this.createProjectionDeltas();\n            } else {\n                copyAxisDeltaInto(this.prevProjectionDelta.x, this.projectionDelta.x);\n                copyAxisDeltaInto(this.prevProjectionDelta.y, this.projectionDelta.y);\n            }\n            /**\n             * Update the delta between the corrected box and the target box before user-set transforms were applied.\n             * This will allow us to calculate the corrected borderRadius and boxShadow to compensate\n             * for our layout reprojection, but still allow them to be scaled correctly by the user.\n             * It might be that to simplify this we may want to accept that user-set scale is also corrected\n             * and we wouldn't have to keep and calc both deltas, OR we could support a user setting\n             * to allow people to choose whether these styles are corrected based on just the\n             * layout reprojection or the final bounding box.\n             */ calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);\n            if (this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY || !axisDeltaEquals(this.projectionDelta.x, this.prevProjectionDelta.x) || !axisDeltaEquals(this.projectionDelta.y, this.prevProjectionDelta.y)) {\n                this.hasProjected = true;\n                this.scheduleRender();\n                this.notifyListeners(\"projectionUpdate\", target);\n            }\n            /**\n             * Increase debug counter for recalculated projections\n             */ if (isDebug) {\n                metrics.recalculatedProjection++;\n            }\n        }\n        hide() {\n            this.isVisible = false;\n        // TODO: Schedule render\n        }\n        show() {\n            this.isVisible = true;\n        // TODO: Schedule render\n        }\n        scheduleRender(notifyAll = true) {\n            var _a;\n            (_a = this.options.visualElement) === null || _a === void 0 ? void 0 : _a.scheduleRender();\n            if (notifyAll) {\n                const stack = this.getStack();\n                stack && stack.scheduleRender();\n            }\n            if (this.resumingFrom && !this.resumingFrom.instance) {\n                this.resumingFrom = undefined;\n            }\n        }\n        createProjectionDeltas() {\n            this.prevProjectionDelta = createDelta();\n            this.projectionDelta = createDelta();\n            this.projectionDeltaWithTransform = createDelta();\n        }\n        setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false) {\n            const snapshot = this.snapshot;\n            const snapshotLatestValues = snapshot ? snapshot.latestValues : {};\n            const mixedValues = {\n                ...this.latestValues\n            };\n            const targetDelta = createDelta();\n            if (!this.relativeParent || !this.relativeParent.options.layoutRoot) {\n                this.relativeTarget = this.relativeTargetOrigin = undefined;\n            }\n            this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;\n            const relativeLayout = createBox();\n            const snapshotSource = snapshot ? snapshot.source : undefined;\n            const layoutSource = this.layout ? this.layout.source : undefined;\n            const isSharedLayoutAnimation = snapshotSource !== layoutSource;\n            const stack = this.getStack();\n            const isOnlyMember = !stack || stack.members.length <= 1;\n            const shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === true && !this.path.some(hasOpacityCrossfade));\n            this.animationProgress = 0;\n            let prevRelativeTarget;\n            this.mixTargetDelta = (latest)=>{\n                const progress = latest / 1000;\n                mixAxisDelta(targetDelta.x, delta.x, progress);\n                mixAxisDelta(targetDelta.y, delta.y, progress);\n                this.setTargetDelta(targetDelta);\n                if (this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout) {\n                    calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox);\n                    mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress);\n                    /**\n                     * If this is an unchanged relative target we can consider the\n                     * projection not dirty.\n                     */ if (prevRelativeTarget && boxEquals(this.relativeTarget, prevRelativeTarget)) {\n                        this.isProjectionDirty = false;\n                    }\n                    if (!prevRelativeTarget) prevRelativeTarget = createBox();\n                    copyBoxInto(prevRelativeTarget, this.relativeTarget);\n                }\n                if (isSharedLayoutAnimation) {\n                    this.animationValues = mixedValues;\n                    mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress, shouldCrossfadeOpacity, isOnlyMember);\n                }\n                this.root.scheduleUpdateProjection();\n                this.scheduleRender();\n                this.animationProgress = progress;\n            };\n            this.mixTargetDelta(this.options.layoutRoot ? 1000 : 0);\n        }\n        startAnimation(options) {\n            this.notifyListeners(\"animationStart\");\n            this.currentAnimation && this.currentAnimation.stop();\n            if (this.resumingFrom && this.resumingFrom.currentAnimation) {\n                this.resumingFrom.currentAnimation.stop();\n            }\n            if (this.pendingAnimation) {\n                cancelFrame(this.pendingAnimation);\n                this.pendingAnimation = undefined;\n            }\n            /**\n             * Start the animation in the next frame to have a frame with progress 0,\n             * where the target is the same as when the animation started, so we can\n             * calculate the relative positions correctly for instant transitions.\n             */ this.pendingAnimation = frame.update(()=>{\n                globalProjectionState.hasAnimatedSinceResize = true;\n                this.currentAnimation = animateSingleValue(0, animationTarget, {\n                    ...options,\n                    onUpdate: (latest)=>{\n                        this.mixTargetDelta(latest);\n                        options.onUpdate && options.onUpdate(latest);\n                    },\n                    onComplete: ()=>{\n                        options.onComplete && options.onComplete();\n                        this.completeAnimation();\n                    }\n                });\n                if (this.resumingFrom) {\n                    this.resumingFrom.currentAnimation = this.currentAnimation;\n                }\n                this.pendingAnimation = undefined;\n            });\n        }\n        completeAnimation() {\n            if (this.resumingFrom) {\n                this.resumingFrom.currentAnimation = undefined;\n                this.resumingFrom.preserveOpacity = undefined;\n            }\n            const stack = this.getStack();\n            stack && stack.exitAnimationComplete();\n            this.resumingFrom = this.currentAnimation = this.animationValues = undefined;\n            this.notifyListeners(\"animationComplete\");\n        }\n        finishAnimation() {\n            if (this.currentAnimation) {\n                this.mixTargetDelta && this.mixTargetDelta(animationTarget);\n                this.currentAnimation.stop();\n            }\n            this.completeAnimation();\n        }\n        applyTransformsToTarget() {\n            const lead = this.getLead();\n            let { targetWithTransforms, target, layout, latestValues } = lead;\n            if (!targetWithTransforms || !target || !layout) return;\n            /**\n             * If we're only animating position, and this element isn't the lead element,\n             * then instead of projecting into the lead box we instead want to calculate\n             * a new target that aligns the two boxes but maintains the layout shape.\n             */ if (this !== lead && this.layout && layout && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout.layoutBox)) {\n                target = this.target || createBox();\n                const xLength = calcLength(this.layout.layoutBox.x);\n                target.x.min = lead.target.x.min;\n                target.x.max = target.x.min + xLength;\n                const yLength = calcLength(this.layout.layoutBox.y);\n                target.y.min = lead.target.y.min;\n                target.y.max = target.y.min + yLength;\n            }\n            copyBoxInto(targetWithTransforms, target);\n            /**\n             * Apply the latest user-set transforms to the targetBox to produce the targetBoxFinal.\n             * This is the final box that we will then project into by calculating a transform delta and\n             * applying it to the corrected box.\n             */ transformBox(targetWithTransforms, latestValues);\n            /**\n             * Update the delta between the corrected box and the final target box, after\n             * user-set transforms are applied to it. This will be used by the renderer to\n             * create a transform style that will reproject the element from its layout layout\n             * into the desired bounding box.\n             */ calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);\n        }\n        registerSharedNode(layoutId, node) {\n            if (!this.sharedNodes.has(layoutId)) {\n                this.sharedNodes.set(layoutId, new NodeStack());\n            }\n            const stack = this.sharedNodes.get(layoutId);\n            stack.add(node);\n            const config = node.options.initialPromotionConfig;\n            node.promote({\n                transition: config ? config.transition : undefined,\n                preserveFollowOpacity: config && config.shouldPreserveFollowOpacity ? config.shouldPreserveFollowOpacity(node) : undefined\n            });\n        }\n        isLead() {\n            const stack = this.getStack();\n            return stack ? stack.lead === this : true;\n        }\n        getLead() {\n            var _a;\n            const { layoutId } = this.options;\n            return layoutId ? ((_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.lead) || this : this;\n        }\n        getPrevLead() {\n            var _a;\n            const { layoutId } = this.options;\n            return layoutId ? (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.prevLead : undefined;\n        }\n        getStack() {\n            const { layoutId } = this.options;\n            if (layoutId) return this.root.sharedNodes.get(layoutId);\n        }\n        promote({ needsReset, transition, preserveFollowOpacity } = {}) {\n            const stack = this.getStack();\n            if (stack) stack.promote(this, preserveFollowOpacity);\n            if (needsReset) {\n                this.projectionDelta = undefined;\n                this.needsReset = true;\n            }\n            if (transition) this.setOptions({\n                transition\n            });\n        }\n        relegate() {\n            const stack = this.getStack();\n            if (stack) {\n                return stack.relegate(this);\n            } else {\n                return false;\n            }\n        }\n        resetSkewAndRotation() {\n            const { visualElement } = this.options;\n            if (!visualElement) return;\n            // If there's no detected skew or rotation values, we can early return without a forced render.\n            let hasDistortingTransform = false;\n            /**\n             * An unrolled check for rotation values. Most elements don't have any rotation and\n             * skipping the nested loop and new object creation is 50% faster.\n             */ const { latestValues } = visualElement;\n            if (latestValues.z || latestValues.rotate || latestValues.rotateX || latestValues.rotateY || latestValues.rotateZ || latestValues.skewX || latestValues.skewY) {\n                hasDistortingTransform = true;\n            }\n            // If there's no distorting values, we don't need to do any more.\n            if (!hasDistortingTransform) return;\n            const resetValues = {};\n            if (latestValues.z) {\n                resetDistortingTransform(\"z\", visualElement, resetValues, this.animationValues);\n            }\n            // Check the skew and rotate value of all axes and reset to 0\n            for(let i = 0; i < transformAxes.length; i++){\n                resetDistortingTransform(`rotate${transformAxes[i]}`, visualElement, resetValues, this.animationValues);\n                resetDistortingTransform(`skew${transformAxes[i]}`, visualElement, resetValues, this.animationValues);\n            }\n            // Force a render of this element to apply the transform with all skews and rotations\n            // set to 0.\n            visualElement.render();\n            // Put back all the values we reset\n            for(const key in resetValues){\n                visualElement.setStaticValue(key, resetValues[key]);\n                if (this.animationValues) {\n                    this.animationValues[key] = resetValues[key];\n                }\n            }\n            // Schedule a render for the next frame. This ensures we won't visually\n            // see the element with the reset rotate value applied.\n            visualElement.scheduleRender();\n        }\n        getProjectionStyles(styleProp) {\n            var _a, _b;\n            if (!this.instance || this.isSVG) return undefined;\n            if (!this.isVisible) {\n                return hiddenVisibility;\n            }\n            const styles = {\n                visibility: \"\"\n            };\n            const transformTemplate = this.getTransformTemplate();\n            if (this.needsReset) {\n                this.needsReset = false;\n                styles.opacity = \"\";\n                styles.pointerEvents = resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || \"\";\n                styles.transform = transformTemplate ? transformTemplate(this.latestValues, \"\") : \"none\";\n                return styles;\n            }\n            const lead = this.getLead();\n            if (!this.projectionDelta || !this.layout || !lead.target) {\n                const emptyStyles = {};\n                if (this.options.layoutId) {\n                    emptyStyles.opacity = this.latestValues.opacity !== undefined ? this.latestValues.opacity : 1;\n                    emptyStyles.pointerEvents = resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || \"\";\n                }\n                if (this.hasProjected && !hasTransform(this.latestValues)) {\n                    emptyStyles.transform = transformTemplate ? transformTemplate({}, \"\") : \"none\";\n                    this.hasProjected = false;\n                }\n                return emptyStyles;\n            }\n            const valuesToRender = lead.animationValues || lead.latestValues;\n            this.applyTransformsToTarget();\n            styles.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);\n            if (transformTemplate) {\n                styles.transform = transformTemplate(valuesToRender, styles.transform);\n            }\n            const { x, y } = this.projectionDelta;\n            styles.transformOrigin = `${x.origin * 100}% ${y.origin * 100}% 0`;\n            if (lead.animationValues) {\n                /**\n                 * If the lead component is animating, assign this either the entering/leaving\n                 * opacity\n                 */ styles.opacity = lead === this ? (_b = (_a = valuesToRender.opacity) !== null && _a !== void 0 ? _a : this.latestValues.opacity) !== null && _b !== void 0 ? _b : 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit;\n            } else {\n                /**\n                 * Or we're not animating at all, set the lead component to its layout\n                 * opacity and other components to hidden.\n                 */ styles.opacity = lead === this ? valuesToRender.opacity !== undefined ? valuesToRender.opacity : \"\" : valuesToRender.opacityExit !== undefined ? valuesToRender.opacityExit : 0;\n            }\n            /**\n             * Apply scale correction\n             */ for(const key in scaleCorrectors){\n                if (valuesToRender[key] === undefined) continue;\n                const { correct, applyTo } = scaleCorrectors[key];\n                /**\n                 * Only apply scale correction to the value if we have an\n                 * active projection transform. Otherwise these values become\n                 * vulnerable to distortion if the element changes size without\n                 * a corresponding layout animation.\n                 */ const corrected = styles.transform === \"none\" ? valuesToRender[key] : correct(valuesToRender[key], lead);\n                if (applyTo) {\n                    const num = applyTo.length;\n                    for(let i = 0; i < num; i++){\n                        styles[applyTo[i]] = corrected;\n                    }\n                } else {\n                    styles[key] = corrected;\n                }\n            }\n            /**\n             * Disable pointer events on follow components. This is to ensure\n             * that if a follow component covers a lead component it doesn't block\n             * pointer events on the lead.\n             */ if (this.options.layoutId) {\n                styles.pointerEvents = lead === this ? resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || \"\" : \"none\";\n            }\n            return styles;\n        }\n        clearSnapshot() {\n            this.resumeFrom = this.snapshot = undefined;\n        }\n        // Only run on root\n        resetTree() {\n            this.root.nodes.forEach((node)=>{\n                var _a;\n                return (_a = node.currentAnimation) === null || _a === void 0 ? void 0 : _a.stop();\n            });\n            this.root.nodes.forEach(clearMeasurements);\n            this.root.sharedNodes.clear();\n        }\n    };\n}\nfunction updateLayout(node) {\n    node.updateLayout();\n}\nfunction notifyLayoutUpdate(node) {\n    var _a;\n    const snapshot = ((_a = node.resumeFrom) === null || _a === void 0 ? void 0 : _a.snapshot) || node.snapshot;\n    if (node.isLead() && node.layout && snapshot && node.hasListeners(\"didUpdate\")) {\n        const { layoutBox: layout, measuredBox: measuredLayout } = node.layout;\n        const { animationType } = node.options;\n        const isShared = snapshot.source !== node.layout.source;\n        // TODO Maybe we want to also resize the layout snapshot so we don't trigger\n        // animations for instance if layout=\"size\" and an element has only changed position\n        if (animationType === \"size\") {\n            eachAxis((axis)=>{\n                const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];\n                const length = calcLength(axisSnapshot);\n                axisSnapshot.min = layout[axis].min;\n                axisSnapshot.max = axisSnapshot.min + length;\n            });\n        } else if (shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout)) {\n            eachAxis((axis)=>{\n                const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];\n                const length = calcLength(layout[axis]);\n                axisSnapshot.max = axisSnapshot.min + length;\n                /**\n                 * Ensure relative target gets resized and rerendererd\n                 */ if (node.relativeTarget && !node.currentAnimation) {\n                    node.isProjectionDirty = true;\n                    node.relativeTarget[axis].max = node.relativeTarget[axis].min + length;\n                }\n            });\n        }\n        const layoutDelta = createDelta();\n        calcBoxDelta(layoutDelta, layout, snapshot.layoutBox);\n        const visualDelta = createDelta();\n        if (isShared) {\n            calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, true), snapshot.measuredBox);\n        } else {\n            calcBoxDelta(visualDelta, layout, snapshot.layoutBox);\n        }\n        const hasLayoutChanged = !isDeltaZero(layoutDelta);\n        let hasRelativeTargetChanged = false;\n        if (!node.resumeFrom) {\n            const relativeParent = node.getClosestProjectingParent();\n            /**\n             * If the relativeParent is itself resuming from a different element then\n             * the relative snapshot is not relavent\n             */ if (relativeParent && !relativeParent.resumeFrom) {\n                const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;\n                if (parentSnapshot && parentLayout) {\n                    const relativeSnapshot = createBox();\n                    calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);\n                    const relativeLayout = createBox();\n                    calcRelativePosition(relativeLayout, layout, parentLayout.layoutBox);\n                    if (!boxEqualsRounded(relativeSnapshot, relativeLayout)) {\n                        hasRelativeTargetChanged = true;\n                    }\n                    if (relativeParent.options.layoutRoot) {\n                        node.relativeTarget = relativeLayout;\n                        node.relativeTargetOrigin = relativeSnapshot;\n                        node.relativeParent = relativeParent;\n                    }\n                }\n            }\n        }\n        node.notifyListeners(\"didUpdate\", {\n            layout,\n            snapshot,\n            delta: visualDelta,\n            layoutDelta,\n            hasLayoutChanged,\n            hasRelativeTargetChanged\n        });\n    } else if (node.isLead()) {\n        const { onExitComplete } = node.options;\n        onExitComplete && onExitComplete();\n    }\n    /**\n     * Clearing transition\n     * TODO: Investigate why this transition is being passed in as {type: false } from Framer\n     * and why we need it at all\n     */ node.options.transition = undefined;\n}\nfunction propagateDirtyNodes(node) {\n    /**\n     * Increase debug counter for nodes encountered this frame\n     */ if (isDebug) {\n        metrics.totalNodes++;\n    }\n    if (!node.parent) return;\n    /**\n     * If this node isn't projecting, propagate isProjectionDirty. It will have\n     * no performance impact but it will allow the next child that *is* projecting\n     * but *isn't* dirty to just check its parent to see if *any* ancestor needs\n     * correcting.\n     */ if (!node.isProjecting()) {\n        node.isProjectionDirty = node.parent.isProjectionDirty;\n    }\n    /**\n     * Propagate isSharedProjectionDirty and isTransformDirty\n     * throughout the whole tree. A future revision can take another look at\n     * this but for safety we still recalcualte shared nodes.\n     */ node.isSharedProjectionDirty || (node.isSharedProjectionDirty = Boolean(node.isProjectionDirty || node.parent.isProjectionDirty || node.parent.isSharedProjectionDirty));\n    node.isTransformDirty || (node.isTransformDirty = node.parent.isTransformDirty);\n}\nfunction cleanDirtyNodes(node) {\n    node.isProjectionDirty = node.isSharedProjectionDirty = node.isTransformDirty = false;\n}\nfunction clearSnapshot(node) {\n    node.clearSnapshot();\n}\nfunction clearMeasurements(node) {\n    node.clearMeasurements();\n}\nfunction clearIsLayoutDirty(node) {\n    node.isLayoutDirty = false;\n}\nfunction resetTransformStyle(node) {\n    const { visualElement } = node.options;\n    if (visualElement && visualElement.getProps().onBeforeLayoutMeasure) {\n        visualElement.notify(\"BeforeLayoutMeasure\");\n    }\n    node.resetTransform();\n}\nfunction finishAnimation(node) {\n    node.finishAnimation();\n    node.targetDelta = node.relativeTarget = node.target = undefined;\n    node.isProjectionDirty = true;\n}\nfunction resolveTargetDelta(node) {\n    node.resolveTargetDelta();\n}\nfunction calcProjection(node) {\n    node.calcProjection();\n}\nfunction resetSkewAndRotation(node) {\n    node.resetSkewAndRotation();\n}\nfunction removeLeadSnapshots(stack) {\n    stack.removeLeadSnapshot();\n}\nfunction mixAxisDelta(output, delta, p) {\n    output.translate = mixNumber$1(delta.translate, 0, p);\n    output.scale = mixNumber$1(delta.scale, 1, p);\n    output.origin = delta.origin;\n    output.originPoint = delta.originPoint;\n}\nfunction mixAxis(output, from, to, p) {\n    output.min = mixNumber$1(from.min, to.min, p);\n    output.max = mixNumber$1(from.max, to.max, p);\n}\nfunction mixBox(output, from, to, p) {\n    mixAxis(output.x, from.x, to.x, p);\n    mixAxis(output.y, from.y, to.y, p);\n}\nfunction hasOpacityCrossfade(node) {\n    return node.animationValues && node.animationValues.opacityExit !== undefined;\n}\nconst defaultLayoutTransition = {\n    duration: 0.45,\n    ease: [\n        0.4,\n        0,\n        0.1,\n        1\n    ]\n};\nconst userAgentContains = (string)=>typeof navigator !== \"undefined\" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(string);\n/**\n * Measured bounding boxes must be rounded in Safari and\n * left untouched in Chrome, otherwise non-integer layouts within scaled-up elements\n * can appear to jump.\n */ const roundPoint = userAgentContains(\"applewebkit/\") && !userAgentContains(\"chrome/\") ? Math.round : motionUtils.noop;\nfunction roundAxis(axis) {\n    // Round to the nearest .5 pixels to support subpixel layouts\n    axis.min = roundPoint(axis.min);\n    axis.max = roundPoint(axis.max);\n}\nfunction roundBox(box) {\n    roundAxis(box.x);\n    roundAxis(box.y);\n}\nfunction shouldAnimatePositionOnly(animationType, snapshot, layout) {\n    return animationType === \"position\" || animationType === \"preserve-aspect\" && !isNear(aspectRatio(snapshot), aspectRatio(layout), 0.2);\n}\nfunction checkNodeWasScrollRoot(node) {\n    var _a;\n    return node !== node.root && ((_a = node.scroll) === null || _a === void 0 ? void 0 : _a.wasRoot);\n}\nconst DocumentProjectionNode = createProjectionNode$1({\n    attachResizeListener: (ref, notify)=>addDomEvent(ref, \"resize\", notify),\n    measureScroll: ()=>({\n            x: document.documentElement.scrollLeft || document.body.scrollLeft,\n            y: document.documentElement.scrollTop || document.body.scrollTop\n        }),\n    checkIsScrollRoot: ()=>true\n});\nconst rootProjectionNode = {\n    current: undefined\n};\nconst HTMLProjectionNode = createProjectionNode$1({\n    measureScroll: (instance)=>({\n            x: instance.scrollLeft,\n            y: instance.scrollTop\n        }),\n    defaultParent: ()=>{\n        if (!rootProjectionNode.current) {\n            const documentNode = new DocumentProjectionNode({});\n            documentNode.mount(window);\n            documentNode.setOptions({\n                layoutScroll: true\n            });\n            rootProjectionNode.current = documentNode;\n        }\n        return rootProjectionNode.current;\n    },\n    resetTransform: (instance, value)=>{\n        instance.style.transform = value !== undefined ? value : \"none\";\n    },\n    checkIsScrollRoot: (instance)=>Boolean(window.getComputedStyle(instance).position === \"fixed\")\n});\nconst notify = (node)=>!node.isLayoutDirty && node.willUpdate(false);\nfunction nodeGroup() {\n    const nodes = new Set();\n    const subscriptions = new WeakMap();\n    const dirtyAll = ()=>nodes.forEach(notify);\n    return {\n        add: (node)=>{\n            nodes.add(node);\n            subscriptions.set(node, node.addEventListener(\"willUpdate\", dirtyAll));\n        },\n        remove: (node)=>{\n            nodes.delete(node);\n            const unsubscribe = subscriptions.get(node);\n            if (unsubscribe) {\n                unsubscribe();\n                subscriptions.delete(node);\n            }\n            dirtyAll();\n        },\n        dirty: dirtyAll\n    };\n}\nfunction pixelsToPercent(pixels, axis) {\n    if (axis.max === axis.min) return 0;\n    return pixels / (axis.max - axis.min) * 100;\n}\n/**\n * We always correct borderRadius as a percentage rather than pixels to reduce paints.\n * For example, if you are projecting a box that is 100px wide with a 10px borderRadius\n * into a box that is 200px wide with a 20px borderRadius, that is actually a 10%\n * borderRadius in both states. If we animate between the two in pixels that will trigger\n * a paint each time. If we animate between the two in percentage we'll avoid a paint.\n */ const correctBorderRadius = {\n    correct: (latest, node)=>{\n        if (!node.target) return latest;\n        /**\n         * If latest is a string, if it's a percentage we can return immediately as it's\n         * going to be stretched appropriately. Otherwise, if it's a pixel, convert it to a number.\n         */ if (typeof latest === \"string\") {\n            if (px.test(latest)) {\n                latest = parseFloat(latest);\n            } else {\n                return latest;\n            }\n        }\n        /**\n         * If latest is a number, it's a pixel value. We use the current viewportBox to calculate that\n         * pixel value as a percentage of each axis\n         */ const x = pixelsToPercent(latest, node.target.x);\n        const y = pixelsToPercent(latest, node.target.y);\n        return `${x}% ${y}%`;\n    }\n};\nconst correctBoxShadow = {\n    correct: (latest, { treeScale, projectionDelta })=>{\n        const original = latest;\n        const shadow = complex.parse(latest);\n        // TODO: Doesn't support multiple shadows\n        if (shadow.length > 5) return original;\n        const template = complex.createTransformer(latest);\n        const offset = typeof shadow[0] !== \"number\" ? 1 : 0;\n        // Calculate the overall context scale\n        const xScale = projectionDelta.x.scale * treeScale.x;\n        const yScale = projectionDelta.y.scale * treeScale.y;\n        shadow[0 + offset] /= xScale;\n        shadow[1 + offset] /= yScale;\n        /**\n         * Ideally we'd correct x and y scales individually, but because blur and\n         * spread apply to both we have to take a scale average and apply that instead.\n         * We could potentially improve the outcome of this by incorporating the ratio between\n         * the two scales.\n         */ const averageScale = mixNumber$1(xScale, yScale, 0.5);\n        // Blur\n        if (typeof shadow[2 + offset] === \"number\") shadow[2 + offset] /= averageScale;\n        // Spread\n        if (typeof shadow[3 + offset] === \"number\") shadow[3 + offset] /= averageScale;\n        return template(shadow);\n    }\n};\n/**\n * @public\n */ const PresenceContext = React.createContext(null);\n/**\n * When a component is the child of `AnimatePresence`, it can use `usePresence`\n * to access information about whether it's still present in the React tree.\n *\n * ```jsx\n * import { usePresence } from \"framer-motion\"\n *\n * export const Component = () => {\n *   const [isPresent, safeToRemove] = usePresence()\n *\n *   useEffect(() => {\n *     !isPresent && setTimeout(safeToRemove, 1000)\n *   }, [isPresent])\n *\n *   return <div />\n * }\n * ```\n *\n * If `isPresent` is `false`, it means that a component has been removed the tree, but\n * `AnimatePresence` won't really remove it until `safeToRemove` has been called.\n *\n * @public\n */ function usePresence() {\n    const context = React.useContext(PresenceContext);\n    if (context === null) return [\n        true,\n        null\n    ];\n    const { isPresent, onExitComplete, register } = context;\n    // It's safe to call the following hooks conditionally (after an early return) because the context will always\n    // either be null or non-null for the lifespan of the component.\n    const id = React.useId();\n    React.useEffect(()=>register(id), []);\n    const safeToRemove = React.useCallback(()=>onExitComplete && onExitComplete(id), [\n        id,\n        onExitComplete\n    ]);\n    return !isPresent && onExitComplete ? [\n        false,\n        safeToRemove\n    ] : [\n        true\n    ];\n}\n/**\n * Similar to `usePresence`, except `useIsPresent` simply returns whether or not the component is present.\n * There is no `safeToRemove` function.\n *\n * ```jsx\n * import { useIsPresent } from \"framer-motion\"\n *\n * export const Component = () => {\n *   const isPresent = useIsPresent()\n *\n *   useEffect(() => {\n *     !isPresent && console.log(\"I've been removed!\")\n *   }, [isPresent])\n *\n *   return <div />\n * }\n * ```\n *\n * @public\n */ function useIsPresent() {\n    return isPresent(React.useContext(PresenceContext));\n}\nfunction isPresent(context) {\n    return context === null ? true : context.isPresent;\n}\nconst LayoutGroupContext = React.createContext({});\n/**\n * Internal, exported only for usage in Framer\n */ const SwitchLayoutGroupContext = React.createContext({});\nclass MeasureLayoutWithContext extends React.Component {\n    /**\n     * This only mounts projection nodes for components that\n     * need measuring, we might want to do it for all components\n     * in order to incorporate transforms\n     */ componentDidMount() {\n        const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;\n        const { projection } = visualElement;\n        addScaleCorrector(defaultScaleCorrectors);\n        if (projection) {\n            if (layoutGroup.group) layoutGroup.group.add(projection);\n            if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {\n                switchLayoutGroup.register(projection);\n            }\n            projection.root.didUpdate();\n            projection.addEventListener(\"animationComplete\", ()=>{\n                this.safeToRemove();\n            });\n            projection.setOptions({\n                ...projection.options,\n                onExitComplete: ()=>this.safeToRemove()\n            });\n        }\n        globalProjectionState.hasEverUpdated = true;\n    }\n    getSnapshotBeforeUpdate(prevProps) {\n        const { layoutDependency, visualElement, drag, isPresent } = this.props;\n        const projection = visualElement.projection;\n        if (!projection) return null;\n        /**\n         * TODO: We use this data in relegate to determine whether to\n         * promote a previous element. There's no guarantee its presence data\n         * will have updated by this point - if a bug like this arises it will\n         * have to be that we markForRelegation and then find a new lead some other way,\n         * perhaps in didUpdate\n         */ projection.isPresent = isPresent;\n        if (drag || prevProps.layoutDependency !== layoutDependency || layoutDependency === undefined) {\n            projection.willUpdate();\n        } else {\n            this.safeToRemove();\n        }\n        if (prevProps.isPresent !== isPresent) {\n            if (isPresent) {\n                projection.promote();\n            } else if (!projection.relegate()) {\n                /**\n                 * If there's another stack member taking over from this one,\n                 * it's in charge of the exit animation and therefore should\n                 * be in charge of the safe to remove. Otherwise we call it here.\n                 */ frame.postRender(()=>{\n                    const stack = projection.getStack();\n                    if (!stack || !stack.members.length) {\n                        this.safeToRemove();\n                    }\n                });\n            }\n        }\n        return null;\n    }\n    componentDidUpdate() {\n        const { projection } = this.props.visualElement;\n        if (projection) {\n            projection.root.didUpdate();\n            microtask.postRender(()=>{\n                if (!projection.currentAnimation && projection.isLead()) {\n                    this.safeToRemove();\n                }\n            });\n        }\n    }\n    componentWillUnmount() {\n        const { visualElement, layoutGroup, switchLayoutGroup: promoteContext } = this.props;\n        const { projection } = visualElement;\n        if (projection) {\n            projection.scheduleCheckAfterUnmount();\n            if (layoutGroup && layoutGroup.group) layoutGroup.group.remove(projection);\n            if (promoteContext && promoteContext.deregister) promoteContext.deregister(projection);\n        }\n    }\n    safeToRemove() {\n        const { safeToRemove } = this.props;\n        safeToRemove && safeToRemove();\n    }\n    render() {\n        return null;\n    }\n}\nfunction MeasureLayout(props) {\n    const [isPresent, safeToRemove] = usePresence();\n    const layoutGroup = React.useContext(LayoutGroupContext);\n    return jsxRuntime.jsx(MeasureLayoutWithContext, {\n        ...props,\n        layoutGroup: layoutGroup,\n        switchLayoutGroup: React.useContext(SwitchLayoutGroupContext),\n        isPresent: isPresent,\n        safeToRemove: safeToRemove\n    });\n}\nconst defaultScaleCorrectors = {\n    borderRadius: {\n        ...correctBorderRadius,\n        applyTo: [\n            \"borderTopLeftRadius\",\n            \"borderTopRightRadius\",\n            \"borderBottomLeftRadius\",\n            \"borderBottomRightRadius\"\n        ]\n    },\n    borderTopLeftRadius: correctBorderRadius,\n    borderTopRightRadius: correctBorderRadius,\n    borderBottomLeftRadius: correctBorderRadius,\n    borderBottomRightRadius: correctBorderRadius,\n    boxShadow: correctBoxShadow\n};\nconst drag = {\n    pan: {\n        Feature: PanGesture\n    },\n    drag: {\n        Feature: DragGesture,\n        ProjectionNode: HTMLProjectionNode,\n        MeasureLayout\n    }\n};\nfunction handleHoverEvent(node, event, lifecycle) {\n    const { props } = node;\n    if (node.animationState && props.whileHover) {\n        node.animationState.setActive(\"whileHover\", lifecycle === \"Start\");\n    }\n    const eventName = \"onHover\" + lifecycle;\n    const callback = props[eventName];\n    if (callback) {\n        frame.postRender(()=>callback(event, extractEventInfo(event)));\n    }\n}\nclass HoverGesture extends Feature {\n    mount() {\n        const { current } = this.node;\n        if (!current) return;\n        this.unmount = motionDom.hover(current, (startEvent)=>{\n            handleHoverEvent(this.node, startEvent, \"Start\");\n            return (endEvent)=>handleHoverEvent(this.node, endEvent, \"End\");\n        });\n    }\n    unmount() {}\n}\nclass FocusGesture extends Feature {\n    constructor(){\n        super(...arguments);\n        this.isActive = false;\n    }\n    onFocus() {\n        let isFocusVisible = false;\n        /**\n         * If this element doesn't match focus-visible then don't\n         * apply whileHover. But, if matches throws that focus-visible\n         * is not a valid selector then in that browser outline styles will be applied\n         * to the element by default and we want to match that behaviour with whileFocus.\n         */ try {\n            isFocusVisible = this.node.current.matches(\":focus-visible\");\n        } catch (e) {\n            isFocusVisible = true;\n        }\n        if (!isFocusVisible || !this.node.animationState) return;\n        this.node.animationState.setActive(\"whileFocus\", true);\n        this.isActive = true;\n    }\n    onBlur() {\n        if (!this.isActive || !this.node.animationState) return;\n        this.node.animationState.setActive(\"whileFocus\", false);\n        this.isActive = false;\n    }\n    mount() {\n        this.unmount = pipe(addDomEvent(this.node.current, \"focus\", ()=>this.onFocus()), addDomEvent(this.node.current, \"blur\", ()=>this.onBlur()));\n    }\n    unmount() {}\n}\nfunction handlePressEvent(node, event, lifecycle) {\n    const { props } = node;\n    if (node.animationState && props.whileTap) {\n        node.animationState.setActive(\"whileTap\", lifecycle === \"Start\");\n    }\n    const eventName = \"onTap\" + (lifecycle === \"End\" ? \"\" : lifecycle);\n    const callback = props[eventName];\n    if (callback) {\n        frame.postRender(()=>callback(event, extractEventInfo(event)));\n    }\n}\nclass PressGesture extends Feature {\n    mount() {\n        const { current } = this.node;\n        if (!current) return;\n        this.unmount = motionDom.press(current, (startEvent)=>{\n            handlePressEvent(this.node, startEvent, \"Start\");\n            return (endEvent, { success })=>handlePressEvent(this.node, endEvent, success ? \"End\" : \"Cancel\");\n        }, {\n            useGlobalTarget: this.node.props.globalTapTarget\n        });\n    }\n    unmount() {}\n}\n/**\n * Map an IntersectionHandler callback to an element. We only ever make one handler for one\n * element, so even though these handlers might all be triggered by different\n * observers, we can keep them in the same map.\n */ const observerCallbacks = new WeakMap();\n/**\n * Multiple observers can be created for multiple element/document roots. Each with\n * different settings. So here we store dictionaries of observers to each root,\n * using serialised settings (threshold/margin) as lookup keys.\n */ const observers = new WeakMap();\nconst fireObserverCallback = (entry)=>{\n    const callback = observerCallbacks.get(entry.target);\n    callback && callback(entry);\n};\nconst fireAllObserverCallbacks = (entries)=>{\n    entries.forEach(fireObserverCallback);\n};\nfunction initIntersectionObserver({ root, ...options }) {\n    const lookupRoot = root || document;\n    /**\n     * If we don't have an observer lookup map for this root, create one.\n     */ if (!observers.has(lookupRoot)) {\n        observers.set(lookupRoot, {});\n    }\n    const rootObservers = observers.get(lookupRoot);\n    const key = JSON.stringify(options);\n    /**\n     * If we don't have an observer for this combination of root and settings,\n     * create one.\n     */ if (!rootObservers[key]) {\n        rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, {\n            root,\n            ...options\n        });\n    }\n    return rootObservers[key];\n}\nfunction observeIntersection(element, options, callback) {\n    const rootInteresectionObserver = initIntersectionObserver(options);\n    observerCallbacks.set(element, callback);\n    rootInteresectionObserver.observe(element);\n    return ()=>{\n        observerCallbacks.delete(element);\n        rootInteresectionObserver.unobserve(element);\n    };\n}\nconst thresholdNames = {\n    some: 0,\n    all: 1\n};\nclass InViewFeature extends Feature {\n    constructor(){\n        super(...arguments);\n        this.hasEnteredView = false;\n        this.isInView = false;\n    }\n    startObserver() {\n        this.unmount();\n        const { viewport = {} } = this.node.getProps();\n        const { root, margin: rootMargin, amount = \"some\", once } = viewport;\n        const options = {\n            root: root ? root.current : undefined,\n            rootMargin,\n            threshold: typeof amount === \"number\" ? amount : thresholdNames[amount]\n        };\n        const onIntersectionUpdate = (entry)=>{\n            const { isIntersecting } = entry;\n            /**\n             * If there's been no change in the viewport state, early return.\n             */ if (this.isInView === isIntersecting) return;\n            this.isInView = isIntersecting;\n            /**\n             * Handle hasEnteredView. If this is only meant to run once, and\n             * element isn't visible, early return. Otherwise set hasEnteredView to true.\n             */ if (once && !isIntersecting && this.hasEnteredView) {\n                return;\n            } else if (isIntersecting) {\n                this.hasEnteredView = true;\n            }\n            if (this.node.animationState) {\n                this.node.animationState.setActive(\"whileInView\", isIntersecting);\n            }\n            /**\n             * Use the latest committed props rather than the ones in scope\n             * when this observer is created\n             */ const { onViewportEnter, onViewportLeave } = this.node.getProps();\n            const callback = isIntersecting ? onViewportEnter : onViewportLeave;\n            callback && callback(entry);\n        };\n        return observeIntersection(this.node.current, options, onIntersectionUpdate);\n    }\n    mount() {\n        this.startObserver();\n    }\n    update() {\n        if (typeof IntersectionObserver === \"undefined\") return;\n        const { props, prevProps } = this.node;\n        const hasOptionsChanged = [\n            \"amount\",\n            \"margin\",\n            \"root\"\n        ].some(hasViewportOptionChanged(props, prevProps));\n        if (hasOptionsChanged) {\n            this.startObserver();\n        }\n    }\n    unmount() {}\n}\nfunction hasViewportOptionChanged({ viewport = {} }, { viewport: prevViewport = {} } = {}) {\n    return (name)=>viewport[name] !== prevViewport[name];\n}\nconst gestureAnimations = {\n    inView: {\n        Feature: InViewFeature\n    },\n    tap: {\n        Feature: PressGesture\n    },\n    focus: {\n        Feature: FocusGesture\n    },\n    hover: {\n        Feature: HoverGesture\n    }\n};\nconst layout = {\n    layout: {\n        ProjectionNode: HTMLProjectionNode,\n        MeasureLayout\n    }\n};\n/**\n * @public\n */ const MotionConfigContext = React.createContext({\n    transformPagePoint: (p)=>p,\n    isStatic: false,\n    reducedMotion: \"never\"\n});\nconst MotionContext = React.createContext({});\nconst useIsomorphicLayoutEffect = isBrowser ? React.useLayoutEffect : React.useEffect;\nconst LazyContext = React.createContext({\n    strict: false\n});\nfunction useVisualElement(Component, visualState, props, createVisualElement, ProjectionNodeConstructor) {\n    var _a, _b;\n    const { visualElement: parent } = React.useContext(MotionContext);\n    const lazyContext = React.useContext(LazyContext);\n    const presenceContext = React.useContext(PresenceContext);\n    const reducedMotionConfig = React.useContext(MotionConfigContext).reducedMotion;\n    const visualElementRef = React.useRef(null);\n    /**\n     * If we haven't preloaded a renderer, check to see if we have one lazy-loaded\n     */ createVisualElement = createVisualElement || lazyContext.renderer;\n    if (!visualElementRef.current && createVisualElement) {\n        visualElementRef.current = createVisualElement(Component, {\n            visualState,\n            parent,\n            props,\n            presenceContext,\n            blockInitialAnimation: presenceContext ? presenceContext.initial === false : false,\n            reducedMotionConfig\n        });\n    }\n    const visualElement = visualElementRef.current;\n    /**\n     * Load Motion gesture and animation features. These are rendered as renderless\n     * components so each feature can optionally make use of React lifecycle methods.\n     */ const initialLayoutGroupConfig = React.useContext(SwitchLayoutGroupContext);\n    if (visualElement && !visualElement.projection && ProjectionNodeConstructor && (visualElement.type === \"html\" || visualElement.type === \"svg\")) {\n        createProjectionNode(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);\n    }\n    const isMounted = React.useRef(false);\n    React.useInsertionEffect(()=>{\n        /**\n         * Check the component has already mounted before calling\n         * `update` unnecessarily. This ensures we skip the initial update.\n         */ if (visualElement && isMounted.current) {\n            visualElement.update(props, presenceContext);\n        }\n    });\n    /**\n     * Cache this value as we want to know whether HandoffAppearAnimations\n     * was present on initial render - it will be deleted after this.\n     */ const optimisedAppearId = props[optimizedAppearDataAttribute];\n    const wantsHandoff = React.useRef(Boolean(optimisedAppearId) && !((_a = window.MotionHandoffIsComplete) === null || _a === void 0 ? void 0 : _a.call(window, optimisedAppearId)) && ((_b = window.MotionHasOptimisedAnimation) === null || _b === void 0 ? void 0 : _b.call(window, optimisedAppearId)));\n    useIsomorphicLayoutEffect(()=>{\n        if (!visualElement) return;\n        isMounted.current = true;\n        window.MotionIsMounted = true;\n        visualElement.updateFeatures();\n        microtask.render(visualElement.render);\n        /**\n         * Ideally this function would always run in a useEffect.\n         *\n         * However, if we have optimised appear animations to handoff from,\n         * it needs to happen synchronously to ensure there's no flash of\n         * incorrect styles in the event of a hydration error.\n         *\n         * So if we detect a situtation where optimised appear animations\n         * are running, we use useLayoutEffect to trigger animations.\n         */ if (wantsHandoff.current && visualElement.animationState) {\n            visualElement.animationState.animateChanges();\n        }\n    });\n    React.useEffect(()=>{\n        if (!visualElement) return;\n        if (!wantsHandoff.current && visualElement.animationState) {\n            visualElement.animationState.animateChanges();\n        }\n        if (wantsHandoff.current) {\n            // This ensures all future calls to animateChanges() in this component will run in useEffect\n            queueMicrotask(()=>{\n                var _a;\n                (_a = window.MotionHandoffMarkAsComplete) === null || _a === void 0 ? void 0 : _a.call(window, optimisedAppearId);\n            });\n            wantsHandoff.current = false;\n        }\n    });\n    return visualElement;\n}\nfunction createProjectionNode(visualElement, props, ProjectionNodeConstructor, initialPromotionConfig) {\n    const { layoutId, layout, drag, dragConstraints, layoutScroll, layoutRoot } = props;\n    visualElement.projection = new ProjectionNodeConstructor(visualElement.latestValues, props[\"data-framer-portal-id\"] ? undefined : getClosestProjectingNode(visualElement.parent));\n    visualElement.projection.setOptions({\n        layoutId,\n        layout,\n        alwaysMeasureLayout: Boolean(drag) || dragConstraints && isRefObject(dragConstraints),\n        visualElement,\n        /**\n         * TODO: Update options in an effect. This could be tricky as it'll be too late\n         * to update by the time layout animations run.\n         * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,\n         * ensuring it gets called if there's no potential layout animations.\n         *\n         */ animationType: typeof layout === \"string\" ? layout : \"both\",\n        initialPromotionConfig,\n        layoutScroll,\n        layoutRoot\n    });\n}\nfunction getClosestProjectingNode(visualElement) {\n    if (!visualElement) return undefined;\n    return visualElement.options.allowProjection !== false ? visualElement.projection : getClosestProjectingNode(visualElement.parent);\n}\n/**\n * Creates a ref function that, when called, hydrates the provided\n * external ref and VisualElement.\n */ function useMotionRef(visualState, visualElement, externalRef) {\n    return React.useCallback((instance)=>{\n        instance && visualState.mount && visualState.mount(instance);\n        if (visualElement) {\n            if (instance) {\n                visualElement.mount(instance);\n            } else {\n                visualElement.unmount();\n            }\n        }\n        if (externalRef) {\n            if (typeof externalRef === \"function\") {\n                externalRef(instance);\n            } else if (isRefObject(externalRef)) {\n                externalRef.current = instance;\n            }\n        }\n    }, /**\n     * Only pass a new ref callback to React if we've received a visual element\n     * factory. Otherwise we'll be mounting/remounting every time externalRef\n     * or other dependencies change.\n     */ [\n        visualElement\n    ]);\n}\nfunction getCurrentTreeVariants(props, context) {\n    if (isControllingVariants(props)) {\n        const { initial, animate } = props;\n        return {\n            initial: initial === false || isVariantLabel(initial) ? initial : undefined,\n            animate: isVariantLabel(animate) ? animate : undefined\n        };\n    }\n    return props.inherit !== false ? context : {};\n}\nfunction useCreateMotionContext(props) {\n    const { initial, animate } = getCurrentTreeVariants(props, React.useContext(MotionContext));\n    return React.useMemo(()=>({\n            initial,\n            animate\n        }), [\n        variantLabelsAsDependency(initial),\n        variantLabelsAsDependency(animate)\n    ]);\n}\nfunction variantLabelsAsDependency(prop) {\n    return Array.isArray(prop) ? prop.join(\" \") : prop;\n}\nfunction loadFeatures(features) {\n    for(const key in features){\n        featureDefinitions[key] = {\n            ...featureDefinitions[key],\n            ...features[key]\n        };\n    }\n}\nconst motionComponentSymbol = Symbol.for(\"motionComponentSymbol\");\n/**\n * Create a `motion` component.\n *\n * This function accepts a Component argument, which can be either a string (ie \"div\"\n * for `motion.div`), or an actual React component.\n *\n * Alongside this is a config option which provides a way of rendering the provided\n * component \"offline\", or outside the React render cycle.\n */ function createRendererMotionComponent({ preloadedFeatures, createVisualElement, useRender, useVisualState, Component }) {\n    preloadedFeatures && loadFeatures(preloadedFeatures);\n    function MotionComponent(props, externalRef) {\n        /**\n         * If we need to measure the element we load this functionality in a\n         * separate class component in order to gain access to getSnapshotBeforeUpdate.\n         */ let MeasureLayout;\n        const configAndProps = {\n            ...React.useContext(MotionConfigContext),\n            ...props,\n            layoutId: useLayoutId(props)\n        };\n        const { isStatic } = configAndProps;\n        const context = useCreateMotionContext(props);\n        const visualState = useVisualState(props, isStatic);\n        if (!isStatic && isBrowser) {\n            useStrictMode(configAndProps, preloadedFeatures);\n            const layoutProjection = getProjectionFunctionality(configAndProps);\n            MeasureLayout = layoutProjection.MeasureLayout;\n            /**\n             * Create a VisualElement for this component. A VisualElement provides a common\n             * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as\n             * providing a way of rendering to these APIs outside of the React render loop\n             * for more performant animations and interactions\n             */ context.visualElement = useVisualElement(Component, visualState, configAndProps, createVisualElement, layoutProjection.ProjectionNode);\n        }\n        /**\n         * The mount order and hierarchy is specific to ensure our element ref\n         * is hydrated by the time features fire their effects.\n         */ return jsxRuntime.jsxs(MotionContext.Provider, {\n            value: context,\n            children: [\n                MeasureLayout && context.visualElement ? jsxRuntime.jsx(MeasureLayout, {\n                    visualElement: context.visualElement,\n                    ...configAndProps\n                }) : null,\n                useRender(Component, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, context.visualElement)\n            ]\n        });\n    }\n    const ForwardRefMotionComponent = React.forwardRef(MotionComponent);\n    ForwardRefMotionComponent[motionComponentSymbol] = Component;\n    return ForwardRefMotionComponent;\n}\nfunction useLayoutId({ layoutId }) {\n    const layoutGroupId = React.useContext(LayoutGroupContext).id;\n    return layoutGroupId && layoutId !== undefined ? layoutGroupId + \"-\" + layoutId : layoutId;\n}\nfunction useStrictMode(configAndProps, preloadedFeatures) {\n    const isStrict = React.useContext(LazyContext).strict;\n    /**\n     * If we're in development mode, check to make sure we're not rendering a motion component\n     * as a child of LazyMotion, as this will break the file-size benefits of using it.\n     */ if ( true && preloadedFeatures && isStrict) {\n        const strictMessage = \"You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.\";\n        configAndProps.ignoreStrict ? motionUtils.warning(false, strictMessage) : motionUtils.invariant(false, strictMessage);\n    }\n}\nfunction getProjectionFunctionality(props) {\n    const { drag, layout } = featureDefinitions;\n    if (!drag && !layout) return {};\n    const combined = {\n        ...drag,\n        ...layout\n    };\n    return {\n        MeasureLayout: (drag === null || drag === void 0 ? void 0 : drag.isEnabled(props)) || (layout === null || layout === void 0 ? void 0 : layout.isEnabled(props)) ? combined.MeasureLayout : undefined,\n        ProjectionNode: combined.ProjectionNode\n    };\n}\n/**\n * We keep these listed separately as we use the lowercase tag names as part\n * of the runtime bundle to detect SVG components\n */ const lowercaseSVGElements = [\n    \"animate\",\n    \"circle\",\n    \"defs\",\n    \"desc\",\n    \"ellipse\",\n    \"g\",\n    \"image\",\n    \"line\",\n    \"filter\",\n    \"marker\",\n    \"mask\",\n    \"metadata\",\n    \"path\",\n    \"pattern\",\n    \"polygon\",\n    \"polyline\",\n    \"rect\",\n    \"stop\",\n    \"switch\",\n    \"symbol\",\n    \"svg\",\n    \"text\",\n    \"tspan\",\n    \"use\",\n    \"view\"\n];\nfunction isSVGComponent(Component) {\n    if (/**\n     * If it's not a string, it's a custom React component. Currently we only support\n     * HTML custom React components.\n     */ typeof Component !== \"string\" || /**\n         * If it contains a dash, the element is a custom HTML webcomponent.\n         */ Component.includes(\"-\")) {\n        return false;\n    } else if (/**\n     * If it's in our list of lowercase SVG tags, it's an SVG component\n     */ lowercaseSVGElements.indexOf(Component) > -1 || /**\n         * If it contains a capital letter, it's an SVG component\n         */ /[A-Z]/u.test(Component)) {\n        return true;\n    }\n    return false;\n}\n/**\n * Creates a constant value over the lifecycle of a component.\n *\n * Even if `useMemo` is provided an empty array as its final argument, it doesn't offer\n * a guarantee that it won't re-run for performance reasons later on. By using `useConstant`\n * you can ensure that initialisers don't execute twice or more.\n */ function useConstant(init) {\n    const ref = React.useRef(null);\n    if (ref.current === null) {\n        ref.current = init();\n    }\n    return ref.current;\n}\nfunction makeState({ scrapeMotionValuesFromProps, createRenderState, onMount }, props, context, presenceContext) {\n    const state = {\n        latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps),\n        renderState: createRenderState()\n    };\n    if (onMount) {\n        state.mount = (instance)=>onMount(props, instance, state);\n    }\n    return state;\n}\nconst makeUseVisualState = (config)=>(props, isStatic)=>{\n        const context = React.useContext(MotionContext);\n        const presenceContext = React.useContext(PresenceContext);\n        const make = ()=>makeState(config, props, context, presenceContext);\n        return isStatic ? make() : useConstant(make);\n    };\nfunction makeLatestValues(props, context, presenceContext, scrapeMotionValues) {\n    const values = {};\n    const motionValues = scrapeMotionValues(props, {});\n    for(const key in motionValues){\n        values[key] = resolveMotionValue(motionValues[key]);\n    }\n    let { initial, animate } = props;\n    const isControllingVariants$1 = isControllingVariants(props);\n    const isVariantNode$1 = isVariantNode(props);\n    if (context && isVariantNode$1 && !isControllingVariants$1 && props.inherit !== false) {\n        if (initial === undefined) initial = context.initial;\n        if (animate === undefined) animate = context.animate;\n    }\n    let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === false : false;\n    isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;\n    const variantToSet = isInitialAnimationBlocked ? animate : initial;\n    if (variantToSet && typeof variantToSet !== \"boolean\" && !isAnimationControls(variantToSet)) {\n        const list = Array.isArray(variantToSet) ? variantToSet : [\n            variantToSet\n        ];\n        for(let i = 0; i < list.length; i++){\n            const resolved = resolveVariantFromProps(props, list[i]);\n            if (resolved) {\n                const { transitionEnd, transition, ...target } = resolved;\n                for(const key in target){\n                    let valueTarget = target[key];\n                    if (Array.isArray(valueTarget)) {\n                        /**\n                         * Take final keyframe if the initial animation is blocked because\n                         * we want to initialise at the end of that blocked animation.\n                         */ const index = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;\n                        valueTarget = valueTarget[index];\n                    }\n                    if (valueTarget !== null) {\n                        values[key] = valueTarget;\n                    }\n                }\n                for(const key in transitionEnd){\n                    values[key] = transitionEnd[key];\n                }\n            }\n        }\n    }\n    return values;\n}\nconst createHtmlRenderState = ()=>({\n        style: {},\n        transform: {},\n        transformOrigin: {},\n        vars: {}\n    });\nconst createSvgRenderState = ()=>({\n        ...createHtmlRenderState(),\n        attrs: {}\n    });\nconst svgMotionConfig = {\n    useVisualState: makeUseVisualState({\n        scrapeMotionValuesFromProps: scrapeMotionValuesFromProps,\n        createRenderState: createSvgRenderState,\n        onMount: (props, instance, { renderState, latestValues })=>{\n            frame.read(()=>{\n                try {\n                    renderState.dimensions = typeof instance.getBBox === \"function\" ? instance.getBBox() : instance.getBoundingClientRect();\n                } catch (e) {\n                    // Most likely trying to measure an unrendered element under Firefox\n                    renderState.dimensions = {\n                        x: 0,\n                        y: 0,\n                        width: 0,\n                        height: 0\n                    };\n                }\n            });\n            frame.render(()=>{\n                buildSVGAttrs(renderState, latestValues, isSVGTag(instance.tagName), props.transformTemplate);\n                renderSVG(instance, renderState);\n            });\n        }\n    })\n};\nconst htmlMotionConfig = {\n    useVisualState: makeUseVisualState({\n        scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,\n        createRenderState: createHtmlRenderState\n    })\n};\nfunction copyRawValuesOnly(target, source, props) {\n    for(const key in source){\n        if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {\n            target[key] = source[key];\n        }\n    }\n}\nfunction useInitialMotionValues({ transformTemplate }, visualState) {\n    return React.useMemo(()=>{\n        const state = createHtmlRenderState();\n        buildHTMLStyles(state, visualState, transformTemplate);\n        return Object.assign({}, state.vars, state.style);\n    }, [\n        visualState\n    ]);\n}\nfunction useStyle(props, visualState) {\n    const styleProp = props.style || {};\n    const style = {};\n    /**\n     * Copy non-Motion Values straight into style\n     */ copyRawValuesOnly(style, styleProp, props);\n    Object.assign(style, useInitialMotionValues(props, visualState));\n    return style;\n}\nfunction useHTMLProps(props, visualState) {\n    // The `any` isn't ideal but it is the type of createElement props argument\n    const htmlProps = {};\n    const style = useStyle(props, visualState);\n    if (props.drag && props.dragListener !== false) {\n        // Disable the ghost element when a user drags\n        htmlProps.draggable = false;\n        // Disable text selection\n        style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = \"none\";\n        // Disable scrolling on the draggable direction\n        style.touchAction = props.drag === true ? \"none\" : `pan-${props.drag === \"x\" ? \"y\" : \"x\"}`;\n    }\n    if (props.tabIndex === undefined && (props.onTap || props.onTapStart || props.whileTap)) {\n        htmlProps.tabIndex = 0;\n    }\n    htmlProps.style = style;\n    return htmlProps;\n}\n/**\n * A list of all valid MotionProps.\n *\n * @privateRemarks\n * This doesn't throw if a `MotionProp` name is missing - it should.\n */ const validMotionProps = new Set([\n    \"animate\",\n    \"exit\",\n    \"variants\",\n    \"initial\",\n    \"style\",\n    \"values\",\n    \"variants\",\n    \"transition\",\n    \"transformTemplate\",\n    \"custom\",\n    \"inherit\",\n    \"onBeforeLayoutMeasure\",\n    \"onAnimationStart\",\n    \"onAnimationComplete\",\n    \"onUpdate\",\n    \"onDragStart\",\n    \"onDrag\",\n    \"onDragEnd\",\n    \"onMeasureDragConstraints\",\n    \"onDirectionLock\",\n    \"onDragTransitionEnd\",\n    \"_dragX\",\n    \"_dragY\",\n    \"onHoverStart\",\n    \"onHoverEnd\",\n    \"onViewportEnter\",\n    \"onViewportLeave\",\n    \"globalTapTarget\",\n    \"ignoreStrict\",\n    \"viewport\"\n]);\n/**\n * Check whether a prop name is a valid `MotionProp` key.\n *\n * @param key - Name of the property to check\n * @returns `true` is key is a valid `MotionProp`.\n *\n * @public\n */ function isValidMotionProp(key) {\n    return key.startsWith(\"while\") || key.startsWith(\"drag\") && key !== \"draggable\" || key.startsWith(\"layout\") || key.startsWith(\"onTap\") || key.startsWith(\"onPan\") || key.startsWith(\"onLayout\") || validMotionProps.has(key);\n}\nlet shouldForward = (key)=>!isValidMotionProp(key);\nfunction loadExternalIsValidProp(isValidProp) {\n    if (!isValidProp) return;\n    // Explicitly filter our events\n    shouldForward = (key)=>key.startsWith(\"on\") ? !isValidMotionProp(key) : isValidProp(key);\n}\n/**\n * Emotion and Styled Components both allow users to pass through arbitrary props to their components\n * to dynamically generate CSS. They both use the `@emotion/is-prop-valid` package to determine which\n * of these should be passed to the underlying DOM node.\n *\n * However, when styling a Motion component `styled(motion.div)`, both packages pass through *all* props\n * as it's seen as an arbitrary component rather than a DOM node. Motion only allows arbitrary props\n * passed through the `custom` prop so it doesn't *need* the payload or computational overhead of\n * `@emotion/is-prop-valid`, however to fix this problem we need to use it.\n *\n * By making it an optionalDependency we can offer this functionality only in the situations where it's\n * actually required.\n */ try {\n    /**\n     * We attempt to import this package but require won't be defined in esm environments, in that case\n     * isPropValid will have to be provided via `MotionContext`. In a 6.0.0 this should probably be removed\n     * in favour of explicit injection.\n     */ loadExternalIsValidProp((__webpack_require__(/*! @emotion/is-prop-valid */ \"(ssr)/./node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.esm.js\")[\"default\"]));\n} catch (_a) {\n// We don't need to actually do anything here - the fallback is the existing `isPropValid`.\n}\nfunction filterProps(props, isDom, forwardMotionProps) {\n    const filteredProps = {};\n    for(const key in props){\n        /**\n         * values is considered a valid prop by Emotion, so if it's present\n         * this will be rendered out to the DOM unless explicitly filtered.\n         *\n         * We check the type as it could be used with the `feColorMatrix`\n         * element, which we support.\n         */ if (key === \"values\" && typeof props.values === \"object\") continue;\n        if (shouldForward(key) || forwardMotionProps === true && isValidMotionProp(key) || !isDom && !isValidMotionProp(key) || // If trying to use native HTML drag events, forward drag listeners\n        props[\"draggable\"] && key.startsWith(\"onDrag\")) {\n            filteredProps[key] = props[key];\n        }\n    }\n    return filteredProps;\n}\nfunction useSVGProps(props, visualState, _isStatic, Component) {\n    const visualProps = React.useMemo(()=>{\n        const state = createSvgRenderState();\n        buildSVGAttrs(state, visualState, isSVGTag(Component), props.transformTemplate);\n        return {\n            ...state.attrs,\n            style: {\n                ...state.style\n            }\n        };\n    }, [\n        visualState\n    ]);\n    if (props.style) {\n        const rawStyles = {};\n        copyRawValuesOnly(rawStyles, props.style, props);\n        visualProps.style = {\n            ...rawStyles,\n            ...visualProps.style\n        };\n    }\n    return visualProps;\n}\nfunction createUseRender(forwardMotionProps = false) {\n    const useRender = (Component, props, ref, { latestValues }, isStatic)=>{\n        const useVisualProps = isSVGComponent(Component) ? useSVGProps : useHTMLProps;\n        const visualProps = useVisualProps(props, latestValues, isStatic, Component);\n        const filteredProps = filterProps(props, typeof Component === \"string\", forwardMotionProps);\n        const elementProps = Component !== React.Fragment ? {\n            ...filteredProps,\n            ...visualProps,\n            ref\n        } : {};\n        /**\n         * If component has been handed a motion value as its child,\n         * memoise its initial value and render that. Subsequent updates\n         * will be handled by the onChange handler\n         */ const { children } = props;\n        const renderedChildren = React.useMemo(()=>isMotionValue(children) ? children.get() : children, [\n            children\n        ]);\n        return React.createElement(Component, {\n            ...elementProps,\n            children: renderedChildren\n        });\n    };\n    return useRender;\n}\nfunction createMotionComponentFactory(preloadedFeatures, createVisualElement) {\n    return function createMotionComponent(Component, { forwardMotionProps } = {\n        forwardMotionProps: false\n    }) {\n        const baseConfig = isSVGComponent(Component) ? svgMotionConfig : htmlMotionConfig;\n        const config = {\n            ...baseConfig,\n            preloadedFeatures,\n            useRender: createUseRender(forwardMotionProps),\n            createVisualElement,\n            Component\n        };\n        return createRendererMotionComponent(config);\n    };\n}\nconst createDomVisualElement = (Component, options)=>{\n    return isSVGComponent(Component) ? new SVGVisualElement(options) : new HTMLVisualElement(options, {\n        allowProjection: Component !== React.Fragment\n    });\n};\nconst createMotionComponent = /*@__PURE__*/ createMotionComponentFactory({\n    ...animations,\n    ...gestureAnimations,\n    ...drag,\n    ...layout\n}, createDomVisualElement);\nconst motion = /*@__PURE__*/ createDOMMotionComponentProxy(createMotionComponent);\nconst createMinimalMotionComponent = /*@__PURE__*/ createMotionComponentFactory();\nconst m = /*@__PURE__*/ createDOMMotionComponentProxy(createMinimalMotionComponent);\n/**\n * Measurement functionality has to be within a separate component\n * to leverage snapshot lifecycle.\n */ class PopChildMeasure extends React__namespace.Component {\n    getSnapshotBeforeUpdate(prevProps) {\n        const element = this.props.childRef.current;\n        if (element && prevProps.isPresent && !this.props.isPresent) {\n            const size = this.props.sizeRef.current;\n            size.height = element.offsetHeight || 0;\n            size.width = element.offsetWidth || 0;\n            size.top = element.offsetTop;\n            size.left = element.offsetLeft;\n        }\n        return null;\n    }\n    /**\n     * Required with getSnapshotBeforeUpdate to stop React complaining.\n     */ componentDidUpdate() {}\n    render() {\n        return this.props.children;\n    }\n}\nfunction PopChild({ children, isPresent }) {\n    const id = React.useId();\n    const ref = React.useRef(null);\n    const size = React.useRef({\n        width: 0,\n        height: 0,\n        top: 0,\n        left: 0\n    });\n    const { nonce } = React.useContext(MotionConfigContext);\n    /**\n     * We create and inject a style block so we can apply this explicit\n     * sizing in a non-destructive manner by just deleting the style block.\n     *\n     * We can't apply size via render as the measurement happens\n     * in getSnapshotBeforeUpdate (post-render), likewise if we apply the\n     * styles directly on the DOM node, we might be overwriting\n     * styles set via the style prop.\n     */ React.useInsertionEffect(()=>{\n        const { width, height, top, left } = size.current;\n        if (isPresent || !ref.current || !width || !height) return;\n        ref.current.dataset.motionPopId = id;\n        const style = document.createElement(\"style\");\n        if (nonce) style.nonce = nonce;\n        document.head.appendChild(style);\n        if (style.sheet) {\n            style.sheet.insertRule(`\n          [data-motion-pop-id=\"${id}\"] {\n            position: absolute !important;\n            width: ${width}px !important;\n            height: ${height}px !important;\n            top: ${top}px !important;\n            left: ${left}px !important;\n          }\n        `);\n        }\n        return ()=>{\n            document.head.removeChild(style);\n        };\n    }, [\n        isPresent\n    ]);\n    return jsxRuntime.jsx(PopChildMeasure, {\n        isPresent: isPresent,\n        childRef: ref,\n        sizeRef: size,\n        children: React__namespace.cloneElement(children, {\n            ref\n        })\n    });\n}\nconst PresenceChild = ({ children, initial, isPresent, onExitComplete, custom, presenceAffectsLayout, mode })=>{\n    const presenceChildren = useConstant(newChildrenMap);\n    const id = React.useId();\n    const memoizedOnExitComplete = React.useCallback((childId)=>{\n        presenceChildren.set(childId, true);\n        for (const isComplete of presenceChildren.values()){\n            if (!isComplete) return; // can stop searching when any is incomplete\n        }\n        onExitComplete && onExitComplete();\n    }, [\n        presenceChildren,\n        onExitComplete\n    ]);\n    const context = React.useMemo(()=>({\n            id,\n            initial,\n            isPresent,\n            custom,\n            onExitComplete: memoizedOnExitComplete,\n            register: (childId)=>{\n                presenceChildren.set(childId, false);\n                return ()=>presenceChildren.delete(childId);\n            }\n        }), /**\n     * If the presence of a child affects the layout of the components around it,\n     * we want to make a new context value to ensure they get re-rendered\n     * so they can detect that layout change.\n     */ presenceAffectsLayout ? [\n        Math.random(),\n        memoizedOnExitComplete\n    ] : [\n        isPresent,\n        memoizedOnExitComplete\n    ]);\n    React.useMemo(()=>{\n        presenceChildren.forEach((_, key)=>presenceChildren.set(key, false));\n    }, [\n        isPresent\n    ]);\n    /**\n     * If there's no `motion` components to fire exit animations, we want to remove this\n     * component immediately.\n     */ React__namespace.useEffect(()=>{\n        !isPresent && !presenceChildren.size && onExitComplete && onExitComplete();\n    }, [\n        isPresent\n    ]);\n    if (mode === \"popLayout\") {\n        children = jsxRuntime.jsx(PopChild, {\n            isPresent: isPresent,\n            children: children\n        });\n    }\n    return jsxRuntime.jsx(PresenceContext.Provider, {\n        value: context,\n        children: children\n    });\n};\nfunction newChildrenMap() {\n    return new Map();\n}\nfunction useUnmountEffect(callback) {\n    return React.useEffect(()=>()=>callback(), []);\n}\nfunction useIsMounted() {\n    const isMounted = React.useRef(false);\n    useIsomorphicLayoutEffect(()=>{\n        isMounted.current = true;\n        return ()=>{\n            isMounted.current = false;\n        };\n    }, []);\n    return isMounted;\n}\nfunction useForceUpdate() {\n    const isMounted = useIsMounted();\n    const [forcedRenderCount, setForcedRenderCount] = React.useState(0);\n    const forceRender = React.useCallback(()=>{\n        isMounted.current && setForcedRenderCount(forcedRenderCount + 1);\n    }, [\n        forcedRenderCount\n    ]);\n    /**\n     * Defer this to the end of the next animation frame in case there are multiple\n     * synchronous calls.\n     */ const deferredForceRender = React.useCallback(()=>frame.postRender(forceRender), [\n        forceRender\n    ]);\n    return [\n        deferredForceRender,\n        forcedRenderCount\n    ];\n}\nconst getChildKey = (child)=>child.key || \"\";\nfunction onlyElements(children) {\n    const filtered = [];\n    // We use forEach here instead of map as map mutates the component key by preprending `.$`\n    React.Children.forEach(children, (child)=>{\n        if (React.isValidElement(child)) filtered.push(child);\n    });\n    return filtered;\n}\n/**\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\n *\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\n *\n * Any `motion` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { motion, AnimatePresence } from 'framer-motion'\n *\n * export const Items = ({ items }) => (\n *   <AnimatePresence>\n *     {items.map(item => (\n *       <motion.div\n *         key={item.id}\n *         initial={{ opacity: 0 }}\n *         animate={{ opacity: 1 }}\n *         exit={{ opacity: 0 }}\n *       />\n *     ))}\n *   </AnimatePresence>\n * )\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\n * once all `motion` components have finished animating out. Likewise, any components using\n * `usePresence` all need to call `safeToRemove`.\n *\n * @public\n */ const AnimatePresence = ({ children, exitBeforeEnter, custom, initial = true, onExitComplete, presenceAffectsLayout = true, mode = \"sync\" })=>{\n    motionUtils.invariant(!exitBeforeEnter, \"Replace exitBeforeEnter with mode='wait'\");\n    /**\n     * Filter any children that aren't ReactElements. We can only track components\n     * between renders with a props.key.\n     */ const presentChildren = React.useMemo(()=>onlyElements(children), [\n        children\n    ]);\n    /**\n     * Track the keys of the currently rendered children. This is used to\n     * determine which children are exiting.\n     */ const presentKeys = presentChildren.map(getChildKey);\n    /**\n     * If `initial={false}` we only want to pass this to components in the first render.\n     */ const isInitialRender = React.useRef(true);\n    /**\n     * A ref containing the currently present children. When all exit animations\n     * are complete, we use this to re-render the component with the latest children\n     * *committed* rather than the latest children *rendered*.\n     */ const pendingPresentChildren = React.useRef(presentChildren);\n    /**\n     * Track which exiting children have finished animating out.\n     */ const exitComplete = useConstant(()=>new Map());\n    /**\n     * Save children to render as React state. To ensure this component is concurrent-safe,\n     * we check for exiting children via an effect.\n     */ const [diffedChildren, setDiffedChildren] = React.useState(presentChildren);\n    const [renderedChildren, setRenderedChildren] = React.useState(presentChildren);\n    useIsomorphicLayoutEffect(()=>{\n        isInitialRender.current = false;\n        pendingPresentChildren.current = presentChildren;\n        /**\n         * Update complete status of exiting children.\n         */ for(let i = 0; i < renderedChildren.length; i++){\n            const key = getChildKey(renderedChildren[i]);\n            if (!presentKeys.includes(key)) {\n                if (exitComplete.get(key) !== true) {\n                    exitComplete.set(key, false);\n                }\n            } else {\n                exitComplete.delete(key);\n            }\n        }\n    }, [\n        renderedChildren,\n        presentKeys.length,\n        presentKeys.join(\"-\")\n    ]);\n    const exitingChildren = [];\n    if (presentChildren !== diffedChildren) {\n        let nextChildren = [\n            ...presentChildren\n        ];\n        /**\n         * Loop through all the currently rendered components and decide which\n         * are exiting.\n         */ for(let i = 0; i < renderedChildren.length; i++){\n            const child = renderedChildren[i];\n            const key = getChildKey(child);\n            if (!presentKeys.includes(key)) {\n                nextChildren.splice(i, 0, child);\n                exitingChildren.push(child);\n            }\n        }\n        /**\n         * If we're in \"wait\" mode, and we have exiting children, we want to\n         * only render these until they've all exited.\n         */ if (mode === \"wait\" && exitingChildren.length) {\n            nextChildren = exitingChildren;\n        }\n        setRenderedChildren(onlyElements(nextChildren));\n        setDiffedChildren(presentChildren);\n        /**\n         * Early return to ensure once we've set state with the latest diffed\n         * children, we can immediately re-render.\n         */ return;\n    }\n    if ( true && mode === \"wait\" && renderedChildren.length > 1) {\n        console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to \"wait\". This will lead to odd visual behaviour.`);\n    }\n    /**\n     * If we've been provided a forceRender function by the LayoutGroupContext,\n     * we can use it to force a re-render amongst all surrounding components once\n     * all components have finished animating out.\n     */ const { forceRender } = React.useContext(LayoutGroupContext);\n    return jsxRuntime.jsx(jsxRuntime.Fragment, {\n        children: renderedChildren.map((child)=>{\n            const key = getChildKey(child);\n            const isPresent = presentChildren === renderedChildren || presentKeys.includes(key);\n            const onExit = ()=>{\n                if (exitComplete.has(key)) {\n                    exitComplete.set(key, true);\n                } else {\n                    return;\n                }\n                let isEveryExitComplete = true;\n                exitComplete.forEach((isExitComplete)=>{\n                    if (!isExitComplete) isEveryExitComplete = false;\n                });\n                if (isEveryExitComplete) {\n                    forceRender === null || forceRender === void 0 ? void 0 : forceRender();\n                    setRenderedChildren(pendingPresentChildren.current);\n                    onExitComplete && onExitComplete();\n                }\n            };\n            return jsxRuntime.jsx(PresenceChild, {\n                isPresent: isPresent,\n                initial: !isInitialRender.current || initial ? undefined : false,\n                custom: isPresent ? undefined : custom,\n                presenceAffectsLayout: presenceAffectsLayout,\n                mode: mode,\n                onExitComplete: isPresent ? undefined : onExit,\n                children: child\n            }, key);\n        })\n    });\n};\n/**\n * `MotionConfig` is used to set configuration options for all children `motion` components.\n *\n * ```jsx\n * import { motion, MotionConfig } from \"framer-motion\"\n *\n * export function App() {\n *   return (\n *     <MotionConfig transition={{ type: \"spring\" }}>\n *       <motion.div animate={{ x: 100 }} />\n *     </MotionConfig>\n *   )\n * }\n * ```\n *\n * @public\n */ function MotionConfig({ children, isValidProp, ...config }) {\n    isValidProp && loadExternalIsValidProp(isValidProp);\n    /**\n     * Inherit props from any parent MotionConfig components\n     */ config = {\n        ...React.useContext(MotionConfigContext),\n        ...config\n    };\n    /**\n     * Don't allow isStatic to change between renders as it affects how many hooks\n     * motion components fire.\n     */ config.isStatic = useConstant(()=>config.isStatic);\n    /**\n     * Creating a new config context object will re-render every `motion` component\n     * every time it renders. So we only want to create a new one sparingly.\n     */ const context = React.useMemo(()=>config, [\n        JSON.stringify(config.transition),\n        config.transformPagePoint,\n        config.reducedMotion\n    ]);\n    return jsxRuntime.jsx(MotionConfigContext.Provider, {\n        value: context,\n        children: children\n    });\n}\n/**\n * Used in conjunction with the `m` component to reduce bundle size.\n *\n * `m` is a version of the `motion` component that only loads functionality\n * critical for the initial render.\n *\n * `LazyMotion` can then be used to either synchronously or asynchronously\n * load animation and gesture support.\n *\n * ```jsx\n * // Synchronous loading\n * import { LazyMotion, m, domAnimation } from \"framer-motion\"\n *\n * function App() {\n *   return (\n *     <LazyMotion features={domAnimation}>\n *       <m.div animate={{ scale: 2 }} />\n *     </LazyMotion>\n *   )\n * }\n *\n * // Asynchronous loading\n * import { LazyMotion, m } from \"framer-motion\"\n *\n * function App() {\n *   return (\n *     <LazyMotion features={() => import('./path/to/domAnimation')}>\n *       <m.div animate={{ scale: 2 }} />\n *     </LazyMotion>\n *   )\n * }\n * ```\n *\n * @public\n */ function LazyMotion({ children, features, strict = false }) {\n    const [, setIsLoaded] = React.useState(!isLazyBundle(features));\n    const loadedRenderer = React.useRef(undefined);\n    /**\n     * If this is a synchronous load, load features immediately\n     */ if (!isLazyBundle(features)) {\n        const { renderer, ...loadedFeatures } = features;\n        loadedRenderer.current = renderer;\n        loadFeatures(loadedFeatures);\n    }\n    React.useEffect(()=>{\n        if (isLazyBundle(features)) {\n            features().then(({ renderer, ...loadedFeatures })=>{\n                loadFeatures(loadedFeatures);\n                loadedRenderer.current = renderer;\n                setIsLoaded(true);\n            });\n        }\n    }, []);\n    return jsxRuntime.jsx(LazyContext.Provider, {\n        value: {\n            renderer: loadedRenderer.current,\n            strict\n        },\n        children: children\n    });\n}\nfunction isLazyBundle(features) {\n    return typeof features === \"function\";\n}\n/**\n * Note: Still used by components generated by old versions of Framer\n *\n * @deprecated\n */ const DeprecatedLayoutGroupContext = React.createContext(null);\nconst shouldInheritGroup = (inherit)=>inherit === true;\nconst shouldInheritId = (inherit)=>shouldInheritGroup(inherit === true) || inherit === \"id\";\nconst LayoutGroup = ({ children, id, inherit = true })=>{\n    const layoutGroupContext = React.useContext(LayoutGroupContext);\n    const deprecatedLayoutGroupContext = React.useContext(DeprecatedLayoutGroupContext);\n    const [forceRender, key] = useForceUpdate();\n    const context = React.useRef(null);\n    const upstreamId = layoutGroupContext.id || deprecatedLayoutGroupContext;\n    if (context.current === null) {\n        if (shouldInheritId(inherit) && upstreamId) {\n            id = id ? upstreamId + \"-\" + id : upstreamId;\n        }\n        context.current = {\n            id,\n            group: shouldInheritGroup(inherit) ? layoutGroupContext.group || nodeGroup() : nodeGroup()\n        };\n    }\n    const memoizedContext = React.useMemo(()=>({\n            ...context.current,\n            forceRender\n        }), [\n        key\n    ]);\n    return jsxRuntime.jsx(LayoutGroupContext.Provider, {\n        value: memoizedContext,\n        children: children\n    });\n};\nconst ReorderContext = React.createContext(null);\nfunction checkReorder(order, value, offset, velocity) {\n    if (!velocity) return order;\n    const index = order.findIndex((item)=>item.value === value);\n    if (index === -1) return order;\n    const nextOffset = velocity > 0 ? 1 : -1;\n    const nextItem = order[index + nextOffset];\n    if (!nextItem) return order;\n    const item = order[index];\n    const nextLayout = nextItem.layout;\n    const nextItemCenter = mixNumber$1(nextLayout.min, nextLayout.max, 0.5);\n    if (nextOffset === 1 && item.layout.max + offset > nextItemCenter || nextOffset === -1 && item.layout.min + offset < nextItemCenter) {\n        return moveItem(order, index, index + nextOffset);\n    }\n    return order;\n}\nfunction ReorderGroupComponent({ children, as = \"ul\", axis = \"y\", onReorder, values, ...props }, externalRef) {\n    const Component = useConstant(()=>motion[as]);\n    const order = [];\n    const isReordering = React.useRef(false);\n    motionUtils.invariant(Boolean(values), \"Reorder.Group must be provided a values prop\");\n    const context = {\n        axis,\n        registerItem: (value, layout)=>{\n            // If the entry was already added, update it rather than adding it again\n            const idx = order.findIndex((entry)=>value === entry.value);\n            if (idx !== -1) {\n                order[idx].layout = layout[axis];\n            } else {\n                order.push({\n                    value: value,\n                    layout: layout[axis]\n                });\n            }\n            order.sort(compareMin);\n        },\n        updateOrder: (item, offset, velocity)=>{\n            if (isReordering.current) return;\n            const newOrder = checkReorder(order, item, offset, velocity);\n            if (order !== newOrder) {\n                isReordering.current = true;\n                onReorder(newOrder.map(getValue).filter((value)=>values.indexOf(value) !== -1));\n            }\n        }\n    };\n    React.useEffect(()=>{\n        isReordering.current = false;\n    });\n    return jsxRuntime.jsx(Component, {\n        ...props,\n        ref: externalRef,\n        ignoreStrict: true,\n        children: jsxRuntime.jsx(ReorderContext.Provider, {\n            value: context,\n            children: children\n        })\n    });\n}\nconst ReorderGroup = /*@__PURE__*/ React.forwardRef(ReorderGroupComponent);\nfunction getValue(item) {\n    return item.value;\n}\nfunction compareMin(a, b) {\n    return a.layout.min - b.layout.min;\n}\n/**\n * Creates a `MotionValue` to track the state and velocity of a value.\n *\n * Usually, these are created automatically. For advanced use-cases, like use with `useTransform`, you can create `MotionValue`s externally and pass them into the animated component via the `style` prop.\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const scale = useMotionValue(1)\n *\n *   return <motion.div style={{ scale }} />\n * }\n * ```\n *\n * @param initial - The initial state.\n *\n * @public\n */ function useMotionValue(initial) {\n    const value = useConstant(()=>motionValue(initial));\n    /**\n     * If this motion value is being used in static mode, like on\n     * the Framer canvas, force components to rerender when the motion\n     * value is updated.\n     */ const { isStatic } = React.useContext(MotionConfigContext);\n    if (isStatic) {\n        const [, setLatest] = React.useState(initial);\n        React.useEffect(()=>value.on(\"change\", setLatest), []);\n    }\n    return value;\n}\nfunction useCombineMotionValues(values, combineValues) {\n    /**\n     * Initialise the returned motion value. This remains the same between renders.\n     */ const value = useMotionValue(combineValues());\n    /**\n     * Create a function that will update the template motion value with the latest values.\n     * This is pre-bound so whenever a motion value updates it can schedule its\n     * execution in Framesync. If it's already been scheduled it won't be fired twice\n     * in a single frame.\n     */ const updateValue = ()=>value.set(combineValues());\n    /**\n     * Synchronously update the motion value with the latest values during the render.\n     * This ensures that within a React render, the styles applied to the DOM are up-to-date.\n     */ updateValue();\n    /**\n     * Subscribe to all motion values found within the template. Whenever any of them change,\n     * schedule an update.\n     */ useIsomorphicLayoutEffect(()=>{\n        const scheduleUpdate = ()=>frame.preRender(updateValue, false, true);\n        const subscriptions = values.map((v)=>v.on(\"change\", scheduleUpdate));\n        return ()=>{\n            subscriptions.forEach((unsubscribe)=>unsubscribe());\n            cancelFrame(updateValue);\n        };\n    });\n    return value;\n}\nfunction useComputed(compute) {\n    /**\n     * Open session of collectMotionValues. Any MotionValue that calls get()\n     * will be saved into this array.\n     */ collectMotionValues.current = [];\n    compute();\n    const value = useCombineMotionValues(collectMotionValues.current, compute);\n    /**\n     * Synchronously close session of collectMotionValues.\n     */ collectMotionValues.current = undefined;\n    return value;\n}\nfunction useTransform(input, inputRangeOrTransformer, outputRange, options) {\n    if (typeof input === \"function\") {\n        return useComputed(input);\n    }\n    const transformer = typeof inputRangeOrTransformer === \"function\" ? inputRangeOrTransformer : transform(inputRangeOrTransformer, outputRange, options);\n    return Array.isArray(input) ? useListTransform(input, transformer) : useListTransform([\n        input\n    ], ([latest])=>transformer(latest));\n}\nfunction useListTransform(values, transformer) {\n    const latest = useConstant(()=>[]);\n    return useCombineMotionValues(values, ()=>{\n        latest.length = 0;\n        const numValues = values.length;\n        for(let i = 0; i < numValues; i++){\n            latest[i] = values[i].get();\n        }\n        return transformer(latest);\n    });\n}\nfunction useDefaultMotionValue(value, defaultValue = 0) {\n    return isMotionValue(value) ? value : useMotionValue(defaultValue);\n}\nfunction ReorderItemComponent({ children, style = {}, value, as = \"li\", onDrag, layout = true, ...props }, externalRef) {\n    const Component = useConstant(()=>motion[as]);\n    const context = React.useContext(ReorderContext);\n    const point = {\n        x: useDefaultMotionValue(style.x),\n        y: useDefaultMotionValue(style.y)\n    };\n    const zIndex = useTransform([\n        point.x,\n        point.y\n    ], ([latestX, latestY])=>latestX || latestY ? 1 : \"unset\");\n    motionUtils.invariant(Boolean(context), \"Reorder.Item must be a child of Reorder.Group\");\n    const { axis, registerItem, updateOrder } = context;\n    return jsxRuntime.jsx(Component, {\n        drag: axis,\n        ...props,\n        dragSnapToOrigin: true,\n        style: {\n            ...style,\n            x: point.x,\n            y: point.y,\n            zIndex\n        },\n        layout: layout,\n        onDrag: (event, gesturePoint)=>{\n            const { velocity } = gesturePoint;\n            velocity[axis] && updateOrder(value, point[axis].get(), velocity[axis]);\n            onDrag && onDrag(event, gesturePoint);\n        },\n        onLayoutMeasure: (measured)=>registerItem(value, measured),\n        ref: externalRef,\n        ignoreStrict: true,\n        children: children\n    });\n}\nconst ReorderItem = /*@__PURE__*/ React.forwardRef(ReorderItemComponent);\nvar namespace = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    Group: ReorderGroup,\n    Item: ReorderItem\n});\n/**\n * @public\n */ const domMin = {\n    renderer: createDomVisualElement,\n    ...animations\n};\n/**\n * @public\n */ const domAnimation = {\n    renderer: createDomVisualElement,\n    ...animations,\n    ...gestureAnimations\n};\n/**\n * @public\n */ const domMax = {\n    ...domAnimation,\n    ...drag,\n    ...layout\n};\n/**\n * Combine multiple motion values into a new one using a string template literal.\n *\n * ```jsx\n * import {\n *   motion,\n *   useSpring,\n *   useMotionValue,\n *   useMotionTemplate\n * } from \"framer-motion\"\n *\n * function Component() {\n *   const shadowX = useSpring(0)\n *   const shadowY = useMotionValue(0)\n *   const shadow = useMotionTemplate`drop-shadow(${shadowX}px ${shadowY}px 20px rgba(0,0,0,0.3))`\n *\n *   return <motion.div style={{ filter: shadow }} />\n * }\n * ```\n *\n * @public\n */ function useMotionTemplate(fragments, ...values) {\n    /**\n     * Create a function that will build a string from the latest motion values.\n     */ const numFragments = fragments.length;\n    function buildValue() {\n        let output = ``;\n        for(let i = 0; i < numFragments; i++){\n            output += fragments[i];\n            const value = values[i];\n            if (value) {\n                output += isMotionValue(value) ? value.get() : value;\n            }\n        }\n        return output;\n    }\n    return useCombineMotionValues(values.filter(isMotionValue), buildValue);\n}\nfunction toNumber(v) {\n    if (typeof v === \"number\") return v;\n    return parseFloat(v);\n}\n/**\n * Creates a `MotionValue` that, when `set`, will use a spring animation to animate to its new state.\n *\n * It can either work as a stand-alone `MotionValue` by initialising it with a value, or as a subscriber\n * to another `MotionValue`.\n *\n * @remarks\n *\n * ```jsx\n * const x = useSpring(0, { stiffness: 300 })\n * const y = useSpring(x, { damping: 10 })\n * ```\n *\n * @param inputValue - `MotionValue` or number. If provided a `MotionValue`, when the input `MotionValue` changes, the created `MotionValue` will spring towards that value.\n * @param springConfig - Configuration options for the spring.\n * @returns `MotionValue`\n *\n * @public\n */ function useSpring(source, config = {}) {\n    const { isStatic } = React.useContext(MotionConfigContext);\n    const activeSpringAnimation = React.useRef(null);\n    const value = useMotionValue(isMotionValue(source) ? toNumber(source.get()) : source);\n    const latestValue = React.useRef(value.get());\n    const latestSetter = React.useRef(()=>{});\n    const startAnimation = ()=>{\n        /**\n         * If the previous animation hasn't had the chance to even render a frame, render it now.\n         */ const animation = activeSpringAnimation.current;\n        if (animation && animation.time === 0) {\n            animation.sample(frameData.delta);\n        }\n        stopAnimation();\n        activeSpringAnimation.current = animateValue({\n            keyframes: [\n                value.get(),\n                latestValue.current\n            ],\n            velocity: value.getVelocity(),\n            type: \"spring\",\n            restDelta: 0.001,\n            restSpeed: 0.01,\n            ...config,\n            onUpdate: latestSetter.current\n        });\n    };\n    const stopAnimation = ()=>{\n        if (activeSpringAnimation.current) {\n            activeSpringAnimation.current.stop();\n        }\n    };\n    React.useInsertionEffect(()=>{\n        return value.attach((v, set)=>{\n            /**\n             * A more hollistic approach to this might be to use isStatic to fix VisualElement animations\n             * at that level, but this will work for now\n             */ if (isStatic) return set(v);\n            latestValue.current = v;\n            latestSetter.current = set;\n            frame.update(startAnimation);\n            return value.get();\n        }, stopAnimation);\n    }, [\n        JSON.stringify(config)\n    ]);\n    useIsomorphicLayoutEffect(()=>{\n        if (isMotionValue(source)) {\n            return source.on(\"change\", (v)=>value.set(toNumber(v)));\n        }\n    }, [\n        value\n    ]);\n    return value;\n}\nfunction useMotionValueEvent(value, event, callback) {\n    /**\n     * useInsertionEffect will create subscriptions before any other\n     * effects will run. Effects run upwards through the tree so it\n     * can be that binding a useLayoutEffect higher up the tree can\n     * miss changes from lower down the tree.\n     */ React.useInsertionEffect(()=>value.on(event, callback), [\n        value,\n        event,\n        callback\n    ]);\n}\n/**\n * Creates a `MotionValue` that updates when the velocity of the provided `MotionValue` changes.\n *\n * ```javascript\n * const x = useMotionValue(0)\n * const xVelocity = useVelocity(x)\n * const xAcceleration = useVelocity(xVelocity)\n * ```\n *\n * @public\n */ function useVelocity(value) {\n    const velocity = useMotionValue(value.getVelocity());\n    const updateVelocity = ()=>{\n        const latest = value.getVelocity();\n        velocity.set(latest);\n        /**\n         * If we still have velocity, schedule an update for the next frame\n         * to keep checking until it is zero.\n         */ if (latest) frame.update(updateVelocity);\n    };\n    useMotionValueEvent(value, \"change\", ()=>{\n        // Schedule an update to this value at the end of the current frame.\n        frame.update(updateVelocity, false, true);\n    });\n    return velocity;\n}\nfunction refWarning(name, ref) {\n    motionUtils.warning(Boolean(!ref || ref.current), `You have defined a ${name} options but the provided ref is not yet hydrated, probably because it's defined higher up the tree. Try calling useScroll() in the same component as the ref, or setting its \\`layoutEffect: false\\` option.`);\n}\nconst createScrollMotionValues = ()=>({\n        scrollX: motionValue(0),\n        scrollY: motionValue(0),\n        scrollXProgress: motionValue(0),\n        scrollYProgress: motionValue(0)\n    });\nfunction useScroll({ container, target, layoutEffect = true, ...options } = {}) {\n    const values = useConstant(createScrollMotionValues);\n    const useLifecycleEffect = layoutEffect ? useIsomorphicLayoutEffect : React.useEffect;\n    useLifecycleEffect(()=>{\n        refWarning(\"target\", target);\n        refWarning(\"container\", container);\n        return scroll((_progress, { x, y })=>{\n            values.scrollX.set(x.current);\n            values.scrollXProgress.set(x.progress);\n            values.scrollY.set(y.current);\n            values.scrollYProgress.set(y.progress);\n        }, {\n            ...options,\n            container: (container === null || container === void 0 ? void 0 : container.current) || undefined,\n            target: (target === null || target === void 0 ? void 0 : target.current) || undefined\n        });\n    }, [\n        container,\n        target,\n        JSON.stringify(options.offset)\n    ]);\n    return values;\n}\n/**\n * @deprecated useElementScroll is deprecated. Convert to useScroll({ container: ref })\n */ function useElementScroll(ref) {\n    if (true) {\n        warnOnce(false, \"useElementScroll is deprecated. Convert to useScroll({ container: ref }).\");\n    }\n    return useScroll({\n        container: ref\n    });\n}\n/**\n * @deprecated useViewportScroll is deprecated. Convert to useScroll()\n */ function useViewportScroll() {\n    if (true) {\n        warnOnce(false, \"useViewportScroll is deprecated. Convert to useScroll().\");\n    }\n    return useScroll();\n}\nfunction useAnimationFrame(callback) {\n    const initialTimestamp = React.useRef(0);\n    const { isStatic } = React.useContext(MotionConfigContext);\n    React.useEffect(()=>{\n        if (isStatic) return;\n        const provideTimeSinceStart = ({ timestamp, delta })=>{\n            if (!initialTimestamp.current) initialTimestamp.current = timestamp;\n            callback(timestamp - initialTimestamp.current, delta);\n        };\n        frame.update(provideTimeSinceStart, true);\n        return ()=>cancelFrame(provideTimeSinceStart);\n    }, [\n        callback\n    ]);\n}\nfunction useTime() {\n    const time = useMotionValue(0);\n    useAnimationFrame((t)=>time.set(t));\n    return time;\n}\nfunction getWillChangeName(name) {\n    if (transformProps.has(name)) {\n        return \"transform\";\n    } else if (acceleratedValues.has(name)) {\n        return camelToDash(name);\n    }\n}\nclass WillChangeMotionValue extends MotionValue {\n    constructor(){\n        super(...arguments);\n        this.values = [];\n    }\n    add(name) {\n        const styleName = getWillChangeName(name);\n        if (styleName) {\n            addUniqueItem(this.values, styleName);\n            this.update();\n        }\n    }\n    update() {\n        this.set(this.values.length ? this.values.join(\", \") : \"auto\");\n    }\n}\nfunction useWillChange() {\n    return useConstant(()=>new WillChangeMotionValue(\"auto\"));\n}\n/**\n * A hook that returns `true` if we should be using reduced motion based on the current device's Reduced Motion setting.\n *\n * This can be used to implement changes to your UI based on Reduced Motion. For instance, replacing motion-sickness inducing\n * `x`/`y` animations with `opacity`, disabling the autoplay of background videos, or turning off parallax motion.\n *\n * It will actively respond to changes and re-render your components with the latest setting.\n *\n * ```jsx\n * export function Sidebar({ isOpen }) {\n *   const shouldReduceMotion = useReducedMotion()\n *   const closedX = shouldReduceMotion ? 0 : \"-100%\"\n *\n *   return (\n *     <motion.div animate={{\n *       opacity: isOpen ? 1 : 0,\n *       x: isOpen ? 0 : closedX\n *     }} />\n *   )\n * }\n * ```\n *\n * @return boolean\n *\n * @public\n */ function useReducedMotion() {\n    /**\n     * Lazy initialisation of prefersReducedMotion\n     */ !hasReducedMotionListener.current && initPrefersReducedMotion();\n    const [shouldReduceMotion] = React.useState(prefersReducedMotion.current);\n    if (true) {\n        warnOnce(shouldReduceMotion !== true, \"You have Reduced Motion enabled on your device. Animations may not appear as expected.\");\n    }\n    /**\n     * TODO See if people miss automatically updating shouldReduceMotion setting\n     */ return shouldReduceMotion;\n}\nfunction useReducedMotionConfig() {\n    const reducedMotionPreference = useReducedMotion();\n    const { reducedMotion } = React.useContext(MotionConfigContext);\n    if (reducedMotion === \"never\") {\n        return false;\n    } else if (reducedMotion === \"always\") {\n        return true;\n    } else {\n        return reducedMotionPreference;\n    }\n}\nfunction stopAnimation(visualElement) {\n    visualElement.values.forEach((value)=>value.stop());\n}\nfunction setVariants(visualElement, variantLabels) {\n    const reversedLabels = [\n        ...variantLabels\n    ].reverse();\n    reversedLabels.forEach((key)=>{\n        const variant = visualElement.getVariant(key);\n        variant && setTarget(visualElement, variant);\n        if (visualElement.variantChildren) {\n            visualElement.variantChildren.forEach((child)=>{\n                setVariants(child, variantLabels);\n            });\n        }\n    });\n}\nfunction setValues(visualElement, definition) {\n    if (Array.isArray(definition)) {\n        return setVariants(visualElement, definition);\n    } else if (typeof definition === \"string\") {\n        return setVariants(visualElement, [\n            definition\n        ]);\n    } else {\n        setTarget(visualElement, definition);\n    }\n}\n/**\n * @public\n */ function animationControls() {\n    /**\n     * Track whether the host component has mounted.\n     */ let hasMounted = false;\n    /**\n     * A collection of linked component animation controls.\n     */ const subscribers = new Set();\n    const controls = {\n        subscribe (visualElement) {\n            subscribers.add(visualElement);\n            return ()=>void subscribers.delete(visualElement);\n        },\n        start (definition, transitionOverride) {\n            motionUtils.invariant(hasMounted, \"controls.start() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n            const animations = [];\n            subscribers.forEach((visualElement)=>{\n                animations.push(animateVisualElement(visualElement, definition, {\n                    transitionOverride\n                }));\n            });\n            return Promise.all(animations);\n        },\n        set (definition) {\n            motionUtils.invariant(hasMounted, \"controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n            return subscribers.forEach((visualElement)=>{\n                setValues(visualElement, definition);\n            });\n        },\n        stop () {\n            subscribers.forEach((visualElement)=>{\n                stopAnimation(visualElement);\n            });\n        },\n        mount () {\n            hasMounted = true;\n            return ()=>{\n                hasMounted = false;\n                controls.stop();\n            };\n        }\n    };\n    return controls;\n}\nfunction useAnimate() {\n    const scope = useConstant(()=>({\n            current: null,\n            animations: []\n        }));\n    const animate = useConstant(()=>createScopedAnimate(scope));\n    useUnmountEffect(()=>{\n        scope.animations.forEach((animation)=>animation.stop());\n    });\n    return [\n        scope,\n        animate\n    ];\n}\nfunction useAnimateMini() {\n    const scope = useConstant(()=>({\n            current: null,\n            animations: []\n        }));\n    const animate = useConstant(()=>createScopedWaapiAnimate(scope));\n    useUnmountEffect(()=>{\n        scope.animations.forEach((animation)=>animation.stop());\n    });\n    return [\n        scope,\n        animate\n    ];\n}\n/**\n * Creates `AnimationControls`, which can be used to manually start, stop\n * and sequence animations on one or more components.\n *\n * The returned `AnimationControls` should be passed to the `animate` property\n * of the components you want to animate.\n *\n * These components can then be animated with the `start` method.\n *\n * ```jsx\n * import * as React from 'react'\n * import { motion, useAnimation } from 'framer-motion'\n *\n * export function MyComponent(props) {\n *    const controls = useAnimation()\n *\n *    controls.start({\n *        x: 100,\n *        transition: { duration: 0.5 },\n *    })\n *\n *    return <motion.div animate={controls} />\n * }\n * ```\n *\n * @returns Animation controller with `start` and `stop` methods\n *\n * @public\n */ function useAnimationControls() {\n    const controls = useConstant(animationControls);\n    useIsomorphicLayoutEffect(controls.mount, []);\n    return controls;\n}\nconst useAnimation = useAnimationControls;\n/**\n * Cycles through a series of visual properties. Can be used to toggle between or cycle through animations. It works similar to `useState` in React. It is provided an initial array of possible states, and returns an array of two arguments.\n *\n * An index value can be passed to the returned `cycle` function to cycle to a specific index.\n *\n * ```jsx\n * import * as React from \"react\"\n * import { motion, useCycle } from \"framer-motion\"\n *\n * export const MyComponent = () => {\n *   const [x, cycleX] = useCycle(0, 50, 100)\n *\n *   return (\n *     <motion.div\n *       animate={{ x: x }}\n *       onTap={() => cycleX()}\n *      />\n *    )\n * }\n * ```\n *\n * @param items - items to cycle through\n * @returns [currentState, cycleState]\n *\n * @public\n */ function useCycle(...items) {\n    const index = React.useRef(0);\n    const [item, setItem] = React.useState(items[index.current]);\n    const runCycle = React.useCallback((next)=>{\n        index.current = typeof next !== \"number\" ? wrap(0, items.length, index.current + 1) : next;\n        setItem(items[index.current]);\n    }, // The array will change on each call, but by putting items.length at\n    // the front of this array, we guarantee the dependency comparison will match up\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        items.length,\n        ...items\n    ]);\n    return [\n        item,\n        runCycle\n    ];\n}\nfunction useInView(ref, { root, margin, amount, once = false } = {}) {\n    const [isInView, setInView] = React.useState(false);\n    React.useEffect(()=>{\n        if (!ref.current || once && isInView) return;\n        const onEnter = ()=>{\n            setInView(true);\n            return once ? undefined : ()=>setInView(false);\n        };\n        const options = {\n            root: root && root.current || undefined,\n            margin,\n            amount\n        };\n        return inView(ref.current, onEnter, options);\n    }, [\n        root,\n        ref,\n        margin,\n        once,\n        amount\n    ]);\n    return isInView;\n}\n/**\n * Can manually trigger a drag gesture on one or more `drag`-enabled `motion` components.\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <div onPointerDown={startDrag} />\n *     <motion.div drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @public\n */ class DragControls {\n    constructor(){\n        this.componentControls = new Set();\n    }\n    /**\n     * Subscribe a component's internal `VisualElementDragControls` to the user-facing API.\n     *\n     * @internal\n     */ subscribe(controls) {\n        this.componentControls.add(controls);\n        return ()=>this.componentControls.delete(controls);\n    }\n    /**\n     * Start a drag gesture on every `motion` component that has this set of drag controls\n     * passed into it via the `dragControls` prop.\n     *\n     * ```jsx\n     * dragControls.start(e, {\n     *   snapToCursor: true\n     * })\n     * ```\n     *\n     * @param event - PointerEvent\n     * @param options - Options\n     *\n     * @public\n     */ start(event, options) {\n        this.componentControls.forEach((controls)=>{\n            controls.start(event.nativeEvent || event, options);\n        });\n    }\n}\nconst createDragControls = ()=>new DragControls();\n/**\n * Usually, dragging is initiated by pressing down on a `motion` component with a `drag` prop\n * and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we\n * might want to initiate that dragging from a different component than the draggable one.\n *\n * By creating a `dragControls` using the `useDragControls` hook, we can pass this into\n * the draggable component's `dragControls` prop. It exposes a `start` method\n * that can start dragging from pointer events on other components.\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <div onPointerDown={startDrag} />\n *     <motion.div drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @public\n */ function useDragControls() {\n    return useConstant(createDragControls);\n}\n/**\n * Attaches an event listener directly to the provided DOM element.\n *\n * Bypassing React's event system can be desirable, for instance when attaching non-passive\n * event handlers.\n *\n * ```jsx\n * const ref = useRef(null)\n *\n * useDomEvent(ref, 'wheel', onWheel, { passive: false })\n *\n * return <div ref={ref} />\n * ```\n *\n * @param ref - React.RefObject that's been provided to the element you want to bind the listener to.\n * @param eventName - Name of the event you want listen for.\n * @param handler - Function to fire when receiving the event.\n * @param options - Options to pass to `Event.addEventListener`.\n *\n * @public\n */ function useDomEvent(ref, eventName, handler, options) {\n    React.useEffect(()=>{\n        const element = ref.current;\n        if (handler && element) {\n            return addDomEvent(element, eventName, handler, options);\n        }\n    }, [\n        ref,\n        eventName,\n        handler,\n        options\n    ]);\n}\n/**\n * Checks if a component is a `motion` component.\n */ function isMotionComponent(component) {\n    return component !== null && typeof component === \"object\" && motionComponentSymbol in component;\n}\n/**\n * Unwraps a `motion` component and returns either a string for `motion.div` or\n * the React component for `motion(Component)`.\n *\n * If the component is not a `motion` component it returns undefined.\n */ function unwrapMotionComponent(component) {\n    if (isMotionComponent(component)) {\n        return component[motionComponentSymbol];\n    }\n    return undefined;\n}\nfunction useInstantLayoutTransition() {\n    return startTransition;\n}\nfunction startTransition(callback) {\n    if (!rootProjectionNode.current) return;\n    rootProjectionNode.current.isUpdating = false;\n    rootProjectionNode.current.blockUpdate();\n    callback && callback();\n}\nfunction useInstantTransition() {\n    const [forceUpdate, forcedRenderCount] = useForceUpdate();\n    const startInstantLayoutTransition = useInstantLayoutTransition();\n    const unlockOnFrameRef = React.useRef(-1);\n    React.useEffect(()=>{\n        /**\n         * Unblock after two animation frames, otherwise this will unblock too soon.\n         */ frame.postRender(()=>frame.postRender(()=>{\n                /**\n             * If the callback has been called again after the effect\n             * triggered this 2 frame delay, don't unblock animations. This\n             * prevents the previous effect from unblocking the current\n             * instant transition too soon. This becomes more likely when\n             * used in conjunction with React.startTransition().\n             */ if (forcedRenderCount !== unlockOnFrameRef.current) return;\n                instantAnimationState.current = false;\n            }));\n    }, [\n        forcedRenderCount\n    ]);\n    return (callback)=>{\n        startInstantLayoutTransition(()=>{\n            instantAnimationState.current = true;\n            forceUpdate();\n            callback();\n            unlockOnFrameRef.current = forcedRenderCount + 1;\n        });\n    };\n}\nfunction disableInstantTransitions() {\n    instantAnimationState.current = false;\n}\nfunction useResetProjection() {\n    const reset = React.useCallback(()=>{\n        const root = rootProjectionNode.current;\n        if (!root) return;\n        root.resetTree();\n    }, []);\n    return reset;\n}\nconst appearStoreId = (elementId, valueName)=>{\n    const key = transformProps.has(valueName) ? \"transform\" : valueName;\n    return `${elementId}: ${key}`;\n};\nconst appearAnimationStore = new Map();\nconst appearComplete = new Map();\nfunction handoffOptimizedAppearAnimation(elementId, valueName, frame) {\n    var _a;\n    const storeId = appearStoreId(elementId, valueName);\n    const optimisedAnimation = appearAnimationStore.get(storeId);\n    if (!optimisedAnimation) {\n        return null;\n    }\n    const { animation, startTime } = optimisedAnimation;\n    function cancelAnimation() {\n        var _a;\n        (_a = window.MotionCancelOptimisedAnimation) === null || _a === void 0 ? void 0 : _a.call(window, elementId, valueName, frame);\n    }\n    /**\n     * We can cancel the animation once it's finished now that we've synced\n     * with Motion.\n     *\n     * Prefer onfinish over finished as onfinish is backwards compatible with\n     * older browsers.\n     */ animation.onfinish = cancelAnimation;\n    if (startTime === null || ((_a = window.MotionHandoffIsComplete) === null || _a === void 0 ? void 0 : _a.call(window, elementId))) {\n        /**\n         * If the startTime is null, this animation is the Paint Ready detection animation\n         * and we can cancel it immediately without handoff.\n         *\n         * Or if we've already handed off the animation then we're now interrupting it.\n         * In which case we need to cancel it.\n         */ cancelAnimation();\n        return null;\n    } else {\n        return startTime;\n    }\n}\n/**\n * A single time to use across all animations to manually set startTime\n * and ensure they're all in sync.\n */ let startFrameTime;\n/**\n * A dummy animation to detect when Chrome is ready to start\n * painting the page and hold off from triggering the real animation\n * until then. We only need one animation to detect paint ready.\n *\n * https://bugs.chromium.org/p/chromium/issues/detail?id=1406850\n */ let readyAnimation;\n/**\n * Keep track of animations that were suspended vs cancelled so we\n * can easily resume them when we're done measuring layout.\n */ const suspendedAnimations = new Set();\nfunction resumeSuspendedAnimations() {\n    suspendedAnimations.forEach((data)=>{\n        data.animation.play();\n        data.animation.startTime = data.startTime;\n    });\n    suspendedAnimations.clear();\n}\nfunction startOptimizedAppearAnimation(element, name, keyframes, options, onReady) {\n    // Prevent optimised appear animations if Motion has already started animating.\n    if (window.MotionIsMounted) {\n        return;\n    }\n    const id = element.dataset[optimizedAppearDataId];\n    if (!id) return;\n    window.MotionHandoffAnimation = handoffOptimizedAppearAnimation;\n    const storeId = appearStoreId(id, name);\n    if (!readyAnimation) {\n        readyAnimation = startWaapiAnimation(element, name, [\n            keyframes[0],\n            keyframes[0]\n        ], /**\n         * 10 secs is basically just a super-safe duration to give Chrome\n         * long enough to get the animation ready.\n         */ {\n            duration: 10000,\n            ease: \"linear\"\n        });\n        appearAnimationStore.set(storeId, {\n            animation: readyAnimation,\n            startTime: null\n        });\n        /**\n         * If there's no readyAnimation then there's been no instantiation\n         * of handoff animations.\n         */ window.MotionHandoffAnimation = handoffOptimizedAppearAnimation;\n        window.MotionHasOptimisedAnimation = (elementId, valueName)=>{\n            if (!elementId) return false;\n            /**\n             * Keep a map of elementIds that have started animating. We check\n             * via ID instead of Element because of hydration errors and\n             * pre-hydration checks. We also actively record IDs as they start\n             * animating rather than simply checking for data-appear-id as\n             * this attrbute might be present but not lead to an animation, for\n             * instance if the element's appear animation is on a different\n             * breakpoint.\n             */ if (!valueName) {\n                return appearComplete.has(elementId);\n            }\n            const animationId = appearStoreId(elementId, valueName);\n            return Boolean(appearAnimationStore.get(animationId));\n        };\n        window.MotionHandoffMarkAsComplete = (elementId)=>{\n            if (appearComplete.has(elementId)) {\n                appearComplete.set(elementId, true);\n            }\n        };\n        window.MotionHandoffIsComplete = (elementId)=>{\n            return appearComplete.get(elementId) === true;\n        };\n        /**\n         * We only need to cancel transform animations as\n         * they're the ones that will interfere with the\n         * layout animation measurements.\n         */ window.MotionCancelOptimisedAnimation = (elementId, valueName, frame, canResume)=>{\n            const animationId = appearStoreId(elementId, valueName);\n            const data = appearAnimationStore.get(animationId);\n            if (!data) return;\n            if (frame && canResume === undefined) {\n                /**\n                 * Wait until the end of the subsequent frame to cancel the animation\n                 * to ensure we don't remove the animation before the main thread has\n                 * had a chance to resolve keyframes and render.\n                 */ frame.postRender(()=>{\n                    frame.postRender(()=>{\n                        data.animation.cancel();\n                    });\n                });\n            } else {\n                data.animation.cancel();\n            }\n            if (frame && canResume) {\n                suspendedAnimations.add(data);\n                frame.render(resumeSuspendedAnimations);\n            } else {\n                appearAnimationStore.delete(animationId);\n                /**\n                 * If there are no more animations left, we can remove the cancel function.\n                 * This will let us know when we can stop checking for conflicting layout animations.\n                 */ if (!appearAnimationStore.size) {\n                    window.MotionCancelOptimisedAnimation = undefined;\n                }\n            }\n        };\n        window.MotionCheckAppearSync = (visualElement, valueName, value)=>{\n            var _a, _b;\n            const appearId = getOptimisedAppearId(visualElement);\n            if (!appearId) return;\n            const valueIsOptimised = (_a = window.MotionHasOptimisedAnimation) === null || _a === void 0 ? void 0 : _a.call(window, appearId, valueName);\n            const externalAnimationValue = (_b = visualElement.props.values) === null || _b === void 0 ? void 0 : _b[valueName];\n            if (!valueIsOptimised || !externalAnimationValue) return;\n            const removeSyncCheck = value.on(\"change\", (latestValue)=>{\n                var _a;\n                if (externalAnimationValue.get() !== latestValue) {\n                    (_a = window.MotionCancelOptimisedAnimation) === null || _a === void 0 ? void 0 : _a.call(window, appearId, valueName);\n                    removeSyncCheck();\n                }\n            });\n            return removeSyncCheck;\n        };\n    }\n    const startAnimation = ()=>{\n        readyAnimation.cancel();\n        const appearAnimation = startWaapiAnimation(element, name, keyframes, options);\n        /**\n         * Record the time of the first started animation. We call performance.now() once\n         * here and once in handoff to ensure we're getting\n         * close to a frame-locked time. This keeps all animations in sync.\n         */ if (startFrameTime === undefined) {\n            startFrameTime = performance.now();\n        }\n        appearAnimation.startTime = startFrameTime;\n        appearAnimationStore.set(storeId, {\n            animation: appearAnimation,\n            startTime: startFrameTime\n        });\n        if (onReady) onReady(appearAnimation);\n    };\n    appearComplete.set(id, false);\n    if (readyAnimation.ready) {\n        readyAnimation.ready.then(startAnimation).catch(motionUtils.noop);\n    } else {\n        startAnimation();\n    }\n}\nconst createObject = ()=>({});\nclass StateVisualElement extends VisualElement {\n    constructor(){\n        super(...arguments);\n        this.measureInstanceViewportBox = createBox;\n    }\n    build() {}\n    resetTransform() {}\n    restoreTransform() {}\n    removeValueFromRenderState() {}\n    renderInstance() {}\n    scrapeMotionValuesFromProps() {\n        return createObject();\n    }\n    getBaseTargetFromProps() {\n        return undefined;\n    }\n    readValueFromInstance(_state, key, options) {\n        return options.initialState[key] || 0;\n    }\n    sortInstanceNodePosition() {\n        return 0;\n    }\n}\nconst useVisualState = makeUseVisualState({\n    scrapeMotionValuesFromProps: createObject,\n    createRenderState: createObject\n});\n/**\n * This is not an officially supported API and may be removed\n * on any version.\n */ function useAnimatedState(initialState) {\n    const [animationState, setAnimationState] = React.useState(initialState);\n    const visualState = useVisualState({}, false);\n    const element = useConstant(()=>{\n        return new StateVisualElement({\n            props: {\n                onUpdate: (v)=>{\n                    setAnimationState({\n                        ...v\n                    });\n                }\n            },\n            visualState,\n            presenceContext: null\n        }, {\n            initialState\n        });\n    });\n    React.useLayoutEffect(()=>{\n        element.mount({});\n        return ()=>element.unmount();\n    }, [\n        element\n    ]);\n    const startAnimation = useConstant(()=>(animationDefinition)=>{\n            return animateVisualElement(element, animationDefinition);\n        });\n    return [\n        animationState,\n        startAnimation\n    ];\n}\n// Keep things reasonable and avoid scale: Infinity. In practise we might need\n// to add another value, opacity, that could interpolate scaleX/Y [0,0.01] => [0,1]\n// to simply hide content at unreasonable scales.\nconst maxScale = 100000;\nconst invertScale = (scale)=>scale > 0.001 ? 1 / scale : maxScale;\nlet hasWarned = false;\n/**\n * Returns a `MotionValue` each for `scaleX` and `scaleY` that update with the inverse\n * of their respective parent scales.\n *\n * This is useful for undoing the distortion of content when scaling a parent component.\n *\n * By default, `useInvertedScale` will automatically fetch `scaleX` and `scaleY` from the nearest parent.\n * By passing other `MotionValue`s in as `useInvertedScale({ scaleX, scaleY })`, it will invert the output\n * of those instead.\n *\n * ```jsx\n * const MyComponent = () => {\n *   const { scaleX, scaleY } = useInvertedScale()\n *   return <motion.div style={{ scaleX, scaleY }} />\n * }\n * ```\n *\n * @deprecated\n */ function useInvertedScale(scale) {\n    let parentScaleX = useMotionValue(1);\n    let parentScaleY = useMotionValue(1);\n    const { visualElement } = React.useContext(MotionContext);\n    motionUtils.invariant(!!(scale || visualElement), \"If no scale values are provided, useInvertedScale must be used within a child of another motion component.\");\n    motionUtils.warning(hasWarned, \"useInvertedScale is deprecated and will be removed in 3.0. Use the layout prop instead.\");\n    hasWarned = true;\n    if (scale) {\n        parentScaleX = scale.scaleX || parentScaleX;\n        parentScaleY = scale.scaleY || parentScaleY;\n    } else if (visualElement) {\n        parentScaleX = visualElement.getValue(\"scaleX\", 1);\n        parentScaleY = visualElement.getValue(\"scaleY\", 1);\n    }\n    const scaleX = useTransform(parentScaleX, invertScale);\n    const scaleY = useTransform(parentScaleY, invertScale);\n    return {\n        scaleX,\n        scaleY\n    };\n}\nlet id = 0;\nconst AnimateSharedLayout = ({ children })=>{\n    React__namespace.useEffect(()=>{\n        motionUtils.invariant(false, \"AnimateSharedLayout is deprecated: https://www.framer.com/docs/guide-upgrade/##shared-layout-animations\");\n    }, []);\n    return jsxRuntime.jsx(LayoutGroup, {\n        id: useConstant(()=>`asl-${id++}`),\n        children: children\n    });\n};\nObject.defineProperty(exports, \"invariant\", ({\n    enumerable: true,\n    get: function() {\n        return motionUtils.invariant;\n    }\n}));\nObject.defineProperty(exports, \"noop\", ({\n    enumerable: true,\n    get: function() {\n        return motionUtils.noop;\n    }\n}));\nObject.defineProperty(exports, \"isDragActive\", ({\n    enumerable: true,\n    get: function() {\n        return motionDom.isDragActive;\n    }\n}));\nexports.AcceleratedAnimation = AcceleratedAnimation;\nexports.AnimatePresence = AnimatePresence;\nexports.AnimateSharedLayout = AnimateSharedLayout;\nexports.DeprecatedLayoutGroupContext = DeprecatedLayoutGroupContext;\nexports.DragControls = DragControls;\nexports.FlatTree = FlatTree;\nexports.LayoutGroup = LayoutGroup;\nexports.LayoutGroupContext = LayoutGroupContext;\nexports.LazyMotion = LazyMotion;\nexports.MotionConfig = MotionConfig;\nexports.MotionConfigContext = MotionConfigContext;\nexports.MotionContext = MotionContext;\nexports.MotionGlobalConfig = MotionGlobalConfig;\nexports.MotionValue = MotionValue;\nexports.PresenceContext = PresenceContext;\nexports.Reorder = namespace;\nexports.SwitchLayoutGroupContext = SwitchLayoutGroupContext;\nexports.VisualElement = VisualElement;\nexports.addPointerEvent = addPointerEvent;\nexports.addPointerInfo = addPointerInfo;\nexports.addScaleCorrector = addScaleCorrector;\nexports.animate = animate;\nexports.animateMini = animateMini;\nexports.animateValue = animateValue;\nexports.animateVisualElement = animateVisualElement;\nexports.animationControls = animationControls;\nexports.animations = animations;\nexports.anticipate = anticipate;\nexports.backIn = backIn;\nexports.backInOut = backInOut;\nexports.backOut = backOut;\nexports.buildTransform = buildTransform;\nexports.calcLength = calcLength;\nexports.cancelFrame = cancelFrame;\nexports.cancelSync = cancelSync;\nexports.circIn = circIn;\nexports.circInOut = circInOut;\nexports.circOut = circOut;\nexports.clamp = clamp;\nexports.color = color;\nexports.complex = complex;\nexports.createBox = createBox;\nexports.createRendererMotionComponent = createRendererMotionComponent;\nexports.createScopedAnimate = createScopedAnimate;\nexports.cubicBezier = cubicBezier;\nexports.delay = delay;\nexports.disableInstantTransitions = disableInstantTransitions;\nexports.distance = distance;\nexports.distance2D = distance2D;\nexports.domAnimation = domAnimation;\nexports.domMax = domMax;\nexports.domMin = domMin;\nexports.easeIn = easeIn;\nexports.easeInOut = easeInOut;\nexports.easeOut = easeOut;\nexports.filterProps = filterProps;\nexports.findSpring = findSpring;\nexports.frame = frame;\nexports.frameData = frameData;\nexports.frameSteps = frameSteps;\nexports.inView = inView;\nexports.inertia = inertia;\nexports.interpolate = interpolate;\nexports.isBrowser = isBrowser;\nexports.isMotionComponent = isMotionComponent;\nexports.isMotionValue = isMotionValue;\nexports.isValidMotionProp = isValidMotionProp;\nexports.keyframes = keyframes;\nexports.m = m;\nexports.makeUseVisualState = makeUseVisualState;\nexports.mirrorEasing = mirrorEasing;\nexports.mix = mix;\nexports.motion = motion;\nexports.motionValue = motionValue;\nexports.optimizedAppearDataAttribute = optimizedAppearDataAttribute;\nexports.pipe = pipe;\nexports.progress = progress;\nexports.px = px;\nexports.resolveMotionValue = resolveMotionValue;\nexports.reverseEasing = reverseEasing;\nexports.scroll = scroll;\nexports.scrollInfo = scrollInfo;\nexports.spring = spring;\nexports.stagger = stagger;\nexports.startOptimizedAppearAnimation = startOptimizedAppearAnimation;\nexports.steps = steps;\nexports.sync = sync;\nexports.time = time;\nexports.transform = transform;\nexports.unwrapMotionComponent = unwrapMotionComponent;\nexports.useAnimate = useAnimate;\nexports.useAnimateMini = useAnimateMini;\nexports.useAnimation = useAnimation;\nexports.useAnimationControls = useAnimationControls;\nexports.useAnimationFrame = useAnimationFrame;\nexports.useCycle = useCycle;\nexports.useDeprecatedAnimatedState = useAnimatedState;\nexports.useDeprecatedInvertedScale = useInvertedScale;\nexports.useDomEvent = useDomEvent;\nexports.useDragControls = useDragControls;\nexports.useElementScroll = useElementScroll;\nexports.useForceUpdate = useForceUpdate;\nexports.useInView = useInView;\nexports.useInstantLayoutTransition = useInstantLayoutTransition;\nexports.useInstantTransition = useInstantTransition;\nexports.useIsPresent = useIsPresent;\nexports.useIsomorphicLayoutEffect = useIsomorphicLayoutEffect;\nexports.useMotionTemplate = useMotionTemplate;\nexports.useMotionValue = useMotionValue;\nexports.useMotionValueEvent = useMotionValueEvent;\nexports.usePresence = usePresence;\nexports.useReducedMotion = useReducedMotion;\nexports.useReducedMotionConfig = useReducedMotionConfig;\nexports.useResetProjection = useResetProjection;\nexports.useScroll = useScroll;\nexports.useSpring = useSpring;\nexports.useTime = useTime;\nexports.useTransform = useTransform;\nexports.useUnmountEffect = useUnmountEffect;\nexports.useVelocity = useVelocity;\nexports.useViewportScroll = useViewportScroll;\nexports.useWillChange = useWillChange;\nexports.visualElementStore = visualElementStore;\nexports.wrap = wrap;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2Nqcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUU3RCxJQUFJQyxjQUFjQyxtQkFBT0EsQ0FBQztBQUMxQixJQUFJQyxZQUFZRCxtQkFBT0EsQ0FBQztBQUN4QixJQUFJRSxhQUFhRixtQkFBT0EsQ0FBQztBQUN6QixJQUFJRyxRQUFRSCxtQkFBT0EsQ0FBQztBQUVwQixTQUFTSSx5QkFBeUJDLENBQUM7SUFDL0IsSUFBSUMsSUFBSVgsT0FBT1ksTUFBTSxDQUFDO0lBQ3RCLElBQUlGLEdBQUc7UUFDSFYsT0FBT2EsSUFBSSxDQUFDSCxHQUFHSSxPQUFPLENBQUMsU0FBVUMsQ0FBQztZQUM5QixJQUFJQSxNQUFNLFdBQVc7Z0JBQ2pCLElBQUlDLElBQUloQixPQUFPaUIsd0JBQXdCLENBQUNQLEdBQUdLO2dCQUMzQ2YsT0FBT0MsY0FBYyxDQUFDVSxHQUFHSSxHQUFHQyxFQUFFRSxHQUFHLEdBQUdGLElBQUk7b0JBQ3BDRyxZQUFZO29CQUNaRCxLQUFLO3dCQUFjLE9BQU9SLENBQUMsQ0FBQ0ssRUFBRTtvQkFBRTtnQkFDcEM7WUFDSjtRQUNKO0lBQ0o7SUFDQUosRUFBRVMsT0FBTyxHQUFHVjtJQUNaLE9BQU9WLE9BQU9xQixNQUFNLENBQUNWO0FBQ3pCO0FBRUEsSUFBSVcsbUJBQW1CLFdBQVcsR0FBRWIseUJBQXlCRDtBQUU3RCxNQUFNZSxTQUFTLElBQUlDO0FBQ25CLFNBQVNDLFNBQVNDLFNBQVMsRUFBRUMsT0FBTyxFQUFFQyxPQUFPO0lBQ3pDLElBQUlGLGFBQWFILE9BQU9NLEdBQUcsQ0FBQ0YsVUFDeEI7SUFDSkcsUUFBUUMsSUFBSSxDQUFDSjtJQUNiLElBQUlDLFNBQ0FFLFFBQVFDLElBQUksQ0FBQ0g7SUFDakJMLE9BQU9TLEdBQUcsQ0FBQ0w7QUFDZjtBQUVBLFNBQVNNLDhCQUE4QkMsZ0JBQWdC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bkUsZ0JBQWdCLEdBQUcyb0U7QUFDbkIzb0Usa0NBQWtDLEdBQUc0ckU7QUFDckM1ckUsa0NBQWtDLEdBQUdrc0U7QUFDckNsc0UsbUJBQW1CLEdBQUd1cEU7QUFDdEJ2cEUsdUJBQXVCLEdBQUdzcEU7QUFDMUJ0cEUsd0JBQXdCLEdBQUdtbkU7QUFDM0JubkUsc0JBQXNCLEdBQUc2Z0U7QUFDekI3Z0UsaUJBQWlCLEdBQUcrb0U7QUFDcEIvb0Usa0NBQWtDLEdBQUcycEU7QUFDckMzcEUsNEJBQTRCLEdBQUc2cEU7QUFDL0I3cEUsb0JBQW9CLEdBQUcyMEQ7QUFDdkIzMEQsaUNBQWlDLEdBQUd5NEQ7QUFDcEN6NEQseUJBQXlCLEdBQUc4bEU7QUFDNUI5bEUsc0JBQXNCLEdBQUdxa0U7QUFDekJya0UsMkJBQTJCLEdBQUdzbUU7QUFDOUJ0bUUsbUJBQW1CLEdBQUdxMEQ7QUFDdEJyMEQsd0JBQXdCLEdBQUc2bkU7QUFDM0I3bkUsOEJBQThCLEdBQUc4bkU7QUFDakM5bkUsMEJBQTBCLEdBQUdrcUU7QUFDN0JscUUsaUJBQWlCLEdBQUcrbUU7QUFDcEIvbUUsaUJBQWlCLEdBQUdtbUU7QUFDcEJubUUsZUFBZSxHQUFHd25FO0FBQ2xCeG5FLG9CQUFvQixHQUFHNGtFO0FBQ3ZCNWtFLHdCQUF3QixHQUFHMmdFO0FBQzNCM2dFLG1CQUFtQixHQUFHdW1FO0FBQ3RCdm1FLHlCQUF5QixHQUFHb25FO0FBQzVCcG5FLHFCQUFxQixHQUFHNG5FO0FBQ3hCNW5FLDBCQUEwQixHQUFHeXpDO0FBQzdCenpDLFlBQVksR0FBR2d3QyIsInNvdXJjZXMiOlsid2VicGFjazovL21lbWUtcGVycHMtdHJhZGluZy8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvY2pzL2luZGV4LmpzPzczMmIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgbW90aW9uVXRpbHMgPSByZXF1aXJlKCdtb3Rpb24tdXRpbHMnKTtcbnZhciBtb3Rpb25Eb20gPSByZXF1aXJlKCdtb3Rpb24tZG9tJyk7XG52YXIganN4UnVudGltZSA9IHJlcXVpcmUoJ3JlYWN0L2pzeC1ydW50aW1lJyk7XG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcE5hbWVzcGFjZURlZmF1bHQoZSkge1xuICAgIHZhciBuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBpZiAoZSkge1xuICAgICAgICBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICBpZiAoayAhPT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIGspO1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBrLCBkLmdldCA/IGQgOiB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZVtrXTsgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbi5kZWZhdWx0ID0gZTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShuKTtcbn1cblxudmFyIFJlYWN0X19uYW1lc3BhY2UgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BOYW1lc3BhY2VEZWZhdWx0KFJlYWN0KTtcblxuY29uc3Qgd2FybmVkID0gbmV3IFNldCgpO1xuZnVuY3Rpb24gd2Fybk9uY2UoY29uZGl0aW9uLCBtZXNzYWdlLCBlbGVtZW50KSB7XG4gICAgaWYgKGNvbmRpdGlvbiB8fCB3YXJuZWQuaGFzKG1lc3NhZ2UpKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgIGlmIChlbGVtZW50KVxuICAgICAgICBjb25zb2xlLndhcm4oZWxlbWVudCk7XG4gICAgd2FybmVkLmFkZChtZXNzYWdlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRE9NTW90aW9uQ29tcG9uZW50UHJveHkoY29tcG9uZW50RmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudEZhY3Rvcnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgY2FjaGUgb2YgZ2VuZXJhdGVkIGBtb3Rpb25gIGNvbXBvbmVudHMsIGUuZyBgbW90aW9uLmRpdmAsIGBtb3Rpb24uaW5wdXRgIGV0Yy5cbiAgICAgKiBSYXRoZXIgdGhhbiBnZW5lcmF0aW5nIHRoZW0gYW5ldyBldmVyeSByZW5kZXIuXG4gICAgICovXG4gICAgY29uc3QgY29tcG9uZW50Q2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgZGVwcmVjYXRlZEZhY3RvcnlGdW5jdGlvbiA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKGZhbHNlLCBcIm1vdGlvbigpIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb3Rpb24uY3JlYXRlKCkgaW5zdGVhZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudEZhY3RvcnkoLi4uYXJncyk7XG4gICAgfTtcbiAgICByZXR1cm4gbmV3IFByb3h5KGRlcHJlY2F0ZWRGYWN0b3J5RnVuY3Rpb24sIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxlZCB3aGVuIGBtb3Rpb25gIGlzIHJlZmVyZW5jZWQgd2l0aCBhIHByb3A6IGBtb3Rpb24uZGl2YCwgYG1vdGlvbi5pbnB1dGAgZXRjLlxuICAgICAgICAgKiBUaGUgcHJvcCBuYW1lIGlzIHBhc3NlZCB0aHJvdWdoIGFzIGBrZXlgIGFuZCB3ZSBjYW4gdXNlIHRoYXQgdG8gZ2VuZXJhdGUgYSBgbW90aW9uYFxuICAgICAgICAgKiBET00gY29tcG9uZW50IHdpdGggdGhhdCBuYW1lLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiAoX3RhcmdldCwga2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBcImNyZWF0ZVwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBjb21wb25lbnRGYWN0b3J5O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB0aGlzIGVsZW1lbnQgZG9lc24ndCBleGlzdCBpbiB0aGUgY29tcG9uZW50IGNhY2hlLCBjcmVhdGUgaXQgYW5kIGNhY2hlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoIWNvbXBvbmVudENhY2hlLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50Q2FjaGUuc2V0KGtleSwgY29tcG9uZW50RmFjdG9yeShrZXkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb21wb25lbnRDYWNoZS5nZXQoa2V5KTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gaXNBbmltYXRpb25Db250cm9scyh2KSB7XG4gICAgcmV0dXJuICh2ICE9PSBudWxsICYmXG4gICAgICAgIHR5cGVvZiB2ID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIHR5cGVvZiB2LnN0YXJ0ID09PSBcImZ1bmN0aW9uXCIpO1xufVxuXG5jb25zdCBpc0tleWZyYW1lc1RhcmdldCA9ICh2KSA9PiB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodik7XG59O1xuXG5mdW5jdGlvbiBzaGFsbG93Q29tcGFyZShuZXh0LCBwcmV2KSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHByZXYpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgcHJldkxlbmd0aCA9IHByZXYubGVuZ3RoO1xuICAgIGlmIChwcmV2TGVuZ3RoICE9PSBuZXh0Lmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldkxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChwcmV2W2ldICE9PSBuZXh0W2ldKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBEZWNpZGVzIGlmIHRoZSBzdXBwbGllZCB2YXJpYWJsZSBpcyB2YXJpYW50IGxhYmVsXG4gKi9cbmZ1bmN0aW9uIGlzVmFyaWFudExhYmVsKHYpIHtcbiAgICByZXR1cm4gdHlwZW9mIHYgPT09IFwic3RyaW5nXCIgfHwgQXJyYXkuaXNBcnJheSh2KTtcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWVTdGF0ZSh2aXN1YWxFbGVtZW50KSB7XG4gICAgY29uc3Qgc3RhdGUgPSBbe30sIHt9XTtcbiAgICB2aXN1YWxFbGVtZW50ID09PSBudWxsIHx8IHZpc3VhbEVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZpc3VhbEVsZW1lbnQudmFsdWVzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgc3RhdGVbMF1ba2V5XSA9IHZhbHVlLmdldCgpO1xuICAgICAgICBzdGF0ZVsxXVtrZXldID0gdmFsdWUuZ2V0VmVsb2NpdHkoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gc3RhdGU7XG59XG5mdW5jdGlvbiByZXNvbHZlVmFyaWFudEZyb21Qcm9wcyhwcm9wcywgZGVmaW5pdGlvbiwgY3VzdG9tLCB2aXN1YWxFbGVtZW50KSB7XG4gICAgLyoqXG4gICAgICogSWYgdGhlIHZhcmlhbnQgZGVmaW5pdGlvbiBpcyBhIGZ1bmN0aW9uLCByZXNvbHZlLlxuICAgICAqL1xuICAgIGlmICh0eXBlb2YgZGVmaW5pdGlvbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IFtjdXJyZW50LCB2ZWxvY2l0eV0gPSBnZXRWYWx1ZVN0YXRlKHZpc3VhbEVsZW1lbnQpO1xuICAgICAgICBkZWZpbml0aW9uID0gZGVmaW5pdGlvbihjdXN0b20gIT09IHVuZGVmaW5lZCA/IGN1c3RvbSA6IHByb3BzLmN1c3RvbSwgY3VycmVudCwgdmVsb2NpdHkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgdmFyaWFudCBkZWZpbml0aW9uIGlzIGEgdmFyaWFudCBsYWJlbCwgb3JcbiAgICAgKiB0aGUgZnVuY3Rpb24gcmV0dXJuZWQgYSB2YXJpYW50IGxhYmVsLCByZXNvbHZlLlxuICAgICAqL1xuICAgIGlmICh0eXBlb2YgZGVmaW5pdGlvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBkZWZpbml0aW9uID0gcHJvcHMudmFyaWFudHMgJiYgcHJvcHMudmFyaWFudHNbZGVmaW5pdGlvbl07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0IHRoaXMgcG9pbnQgd2UndmUgcmVzb2x2ZWQgYm90aCBmdW5jdGlvbnMgYW5kIHZhcmlhbnQgbGFiZWxzLFxuICAgICAqIGJ1dCB0aGUgcmVzb2x2ZWQgdmFyaWFudCBsYWJlbCBtaWdodCBpdHNlbGYgaGF2ZSBiZWVuIGEgZnVuY3Rpb24uXG4gICAgICogSWYgc28sIHJlc29sdmUuIFRoaXMgY2FuIG9ubHkgaGF2ZSByZXR1cm5lZCBhIHZhbGlkIHRhcmdldCBvYmplY3QuXG4gICAgICovXG4gICAgaWYgKHR5cGVvZiBkZWZpbml0aW9uID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29uc3QgW2N1cnJlbnQsIHZlbG9jaXR5XSA9IGdldFZhbHVlU3RhdGUodmlzdWFsRWxlbWVudCk7XG4gICAgICAgIGRlZmluaXRpb24gPSBkZWZpbml0aW9uKGN1c3RvbSAhPT0gdW5kZWZpbmVkID8gY3VzdG9tIDogcHJvcHMuY3VzdG9tLCBjdXJyZW50LCB2ZWxvY2l0eSk7XG4gICAgfVxuICAgIHJldHVybiBkZWZpbml0aW9uO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlVmFyaWFudCh2aXN1YWxFbGVtZW50LCBkZWZpbml0aW9uLCBjdXN0b20pIHtcbiAgICBjb25zdCBwcm9wcyA9IHZpc3VhbEVsZW1lbnQuZ2V0UHJvcHMoKTtcbiAgICByZXR1cm4gcmVzb2x2ZVZhcmlhbnRGcm9tUHJvcHMocHJvcHMsIGRlZmluaXRpb24sIGN1c3RvbSAhPT0gdW5kZWZpbmVkID8gY3VzdG9tIDogcHJvcHMuY3VzdG9tLCB2aXN1YWxFbGVtZW50KTtcbn1cblxuY29uc3QgdmFyaWFudFByaW9yaXR5T3JkZXIgPSBbXG4gICAgXCJhbmltYXRlXCIsXG4gICAgXCJ3aGlsZUluVmlld1wiLFxuICAgIFwid2hpbGVGb2N1c1wiLFxuICAgIFwid2hpbGVIb3ZlclwiLFxuICAgIFwid2hpbGVUYXBcIixcbiAgICBcIndoaWxlRHJhZ1wiLFxuICAgIFwiZXhpdFwiLFxuXTtcbmNvbnN0IHZhcmlhbnRQcm9wcyA9IFtcImluaXRpYWxcIiwgLi4udmFyaWFudFByaW9yaXR5T3JkZXJdO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgbGlzdCBvZiBldmVyeSBwb3NzaWJsZSB0cmFuc2Zvcm0ga2V5LlxuICovXG5jb25zdCB0cmFuc2Zvcm1Qcm9wT3JkZXIgPSBbXG4gICAgXCJ0cmFuc2Zvcm1QZXJzcGVjdGl2ZVwiLFxuICAgIFwieFwiLFxuICAgIFwieVwiLFxuICAgIFwielwiLFxuICAgIFwidHJhbnNsYXRlWFwiLFxuICAgIFwidHJhbnNsYXRlWVwiLFxuICAgIFwidHJhbnNsYXRlWlwiLFxuICAgIFwic2NhbGVcIixcbiAgICBcInNjYWxlWFwiLFxuICAgIFwic2NhbGVZXCIsXG4gICAgXCJyb3RhdGVcIixcbiAgICBcInJvdGF0ZVhcIixcbiAgICBcInJvdGF0ZVlcIixcbiAgICBcInJvdGF0ZVpcIixcbiAgICBcInNrZXdcIixcbiAgICBcInNrZXdYXCIsXG4gICAgXCJza2V3WVwiLFxuXTtcbi8qKlxuICogQSBxdWljayBsb29rdXAgZm9yIHRyYW5zZm9ybSBwcm9wcy5cbiAqL1xuY29uc3QgdHJhbnNmb3JtUHJvcHMgPSBuZXcgU2V0KHRyYW5zZm9ybVByb3BPcmRlcik7XG5cbi8qKlxuICogQ29udmVydHMgc2Vjb25kcyB0byBtaWxsaXNlY29uZHNcbiAqXG4gKiBAcGFyYW0gc2Vjb25kcyAtIFRpbWUgaW4gc2Vjb25kcy5cbiAqIEByZXR1cm4gbWlsbGlzZWNvbmRzIC0gQ29udmVydGVkIHRpbWUgaW4gbWlsbGlzZWNvbmRzLlxuICovXG5jb25zdCBzZWNvbmRzVG9NaWxsaXNlY29uZHMgPSAoc2Vjb25kcykgPT4gc2Vjb25kcyAqIDEwMDA7XG5jb25zdCBtaWxsaXNlY29uZHNUb1NlY29uZHMgPSAobWlsbGlzZWNvbmRzKSA9PiBtaWxsaXNlY29uZHMgLyAxMDAwO1xuXG5jb25zdCB1bmRlckRhbXBlZFNwcmluZyA9IHtcbiAgICB0eXBlOiBcInNwcmluZ1wiLFxuICAgIHN0aWZmbmVzczogNTAwLFxuICAgIGRhbXBpbmc6IDI1LFxuICAgIHJlc3RTcGVlZDogMTAsXG59O1xuY29uc3QgY3JpdGljYWxseURhbXBlZFNwcmluZyA9ICh0YXJnZXQpID0+ICh7XG4gICAgdHlwZTogXCJzcHJpbmdcIixcbiAgICBzdGlmZm5lc3M6IDU1MCxcbiAgICBkYW1waW5nOiB0YXJnZXQgPT09IDAgPyAyICogTWF0aC5zcXJ0KDU1MCkgOiAzMCxcbiAgICByZXN0U3BlZWQ6IDEwLFxufSk7XG5jb25zdCBrZXlmcmFtZXNUcmFuc2l0aW9uID0ge1xuICAgIHR5cGU6IFwia2V5ZnJhbWVzXCIsXG4gICAgZHVyYXRpb246IDAuOCxcbn07XG4vKipcbiAqIERlZmF1bHQgZWFzaW5nIGN1cnZlIGlzIGEgc2xpZ2h0bHkgc2hhbGxvd2VyIHZlcnNpb24gb2ZcbiAqIHRoZSBkZWZhdWx0IGJyb3dzZXIgZWFzaW5nIGN1cnZlLlxuICovXG5jb25zdCBlYXNlID0ge1xuICAgIHR5cGU6IFwia2V5ZnJhbWVzXCIsXG4gICAgZWFzZTogWzAuMjUsIDAuMSwgMC4zNSwgMV0sXG4gICAgZHVyYXRpb246IDAuMyxcbn07XG5jb25zdCBnZXREZWZhdWx0VHJhbnNpdGlvbiA9ICh2YWx1ZUtleSwgeyBrZXlmcmFtZXMgfSkgPT4ge1xuICAgIGlmIChrZXlmcmFtZXMubGVuZ3RoID4gMikge1xuICAgICAgICByZXR1cm4ga2V5ZnJhbWVzVHJhbnNpdGlvbjtcbiAgICB9XG4gICAgZWxzZSBpZiAodHJhbnNmb3JtUHJvcHMuaGFzKHZhbHVlS2V5KSkge1xuICAgICAgICByZXR1cm4gdmFsdWVLZXkuc3RhcnRzV2l0aChcInNjYWxlXCIpXG4gICAgICAgICAgICA/IGNyaXRpY2FsbHlEYW1wZWRTcHJpbmcoa2V5ZnJhbWVzWzFdKVxuICAgICAgICAgICAgOiB1bmRlckRhbXBlZFNwcmluZztcbiAgICB9XG4gICAgcmV0dXJuIGVhc2U7XG59O1xuXG5mdW5jdGlvbiBnZXRWYWx1ZVRyYW5zaXRpb24kMSh0cmFuc2l0aW9uLCBrZXkpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvblxuICAgICAgICA/IHRyYW5zaXRpb25ba2V5XSB8fFxuICAgICAgICAgICAgdHJhbnNpdGlvbltcImRlZmF1bHRcIl0gfHxcbiAgICAgICAgICAgIHRyYW5zaXRpb25cbiAgICAgICAgOiB1bmRlZmluZWQ7XG59XG5cbmNvbnN0IE1vdGlvbkdsb2JhbENvbmZpZyA9IHtcbiAgICBza2lwQW5pbWF0aW9uczogZmFsc2UsXG4gICAgdXNlTWFudWFsVGltaW5nOiBmYWxzZSxcbn07XG5cbmNvbnN0IGluc3RhbnRBbmltYXRpb25TdGF0ZSA9IHtcbiAgICBjdXJyZW50OiBmYWxzZSxcbn07XG5cbmNvbnN0IGlzTm90TnVsbCA9ICh2YWx1ZSkgPT4gdmFsdWUgIT09IG51bGw7XG5mdW5jdGlvbiBnZXRGaW5hbEtleWZyYW1lKGtleWZyYW1lcywgeyByZXBlYXQsIHJlcGVhdFR5cGUgPSBcImxvb3BcIiB9LCBmaW5hbEtleWZyYW1lKSB7XG4gICAgY29uc3QgcmVzb2x2ZWRLZXlmcmFtZXMgPSBrZXlmcmFtZXMuZmlsdGVyKGlzTm90TnVsbCk7XG4gICAgY29uc3QgaW5kZXggPSByZXBlYXQgJiYgcmVwZWF0VHlwZSAhPT0gXCJsb29wXCIgJiYgcmVwZWF0ICUgMiA9PT0gMVxuICAgICAgICA/IDBcbiAgICAgICAgOiByZXNvbHZlZEtleWZyYW1lcy5sZW5ndGggLSAxO1xuICAgIHJldHVybiAhaW5kZXggfHwgZmluYWxLZXlmcmFtZSA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gcmVzb2x2ZWRLZXlmcmFtZXNbaW5kZXhdXG4gICAgICAgIDogZmluYWxLZXlmcmFtZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUmVuZGVyU3RlcChydW5OZXh0RnJhbWUpIHtcbiAgICAvKipcbiAgICAgKiBXZSBjcmVhdGUgYW5kIHJldXNlIHR3byBxdWV1ZXMsIG9uZSB0byBxdWV1ZSBqb2JzIGZvciB0aGUgY3VycmVudCBmcmFtZVxuICAgICAqIGFuZCBvbmUgZm9yIHRoZSBuZXh0LiBXZSByZXVzZSB0byBhdm9pZCB0cmlnZ2VyaW5nIEdDIGFmdGVyIHggZnJhbWVzLlxuICAgICAqL1xuICAgIGxldCB0aGlzRnJhbWUgPSBuZXcgU2V0KCk7XG4gICAgbGV0IG5leHRGcmFtZSA9IG5ldyBTZXQoKTtcbiAgICAvKipcbiAgICAgKiBUcmFjayB3aGV0aGVyIHdlJ3JlIGN1cnJlbnRseSBwcm9jZXNzaW5nIGpvYnMgaW4gdGhpcyBzdGVwLiBUaGlzIHdheVxuICAgICAqIHdlIGNhbiBkZWNpZGUgd2hldGhlciB0byBzY2hlZHVsZSBuZXcgam9icyBmb3IgdGhpcyBmcmFtZSBvciBuZXh0LlxuICAgICAqL1xuICAgIGxldCBpc1Byb2Nlc3NpbmcgPSBmYWxzZTtcbiAgICBsZXQgZmx1c2hOZXh0RnJhbWUgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBBIHNldCBvZiBwcm9jZXNzZXMgd2hpY2ggd2VyZSBtYXJrZWQga2VlcEFsaXZlIHdoZW4gc2NoZWR1bGVkLlxuICAgICAqL1xuICAgIGNvbnN0IHRvS2VlcEFsaXZlID0gbmV3IFdlYWtTZXQoKTtcbiAgICBsZXQgbGF0ZXN0RnJhbWVEYXRhID0ge1xuICAgICAgICBkZWx0YTogMC4wLFxuICAgICAgICB0aW1lc3RhbXA6IDAuMCxcbiAgICAgICAgaXNQcm9jZXNzaW5nOiBmYWxzZSxcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHRyaWdnZXJDYWxsYmFjayhjYWxsYmFjaykge1xuICAgICAgICBpZiAodG9LZWVwQWxpdmUuaGFzKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgc3RlcC5zY2hlZHVsZShjYWxsYmFjayk7XG4gICAgICAgICAgICBydW5OZXh0RnJhbWUoKTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhsYXRlc3RGcmFtZURhdGEpO1xuICAgIH1cbiAgICBjb25zdCBzdGVwID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogU2NoZWR1bGUgYSBwcm9jZXNzIHRvIHJ1biBvbiB0aGUgbmV4dCBmcmFtZS5cbiAgICAgICAgICovXG4gICAgICAgIHNjaGVkdWxlOiAoY2FsbGJhY2ssIGtlZXBBbGl2ZSA9IGZhbHNlLCBpbW1lZGlhdGUgPSBmYWxzZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYWRkVG9DdXJyZW50RnJhbWUgPSBpbW1lZGlhdGUgJiYgaXNQcm9jZXNzaW5nO1xuICAgICAgICAgICAgY29uc3QgcXVldWUgPSBhZGRUb0N1cnJlbnRGcmFtZSA/IHRoaXNGcmFtZSA6IG5leHRGcmFtZTtcbiAgICAgICAgICAgIGlmIChrZWVwQWxpdmUpXG4gICAgICAgICAgICAgICAgdG9LZWVwQWxpdmUuYWRkKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIGlmICghcXVldWUuaGFzKGNhbGxiYWNrKSlcbiAgICAgICAgICAgICAgICBxdWV1ZS5hZGQoY2FsbGJhY2spO1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FuY2VsIHRoZSBwcm92aWRlZCBjYWxsYmFjayBmcm9tIHJ1bm5pbmcgb24gdGhlIG5leHQgZnJhbWUuXG4gICAgICAgICAqL1xuICAgICAgICBjYW5jZWw6IChjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgbmV4dEZyYW1lLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgICAgICAgICB0b0tlZXBBbGl2ZS5kZWxldGUoY2FsbGJhY2spO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRXhlY3V0ZSBhbGwgc2NoZWR1bGUgY2FsbGJhY2tzLlxuICAgICAgICAgKi9cbiAgICAgICAgcHJvY2VzczogKGZyYW1lRGF0YSkgPT4ge1xuICAgICAgICAgICAgbGF0ZXN0RnJhbWVEYXRhID0gZnJhbWVEYXRhO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB3ZSdyZSBhbHJlYWR5IHByb2Nlc3Npbmcgd2UndmUgcHJvYmFibHkgYmVlbiB0cmlnZ2VyZWQgYnkgYSBmbHVzaFN5bmNcbiAgICAgICAgICAgICAqIGluc2lkZSBhbiBleGlzdGluZyBwcm9jZXNzLiBJbnN0ZWFkIG9mIGV4ZWN1dGluZywgbWFyayBmbHVzaE5leHRGcmFtZVxuICAgICAgICAgICAgICogYXMgdHJ1ZSBhbmQgZW5zdXJlIHdlIGZsdXNoIHRoZSBmb2xsb3dpbmcgZnJhbWUgYXQgdGhlIGVuZCBvZiB0aGlzIG9uZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKGlzUHJvY2Vzc2luZykge1xuICAgICAgICAgICAgICAgIGZsdXNoTmV4dEZyYW1lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpc1Byb2Nlc3NpbmcgPSB0cnVlO1xuICAgICAgICAgICAgW3RoaXNGcmFtZSwgbmV4dEZyYW1lXSA9IFtuZXh0RnJhbWUsIHRoaXNGcmFtZV07XG4gICAgICAgICAgICAvLyBFeGVjdXRlIHRoaXMgZnJhbWVcbiAgICAgICAgICAgIHRoaXNGcmFtZS5mb3JFYWNoKHRyaWdnZXJDYWxsYmFjayk7XG4gICAgICAgICAgICAvLyBDbGVhciB0aGUgZnJhbWUgc28gbm8gY2FsbGJhY2tzIHJlbWFpbi4gVGhpcyBpcyB0byBhdm9pZFxuICAgICAgICAgICAgLy8gbWVtb3J5IGxlYWtzIHNob3VsZCB0aGlzIHJlbmRlciBzdGVwIG5vdCBydW4gZm9yIGEgd2hpbGUuXG4gICAgICAgICAgICB0aGlzRnJhbWUuY2xlYXIoKTtcbiAgICAgICAgICAgIGlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGZsdXNoTmV4dEZyYW1lKSB7XG4gICAgICAgICAgICAgICAgZmx1c2hOZXh0RnJhbWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBzdGVwLnByb2Nlc3MoZnJhbWVEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9O1xuICAgIHJldHVybiBzdGVwO1xufVxuXG5jb25zdCBzdGVwc09yZGVyID0gW1xuICAgIFwicmVhZFwiLCAvLyBSZWFkXG4gICAgXCJyZXNvbHZlS2V5ZnJhbWVzXCIsIC8vIFdyaXRlL1JlYWQvV3JpdGUvUmVhZFxuICAgIFwidXBkYXRlXCIsIC8vIENvbXB1dGVcbiAgICBcInByZVJlbmRlclwiLCAvLyBDb21wdXRlXG4gICAgXCJyZW5kZXJcIiwgLy8gV3JpdGVcbiAgICBcInBvc3RSZW5kZXJcIiwgLy8gQ29tcHV0ZVxuXTtcbmNvbnN0IG1heEVsYXBzZWQkMSA9IDQwO1xuZnVuY3Rpb24gY3JlYXRlUmVuZGVyQmF0Y2hlcihzY2hlZHVsZU5leHRCYXRjaCwgYWxsb3dLZWVwQWxpdmUpIHtcbiAgICBsZXQgcnVuTmV4dEZyYW1lID0gZmFsc2U7XG4gICAgbGV0IHVzZURlZmF1bHRFbGFwc2VkID0gdHJ1ZTtcbiAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgICAgZGVsdGE6IDAuMCxcbiAgICAgICAgdGltZXN0YW1wOiAwLjAsXG4gICAgICAgIGlzUHJvY2Vzc2luZzogZmFsc2UsXG4gICAgfTtcbiAgICBjb25zdCBmbGFnUnVuTmV4dEZyYW1lID0gKCkgPT4gKHJ1bk5leHRGcmFtZSA9IHRydWUpO1xuICAgIGNvbnN0IHN0ZXBzID0gc3RlcHNPcmRlci5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgICAgIGFjY1trZXldID0gY3JlYXRlUmVuZGVyU3RlcChmbGFnUnVuTmV4dEZyYW1lKTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG4gICAgY29uc3QgeyByZWFkLCByZXNvbHZlS2V5ZnJhbWVzLCB1cGRhdGUsIHByZVJlbmRlciwgcmVuZGVyLCBwb3N0UmVuZGVyIH0gPSBzdGVwcztcbiAgICBjb25zdCBwcm9jZXNzQmF0Y2ggPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IE1vdGlvbkdsb2JhbENvbmZpZy51c2VNYW51YWxUaW1pbmdcbiAgICAgICAgICAgID8gc3RhdGUudGltZXN0YW1wXG4gICAgICAgICAgICA6IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBydW5OZXh0RnJhbWUgPSBmYWxzZTtcbiAgICAgICAgc3RhdGUuZGVsdGEgPSB1c2VEZWZhdWx0RWxhcHNlZFxuICAgICAgICAgICAgPyAxMDAwIC8gNjBcbiAgICAgICAgICAgIDogTWF0aC5tYXgoTWF0aC5taW4odGltZXN0YW1wIC0gc3RhdGUudGltZXN0YW1wLCBtYXhFbGFwc2VkJDEpLCAxKTtcbiAgICAgICAgc3RhdGUudGltZXN0YW1wID0gdGltZXN0YW1wO1xuICAgICAgICBzdGF0ZS5pc1Byb2Nlc3NpbmcgPSB0cnVlO1xuICAgICAgICAvLyBVbnJvbGxlZCByZW5kZXIgbG9vcCBmb3IgYmV0dGVyIHBlci1mcmFtZSBwZXJmb3JtYW5jZVxuICAgICAgICByZWFkLnByb2Nlc3Moc3RhdGUpO1xuICAgICAgICByZXNvbHZlS2V5ZnJhbWVzLnByb2Nlc3Moc3RhdGUpO1xuICAgICAgICB1cGRhdGUucHJvY2VzcyhzdGF0ZSk7XG4gICAgICAgIHByZVJlbmRlci5wcm9jZXNzKHN0YXRlKTtcbiAgICAgICAgcmVuZGVyLnByb2Nlc3Moc3RhdGUpO1xuICAgICAgICBwb3N0UmVuZGVyLnByb2Nlc3Moc3RhdGUpO1xuICAgICAgICBzdGF0ZS5pc1Byb2Nlc3NpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKHJ1bk5leHRGcmFtZSAmJiBhbGxvd0tlZXBBbGl2ZSkge1xuICAgICAgICAgICAgdXNlRGVmYXVsdEVsYXBzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHNjaGVkdWxlTmV4dEJhdGNoKHByb2Nlc3NCYXRjaCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHdha2UgPSAoKSA9PiB7XG4gICAgICAgIHJ1bk5leHRGcmFtZSA9IHRydWU7XG4gICAgICAgIHVzZURlZmF1bHRFbGFwc2VkID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFzdGF0ZS5pc1Byb2Nlc3NpbmcpIHtcbiAgICAgICAgICAgIHNjaGVkdWxlTmV4dEJhdGNoKHByb2Nlc3NCYXRjaCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHNjaGVkdWxlID0gc3RlcHNPcmRlci5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgICAgIGNvbnN0IHN0ZXAgPSBzdGVwc1trZXldO1xuICAgICAgICBhY2Nba2V5XSA9IChwcm9jZXNzLCBrZWVwQWxpdmUgPSBmYWxzZSwgaW1tZWRpYXRlID0gZmFsc2UpID0+IHtcbiAgICAgICAgICAgIGlmICghcnVuTmV4dEZyYW1lKVxuICAgICAgICAgICAgICAgIHdha2UoKTtcbiAgICAgICAgICAgIHJldHVybiBzdGVwLnNjaGVkdWxlKHByb2Nlc3MsIGtlZXBBbGl2ZSwgaW1tZWRpYXRlKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG4gICAgY29uc3QgY2FuY2VsID0gKHByb2Nlc3MpID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGVwc09yZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzdGVwc1tzdGVwc09yZGVyW2ldXS5jYW5jZWwocHJvY2Vzcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB7IHNjaGVkdWxlLCBjYW5jZWwsIHN0YXRlLCBzdGVwcyB9O1xufVxuXG5jb25zdCB7IHNjaGVkdWxlOiBmcmFtZSwgY2FuY2VsOiBjYW5jZWxGcmFtZSwgc3RhdGU6IGZyYW1lRGF0YSwgc3RlcHM6IGZyYW1lU3RlcHMsIH0gPSBjcmVhdGVSZW5kZXJCYXRjaGVyKHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgIT09IFwidW5kZWZpbmVkXCIgPyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgOiBtb3Rpb25VdGlscy5ub29wLCB0cnVlKTtcblxuLypcbiAgQmV6aWVyIGZ1bmN0aW9uIGdlbmVyYXRvclxuICBUaGlzIGhhcyBiZWVuIG1vZGlmaWVkIGZyb20gR2HDq3RhbiBSZW5hdWRlYXUncyBCZXppZXJFYXNpbmdcbiAgaHR0cHM6Ly9naXRodWIuY29tL2dyZS9iZXppZXItZWFzaW5nL2Jsb2IvbWFzdGVyL3NyYy9pbmRleC5qc1xuICBodHRwczovL2dpdGh1Yi5jb20vZ3JlL2Jlemllci1lYXNpbmcvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICBcbiAgSSd2ZSByZW1vdmVkIHRoZSBuZXd0b25SYXBoc29uSXRlcmF0ZSBhbGdvIGJlY2F1c2UgaW4gYmVuY2htYXJraW5nIGl0XG4gIHdhc24ndCBub3RpY2lhYmx5IGZhc3RlciB0aGFuIGJpbmFyeVN1YmRpdmlzaW9uLCBpbmRlZWQgcmVtb3ZpbmcgaXRcbiAgdXN1YWxseSBpbXByb3ZlZCB0aW1lcywgZGVwZW5kaW5nIG9uIHRoZSBjdXJ2ZS5cbiAgSSBhbHNvIHJlbW92ZWQgdGhlIGxvb2t1cCB0YWJsZSwgYXMgZm9yIHRoZSBhZGRlZCBidW5kbGUgc2l6ZSBhbmQgbG9vcCB3ZSdyZVxuICBvbmx5IGN1dHRpbmcgfjQgb3Igc28gc3ViZGl2aXNpb24gaXRlcmF0aW9ucy4gSSBidW1wZWQgdGhlIG1heCBpdGVyYXRpb25zIHVwXG4gIHRvIDEyIHRvIGNvbXBlbnNhdGUgYW5kIHRoaXMgc3RpbGwgdGVuZGVkIHRvIGJlIGZhc3RlciBmb3Igbm8gcGVyY2VpdmFibGVcbiAgbG9zcyBpbiBhY2N1cmFjeS5cbiAgVXNhZ2VcbiAgICBjb25zdCBlYXNlT3V0ID0gY3ViaWNCZXppZXIoLjE3LC42NywuODMsLjY3KTtcbiAgICBjb25zdCB4ID0gZWFzZU91dCgwLjUpOyAvLyByZXR1cm5zIDAuNjI3Li4uXG4qL1xuLy8gUmV0dXJucyB4KHQpIGdpdmVuIHQsIHgxLCBhbmQgeDIsIG9yIHkodCkgZ2l2ZW4gdCwgeTEsIGFuZCB5Mi5cbmNvbnN0IGNhbGNCZXppZXIgPSAodCwgYTEsIGEyKSA9PiAoKCgxLjAgLSAzLjAgKiBhMiArIDMuMCAqIGExKSAqIHQgKyAoMy4wICogYTIgLSA2LjAgKiBhMSkpICogdCArIDMuMCAqIGExKSAqXG4gICAgdDtcbmNvbnN0IHN1YmRpdmlzaW9uUHJlY2lzaW9uID0gMC4wMDAwMDAxO1xuY29uc3Qgc3ViZGl2aXNpb25NYXhJdGVyYXRpb25zID0gMTI7XG5mdW5jdGlvbiBiaW5hcnlTdWJkaXZpZGUoeCwgbG93ZXJCb3VuZCwgdXBwZXJCb3VuZCwgbVgxLCBtWDIpIHtcbiAgICBsZXQgY3VycmVudFg7XG4gICAgbGV0IGN1cnJlbnRUO1xuICAgIGxldCBpID0gMDtcbiAgICBkbyB7XG4gICAgICAgIGN1cnJlbnRUID0gbG93ZXJCb3VuZCArICh1cHBlckJvdW5kIC0gbG93ZXJCb3VuZCkgLyAyLjA7XG4gICAgICAgIGN1cnJlbnRYID0gY2FsY0JlemllcihjdXJyZW50VCwgbVgxLCBtWDIpIC0geDtcbiAgICAgICAgaWYgKGN1cnJlbnRYID4gMC4wKSB7XG4gICAgICAgICAgICB1cHBlckJvdW5kID0gY3VycmVudFQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb3dlckJvdW5kID0gY3VycmVudFQ7XG4gICAgICAgIH1cbiAgICB9IHdoaWxlIChNYXRoLmFicyhjdXJyZW50WCkgPiBzdWJkaXZpc2lvblByZWNpc2lvbiAmJlxuICAgICAgICArK2kgPCBzdWJkaXZpc2lvbk1heEl0ZXJhdGlvbnMpO1xuICAgIHJldHVybiBjdXJyZW50VDtcbn1cbmZ1bmN0aW9uIGN1YmljQmV6aWVyKG1YMSwgbVkxLCBtWDIsIG1ZMikge1xuICAgIC8vIElmIHRoaXMgaXMgYSBsaW5lYXIgZ3JhZGllbnQsIHJldHVybiBsaW5lYXIgZWFzaW5nXG4gICAgaWYgKG1YMSA9PT0gbVkxICYmIG1YMiA9PT0gbVkyKVxuICAgICAgICByZXR1cm4gbW90aW9uVXRpbHMubm9vcDtcbiAgICBjb25zdCBnZXRURm9yWCA9IChhWCkgPT4gYmluYXJ5U3ViZGl2aWRlKGFYLCAwLCAxLCBtWDEsIG1YMik7XG4gICAgLy8gSWYgYW5pbWF0aW9uIGlzIGF0IHN0YXJ0L2VuZCwgcmV0dXJuIHQgd2l0aG91dCBlYXNpbmdcbiAgICByZXR1cm4gKHQpID0+IHQgPT09IDAgfHwgdCA9PT0gMSA/IHQgOiBjYWxjQmV6aWVyKGdldFRGb3JYKHQpLCBtWTEsIG1ZMik7XG59XG5cbi8vIEFjY2VwdHMgYW4gZWFzaW5nIGZ1bmN0aW9uIGFuZCByZXR1cm5zIGEgbmV3IG9uZSB0aGF0IG91dHB1dHMgbWlycm9yZWQgdmFsdWVzIGZvclxuLy8gdGhlIHNlY29uZCBoYWxmIG9mIHRoZSBhbmltYXRpb24uIFR1cm5zIGVhc2VJbiBpbnRvIGVhc2VJbk91dC5cbmNvbnN0IG1pcnJvckVhc2luZyA9IChlYXNpbmcpID0+IChwKSA9PiBwIDw9IDAuNSA/IGVhc2luZygyICogcCkgLyAyIDogKDIgLSBlYXNpbmcoMiAqICgxIC0gcCkpKSAvIDI7XG5cbi8vIEFjY2VwdHMgYW4gZWFzaW5nIGZ1bmN0aW9uIGFuZCByZXR1cm5zIGEgbmV3IG9uZSB0aGF0IG91dHB1dHMgcmV2ZXJzZWQgdmFsdWVzLlxuLy8gVHVybnMgZWFzZUluIGludG8gZWFzZU91dC5cbmNvbnN0IHJldmVyc2VFYXNpbmcgPSAoZWFzaW5nKSA9PiAocCkgPT4gMSAtIGVhc2luZygxIC0gcCk7XG5cbmNvbnN0IGJhY2tPdXQgPSAvKkBfX1BVUkVfXyovIGN1YmljQmV6aWVyKDAuMzMsIDEuNTMsIDAuNjksIDAuOTkpO1xuY29uc3QgYmFja0luID0gLypAX19QVVJFX18qLyByZXZlcnNlRWFzaW5nKGJhY2tPdXQpO1xuY29uc3QgYmFja0luT3V0ID0gLypAX19QVVJFX18qLyBtaXJyb3JFYXNpbmcoYmFja0luKTtcblxuY29uc3QgYW50aWNpcGF0ZSA9IChwKSA9PiAocCAqPSAyKSA8IDEgPyAwLjUgKiBiYWNrSW4ocCkgOiAwLjUgKiAoMiAtIE1hdGgucG93KDIsIC0xMCAqIChwIC0gMSkpKTtcblxuY29uc3QgY2lyY0luID0gKHApID0+IDEgLSBNYXRoLnNpbihNYXRoLmFjb3MocCkpO1xuY29uc3QgY2lyY091dCA9IHJldmVyc2VFYXNpbmcoY2lyY0luKTtcbmNvbnN0IGNpcmNJbk91dCA9IG1pcnJvckVhc2luZyhjaXJjSW4pO1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSB2YWx1ZSBpcyBhIHplcm8gdmFsdWUgc3RyaW5nIGxpa2UgXCIwcHhcIiBvciBcIjAlXCJcbiAqL1xuY29uc3QgaXNaZXJvVmFsdWVTdHJpbmcgPSAodikgPT4gL14wW14uXFxzXSskL3UudGVzdCh2KTtcblxuZnVuY3Rpb24gaXNOb25lKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IDA7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gXCJub25lXCIgfHwgdmFsdWUgPT09IFwiMFwiIHx8IGlzWmVyb1ZhbHVlU3RyaW5nKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiB2YWx1ZSBpcyBhIG51bWVyaWNhbCBzdHJpbmcsIGllIGEgc3RyaW5nIHRoYXQgaXMgcHVyZWx5IGEgbnVtYmVyIGVnIFwiMTAwXCIgb3IgXCItMTAwLjFcIlxuICovXG5jb25zdCBpc051bWVyaWNhbFN0cmluZyA9ICh2KSA9PiAvXi0/KD86XFxkKyg/OlxcLlxcZCspP3xcXC5cXGQrKSQvdS50ZXN0KHYpO1xuXG5jb25zdCBjaGVja1N0cmluZ1N0YXJ0c1dpdGggPSAodG9rZW4pID0+IChrZXkpID0+IHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIgJiYga2V5LnN0YXJ0c1dpdGgodG9rZW4pO1xuY29uc3QgaXNDU1NWYXJpYWJsZU5hbWUgPSBcbi8qQF9fUFVSRV9fKi8gY2hlY2tTdHJpbmdTdGFydHNXaXRoKFwiLS1cIik7XG5jb25zdCBzdGFydHNBc1ZhcmlhYmxlVG9rZW4gPSBcbi8qQF9fUFVSRV9fKi8gY2hlY2tTdHJpbmdTdGFydHNXaXRoKFwidmFyKC0tXCIpO1xuY29uc3QgaXNDU1NWYXJpYWJsZVRva2VuID0gKHZhbHVlKSA9PiB7XG4gICAgY29uc3Qgc3RhcnRzV2l0aFRva2VuID0gc3RhcnRzQXNWYXJpYWJsZVRva2VuKHZhbHVlKTtcbiAgICBpZiAoIXN0YXJ0c1dpdGhUb2tlbilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vIEVuc3VyZSBhbnkgY29tbWVudHMgYXJlIHN0cmlwcGVkIGZyb20gdGhlIHZhbHVlIGFzIHRoaXMgY2FuIGhhcm0gcGVyZm9ybWFuY2Ugb2YgdGhlIHJlZ2V4LlxuICAgIHJldHVybiBzaW5nbGVDc3NWYXJpYWJsZVJlZ2V4LnRlc3QodmFsdWUuc3BsaXQoXCIvKlwiKVswXS50cmltKCkpO1xufTtcbmNvbnN0IHNpbmdsZUNzc1ZhcmlhYmxlUmVnZXggPSAvdmFyXFwoLS0oPzpbXFx3LV0rXFxzKnxbXFx3LV0rXFxzKiwoPzpcXHMqW14pKFxcc118XFxzKlxcKCg/OlteKShdfFxcKFteKShdKlxcKSkqXFwpKStcXHMqKVxcKSQvaXU7XG5cbi8qKlxuICogUGFyc2UgRnJhbWVyJ3Mgc3BlY2lhbCBDU1MgdmFyaWFibGUgZm9ybWF0IGludG8gYSBDU1MgdG9rZW4gYW5kIGEgZmFsbGJhY2suXG4gKlxuICogYGBgXG4gKiBgdmFyKC0tZm9vLCAjZmZmKWAgPT4gW2AtLWZvb2AsICcjZmZmJ11cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBjdXJyZW50XG4gKi9cbmNvbnN0IHNwbGl0Q1NTVmFyaWFibGVSZWdleCA9IFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlZG9zLWRldGVjdG9yL25vLXVuc2FmZS1yZWdleCAtLSBmYWxzZSBwb3NpdGl2ZSwgYXMgaXQgY2FuIG1hdGNoIGEgbG90IG9mIHdvcmRzXG4vXnZhclxcKC0tKD86KFtcXHctXSspfChbXFx3LV0rKSwgPyhbYS16QS1aXFxkICgpJSMuLC1dKykpXFwpL3U7XG5mdW5jdGlvbiBwYXJzZUNTU1ZhcmlhYmxlKGN1cnJlbnQpIHtcbiAgICBjb25zdCBtYXRjaCA9IHNwbGl0Q1NTVmFyaWFibGVSZWdleC5leGVjKGN1cnJlbnQpO1xuICAgIGlmICghbWF0Y2gpXG4gICAgICAgIHJldHVybiBbLF07XG4gICAgY29uc3QgWywgdG9rZW4xLCB0b2tlbjIsIGZhbGxiYWNrXSA9IG1hdGNoO1xuICAgIHJldHVybiBbYC0tJHt0b2tlbjEgIT09IG51bGwgJiYgdG9rZW4xICE9PSB2b2lkIDAgPyB0b2tlbjEgOiB0b2tlbjJ9YCwgZmFsbGJhY2tdO1xufVxuY29uc3QgbWF4RGVwdGggPSA0O1xuZnVuY3Rpb24gZ2V0VmFyaWFibGVWYWx1ZShjdXJyZW50LCBlbGVtZW50LCBkZXB0aCA9IDEpIHtcbiAgICBtb3Rpb25VdGlscy5pbnZhcmlhbnQoZGVwdGggPD0gbWF4RGVwdGgsIGBNYXggQ1NTIHZhcmlhYmxlIGZhbGxiYWNrIGRlcHRoIGRldGVjdGVkIGluIHByb3BlcnR5IFwiJHtjdXJyZW50fVwiLiBUaGlzIG1heSBpbmRpY2F0ZSBhIGNpcmN1bGFyIGZhbGxiYWNrIGRlcGVuZGVuY3kuYCk7XG4gICAgY29uc3QgW3Rva2VuLCBmYWxsYmFja10gPSBwYXJzZUNTU1ZhcmlhYmxlKGN1cnJlbnQpO1xuICAgIC8vIE5vIENTUyB2YXJpYWJsZSBkZXRlY3RlZFxuICAgIGlmICghdG9rZW4pXG4gICAgICAgIHJldHVybjtcbiAgICAvLyBBdHRlbXB0IHRvIHJlYWQgdGhpcyBDU1MgdmFyaWFibGUgb2ZmIHRoZSBlbGVtZW50XG4gICAgY29uc3QgcmVzb2x2ZWQgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKHRva2VuKTtcbiAgICBpZiAocmVzb2x2ZWQpIHtcbiAgICAgICAgY29uc3QgdHJpbW1lZCA9IHJlc29sdmVkLnRyaW0oKTtcbiAgICAgICAgcmV0dXJuIGlzTnVtZXJpY2FsU3RyaW5nKHRyaW1tZWQpID8gcGFyc2VGbG9hdCh0cmltbWVkKSA6IHRyaW1tZWQ7XG4gICAgfVxuICAgIHJldHVybiBpc0NTU1ZhcmlhYmxlVG9rZW4oZmFsbGJhY2spXG4gICAgICAgID8gZ2V0VmFyaWFibGVWYWx1ZShmYWxsYmFjaywgZWxlbWVudCwgZGVwdGggKyAxKVxuICAgICAgICA6IGZhbGxiYWNrO1xufVxuXG5jb25zdCBjbGFtcCA9IChtaW4sIG1heCwgdikgPT4ge1xuICAgIGlmICh2ID4gbWF4KVxuICAgICAgICByZXR1cm4gbWF4O1xuICAgIGlmICh2IDwgbWluKVxuICAgICAgICByZXR1cm4gbWluO1xuICAgIHJldHVybiB2O1xufTtcblxuY29uc3QgbnVtYmVyID0ge1xuICAgIHRlc3Q6ICh2KSA9PiB0eXBlb2YgdiA9PT0gXCJudW1iZXJcIixcbiAgICBwYXJzZTogcGFyc2VGbG9hdCxcbiAgICB0cmFuc2Zvcm06ICh2KSA9PiB2LFxufTtcbmNvbnN0IGFscGhhID0ge1xuICAgIC4uLm51bWJlcixcbiAgICB0cmFuc2Zvcm06ICh2KSA9PiBjbGFtcCgwLCAxLCB2KSxcbn07XG5jb25zdCBzY2FsZSA9IHtcbiAgICAuLi5udW1iZXIsXG4gICAgZGVmYXVsdDogMSxcbn07XG5cbmNvbnN0IGNyZWF0ZVVuaXRUeXBlID0gKHVuaXQpID0+ICh7XG4gICAgdGVzdDogKHYpID0+IHR5cGVvZiB2ID09PSBcInN0cmluZ1wiICYmIHYuZW5kc1dpdGgodW5pdCkgJiYgdi5zcGxpdChcIiBcIikubGVuZ3RoID09PSAxLFxuICAgIHBhcnNlOiBwYXJzZUZsb2F0LFxuICAgIHRyYW5zZm9ybTogKHYpID0+IGAke3Z9JHt1bml0fWAsXG59KTtcbmNvbnN0IGRlZ3JlZXMgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVVuaXRUeXBlKFwiZGVnXCIpO1xuY29uc3QgcGVyY2VudCA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlVW5pdFR5cGUoXCIlXCIpO1xuY29uc3QgcHggPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVVuaXRUeXBlKFwicHhcIik7XG5jb25zdCB2aCA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlVW5pdFR5cGUoXCJ2aFwiKTtcbmNvbnN0IHZ3ID0gLypAX19QVVJFX18qLyBjcmVhdGVVbml0VHlwZShcInZ3XCIpO1xuY29uc3QgcHJvZ3Jlc3NQZXJjZW50YWdlID0ge1xuICAgIC4uLnBlcmNlbnQsXG4gICAgcGFyc2U6ICh2KSA9PiBwZXJjZW50LnBhcnNlKHYpIC8gMTAwLFxuICAgIHRyYW5zZm9ybTogKHYpID0+IHBlcmNlbnQudHJhbnNmb3JtKHYgKiAxMDApLFxufTtcblxuY29uc3QgcG9zaXRpb25hbEtleXMgPSBuZXcgU2V0KFtcbiAgICBcIndpZHRoXCIsXG4gICAgXCJoZWlnaHRcIixcbiAgICBcInRvcFwiLFxuICAgIFwibGVmdFwiLFxuICAgIFwicmlnaHRcIixcbiAgICBcImJvdHRvbVwiLFxuICAgIFwieFwiLFxuICAgIFwieVwiLFxuICAgIFwidHJhbnNsYXRlWFwiLFxuICAgIFwidHJhbnNsYXRlWVwiLFxuXSk7XG5jb25zdCBpc051bU9yUHhUeXBlID0gKHYpID0+IHYgPT09IG51bWJlciB8fCB2ID09PSBweDtcbmNvbnN0IGdldFBvc0Zyb21NYXRyaXggPSAobWF0cml4LCBwb3MpID0+IHBhcnNlRmxvYXQobWF0cml4LnNwbGl0KFwiLCBcIilbcG9zXSk7XG5jb25zdCBnZXRUcmFuc2xhdGVGcm9tTWF0cml4ID0gKHBvczIsIHBvczMpID0+IChfYmJveCwgeyB0cmFuc2Zvcm0gfSkgPT4ge1xuICAgIGlmICh0cmFuc2Zvcm0gPT09IFwibm9uZVwiIHx8ICF0cmFuc2Zvcm0pXG4gICAgICAgIHJldHVybiAwO1xuICAgIGNvbnN0IG1hdHJpeDNkID0gdHJhbnNmb3JtLm1hdGNoKC9ebWF0cml4M2RcXCgoLispXFwpJC91KTtcbiAgICBpZiAobWF0cml4M2QpIHtcbiAgICAgICAgcmV0dXJuIGdldFBvc0Zyb21NYXRyaXgobWF0cml4M2RbMV0sIHBvczMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbWF0cml4ID0gdHJhbnNmb3JtLm1hdGNoKC9ebWF0cml4XFwoKC4rKVxcKSQvdSk7XG4gICAgICAgIGlmIChtYXRyaXgpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRQb3NGcm9tTWF0cml4KG1hdHJpeFsxXSwgcG9zMik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCB0cmFuc2Zvcm1LZXlzID0gbmV3IFNldChbXCJ4XCIsIFwieVwiLCBcInpcIl0pO1xuY29uc3Qgbm9uVHJhbnNsYXRpb25hbFRyYW5zZm9ybUtleXMgPSB0cmFuc2Zvcm1Qcm9wT3JkZXIuZmlsdGVyKChrZXkpID0+ICF0cmFuc2Zvcm1LZXlzLmhhcyhrZXkpKTtcbmZ1bmN0aW9uIHJlbW92ZU5vblRyYW5zbGF0aW9uYWxUcmFuc2Zvcm0odmlzdWFsRWxlbWVudCkge1xuICAgIGNvbnN0IHJlbW92ZWRUcmFuc2Zvcm1zID0gW107XG4gICAgbm9uVHJhbnNsYXRpb25hbFRyYW5zZm9ybUtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdmlzdWFsRWxlbWVudC5nZXRWYWx1ZShrZXkpO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVtb3ZlZFRyYW5zZm9ybXMucHVzaChba2V5LCB2YWx1ZS5nZXQoKV0pO1xuICAgICAgICAgICAgdmFsdWUuc2V0KGtleS5zdGFydHNXaXRoKFwic2NhbGVcIikgPyAxIDogMCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVtb3ZlZFRyYW5zZm9ybXM7XG59XG5jb25zdCBwb3NpdGlvbmFsVmFsdWVzID0ge1xuICAgIC8vIERpbWVuc2lvbnNcbiAgICB3aWR0aDogKHsgeCB9LCB7IHBhZGRpbmdMZWZ0ID0gXCIwXCIsIHBhZGRpbmdSaWdodCA9IFwiMFwiIH0pID0+IHgubWF4IC0geC5taW4gLSBwYXJzZUZsb2F0KHBhZGRpbmdMZWZ0KSAtIHBhcnNlRmxvYXQocGFkZGluZ1JpZ2h0KSxcbiAgICBoZWlnaHQ6ICh7IHkgfSwgeyBwYWRkaW5nVG9wID0gXCIwXCIsIHBhZGRpbmdCb3R0b20gPSBcIjBcIiB9KSA9PiB5Lm1heCAtIHkubWluIC0gcGFyc2VGbG9hdChwYWRkaW5nVG9wKSAtIHBhcnNlRmxvYXQocGFkZGluZ0JvdHRvbSksXG4gICAgdG9wOiAoX2Jib3gsIHsgdG9wIH0pID0+IHBhcnNlRmxvYXQodG9wKSxcbiAgICBsZWZ0OiAoX2Jib3gsIHsgbGVmdCB9KSA9PiBwYXJzZUZsb2F0KGxlZnQpLFxuICAgIGJvdHRvbTogKHsgeSB9LCB7IHRvcCB9KSA9PiBwYXJzZUZsb2F0KHRvcCkgKyAoeS5tYXggLSB5Lm1pbiksXG4gICAgcmlnaHQ6ICh7IHggfSwgeyBsZWZ0IH0pID0+IHBhcnNlRmxvYXQobGVmdCkgKyAoeC5tYXggLSB4Lm1pbiksXG4gICAgLy8gVHJhbnNmb3JtXG4gICAgeDogZ2V0VHJhbnNsYXRlRnJvbU1hdHJpeCg0LCAxMyksXG4gICAgeTogZ2V0VHJhbnNsYXRlRnJvbU1hdHJpeCg1LCAxNCksXG59O1xuLy8gQWxpYXMgdHJhbnNsYXRlIGxvbmdmb3JtIG5hbWVzXG5wb3NpdGlvbmFsVmFsdWVzLnRyYW5zbGF0ZVggPSBwb3NpdGlvbmFsVmFsdWVzLng7XG5wb3NpdGlvbmFsVmFsdWVzLnRyYW5zbGF0ZVkgPSBwb3NpdGlvbmFsVmFsdWVzLnk7XG5cbi8qKlxuICogVGVzdHMgYSBwcm92aWRlZCB2YWx1ZSBhZ2FpbnN0IGEgVmFsdWVUeXBlXG4gKi9cbmNvbnN0IHRlc3RWYWx1ZVR5cGUgPSAodikgPT4gKHR5cGUpID0+IHR5cGUudGVzdCh2KTtcblxuLyoqXG4gKiBWYWx1ZVR5cGUgZm9yIFwiYXV0b1wiXG4gKi9cbmNvbnN0IGF1dG8gPSB7XG4gICAgdGVzdDogKHYpID0+IHYgPT09IFwiYXV0b1wiLFxuICAgIHBhcnNlOiAodikgPT4gdixcbn07XG5cbi8qKlxuICogQSBsaXN0IG9mIHZhbHVlIHR5cGVzIGNvbW1vbmx5IHVzZWQgZm9yIGRpbWVuc2lvbnNcbiAqL1xuY29uc3QgZGltZW5zaW9uVmFsdWVUeXBlcyA9IFtudW1iZXIsIHB4LCBwZXJjZW50LCBkZWdyZWVzLCB2dywgdmgsIGF1dG9dO1xuLyoqXG4gKiBUZXN0cyBhIGRpbWVuc2lvbmFsIHZhbHVlIGFnYWluc3QgdGhlIGxpc3Qgb2YgZGltZW5zaW9uIFZhbHVlVHlwZXNcbiAqL1xuY29uc3QgZmluZERpbWVuc2lvblZhbHVlVHlwZSA9ICh2KSA9PiBkaW1lbnNpb25WYWx1ZVR5cGVzLmZpbmQodGVzdFZhbHVlVHlwZSh2KSk7XG5cbmNvbnN0IHRvUmVzb2x2ZSA9IG5ldyBTZXQoKTtcbmxldCBpc1NjaGVkdWxlZCA9IGZhbHNlO1xubGV0IGFueU5lZWRzTWVhc3VyZW1lbnQgPSBmYWxzZTtcbmZ1bmN0aW9uIG1lYXN1cmVBbGxLZXlmcmFtZXMoKSB7XG4gICAgaWYgKGFueU5lZWRzTWVhc3VyZW1lbnQpIHtcbiAgICAgICAgY29uc3QgcmVzb2x2ZXJzVG9NZWFzdXJlID0gQXJyYXkuZnJvbSh0b1Jlc29sdmUpLmZpbHRlcigocmVzb2x2ZXIpID0+IHJlc29sdmVyLm5lZWRzTWVhc3VyZW1lbnQpO1xuICAgICAgICBjb25zdCBlbGVtZW50c1RvTWVhc3VyZSA9IG5ldyBTZXQocmVzb2x2ZXJzVG9NZWFzdXJlLm1hcCgocmVzb2x2ZXIpID0+IHJlc29sdmVyLmVsZW1lbnQpKTtcbiAgICAgICAgY29uc3QgdHJhbnNmb3Jtc1RvUmVzdG9yZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdyaXRlIHBhc3NcbiAgICAgICAgICogSWYgd2UncmUgbWVhc3VyaW5nIGVsZW1lbnRzIHdlIHdhbnQgdG8gcmVtb3ZlIGJvdW5kaW5nIGJveC1jaGFuZ2luZyB0cmFuc2Zvcm1zLlxuICAgICAgICAgKi9cbiAgICAgICAgZWxlbWVudHNUb01lYXN1cmUuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVtb3ZlZFRyYW5zZm9ybXMgPSByZW1vdmVOb25UcmFuc2xhdGlvbmFsVHJhbnNmb3JtKGVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKCFyZW1vdmVkVHJhbnNmb3Jtcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdHJhbnNmb3Jtc1RvUmVzdG9yZS5zZXQoZWxlbWVudCwgcmVtb3ZlZFRyYW5zZm9ybXMpO1xuICAgICAgICAgICAgZWxlbWVudC5yZW5kZXIoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFJlYWRcbiAgICAgICAgcmVzb2x2ZXJzVG9NZWFzdXJlLmZvckVhY2goKHJlc29sdmVyKSA9PiByZXNvbHZlci5tZWFzdXJlSW5pdGlhbFN0YXRlKCkpO1xuICAgICAgICAvLyBXcml0ZVxuICAgICAgICBlbGVtZW50c1RvTWVhc3VyZS5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICBlbGVtZW50LnJlbmRlcigpO1xuICAgICAgICAgICAgY29uc3QgcmVzdG9yZSA9IHRyYW5zZm9ybXNUb1Jlc3RvcmUuZ2V0KGVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKHJlc3RvcmUpIHtcbiAgICAgICAgICAgICAgICByZXN0b3JlLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IGVsZW1lbnQuZ2V0VmFsdWUoa2V5KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBSZWFkXG4gICAgICAgIHJlc29sdmVyc1RvTWVhc3VyZS5mb3JFYWNoKChyZXNvbHZlcikgPT4gcmVzb2x2ZXIubWVhc3VyZUVuZFN0YXRlKCkpO1xuICAgICAgICAvLyBXcml0ZVxuICAgICAgICByZXNvbHZlcnNUb01lYXN1cmUuZm9yRWFjaCgocmVzb2x2ZXIpID0+IHtcbiAgICAgICAgICAgIGlmIChyZXNvbHZlci5zdXNwZW5kZWRTY3JvbGxZICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgcmVzb2x2ZXIuc3VzcGVuZGVkU2Nyb2xsWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhbnlOZWVkc01lYXN1cmVtZW50ID0gZmFsc2U7XG4gICAgaXNTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICB0b1Jlc29sdmUuZm9yRWFjaCgocmVzb2x2ZXIpID0+IHJlc29sdmVyLmNvbXBsZXRlKCkpO1xuICAgIHRvUmVzb2x2ZS5jbGVhcigpO1xufVxuZnVuY3Rpb24gcmVhZEFsbEtleWZyYW1lcygpIHtcbiAgICB0b1Jlc29sdmUuZm9yRWFjaCgocmVzb2x2ZXIpID0+IHtcbiAgICAgICAgcmVzb2x2ZXIucmVhZEtleWZyYW1lcygpO1xuICAgICAgICBpZiAocmVzb2x2ZXIubmVlZHNNZWFzdXJlbWVudCkge1xuICAgICAgICAgICAgYW55TmVlZHNNZWFzdXJlbWVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGZsdXNoS2V5ZnJhbWVSZXNvbHZlcnMoKSB7XG4gICAgcmVhZEFsbEtleWZyYW1lcygpO1xuICAgIG1lYXN1cmVBbGxLZXlmcmFtZXMoKTtcbn1cbmNsYXNzIEtleWZyYW1lUmVzb2x2ZXIge1xuICAgIGNvbnN0cnVjdG9yKHVucmVzb2x2ZWRLZXlmcmFtZXMsIG9uQ29tcGxldGUsIG5hbWUsIG1vdGlvblZhbHVlLCBlbGVtZW50LCBpc0FzeW5jID0gZmFsc2UpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyYWNrIHdoZXRoZXIgdGhpcyByZXNvbHZlciBoYXMgY29tcGxldGVkLiBPbmNlIGNvbXBsZXRlLCBpdCBuZXZlclxuICAgICAgICAgKiBuZWVkcyB0byBhdHRlbXB0IGtleWZyYW1lIHJlc29sdXRpb24gYWdhaW4uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzQ29tcGxldGUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyYWNrIHdoZXRoZXIgdGhpcyByZXNvbHZlciBpcyBhc3luYy4gSWYgaXQgaXMsIGl0J2xsIGJlIGFkZGVkIHRvIHRoZVxuICAgICAgICAgKiByZXNvbHZlciBxdWV1ZSBhbmQgZmx1c2hlZCBpbiB0aGUgbmV4dCBmcmFtZS4gUmVzb2x2ZXJzIHRoYXQgYXJlbid0IGdvaW5nXG4gICAgICAgICAqIHRvIHRyaWdnZXIgcmVhZC93cml0ZSB0aHJhc2hpbmcgZG9uJ3QgbmVlZCB0byBiZSBhc3luYy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXNBc3luYyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVHJhY2sgd2hldGhlciB0aGlzIHJlc29sdmVyIG5lZWRzIHRvIHBlcmZvcm0gYSBtZWFzdXJlbWVudFxuICAgICAgICAgKiB0byByZXNvbHZlIGl0cyBrZXlmcmFtZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5lZWRzTWVhc3VyZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyYWNrIHdoZXRoZXIgdGhpcyByZXNvbHZlciBpcyBjdXJyZW50bHkgc2NoZWR1bGVkIHRvIHJlc29sdmVcbiAgICAgICAgICogdG8gYWxsb3cgaXQgdG8gYmUgY2FuY2VsbGVkIGFuZCByZXN1bWVkIGV4dGVybmFsbHkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMudW5yZXNvbHZlZEtleWZyYW1lcyA9IFsuLi51bnJlc29sdmVkS2V5ZnJhbWVzXTtcbiAgICAgICAgdGhpcy5vbkNvbXBsZXRlID0gb25Db21wbGV0ZTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5tb3Rpb25WYWx1ZSA9IG1vdGlvblZhbHVlO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLmlzQXN5bmMgPSBpc0FzeW5jO1xuICAgIH1cbiAgICBzY2hlZHVsZVJlc29sdmUoKSB7XG4gICAgICAgIHRoaXMuaXNTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5pc0FzeW5jKSB7XG4gICAgICAgICAgICB0b1Jlc29sdmUuYWRkKHRoaXMpO1xuICAgICAgICAgICAgaWYgKCFpc1NjaGVkdWxlZCkge1xuICAgICAgICAgICAgICAgIGlzU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmcmFtZS5yZWFkKHJlYWRBbGxLZXlmcmFtZXMpO1xuICAgICAgICAgICAgICAgIGZyYW1lLnJlc29sdmVLZXlmcmFtZXMobWVhc3VyZUFsbEtleWZyYW1lcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlYWRLZXlmcmFtZXMoKTtcbiAgICAgICAgICAgIHRoaXMuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWFkS2V5ZnJhbWVzKCkge1xuICAgICAgICBjb25zdCB7IHVucmVzb2x2ZWRLZXlmcmFtZXMsIG5hbWUsIGVsZW1lbnQsIG1vdGlvblZhbHVlIH0gPSB0aGlzO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgYSBrZXlmcmFtZSBpcyBudWxsLCB3ZSBoeWRyYXRlIGl0IGVpdGhlciBieSByZWFkaW5nIGl0IGZyb21cbiAgICAgICAgICogdGhlIGluc3RhbmNlLCBvciBwcm9wYWdhdGluZyBmcm9tIHByZXZpb3VzIGtleWZyYW1lcy5cbiAgICAgICAgICovXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdW5yZXNvbHZlZEtleWZyYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHVucmVzb2x2ZWRLZXlmcmFtZXNbaV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBJZiB0aGUgZmlyc3Qga2V5ZnJhbWUgaXMgbnVsbCwgd2UgbmVlZCB0byBmaW5kIGl0cyB2YWx1ZSBieSBzYW1wbGluZyB0aGUgZWxlbWVudFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IG1vdGlvblZhbHVlID09PSBudWxsIHx8IG1vdGlvblZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtb3Rpb25WYWx1ZS5nZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmluYWxLZXlmcmFtZSA9IHVucmVzb2x2ZWRLZXlmcmFtZXNbdW5yZXNvbHZlZEtleWZyYW1lcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bnJlc29sdmVkS2V5ZnJhbWVzWzBdID0gY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVsZW1lbnQgJiYgbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWVBc1JlYWQgPSBlbGVtZW50LnJlYWRWYWx1ZShuYW1lLCBmaW5hbEtleWZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZUFzUmVhZCAhPT0gdW5kZWZpbmVkICYmIHZhbHVlQXNSZWFkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5yZXNvbHZlZEtleWZyYW1lc1swXSA9IHZhbHVlQXNSZWFkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh1bnJlc29sdmVkS2V5ZnJhbWVzWzBdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVucmVzb2x2ZWRLZXlmcmFtZXNbMF0gPSBmaW5hbEtleWZyYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb3Rpb25WYWx1ZSAmJiBjdXJyZW50VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW90aW9uVmFsdWUuc2V0KHVucmVzb2x2ZWRLZXlmcmFtZXNbMF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1bnJlc29sdmVkS2V5ZnJhbWVzW2ldID0gdW5yZXNvbHZlZEtleWZyYW1lc1tpIC0gMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHNldEZpbmFsS2V5ZnJhbWUoKSB7IH1cbiAgICBtZWFzdXJlSW5pdGlhbFN0YXRlKCkgeyB9XG4gICAgcmVuZGVyRW5kU3R5bGVzKCkgeyB9XG4gICAgbWVhc3VyZUVuZFN0YXRlKCkgeyB9XG4gICAgY29tcGxldGUoKSB7XG4gICAgICAgIHRoaXMuaXNDb21wbGV0ZSA9IHRydWU7XG4gICAgICAgIHRoaXMub25Db21wbGV0ZSh0aGlzLnVucmVzb2x2ZWRLZXlmcmFtZXMsIHRoaXMuZmluYWxLZXlmcmFtZSk7XG4gICAgICAgIHRvUmVzb2x2ZS5kZWxldGUodGhpcyk7XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQ29tcGxldGUpIHtcbiAgICAgICAgICAgIHRoaXMuaXNTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRvUmVzb2x2ZS5kZWxldGUodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzdW1lKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNDb21wbGV0ZSlcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVSZXNvbHZlKCk7XG4gICAgfVxufVxuXG4vLyBJZiB0aGlzIG51bWJlciBpcyBhIGRlY2ltYWwsIG1ha2UgaXQganVzdCBmaXZlIGRlY2ltYWwgcGxhY2VzXG4vLyB0byBhdm9pZCBleHBvbmVudHNcbmNvbnN0IHNhbml0aXplID0gKHYpID0+IE1hdGgucm91bmQodiAqIDEwMDAwMCkgLyAxMDAwMDA7XG5cbmNvbnN0IGZsb2F0UmVnZXggPSAvLT8oPzpcXGQrKD86XFwuXFxkKyk/fFxcLlxcZCspL2d1O1xuXG5mdW5jdGlvbiBpc051bGxpc2godikge1xuICAgIHJldHVybiB2ID09IG51bGw7XG59XG5cbmNvbnN0IHNpbmdsZUNvbG9yUmVnZXggPSAvXig/OiNbXFxkYS1mXXszLDh9fCg/OnJnYnxoc2wpYT9cXCgoPzotP1tcXGQuXSslP1ssXFxzXSspezJ9LT9bXFxkLl0rJT9cXHMqKD86WywvXVxccyopPyg/OlxcYlxcZCsoPzpcXC5cXGQrKT98XFwuXFxkKyk/JT9cXCkpJC9pdTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHByb3ZpZGVkIHN0cmluZyBpcyBhIGNvbG9yLCBpZSByZ2JhKDAsMCwwLDApIG9yICMwMDAsXG4gKiBidXQgZmFsc2UgaWYgYSBudW1iZXIgb3IgbXVsdGlwbGUgY29sb3JzXG4gKi9cbmNvbnN0IGlzQ29sb3JTdHJpbmcgPSAodHlwZSwgdGVzdFByb3ApID0+ICh2KSA9PiB7XG4gICAgcmV0dXJuIEJvb2xlYW4oKHR5cGVvZiB2ID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgIHNpbmdsZUNvbG9yUmVnZXgudGVzdCh2KSAmJlxuICAgICAgICB2LnN0YXJ0c1dpdGgodHlwZSkpIHx8XG4gICAgICAgICh0ZXN0UHJvcCAmJlxuICAgICAgICAgICAgIWlzTnVsbGlzaCh2KSAmJlxuICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHYsIHRlc3RQcm9wKSkpO1xufTtcbmNvbnN0IHNwbGl0Q29sb3IgPSAoYU5hbWUsIGJOYW1lLCBjTmFtZSkgPT4gKHYpID0+IHtcbiAgICBpZiAodHlwZW9mIHYgIT09IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiB2O1xuICAgIGNvbnN0IFthLCBiLCBjLCBhbHBoYV0gPSB2Lm1hdGNoKGZsb2F0UmVnZXgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIFthTmFtZV06IHBhcnNlRmxvYXQoYSksXG4gICAgICAgIFtiTmFtZV06IHBhcnNlRmxvYXQoYiksXG4gICAgICAgIFtjTmFtZV06IHBhcnNlRmxvYXQoYyksXG4gICAgICAgIGFscGhhOiBhbHBoYSAhPT0gdW5kZWZpbmVkID8gcGFyc2VGbG9hdChhbHBoYSkgOiAxLFxuICAgIH07XG59O1xuXG5jb25zdCBjbGFtcFJnYlVuaXQgPSAodikgPT4gY2xhbXAoMCwgMjU1LCB2KTtcbmNvbnN0IHJnYlVuaXQgPSB7XG4gICAgLi4ubnVtYmVyLFxuICAgIHRyYW5zZm9ybTogKHYpID0+IE1hdGgucm91bmQoY2xhbXBSZ2JVbml0KHYpKSxcbn07XG5jb25zdCByZ2JhID0ge1xuICAgIHRlc3Q6IC8qQF9fUFVSRV9fKi8gaXNDb2xvclN0cmluZyhcInJnYlwiLCBcInJlZFwiKSxcbiAgICBwYXJzZTogLypAX19QVVJFX18qLyBzcGxpdENvbG9yKFwicmVkXCIsIFwiZ3JlZW5cIiwgXCJibHVlXCIpLFxuICAgIHRyYW5zZm9ybTogKHsgcmVkLCBncmVlbiwgYmx1ZSwgYWxwaGE6IGFscGhhJDEgPSAxIH0pID0+IFwicmdiYShcIiArXG4gICAgICAgIHJnYlVuaXQudHJhbnNmb3JtKHJlZCkgK1xuICAgICAgICBcIiwgXCIgK1xuICAgICAgICByZ2JVbml0LnRyYW5zZm9ybShncmVlbikgK1xuICAgICAgICBcIiwgXCIgK1xuICAgICAgICByZ2JVbml0LnRyYW5zZm9ybShibHVlKSArXG4gICAgICAgIFwiLCBcIiArXG4gICAgICAgIHNhbml0aXplKGFscGhhLnRyYW5zZm9ybShhbHBoYSQxKSkgK1xuICAgICAgICBcIilcIixcbn07XG5cbmZ1bmN0aW9uIHBhcnNlSGV4KHYpIHtcbiAgICBsZXQgciA9IFwiXCI7XG4gICAgbGV0IGcgPSBcIlwiO1xuICAgIGxldCBiID0gXCJcIjtcbiAgICBsZXQgYSA9IFwiXCI7XG4gICAgLy8gSWYgd2UgaGF2ZSA2IGNoYXJhY3RlcnMsIGllICNGRjAwMDBcbiAgICBpZiAodi5sZW5ndGggPiA1KSB7XG4gICAgICAgIHIgPSB2LnN1YnN0cmluZygxLCAzKTtcbiAgICAgICAgZyA9IHYuc3Vic3RyaW5nKDMsIDUpO1xuICAgICAgICBiID0gdi5zdWJzdHJpbmcoNSwgNyk7XG4gICAgICAgIGEgPSB2LnN1YnN0cmluZyg3LCA5KTtcbiAgICAgICAgLy8gT3Igd2UgaGF2ZSAzIGNoYXJhY3RlcnMsIGllICNGMDBcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHIgPSB2LnN1YnN0cmluZygxLCAyKTtcbiAgICAgICAgZyA9IHYuc3Vic3RyaW5nKDIsIDMpO1xuICAgICAgICBiID0gdi5zdWJzdHJpbmcoMywgNCk7XG4gICAgICAgIGEgPSB2LnN1YnN0cmluZyg0LCA1KTtcbiAgICAgICAgciArPSByO1xuICAgICAgICBnICs9IGc7XG4gICAgICAgIGIgKz0gYjtcbiAgICAgICAgYSArPSBhO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICByZWQ6IHBhcnNlSW50KHIsIDE2KSxcbiAgICAgICAgZ3JlZW46IHBhcnNlSW50KGcsIDE2KSxcbiAgICAgICAgYmx1ZTogcGFyc2VJbnQoYiwgMTYpLFxuICAgICAgICBhbHBoYTogYSA/IHBhcnNlSW50KGEsIDE2KSAvIDI1NSA6IDEsXG4gICAgfTtcbn1cbmNvbnN0IGhleCA9IHtcbiAgICB0ZXN0OiAvKkBfX1BVUkVfXyovIGlzQ29sb3JTdHJpbmcoXCIjXCIpLFxuICAgIHBhcnNlOiBwYXJzZUhleCxcbiAgICB0cmFuc2Zvcm06IHJnYmEudHJhbnNmb3JtLFxufTtcblxuY29uc3QgaHNsYSA9IHtcbiAgICB0ZXN0OiAvKkBfX1BVUkVfXyovIGlzQ29sb3JTdHJpbmcoXCJoc2xcIiwgXCJodWVcIiksXG4gICAgcGFyc2U6IC8qQF9fUFVSRV9fKi8gc3BsaXRDb2xvcihcImh1ZVwiLCBcInNhdHVyYXRpb25cIiwgXCJsaWdodG5lc3NcIiksXG4gICAgdHJhbnNmb3JtOiAoeyBodWUsIHNhdHVyYXRpb24sIGxpZ2h0bmVzcywgYWxwaGE6IGFscGhhJDEgPSAxIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIChcImhzbGEoXCIgK1xuICAgICAgICAgICAgTWF0aC5yb3VuZChodWUpICtcbiAgICAgICAgICAgIFwiLCBcIiArXG4gICAgICAgICAgICBwZXJjZW50LnRyYW5zZm9ybShzYW5pdGl6ZShzYXR1cmF0aW9uKSkgK1xuICAgICAgICAgICAgXCIsIFwiICtcbiAgICAgICAgICAgIHBlcmNlbnQudHJhbnNmb3JtKHNhbml0aXplKGxpZ2h0bmVzcykpICtcbiAgICAgICAgICAgIFwiLCBcIiArXG4gICAgICAgICAgICBzYW5pdGl6ZShhbHBoYS50cmFuc2Zvcm0oYWxwaGEkMSkpICtcbiAgICAgICAgICAgIFwiKVwiKTtcbiAgICB9LFxufTtcblxuY29uc3QgY29sb3IgPSB7XG4gICAgdGVzdDogKHYpID0+IHJnYmEudGVzdCh2KSB8fCBoZXgudGVzdCh2KSB8fCBoc2xhLnRlc3QodiksXG4gICAgcGFyc2U6ICh2KSA9PiB7XG4gICAgICAgIGlmIChyZ2JhLnRlc3QodikpIHtcbiAgICAgICAgICAgIHJldHVybiByZ2JhLnBhcnNlKHYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhzbGEudGVzdCh2KSkge1xuICAgICAgICAgICAgcmV0dXJuIGhzbGEucGFyc2Uodik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaGV4LnBhcnNlKHYpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICB0cmFuc2Zvcm06ICh2KSA9PiB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgPyB2XG4gICAgICAgICAgICA6IHYuaGFzT3duUHJvcGVydHkoXCJyZWRcIilcbiAgICAgICAgICAgICAgICA/IHJnYmEudHJhbnNmb3JtKHYpXG4gICAgICAgICAgICAgICAgOiBoc2xhLnRyYW5zZm9ybSh2KTtcbiAgICB9LFxufTtcblxuY29uc3QgY29sb3JSZWdleCA9IC8oPzojW1xcZGEtZl17Myw4fXwoPzpyZ2J8aHNsKWE/XFwoKD86LT9bXFxkLl0rJT9bLFxcc10rKXsyfS0/W1xcZC5dKyU/XFxzKig/OlssL11cXHMqKT8oPzpcXGJcXGQrKD86XFwuXFxkKyk/fFxcLlxcZCspPyU/XFwpKS9naXU7XG5cbmZ1bmN0aW9uIHRlc3Qodikge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChpc05hTih2KSAmJlxuICAgICAgICB0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAoKChfYSA9IHYubWF0Y2goZmxvYXRSZWdleCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpIHx8IDApICtcbiAgICAgICAgICAgICgoKF9iID0gdi5tYXRjaChjb2xvclJlZ2V4KSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmxlbmd0aCkgfHwgMCkgPlxuICAgICAgICAgICAgMCk7XG59XG5jb25zdCBOVU1CRVJfVE9LRU4gPSBcIm51bWJlclwiO1xuY29uc3QgQ09MT1JfVE9LRU4gPSBcImNvbG9yXCI7XG5jb25zdCBWQVJfVE9LRU4gPSBcInZhclwiO1xuY29uc3QgVkFSX0ZVTkNUSU9OX1RPS0VOID0gXCJ2YXIoXCI7XG5jb25zdCBTUExJVF9UT0tFTiA9IFwiJHt9XCI7XG4vLyB0aGlzIHJlZ2V4IGNvbnNpc3RzIG9mIHRoZSBgc2luZ2xlQ3NzVmFyaWFibGVSZWdleHxyZ2JIU0xWYWx1ZVJlZ2V4fGRpZ2l0UmVnZXhgXG5jb25zdCBjb21wbGV4UmVnZXggPSAvdmFyXFxzKlxcKFxccyotLSg/OltcXHctXStcXHMqfFtcXHctXStcXHMqLCg/OlxccypbXikoXFxzXXxcXHMqXFwoKD86W14pKF18XFwoW14pKF0qXFwpKSpcXCkpK1xccyopXFwpfCNbXFxkYS1mXXszLDh9fCg/OnJnYnxoc2wpYT9cXCgoPzotP1tcXGQuXSslP1ssXFxzXSspezJ9LT9bXFxkLl0rJT9cXHMqKD86WywvXVxccyopPyg/OlxcYlxcZCsoPzpcXC5cXGQrKT98XFwuXFxkKyk/JT9cXCl8LT8oPzpcXGQrKD86XFwuXFxkKyk/fFxcLlxcZCspL2dpdTtcbmZ1bmN0aW9uIGFuYWx5c2VDb21wbGV4VmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCBvcmlnaW5hbFZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICBjb25zdCBpbmRleGVzID0ge1xuICAgICAgICBjb2xvcjogW10sXG4gICAgICAgIG51bWJlcjogW10sXG4gICAgICAgIHZhcjogW10sXG4gICAgfTtcbiAgICBjb25zdCB0eXBlcyA9IFtdO1xuICAgIGxldCBpID0gMDtcbiAgICBjb25zdCB0b2tlbmlzZWQgPSBvcmlnaW5hbFZhbHVlLnJlcGxhY2UoY29tcGxleFJlZ2V4LCAocGFyc2VkVmFsdWUpID0+IHtcbiAgICAgICAgaWYgKGNvbG9yLnRlc3QocGFyc2VkVmFsdWUpKSB7XG4gICAgICAgICAgICBpbmRleGVzLmNvbG9yLnB1c2goaSk7XG4gICAgICAgICAgICB0eXBlcy5wdXNoKENPTE9SX1RPS0VOKTtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKGNvbG9yLnBhcnNlKHBhcnNlZFZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFyc2VkVmFsdWUuc3RhcnRzV2l0aChWQVJfRlVOQ1RJT05fVE9LRU4pKSB7XG4gICAgICAgICAgICBpbmRleGVzLnZhci5wdXNoKGkpO1xuICAgICAgICAgICAgdHlwZXMucHVzaChWQVJfVE9LRU4pO1xuICAgICAgICAgICAgdmFsdWVzLnB1c2gocGFyc2VkVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5kZXhlcy5udW1iZXIucHVzaChpKTtcbiAgICAgICAgICAgIHR5cGVzLnB1c2goTlVNQkVSX1RPS0VOKTtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKHBhcnNlRmxvYXQocGFyc2VkVmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICArK2k7XG4gICAgICAgIHJldHVybiBTUExJVF9UT0tFTjtcbiAgICB9KTtcbiAgICBjb25zdCBzcGxpdCA9IHRva2VuaXNlZC5zcGxpdChTUExJVF9UT0tFTik7XG4gICAgcmV0dXJuIHsgdmFsdWVzLCBzcGxpdCwgaW5kZXhlcywgdHlwZXMgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlQ29tcGxleFZhbHVlKHYpIHtcbiAgICByZXR1cm4gYW5hbHlzZUNvbXBsZXhWYWx1ZSh2KS52YWx1ZXM7XG59XG5mdW5jdGlvbiBjcmVhdGVUcmFuc2Zvcm1lcihzb3VyY2UpIHtcbiAgICBjb25zdCB7IHNwbGl0LCB0eXBlcyB9ID0gYW5hbHlzZUNvbXBsZXhWYWx1ZShzb3VyY2UpO1xuICAgIGNvbnN0IG51bVNlY3Rpb25zID0gc3BsaXQubGVuZ3RoO1xuICAgIHJldHVybiAodikgPT4ge1xuICAgICAgICBsZXQgb3V0cHV0ID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1TZWN0aW9uczsgaSsrKSB7XG4gICAgICAgICAgICBvdXRwdXQgKz0gc3BsaXRbaV07XG4gICAgICAgICAgICBpZiAodltpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IHR5cGVzW2ldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBOVU1CRVJfVE9LRU4pIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ICs9IHNhbml0aXplKHZbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSBDT0xPUl9UT0tFTikge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgKz0gY29sb3IudHJhbnNmb3JtKHZbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ICs9IHZbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcbn1cbmNvbnN0IGNvbnZlcnROdW1iZXJzVG9aZXJvID0gKHYpID0+IHR5cGVvZiB2ID09PSBcIm51bWJlclwiID8gMCA6IHY7XG5mdW5jdGlvbiBnZXRBbmltYXRhYmxlTm9uZSQxKHYpIHtcbiAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUNvbXBsZXhWYWx1ZSh2KTtcbiAgICBjb25zdCB0cmFuc2Zvcm1lciA9IGNyZWF0ZVRyYW5zZm9ybWVyKHYpO1xuICAgIHJldHVybiB0cmFuc2Zvcm1lcihwYXJzZWQubWFwKGNvbnZlcnROdW1iZXJzVG9aZXJvKSk7XG59XG5jb25zdCBjb21wbGV4ID0ge1xuICAgIHRlc3QsXG4gICAgcGFyc2U6IHBhcnNlQ29tcGxleFZhbHVlLFxuICAgIGNyZWF0ZVRyYW5zZm9ybWVyLFxuICAgIGdldEFuaW1hdGFibGVOb25lOiBnZXRBbmltYXRhYmxlTm9uZSQxLFxufTtcblxuLyoqXG4gKiBQcm9wZXJ0aWVzIHRoYXQgc2hvdWxkIGRlZmF1bHQgdG8gMSBvciAxMDAlXG4gKi9cbmNvbnN0IG1heERlZmF1bHRzID0gbmV3IFNldChbXCJicmlnaHRuZXNzXCIsIFwiY29udHJhc3RcIiwgXCJzYXR1cmF0ZVwiLCBcIm9wYWNpdHlcIl0pO1xuZnVuY3Rpb24gYXBwbHlEZWZhdWx0RmlsdGVyKHYpIHtcbiAgICBjb25zdCBbbmFtZSwgdmFsdWVdID0gdi5zbGljZSgwLCAtMSkuc3BsaXQoXCIoXCIpO1xuICAgIGlmIChuYW1lID09PSBcImRyb3Atc2hhZG93XCIpXG4gICAgICAgIHJldHVybiB2O1xuICAgIGNvbnN0IFtudW1iZXJdID0gdmFsdWUubWF0Y2goZmxvYXRSZWdleCkgfHwgW107XG4gICAgaWYgKCFudW1iZXIpXG4gICAgICAgIHJldHVybiB2O1xuICAgIGNvbnN0IHVuaXQgPSB2YWx1ZS5yZXBsYWNlKG51bWJlciwgXCJcIik7XG4gICAgbGV0IGRlZmF1bHRWYWx1ZSA9IG1heERlZmF1bHRzLmhhcyhuYW1lKSA/IDEgOiAwO1xuICAgIGlmIChudW1iZXIgIT09IHZhbHVlKVxuICAgICAgICBkZWZhdWx0VmFsdWUgKj0gMTAwO1xuICAgIHJldHVybiBuYW1lICsgXCIoXCIgKyBkZWZhdWx0VmFsdWUgKyB1bml0ICsgXCIpXCI7XG59XG5jb25zdCBmdW5jdGlvblJlZ2V4ID0gL1xcYihbYS16LV0qKVxcKC4qP1xcKS9ndTtcbmNvbnN0IGZpbHRlciA9IHtcbiAgICAuLi5jb21wbGV4LFxuICAgIGdldEFuaW1hdGFibGVOb25lOiAodikgPT4ge1xuICAgICAgICBjb25zdCBmdW5jdGlvbnMgPSB2Lm1hdGNoKGZ1bmN0aW9uUmVnZXgpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb25zID8gZnVuY3Rpb25zLm1hcChhcHBseURlZmF1bHRGaWx0ZXIpLmpvaW4oXCIgXCIpIDogdjtcbiAgICB9LFxufTtcblxuY29uc3QgYnJvd3Nlck51bWJlclZhbHVlVHlwZXMgPSB7XG4gICAgLy8gQm9yZGVyIHByb3BzXG4gICAgYm9yZGVyV2lkdGg6IHB4LFxuICAgIGJvcmRlclRvcFdpZHRoOiBweCxcbiAgICBib3JkZXJSaWdodFdpZHRoOiBweCxcbiAgICBib3JkZXJCb3R0b21XaWR0aDogcHgsXG4gICAgYm9yZGVyTGVmdFdpZHRoOiBweCxcbiAgICBib3JkZXJSYWRpdXM6IHB4LFxuICAgIHJhZGl1czogcHgsXG4gICAgYm9yZGVyVG9wTGVmdFJhZGl1czogcHgsXG4gICAgYm9yZGVyVG9wUmlnaHRSYWRpdXM6IHB4LFxuICAgIGJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzOiBweCxcbiAgICBib3JkZXJCb3R0b21MZWZ0UmFkaXVzOiBweCxcbiAgICAvLyBQb3NpdGlvbmluZyBwcm9wc1xuICAgIHdpZHRoOiBweCxcbiAgICBtYXhXaWR0aDogcHgsXG4gICAgaGVpZ2h0OiBweCxcbiAgICBtYXhIZWlnaHQ6IHB4LFxuICAgIHRvcDogcHgsXG4gICAgcmlnaHQ6IHB4LFxuICAgIGJvdHRvbTogcHgsXG4gICAgbGVmdDogcHgsXG4gICAgLy8gU3BhY2luZyBwcm9wc1xuICAgIHBhZGRpbmc6IHB4LFxuICAgIHBhZGRpbmdUb3A6IHB4LFxuICAgIHBhZGRpbmdSaWdodDogcHgsXG4gICAgcGFkZGluZ0JvdHRvbTogcHgsXG4gICAgcGFkZGluZ0xlZnQ6IHB4LFxuICAgIG1hcmdpbjogcHgsXG4gICAgbWFyZ2luVG9wOiBweCxcbiAgICBtYXJnaW5SaWdodDogcHgsXG4gICAgbWFyZ2luQm90dG9tOiBweCxcbiAgICBtYXJnaW5MZWZ0OiBweCxcbiAgICAvLyBNaXNjXG4gICAgYmFja2dyb3VuZFBvc2l0aW9uWDogcHgsXG4gICAgYmFja2dyb3VuZFBvc2l0aW9uWTogcHgsXG59O1xuXG5jb25zdCB0cmFuc2Zvcm1WYWx1ZVR5cGVzID0ge1xuICAgIHJvdGF0ZTogZGVncmVlcyxcbiAgICByb3RhdGVYOiBkZWdyZWVzLFxuICAgIHJvdGF0ZVk6IGRlZ3JlZXMsXG4gICAgcm90YXRlWjogZGVncmVlcyxcbiAgICBzY2FsZSxcbiAgICBzY2FsZVg6IHNjYWxlLFxuICAgIHNjYWxlWTogc2NhbGUsXG4gICAgc2NhbGVaOiBzY2FsZSxcbiAgICBza2V3OiBkZWdyZWVzLFxuICAgIHNrZXdYOiBkZWdyZWVzLFxuICAgIHNrZXdZOiBkZWdyZWVzLFxuICAgIGRpc3RhbmNlOiBweCxcbiAgICB0cmFuc2xhdGVYOiBweCxcbiAgICB0cmFuc2xhdGVZOiBweCxcbiAgICB0cmFuc2xhdGVaOiBweCxcbiAgICB4OiBweCxcbiAgICB5OiBweCxcbiAgICB6OiBweCxcbiAgICBwZXJzcGVjdGl2ZTogcHgsXG4gICAgdHJhbnNmb3JtUGVyc3BlY3RpdmU6IHB4LFxuICAgIG9wYWNpdHk6IGFscGhhLFxuICAgIG9yaWdpblg6IHByb2dyZXNzUGVyY2VudGFnZSxcbiAgICBvcmlnaW5ZOiBwcm9ncmVzc1BlcmNlbnRhZ2UsXG4gICAgb3JpZ2luWjogcHgsXG59O1xuXG5jb25zdCBpbnQgPSB7XG4gICAgLi4ubnVtYmVyLFxuICAgIHRyYW5zZm9ybTogTWF0aC5yb3VuZCxcbn07XG5cbmNvbnN0IG51bWJlclZhbHVlVHlwZXMgPSB7XG4gICAgLi4uYnJvd3Nlck51bWJlclZhbHVlVHlwZXMsXG4gICAgLi4udHJhbnNmb3JtVmFsdWVUeXBlcyxcbiAgICB6SW5kZXg6IGludCxcbiAgICBzaXplOiBweCxcbiAgICAvLyBTVkdcbiAgICBmaWxsT3BhY2l0eTogYWxwaGEsXG4gICAgc3Ryb2tlT3BhY2l0eTogYWxwaGEsXG4gICAgbnVtT2N0YXZlczogaW50LFxufTtcblxuLyoqXG4gKiBBIG1hcCBvZiBkZWZhdWx0IHZhbHVlIHR5cGVzIGZvciBjb21tb24gdmFsdWVzXG4gKi9cbmNvbnN0IGRlZmF1bHRWYWx1ZVR5cGVzID0ge1xuICAgIC4uLm51bWJlclZhbHVlVHlwZXMsXG4gICAgLy8gQ29sb3IgcHJvcHNcbiAgICBjb2xvcixcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IGNvbG9yLFxuICAgIG91dGxpbmVDb2xvcjogY29sb3IsXG4gICAgZmlsbDogY29sb3IsXG4gICAgc3Ryb2tlOiBjb2xvcixcbiAgICAvLyBCb3JkZXIgcHJvcHNcbiAgICBib3JkZXJDb2xvcjogY29sb3IsXG4gICAgYm9yZGVyVG9wQ29sb3I6IGNvbG9yLFxuICAgIGJvcmRlclJpZ2h0Q29sb3I6IGNvbG9yLFxuICAgIGJvcmRlckJvdHRvbUNvbG9yOiBjb2xvcixcbiAgICBib3JkZXJMZWZ0Q29sb3I6IGNvbG9yLFxuICAgIGZpbHRlcixcbiAgICBXZWJraXRGaWx0ZXI6IGZpbHRlcixcbn07XG4vKipcbiAqIEdldHMgdGhlIGRlZmF1bHQgVmFsdWVUeXBlIGZvciB0aGUgcHJvdmlkZWQgdmFsdWUga2V5XG4gKi9cbmNvbnN0IGdldERlZmF1bHRWYWx1ZVR5cGUgPSAoa2V5KSA9PiBkZWZhdWx0VmFsdWVUeXBlc1trZXldO1xuXG5mdW5jdGlvbiBnZXRBbmltYXRhYmxlTm9uZShrZXksIHZhbHVlKSB7XG4gICAgbGV0IGRlZmF1bHRWYWx1ZVR5cGUgPSBnZXREZWZhdWx0VmFsdWVUeXBlKGtleSk7XG4gICAgaWYgKGRlZmF1bHRWYWx1ZVR5cGUgIT09IGZpbHRlcilcbiAgICAgICAgZGVmYXVsdFZhbHVlVHlwZSA9IGNvbXBsZXg7XG4gICAgLy8gSWYgdmFsdWUgaXMgbm90IHJlY29nbmlzZWQgYXMgYW5pbWF0YWJsZSwgaWUgXCJub25lXCIsIGNyZWF0ZSBhbiBhbmltYXRhYmxlIHZlcnNpb24gb3JpZ2luIGJhc2VkIG9uIHRoZSB0YXJnZXRcbiAgICByZXR1cm4gZGVmYXVsdFZhbHVlVHlwZS5nZXRBbmltYXRhYmxlTm9uZVxuICAgICAgICA/IGRlZmF1bHRWYWx1ZVR5cGUuZ2V0QW5pbWF0YWJsZU5vbmUodmFsdWUpXG4gICAgICAgIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIElmIHdlIGVuY291bnRlciBrZXlmcmFtZXMgbGlrZSBcIm5vbmVcIiBvciBcIjBcIiBhbmQgd2UgYWxzbyBoYXZlIGtleWZyYW1lcyBsaWtlXG4gKiBcIiNmZmZcIiBvciBcIjIwMHB4IDIwMHB4XCIgd2Ugd2FudCB0byBmaW5kIGEga2V5ZnJhbWUgdG8gc2VydmUgYXMgYSB0ZW1wbGF0ZSBmb3JcbiAqIHRoZSBcIm5vbmVcIiBrZXlmcmFtZXMuIEluIHRoaXMgY2FzZSBcIiNmZmZcIiBvciBcIjIwMHB4IDIwMHB4XCIgLSB0aGVuIHRoZXNlIGdldCB0dXJuZWQgaW50b1xuICogemVybyBlcXVpdmFsZW50cywgaS5lLiBcIiNmZmYwXCIgb3IgXCIwcHggMHB4XCIuXG4gKi9cbmNvbnN0IGludmFsaWRUZW1wbGF0ZXMgPSBuZXcgU2V0KFtcImF1dG9cIiwgXCJub25lXCIsIFwiMFwiXSk7XG5mdW5jdGlvbiBtYWtlTm9uZUtleWZyYW1lc0FuaW1hdGFibGUodW5yZXNvbHZlZEtleWZyYW1lcywgbm9uZUtleWZyYW1lSW5kZXhlcywgbmFtZSkge1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgYW5pbWF0YWJsZVRlbXBsYXRlID0gdW5kZWZpbmVkO1xuICAgIHdoaWxlIChpIDwgdW5yZXNvbHZlZEtleWZyYW1lcy5sZW5ndGggJiYgIWFuaW1hdGFibGVUZW1wbGF0ZSkge1xuICAgICAgICBjb25zdCBrZXlmcmFtZSA9IHVucmVzb2x2ZWRLZXlmcmFtZXNbaV07XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ZnJhbWUgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICFpbnZhbGlkVGVtcGxhdGVzLmhhcyhrZXlmcmFtZSkgJiZcbiAgICAgICAgICAgIGFuYWx5c2VDb21wbGV4VmFsdWUoa2V5ZnJhbWUpLnZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGFuaW1hdGFibGVUZW1wbGF0ZSA9IHVucmVzb2x2ZWRLZXlmcmFtZXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICBpZiAoYW5pbWF0YWJsZVRlbXBsYXRlICYmIG5hbWUpIHtcbiAgICAgICAgZm9yIChjb25zdCBub25lSW5kZXggb2Ygbm9uZUtleWZyYW1lSW5kZXhlcykge1xuICAgICAgICAgICAgdW5yZXNvbHZlZEtleWZyYW1lc1tub25lSW5kZXhdID0gZ2V0QW5pbWF0YWJsZU5vbmUobmFtZSwgYW5pbWF0YWJsZVRlbXBsYXRlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgRE9NS2V5ZnJhbWVzUmVzb2x2ZXIgZXh0ZW5kcyBLZXlmcmFtZVJlc29sdmVyIHtcbiAgICBjb25zdHJ1Y3Rvcih1bnJlc29sdmVkS2V5ZnJhbWVzLCBvbkNvbXBsZXRlLCBuYW1lLCBtb3Rpb25WYWx1ZSwgZWxlbWVudCkge1xuICAgICAgICBzdXBlcih1bnJlc29sdmVkS2V5ZnJhbWVzLCBvbkNvbXBsZXRlLCBuYW1lLCBtb3Rpb25WYWx1ZSwgZWxlbWVudCwgdHJ1ZSk7XG4gICAgfVxuICAgIHJlYWRLZXlmcmFtZXMoKSB7XG4gICAgICAgIGNvbnN0IHsgdW5yZXNvbHZlZEtleWZyYW1lcywgZWxlbWVudCwgbmFtZSB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFlbGVtZW50IHx8ICFlbGVtZW50LmN1cnJlbnQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHN1cGVyLnJlYWRLZXlmcmFtZXMoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGFueSBrZXlmcmFtZSBpcyBhIENTUyB2YXJpYWJsZSwgd2UgbmVlZCB0byBmaW5kIGl0cyB2YWx1ZSBieSBzYW1wbGluZyB0aGUgZWxlbWVudFxuICAgICAgICAgKi9cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1bnJlc29sdmVkS2V5ZnJhbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQga2V5ZnJhbWUgPSB1bnJlc29sdmVkS2V5ZnJhbWVzW2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXlmcmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGtleWZyYW1lID0ga2V5ZnJhbWUudHJpbSgpO1xuICAgICAgICAgICAgICAgIGlmIChpc0NTU1ZhcmlhYmxlVG9rZW4oa2V5ZnJhbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkID0gZ2V0VmFyaWFibGVWYWx1ZShrZXlmcmFtZSwgZWxlbWVudC5jdXJyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc29sdmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVucmVzb2x2ZWRLZXlmcmFtZXNbaV0gPSByZXNvbHZlZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gdW5yZXNvbHZlZEtleWZyYW1lcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmFsS2V5ZnJhbWUgPSBrZXlmcmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmVzb2x2ZSBcIm5vbmVcIiB2YWx1ZXMuIFdlIGRvIHRoaXMgcG90ZW50aWFsbHkgdHdpY2UgLSBvbmNlIGJlZm9yZSBhbmQgb25jZSBhZnRlciBtZWFzdXJpbmcga2V5ZnJhbWVzLlxuICAgICAgICAgKiBUaGlzIGNvdWxkIGJlIHNlZW4gYXMgaW5lZmZpY2llbnQgYnV0IGl0J3MgYSB0cmFkZS1vZmYgdG8gYXZvaWQgbWVhc3VyZW1lbnRzIGluIG1vcmUgc2l0dWF0aW9ucywgd2hpY2hcbiAgICAgICAgICogaGF2ZSBhIGZhciBiaWdnZXIgcGVyZm9ybWFuY2UgaW1wYWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXNvbHZlTm9uZUtleWZyYW1lcygpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2sgdG8gc2VlIGlmIHVuaXQgdHlwZSBoYXMgY2hhbmdlZC4gSWYgc28gc2NoZWR1bGUgam9icyB0aGF0IHdpbGxcbiAgICAgICAgICogdGVtcG9yYXJpbHkgc2V0IHN0eWxlcyB0byB0aGUgZGVzdGluYXRpb24ga2V5ZnJhbWVzLlxuICAgICAgICAgKiBTa2lwIGlmIHdlIGhhdmUgbW9yZSB0aGFuIHR3byBrZXlmcmFtZXMgb3IgdGhpcyBpc24ndCBhIHBvc2l0aW9uYWwgdmFsdWUuXG4gICAgICAgICAqIFRPRE86IFdlIGNhbiB0aHJvdyBpZiB0aGVyZSBhcmUgbXVsdGlwbGUga2V5ZnJhbWVzIGFuZCB0aGUgdmFsdWUgdHlwZSBjaGFuZ2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKCFwb3NpdGlvbmFsS2V5cy5oYXMobmFtZSkgfHwgdW5yZXNvbHZlZEtleWZyYW1lcy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbb3JpZ2luLCB0YXJnZXRdID0gdW5yZXNvbHZlZEtleWZyYW1lcztcbiAgICAgICAgY29uc3Qgb3JpZ2luVHlwZSA9IGZpbmREaW1lbnNpb25WYWx1ZVR5cGUob3JpZ2luKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0VHlwZSA9IGZpbmREaW1lbnNpb25WYWx1ZVR5cGUodGFyZ2V0KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVpdGhlciB3ZSBkb24ndCByZWNvZ25pc2UgdGhlc2UgdmFsdWUgdHlwZXMgb3Igd2UgY2FuIGFuaW1hdGUgYmV0d2VlbiB0aGVtLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKG9yaWdpblR5cGUgPT09IHRhcmdldFR5cGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBib3RoIHZhbHVlcyBhcmUgbnVtYmVycyBvciBwaXhlbHMsIHdlIGNhbiBhbmltYXRlIGJldHdlZW4gdGhlbSBieVxuICAgICAgICAgKiBjb252ZXJ0aW5nIHRoZW0gdG8gbnVtYmVycy5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChpc051bU9yUHhUeXBlKG9yaWdpblR5cGUpICYmIGlzTnVtT3JQeFR5cGUodGFyZ2V0VHlwZSkpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdW5yZXNvbHZlZEtleWZyYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdW5yZXNvbHZlZEtleWZyYW1lc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHVucmVzb2x2ZWRLZXlmcmFtZXNbaV0gPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEVsc2UsIHRoZSBvbmx5IHdheSB0byByZXNvbHZlIHRoaXMgaXMgYnkgbWVhc3VyaW5nIHRoZSBlbGVtZW50LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLm5lZWRzTWVhc3VyZW1lbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlc29sdmVOb25lS2V5ZnJhbWVzKCkge1xuICAgICAgICBjb25zdCB7IHVucmVzb2x2ZWRLZXlmcmFtZXMsIG5hbWUgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IG5vbmVLZXlmcmFtZUluZGV4ZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1bnJlc29sdmVkS2V5ZnJhbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaXNOb25lKHVucmVzb2x2ZWRLZXlmcmFtZXNbaV0pKSB7XG4gICAgICAgICAgICAgICAgbm9uZUtleWZyYW1lSW5kZXhlcy5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChub25lS2V5ZnJhbWVJbmRleGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgbWFrZU5vbmVLZXlmcmFtZXNBbmltYXRhYmxlKHVucmVzb2x2ZWRLZXlmcmFtZXMsIG5vbmVLZXlmcmFtZUluZGV4ZXMsIG5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1lYXN1cmVJbml0aWFsU3RhdGUoKSB7XG4gICAgICAgIGNvbnN0IHsgZWxlbWVudCwgdW5yZXNvbHZlZEtleWZyYW1lcywgbmFtZSB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFlbGVtZW50IHx8ICFlbGVtZW50LmN1cnJlbnQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChuYW1lID09PSBcImhlaWdodFwiKSB7XG4gICAgICAgICAgICB0aGlzLnN1c3BlbmRlZFNjcm9sbFkgPSB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZWFzdXJlZE9yaWdpbiA9IHBvc2l0aW9uYWxWYWx1ZXNbbmFtZV0oZWxlbWVudC5tZWFzdXJlVmlld3BvcnRCb3goKSwgd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudC5jdXJyZW50KSk7XG4gICAgICAgIHVucmVzb2x2ZWRLZXlmcmFtZXNbMF0gPSB0aGlzLm1lYXN1cmVkT3JpZ2luO1xuICAgICAgICAvLyBTZXQgZmluYWwga2V5IGZyYW1lIHRvIG1lYXN1cmUgYWZ0ZXIgbmV4dCByZW5kZXJcbiAgICAgICAgY29uc3QgbWVhc3VyZUtleWZyYW1lID0gdW5yZXNvbHZlZEtleWZyYW1lc1t1bnJlc29sdmVkS2V5ZnJhbWVzLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAobWVhc3VyZUtleWZyYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuZ2V0VmFsdWUobmFtZSwgbWVhc3VyZUtleWZyYW1lKS5qdW1wKG1lYXN1cmVLZXlmcmFtZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1lYXN1cmVFbmRTdGF0ZSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB7IGVsZW1lbnQsIG5hbWUsIHVucmVzb2x2ZWRLZXlmcmFtZXMgfSA9IHRoaXM7XG4gICAgICAgIGlmICghZWxlbWVudCB8fCAhZWxlbWVudC5jdXJyZW50KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGVsZW1lbnQuZ2V0VmFsdWUobmFtZSk7XG4gICAgICAgIHZhbHVlICYmIHZhbHVlLmp1bXAodGhpcy5tZWFzdXJlZE9yaWdpbiwgZmFsc2UpO1xuICAgICAgICBjb25zdCBmaW5hbEtleWZyYW1lSW5kZXggPSB1bnJlc29sdmVkS2V5ZnJhbWVzLmxlbmd0aCAtIDE7XG4gICAgICAgIGNvbnN0IGZpbmFsS2V5ZnJhbWUgPSB1bnJlc29sdmVkS2V5ZnJhbWVzW2ZpbmFsS2V5ZnJhbWVJbmRleF07XG4gICAgICAgIHVucmVzb2x2ZWRLZXlmcmFtZXNbZmluYWxLZXlmcmFtZUluZGV4XSA9IHBvc2l0aW9uYWxWYWx1ZXNbbmFtZV0oZWxlbWVudC5tZWFzdXJlVmlld3BvcnRCb3goKSwgd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudC5jdXJyZW50KSk7XG4gICAgICAgIGlmIChmaW5hbEtleWZyYW1lICE9PSBudWxsICYmIHRoaXMuZmluYWxLZXlmcmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmZpbmFsS2V5ZnJhbWUgPSBmaW5hbEtleWZyYW1lO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIHJlbW92ZWQgdHJhbnNmb3JtIHZhbHVlcywgcmVhcHBseSB0aGVtIGJlZm9yZSB0aGUgbmV4dCByZW5kZXJcbiAgICAgICAgaWYgKChfYSA9IHRoaXMucmVtb3ZlZFRyYW5zZm9ybXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlZFRyYW5zZm9ybXMuZm9yRWFjaCgoW3Vuc2V0VHJhbnNmb3JtTmFtZSwgdW5zZXRUcmFuc2Zvcm1WYWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIC5nZXRWYWx1ZSh1bnNldFRyYW5zZm9ybU5hbWUpXG4gICAgICAgICAgICAgICAgICAgIC5zZXQodW5zZXRUcmFuc2Zvcm1WYWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlc29sdmVOb25lS2V5ZnJhbWVzKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc0dlbmVyYXRvcih0eXBlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSBcImZ1bmN0aW9uXCI7XG59XG5cbmxldCBub3c7XG5mdW5jdGlvbiBjbGVhclRpbWUoKSB7XG4gICAgbm93ID0gdW5kZWZpbmVkO1xufVxuLyoqXG4gKiBBbiBldmVudGxvb3Atc3luY2hyb25vdXMgYWx0ZXJuYXRpdmUgdG8gcGVyZm9ybWFuY2Uubm93KCkuXG4gKlxuICogRW5zdXJlcyB0aGF0IHRpbWUgbWVhc3VyZW1lbnRzIHJlbWFpbiBjb25zaXN0ZW50IHdpdGhpbiBhIHN5bmNocm9ub3VzIGNvbnRleHQuXG4gKiBVc3VhbGx5IGNhbGxpbmcgcGVyZm9ybWFuY2Uubm93KCkgdHdpY2Ugd2l0aGluIHRoZSBzYW1lIHN5bmNocm9ub3VzIGNvbnRleHRcbiAqIHdpbGwgcmV0dXJuIGRpZmZlcmVudCB2YWx1ZXMgd2hpY2ggaXNuJ3QgdXNlZnVsIGZvciBhbmltYXRpb25zIHdoZW4gd2UncmUgdXN1YWxseVxuICogdHJ5aW5nIHRvIHN5bmMgYW5pbWF0aW9ucyB0byB0aGUgc2FtZSBmcmFtZS5cbiAqL1xuY29uc3QgdGltZSA9IHtcbiAgICBub3c6ICgpID0+IHtcbiAgICAgICAgaWYgKG5vdyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aW1lLnNldChmcmFtZURhdGEuaXNQcm9jZXNzaW5nIHx8IE1vdGlvbkdsb2JhbENvbmZpZy51c2VNYW51YWxUaW1pbmdcbiAgICAgICAgICAgICAgICA/IGZyYW1lRGF0YS50aW1lc3RhbXBcbiAgICAgICAgICAgICAgICA6IHBlcmZvcm1hbmNlLm5vdygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm93O1xuICAgIH0sXG4gICAgc2V0OiAobmV3VGltZSkgPT4ge1xuICAgICAgICBub3cgPSBuZXdUaW1lO1xuICAgICAgICBxdWV1ZU1pY3JvdGFzayhjbGVhclRpbWUpO1xuICAgIH0sXG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYW5pbWF0YWJsZS4gRXhhbXBsZXM6XG4gKlxuICog4pyFOiAxMDAsIFwiMTAwcHhcIiwgXCIjZmZmXCJcbiAqIOKdjDogXCJibG9ja1wiLCBcInVybCgyLmpwZylcIlxuICogQHBhcmFtIHZhbHVlXG4gKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IGlzQW5pbWF0YWJsZSA9ICh2YWx1ZSwgbmFtZSkgPT4ge1xuICAgIC8vIElmIHRoZSBsaXN0IG9mIGtleXMgdGF0IG1pZ2h0IGJlIG5vbi1hbmltYXRhYmxlIGdyb3dzLCByZXBsYWNlIHdpdGggU2V0XG4gICAgaWYgKG5hbWUgPT09IFwiekluZGV4XCIpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAvLyBJZiBpdCdzIGEgbnVtYmVyIG9yIGEga2V5ZnJhbWVzIGFycmF5LCB3ZSBjYW4gYW5pbWF0ZSBpdC4gV2UgbWlnaHQgYXQgc29tZSBwb2ludFxuICAgIC8vIG5lZWQgdG8gZG8gYSBkZWVwIGlzQW5pbWF0YWJsZSBjaGVjayBvZiBrZXlmcmFtZXMsIG9yIGxldCBQb3Btb3Rpb24gaGFuZGxlIHRoaXMsXG4gICAgLy8gYnV0IGZvciBub3cgbGV0cyBsZWF2ZSBpdCBsaWtlIHRoaXMgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnNcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiIHx8IEFycmF5LmlzQXJyYXkodmFsdWUpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIC8vIEl0J3MgYW5pbWF0YWJsZSBpZiB3ZSBoYXZlIGEgc3RyaW5nXG4gICAgICAgIChjb21wbGV4LnRlc3QodmFsdWUpIHx8IHZhbHVlID09PSBcIjBcIikgJiYgLy8gQW5kIGl0IGNvbnRhaW5zIG51bWJlcnMgYW5kL29yIGNvbG9yc1xuICAgICAgICAhdmFsdWUuc3RhcnRzV2l0aChcInVybChcIikgLy8gVW5sZXNzIGl0IHN0YXJ0cyB3aXRoIFwidXJsKFwiXG4gICAgKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5mdW5jdGlvbiBoYXNLZXlmcmFtZXNDaGFuZ2VkKGtleWZyYW1lcykge1xuICAgIGNvbnN0IGN1cnJlbnQgPSBrZXlmcmFtZXNbMF07XG4gICAgaWYgKGtleWZyYW1lcy5sZW5ndGggPT09IDEpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5ZnJhbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChrZXlmcmFtZXNbaV0gIT09IGN1cnJlbnQpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBjYW5BbmltYXRlKGtleWZyYW1lcywgbmFtZSwgdHlwZSwgdmVsb2NpdHkpIHtcbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB3ZSdyZSBhYmxlIHRvIGFuaW1hdGUgYmV0d2VlbiB0aGUgc3RhcnQgYW5kIGVuZCBrZXlmcmFtZXMsXG4gICAgICogYW5kIHRocm93IGEgd2FybmluZyBpZiB3ZSdyZSBhdHRlbXB0aW5nIHRvIGFuaW1hdGUgYmV0d2VlbiBvbmUgdGhhdCdzXG4gICAgICogYW5pbWF0YWJsZSBhbmQgYW5vdGhlciB0aGF0IGlzbid0LlxuICAgICAqL1xuICAgIGNvbnN0IG9yaWdpbktleWZyYW1lID0ga2V5ZnJhbWVzWzBdO1xuICAgIGlmIChvcmlnaW5LZXlmcmFtZSA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8qKlxuICAgICAqIFRoZXNlIGFyZW4ndCB0cmFkaXRpb25hbGx5IGFuaW1hdGFibGUgYnV0IHdlIGRvIHN1cHBvcnQgdGhlbS5cbiAgICAgKiBJbiBmdXR1cmUgd2UgY291bGQgbG9vayBpbnRvIG1ha2luZyB0aGlzIG1vcmUgZ2VuZXJpYyBvciByZXBsYWNpbmdcbiAgICAgKiB0aGlzIGZ1bmN0aW9uIHdpdGggbWl4KCkgPT09IG1peEltbWVkaWF0ZVxuICAgICAqL1xuICAgIGlmIChuYW1lID09PSBcImRpc3BsYXlcIiB8fCBuYW1lID09PSBcInZpc2liaWxpdHlcIilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgY29uc3QgdGFyZ2V0S2V5ZnJhbWUgPSBrZXlmcmFtZXNba2V5ZnJhbWVzLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IGlzT3JpZ2luQW5pbWF0YWJsZSA9IGlzQW5pbWF0YWJsZShvcmlnaW5LZXlmcmFtZSwgbmFtZSk7XG4gICAgY29uc3QgaXNUYXJnZXRBbmltYXRhYmxlID0gaXNBbmltYXRhYmxlKHRhcmdldEtleWZyYW1lLCBuYW1lKTtcbiAgICBtb3Rpb25VdGlscy53YXJuaW5nKGlzT3JpZ2luQW5pbWF0YWJsZSA9PT0gaXNUYXJnZXRBbmltYXRhYmxlLCBgWW91IGFyZSB0cnlpbmcgdG8gYW5pbWF0ZSAke25hbWV9IGZyb20gXCIke29yaWdpbktleWZyYW1lfVwiIHRvIFwiJHt0YXJnZXRLZXlmcmFtZX1cIi4gJHtvcmlnaW5LZXlmcmFtZX0gaXMgbm90IGFuIGFuaW1hdGFibGUgdmFsdWUgLSB0byBlbmFibGUgdGhpcyBhbmltYXRpb24gc2V0ICR7b3JpZ2luS2V5ZnJhbWV9IHRvIGEgdmFsdWUgYW5pbWF0YWJsZSB0byAke3RhcmdldEtleWZyYW1lfSB2aWEgdGhlIFxcYHN0eWxlXFxgIHByb3BlcnR5LmApO1xuICAgIC8vIEFsd2F5cyBza2lwIGlmIGFueSBvZiB0aGVzZSBhcmUgdHJ1ZVxuICAgIGlmICghaXNPcmlnaW5BbmltYXRhYmxlIHx8ICFpc1RhcmdldEFuaW1hdGFibGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gKGhhc0tleWZyYW1lc0NoYW5nZWQoa2V5ZnJhbWVzKSB8fFxuICAgICAgICAoKHR5cGUgPT09IFwic3ByaW5nXCIgfHwgaXNHZW5lcmF0b3IodHlwZSkpICYmIHZlbG9jaXR5KSk7XG59XG5cbi8qKlxuICogTWF4aW11bSB0aW1lIGFsbG93ZWQgYmV0d2VlbiBhbiBhbmltYXRpb24gYmVpbmcgY3JlYXRlZCBhbmQgaXQgYmVpbmdcbiAqIHJlc29sdmVkIGZvciB1cyB0byB1c2UgdGhlIGxhdHRlciBhcyB0aGUgc3RhcnQgdGltZS5cbiAqXG4gKiBUaGlzIGlzIHRvIGVuc3VyZSB0aGF0IHdoaWxlIHdlIHByZWZlciB0byBcInN0YXJ0XCIgYW4gYW5pbWF0aW9uIGFzIHNvb25cbiAqIGFzIGl0J3MgdHJpZ2dlcmVkLCB3ZSBhbHNvIHdhbnQgdG8gYXZvaWQgYSB2aXN1YWwganVtcCBpZiB0aGVyZSdzIGEgYmlnIGRlbGF5XG4gKiBiZXR3ZWVuIHRoZXNlIHR3byBtb21lbnRzLlxuICovXG5jb25zdCBNQVhfUkVTT0xWRV9ERUxBWSA9IDQwO1xuY2xhc3MgQmFzZUFuaW1hdGlvbiB7XG4gICAgY29uc3RydWN0b3IoeyBhdXRvcGxheSA9IHRydWUsIGRlbGF5ID0gMCwgdHlwZSA9IFwia2V5ZnJhbWVzXCIsIHJlcGVhdCA9IDAsIHJlcGVhdERlbGF5ID0gMCwgcmVwZWF0VHlwZSA9IFwibG9vcFwiLCAuLi5vcHRpb25zIH0pIHtcbiAgICAgICAgLy8gVHJhY2sgd2hldGhlciB0aGUgYW5pbWF0aW9uIGhhcyBiZWVuIHN0b3BwZWQuIFN0b3BwZWQgYW5pbWF0aW9ucyB3b24ndCByZXN0YXJ0LlxuICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhc0F0dGVtcHRlZFJlc29sdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jcmVhdGVkQXQgPSB0aW1lLm5vdygpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAgICAgICBhdXRvcGxheSxcbiAgICAgICAgICAgIGRlbGF5LFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIHJlcGVhdCxcbiAgICAgICAgICAgIHJlcGVhdERlbGF5LFxuICAgICAgICAgICAgcmVwZWF0VHlwZSxcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlRmluaXNoZWRQcm9taXNlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHVzZXMgdGhlIGNyZWF0ZWRBdCBhbmQgcmVzb2x2ZWRBdCB0byBjYWxjdWxhdGUgdGhlXG4gICAgICogYW5pbWF0aW9uIHN0YXJ0VGltZS4gKklkZWFsbHkqLCB3ZSB3b3VsZCB1c2UgdGhlIGNyZWF0ZWRBdCB0aW1lIGFzIHQ9MFxuICAgICAqIGFzIHRoZSBmb2xsb3dpbmcgZnJhbWUgd291bGQgdGhlbiBiZSB0aGUgZmlyc3QgZnJhbWUgb2YgdGhlIGFuaW1hdGlvbiBpblxuICAgICAqIHByb2dyZXNzLCB3aGljaCB3b3VsZCBmZWVsIHNuYXBwaWVyLlxuICAgICAqXG4gICAgICogSG93ZXZlciwgaWYgdGhlcmUncyBhIGRlbGF5IChtYWluIHRocmVhZCB3b3JrKSBiZXR3ZWVuIHRoZSBjcmVhdGlvbiBvZlxuICAgICAqIHRoZSBhbmltYXRpb24gYW5kIHRoZSBmaXJzdCBjb21taXRlZCBmcmFtZSwgd2UgcHJlZmVyIHRvIHVzZSByZXNvbHZlZEF0XG4gICAgICogdG8gYXZvaWQgYSBzdWRkZW4ganVtcCBpbnRvIHRoZSBhbmltYXRpb24uXG4gICAgICovXG4gICAgY2FsY1N0YXJ0VGltZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJlc29sdmVkQXQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVkQXQ7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVkQXQgLSB0aGlzLmNyZWF0ZWRBdCA+IE1BWF9SRVNPTFZFX0RFTEFZXG4gICAgICAgICAgICA/IHRoaXMucmVzb2x2ZWRBdFxuICAgICAgICAgICAgOiB0aGlzLmNyZWF0ZWRBdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBnZXR0ZXIgZm9yIHJlc29sdmVkIGRhdGEuIElmIGtleWZyYW1lcyBhcmUgbm90IHlldCByZXNvbHZlZCwgYWNjZXNzaW5nXG4gICAgICogdGhpcy5yZXNvbHZlZCB3aWxsIHN5bmNocm9ub3VzbHkgZmx1c2ggYWxsIHBlbmRpbmcga2V5ZnJhbWUgcmVzb2x2ZXJzLlxuICAgICAqIFRoaXMgaXMgYSBkZW9wdGltaXNhdGlvbiwgYnV0IGF0IGl0cyB3b3JzdCBzdGlsbCBiYXRjaGVzIHJlYWQvd3JpdGVzLlxuICAgICAqL1xuICAgIGdldCByZXNvbHZlZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9yZXNvbHZlZCAmJiAhdGhpcy5oYXNBdHRlbXB0ZWRSZXNvbHZlKSB7XG4gICAgICAgICAgICBmbHVzaEtleWZyYW1lUmVzb2x2ZXJzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIG1ldGhvZCB0byBiZSBjYWxsZWQgd2hlbiB0aGUga2V5ZnJhbWVzIHJlc29sdmVyIGNvbXBsZXRlcy4gVGhpcyBtZXRob2RcbiAgICAgKiB3aWxsIGNoZWNrIGlmIGl0cyBwb3NzaWJsZSB0byBydW4gdGhlIGFuaW1hdGlvbiBhbmQsIGlmIG5vdCwgc2tpcCBpdC5cbiAgICAgKiBPdGhlcndpc2UsIGl0IHdpbGwgY2FsbCBpbml0UGxheWJhY2sgb24gdGhlIGltcGxlbWVudGluZyBjbGFzcy5cbiAgICAgKi9cbiAgICBvbktleWZyYW1lc1Jlc29sdmVkKGtleWZyYW1lcywgZmluYWxLZXlmcmFtZSkge1xuICAgICAgICB0aGlzLnJlc29sdmVkQXQgPSB0aW1lLm5vdygpO1xuICAgICAgICB0aGlzLmhhc0F0dGVtcHRlZFJlc29sdmUgPSB0cnVlO1xuICAgICAgICBjb25zdCB7IG5hbWUsIHR5cGUsIHZlbG9jaXR5LCBkZWxheSwgb25Db21wbGV0ZSwgb25VcGRhdGUsIGlzR2VuZXJhdG9yLCB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgd2UgY2FuJ3QgYW5pbWF0ZSB0aGlzIHZhbHVlIHdpdGggdGhlIHJlc29sdmVkIGtleWZyYW1lc1xuICAgICAgICAgKiB0aGVuIHdlIHNob3VsZCBjb21wbGV0ZSBpdCBpbW1lZGlhdGVseS5cbiAgICAgICAgICovXG4gICAgICAgIGlmICghaXNHZW5lcmF0b3IgJiYgIWNhbkFuaW1hdGUoa2V5ZnJhbWVzLCBuYW1lLCB0eXBlLCB2ZWxvY2l0eSkpIHtcbiAgICAgICAgICAgIC8vIEZpbmlzaCBpbW1lZGlhdGVseVxuICAgICAgICAgICAgaWYgKGluc3RhbnRBbmltYXRpb25TdGF0ZS5jdXJyZW50IHx8ICFkZWxheSkge1xuICAgICAgICAgICAgICAgIG9uVXBkYXRlID09PSBudWxsIHx8IG9uVXBkYXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvblVwZGF0ZShnZXRGaW5hbEtleWZyYW1lKGtleWZyYW1lcywgdGhpcy5vcHRpb25zLCBmaW5hbEtleWZyYW1lKSk7XG4gICAgICAgICAgICAgICAgb25Db21wbGV0ZSA9PT0gbnVsbCB8fCBvbkNvbXBsZXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlRmluaXNoZWRQcm9taXNlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmluaXNoIGFmdGVyIGEgZGVsYXlcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5kdXJhdGlvbiA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzb2x2ZWRBbmltYXRpb24gPSB0aGlzLmluaXRQbGF5YmFjayhrZXlmcmFtZXMsIGZpbmFsS2V5ZnJhbWUpO1xuICAgICAgICBpZiAocmVzb2x2ZWRBbmltYXRpb24gPT09IGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLl9yZXNvbHZlZCA9IHtcbiAgICAgICAgICAgIGtleWZyYW1lcyxcbiAgICAgICAgICAgIGZpbmFsS2V5ZnJhbWUsXG4gICAgICAgICAgICAuLi5yZXNvbHZlZEFuaW1hdGlvbixcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vblBvc3RSZXNvbHZlZCgpO1xuICAgIH1cbiAgICBvblBvc3RSZXNvbHZlZCgpIHsgfVxuICAgIC8qKlxuICAgICAqIEFsbG93cyB0aGUgcmV0dXJuZWQgYW5pbWF0aW9uIHRvIGJlIGF3YWl0ZWQgb3IgcHJvbWlzZS1jaGFpbmVkLiBDdXJyZW50bHlcbiAgICAgKiByZXNvbHZlcyB3aGVuIHRoZSBhbmltYXRpb24gZmluaXNoZXMgYXQgYWxsIGJ1dCBpbiBhIGZ1dHVyZSB1cGRhdGUgY291bGQvc2hvdWxkXG4gICAgICogcmVqZWN0IGlmIGl0cyBjYW5jZWxzLlxuICAgICAqL1xuICAgIHRoZW4ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRGaW5pc2hlZFByb21pc2UudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgIH1cbiAgICBmbGF0dGVuKCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMudHlwZSA9IFwia2V5ZnJhbWVzXCI7XG4gICAgICAgIHRoaXMub3B0aW9ucy5lYXNlID0gXCJsaW5lYXJcIjtcbiAgICB9XG4gICAgdXBkYXRlRmluaXNoZWRQcm9taXNlKCkge1xuICAgICAgICB0aGlzLmN1cnJlbnRGaW5pc2hlZFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlRmluaXNoZWRQcm9taXNlID0gcmVzb2x2ZTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKlxuICBQcm9ncmVzcyB3aXRoaW4gZ2l2ZW4gcmFuZ2VcblxuICBHaXZlbiBhIGxvd2VyIGxpbWl0IGFuZCBhbiB1cHBlciBsaW1pdCwgd2UgcmV0dXJuIHRoZSBwcm9ncmVzc1xuICAoZXhwcmVzc2VkIGFzIGEgbnVtYmVyIDAtMSkgcmVwcmVzZW50ZWQgYnkgdGhlIGdpdmVuIHZhbHVlLCBhbmRcbiAgbGltaXQgdGhhdCBwcm9ncmVzcyB0byB3aXRoaW4gMC0xLlxuXG4gIEBwYXJhbSBbbnVtYmVyXTogTG93ZXIgbGltaXRcbiAgQHBhcmFtIFtudW1iZXJdOiBVcHBlciBsaW1pdFxuICBAcGFyYW0gW251bWJlcl06IFZhbHVlIHRvIGZpbmQgcHJvZ3Jlc3Mgd2l0aGluIGdpdmVuIHJhbmdlXG4gIEByZXR1cm4gW251bWJlcl06IFByb2dyZXNzIG9mIHZhbHVlIHdpdGhpbiByYW5nZSBhcyBleHByZXNzZWQgMC0xXG4qL1xuY29uc3QgcHJvZ3Jlc3MgPSAoZnJvbSwgdG8sIHZhbHVlKSA9PiB7XG4gICAgY29uc3QgdG9Gcm9tRGlmZmVyZW5jZSA9IHRvIC0gZnJvbTtcbiAgICByZXR1cm4gdG9Gcm9tRGlmZmVyZW5jZSA9PT0gMCA/IDEgOiAodmFsdWUgLSBmcm9tKSAvIHRvRnJvbURpZmZlcmVuY2U7XG59O1xuXG5jb25zdCBnZW5lcmF0ZUxpbmVhckVhc2luZyA9IChlYXNpbmcsIGR1cmF0aW9uLCAvLyBhcyBtaWxsaXNlY29uZHNcbnJlc29sdXRpb24gPSAxMCAvLyBhcyBtaWxsaXNlY29uZHNcbikgPT4ge1xuICAgIGxldCBwb2ludHMgPSBcIlwiO1xuICAgIGNvbnN0IG51bVBvaW50cyA9IE1hdGgubWF4KE1hdGgucm91bmQoZHVyYXRpb24gLyByZXNvbHV0aW9uKSwgMik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Qb2ludHM7IGkrKykge1xuICAgICAgICBwb2ludHMgKz0gZWFzaW5nKHByb2dyZXNzKDAsIG51bVBvaW50cyAtIDEsIGkpKSArIFwiLCBcIjtcbiAgICB9XG4gICAgcmV0dXJuIGBsaW5lYXIoJHtwb2ludHMuc3Vic3RyaW5nKDAsIHBvaW50cy5sZW5ndGggLSAyKX0pYDtcbn07XG5cbi8qXG4gIENvbnZlcnQgdmVsb2NpdHkgaW50byB2ZWxvY2l0eSBwZXIgc2Vjb25kXG5cbiAgQHBhcmFtIFtudW1iZXJdOiBVbml0IHBlciBmcmFtZVxuICBAcGFyYW0gW251bWJlcl06IEZyYW1lIGR1cmF0aW9uIGluIG1zXG4qL1xuZnVuY3Rpb24gdmVsb2NpdHlQZXJTZWNvbmQodmVsb2NpdHksIGZyYW1lRHVyYXRpb24pIHtcbiAgICByZXR1cm4gZnJhbWVEdXJhdGlvbiA/IHZlbG9jaXR5ICogKDEwMDAgLyBmcmFtZUR1cmF0aW9uKSA6IDA7XG59XG5cbmNvbnN0IHZlbG9jaXR5U2FtcGxlRHVyYXRpb24gPSA1OyAvLyBtc1xuZnVuY3Rpb24gY2FsY0dlbmVyYXRvclZlbG9jaXR5KHJlc29sdmVWYWx1ZSwgdCwgY3VycmVudCkge1xuICAgIGNvbnN0IHByZXZUID0gTWF0aC5tYXgodCAtIHZlbG9jaXR5U2FtcGxlRHVyYXRpb24sIDApO1xuICAgIHJldHVybiB2ZWxvY2l0eVBlclNlY29uZChjdXJyZW50IC0gcmVzb2x2ZVZhbHVlKHByZXZUKSwgdCAtIHByZXZUKTtcbn1cblxuY29uc3Qgc3ByaW5nRGVmYXVsdHMgPSB7XG4gICAgLy8gRGVmYXVsdCBzcHJpbmcgcGh5c2ljc1xuICAgIHN0aWZmbmVzczogMTAwLFxuICAgIGRhbXBpbmc6IDEwLFxuICAgIG1hc3M6IDEuMCxcbiAgICB2ZWxvY2l0eTogMC4wLFxuICAgIC8vIERlZmF1bHQgZHVyYXRpb24vYm91bmNlLWJhc2VkIG9wdGlvbnNcbiAgICBkdXJhdGlvbjogODAwLCAvLyBpbiBtc1xuICAgIGJvdW5jZTogMC4zLFxuICAgIHZpc3VhbER1cmF0aW9uOiAwLjMsIC8vIGluIHNlY29uZHNcbiAgICAvLyBSZXN0IHRocmVzaG9sZHNcbiAgICByZXN0U3BlZWQ6IHtcbiAgICAgICAgZ3JhbnVsYXI6IDAuMDEsXG4gICAgICAgIGRlZmF1bHQ6IDIsXG4gICAgfSxcbiAgICByZXN0RGVsdGE6IHtcbiAgICAgICAgZ3JhbnVsYXI6IDAuMDA1LFxuICAgICAgICBkZWZhdWx0OiAwLjUsXG4gICAgfSxcbiAgICAvLyBMaW1pdHNcbiAgICBtaW5EdXJhdGlvbjogMC4wMSwgLy8gaW4gc2Vjb25kc1xuICAgIG1heER1cmF0aW9uOiAxMC4wLCAvLyBpbiBzZWNvbmRzXG4gICAgbWluRGFtcGluZzogMC4wNSxcbiAgICBtYXhEYW1waW5nOiAxLFxufTtcblxuY29uc3Qgc2FmZU1pbiA9IDAuMDAxO1xuZnVuY3Rpb24gZmluZFNwcmluZyh7IGR1cmF0aW9uID0gc3ByaW5nRGVmYXVsdHMuZHVyYXRpb24sIGJvdW5jZSA9IHNwcmluZ0RlZmF1bHRzLmJvdW5jZSwgdmVsb2NpdHkgPSBzcHJpbmdEZWZhdWx0cy52ZWxvY2l0eSwgbWFzcyA9IHNwcmluZ0RlZmF1bHRzLm1hc3MsIH0pIHtcbiAgICBsZXQgZW52ZWxvcGU7XG4gICAgbGV0IGRlcml2YXRpdmU7XG4gICAgbW90aW9uVXRpbHMud2FybmluZyhkdXJhdGlvbiA8PSBzZWNvbmRzVG9NaWxsaXNlY29uZHMoc3ByaW5nRGVmYXVsdHMubWF4RHVyYXRpb24pLCBcIlNwcmluZyBkdXJhdGlvbiBtdXN0IGJlIDEwIHNlY29uZHMgb3IgbGVzc1wiKTtcbiAgICBsZXQgZGFtcGluZ1JhdGlvID0gMSAtIGJvdW5jZTtcbiAgICAvKipcbiAgICAgKiBSZXN0cmljdCBkYW1waW5nUmF0aW8gYW5kIGR1cmF0aW9uIHRvIHdpdGhpbiBhY2NlcHRhYmxlIHJhbmdlcy5cbiAgICAgKi9cbiAgICBkYW1waW5nUmF0aW8gPSBjbGFtcChzcHJpbmdEZWZhdWx0cy5taW5EYW1waW5nLCBzcHJpbmdEZWZhdWx0cy5tYXhEYW1waW5nLCBkYW1waW5nUmF0aW8pO1xuICAgIGR1cmF0aW9uID0gY2xhbXAoc3ByaW5nRGVmYXVsdHMubWluRHVyYXRpb24sIHNwcmluZ0RlZmF1bHRzLm1heER1cmF0aW9uLCBtaWxsaXNlY29uZHNUb1NlY29uZHMoZHVyYXRpb24pKTtcbiAgICBpZiAoZGFtcGluZ1JhdGlvIDwgMSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogVW5kZXJkYW1wZWQgc3ByaW5nXG4gICAgICAgICAqL1xuICAgICAgICBlbnZlbG9wZSA9ICh1bmRhbXBlZEZyZXEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGV4cG9uZW50aWFsRGVjYXkgPSB1bmRhbXBlZEZyZXEgKiBkYW1waW5nUmF0aW87XG4gICAgICAgICAgICBjb25zdCBkZWx0YSA9IGV4cG9uZW50aWFsRGVjYXkgKiBkdXJhdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBleHBvbmVudGlhbERlY2F5IC0gdmVsb2NpdHk7XG4gICAgICAgICAgICBjb25zdCBiID0gY2FsY0FuZ3VsYXJGcmVxKHVuZGFtcGVkRnJlcSwgZGFtcGluZ1JhdGlvKTtcbiAgICAgICAgICAgIGNvbnN0IGMgPSBNYXRoLmV4cCgtZGVsdGEpO1xuICAgICAgICAgICAgcmV0dXJuIHNhZmVNaW4gLSAoYSAvIGIpICogYztcbiAgICAgICAgfTtcbiAgICAgICAgZGVyaXZhdGl2ZSA9ICh1bmRhbXBlZEZyZXEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGV4cG9uZW50aWFsRGVjYXkgPSB1bmRhbXBlZEZyZXEgKiBkYW1waW5nUmF0aW87XG4gICAgICAgICAgICBjb25zdCBkZWx0YSA9IGV4cG9uZW50aWFsRGVjYXkgKiBkdXJhdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGQgPSBkZWx0YSAqIHZlbG9jaXR5ICsgdmVsb2NpdHk7XG4gICAgICAgICAgICBjb25zdCBlID0gTWF0aC5wb3coZGFtcGluZ1JhdGlvLCAyKSAqIE1hdGgucG93KHVuZGFtcGVkRnJlcSwgMikgKiBkdXJhdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGYgPSBNYXRoLmV4cCgtZGVsdGEpO1xuICAgICAgICAgICAgY29uc3QgZyA9IGNhbGNBbmd1bGFyRnJlcShNYXRoLnBvdyh1bmRhbXBlZEZyZXEsIDIpLCBkYW1waW5nUmF0aW8pO1xuICAgICAgICAgICAgY29uc3QgZmFjdG9yID0gLWVudmVsb3BlKHVuZGFtcGVkRnJlcSkgKyBzYWZlTWluID4gMCA/IC0xIDogMTtcbiAgICAgICAgICAgIHJldHVybiAoZmFjdG9yICogKChkIC0gZSkgKiBmKSkgLyBnO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyaXRpY2FsbHktZGFtcGVkIHNwcmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgZW52ZWxvcGUgPSAodW5kYW1wZWRGcmVxKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhID0gTWF0aC5leHAoLXVuZGFtcGVkRnJlcSAqIGR1cmF0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IGIgPSAodW5kYW1wZWRGcmVxIC0gdmVsb2NpdHkpICogZHVyYXRpb24gKyAxO1xuICAgICAgICAgICAgcmV0dXJuIC1zYWZlTWluICsgYSAqIGI7XG4gICAgICAgIH07XG4gICAgICAgIGRlcml2YXRpdmUgPSAodW5kYW1wZWRGcmVxKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhID0gTWF0aC5leHAoLXVuZGFtcGVkRnJlcSAqIGR1cmF0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IGIgPSAodmVsb2NpdHkgLSB1bmRhbXBlZEZyZXEpICogKGR1cmF0aW9uICogZHVyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIGEgKiBiO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBpbml0aWFsR3Vlc3MgPSA1IC8gZHVyYXRpb247XG4gICAgY29uc3QgdW5kYW1wZWRGcmVxID0gYXBwcm94aW1hdGVSb290KGVudmVsb3BlLCBkZXJpdmF0aXZlLCBpbml0aWFsR3Vlc3MpO1xuICAgIGR1cmF0aW9uID0gc2Vjb25kc1RvTWlsbGlzZWNvbmRzKGR1cmF0aW9uKTtcbiAgICBpZiAoaXNOYU4odW5kYW1wZWRGcmVxKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RpZmZuZXNzOiBzcHJpbmdEZWZhdWx0cy5zdGlmZm5lc3MsXG4gICAgICAgICAgICBkYW1waW5nOiBzcHJpbmdEZWZhdWx0cy5kYW1waW5nLFxuICAgICAgICAgICAgZHVyYXRpb24sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBzdGlmZm5lc3MgPSBNYXRoLnBvdyh1bmRhbXBlZEZyZXEsIDIpICogbWFzcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0aWZmbmVzcyxcbiAgICAgICAgICAgIGRhbXBpbmc6IGRhbXBpbmdSYXRpbyAqIDIgKiBNYXRoLnNxcnQobWFzcyAqIHN0aWZmbmVzcyksXG4gICAgICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgfTtcbiAgICB9XG59XG5jb25zdCByb290SXRlcmF0aW9ucyA9IDEyO1xuZnVuY3Rpb24gYXBwcm94aW1hdGVSb290KGVudmVsb3BlLCBkZXJpdmF0aXZlLCBpbml0aWFsR3Vlc3MpIHtcbiAgICBsZXQgcmVzdWx0ID0gaW5pdGlhbEd1ZXNzO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcm9vdEl0ZXJhdGlvbnM7IGkrKykge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQgLSBlbnZlbG9wZShyZXN1bHQpIC8gZGVyaXZhdGl2ZShyZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY2FsY0FuZ3VsYXJGcmVxKHVuZGFtcGVkRnJlcSwgZGFtcGluZ1JhdGlvKSB7XG4gICAgcmV0dXJuIHVuZGFtcGVkRnJlcSAqIE1hdGguc3FydCgxIC0gZGFtcGluZ1JhdGlvICogZGFtcGluZ1JhdGlvKTtcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnQgYSBwcmFjdGljYWwgbWF4IGR1cmF0aW9uIGZvciBrZXlmcmFtZSBnZW5lcmF0aW9uXG4gKiB0byBwcmV2ZW50IGluZmluaXRlIGxvb3BzXG4gKi9cbmNvbnN0IG1heEdlbmVyYXRvckR1cmF0aW9uID0gMjAwMDA7XG5mdW5jdGlvbiBjYWxjR2VuZXJhdG9yRHVyYXRpb24oZ2VuZXJhdG9yKSB7XG4gICAgbGV0IGR1cmF0aW9uID0gMDtcbiAgICBjb25zdCB0aW1lU3RlcCA9IDUwO1xuICAgIGxldCBzdGF0ZSA9IGdlbmVyYXRvci5uZXh0KGR1cmF0aW9uKTtcbiAgICB3aGlsZSAoIXN0YXRlLmRvbmUgJiYgZHVyYXRpb24gPCBtYXhHZW5lcmF0b3JEdXJhdGlvbikge1xuICAgICAgICBkdXJhdGlvbiArPSB0aW1lU3RlcDtcbiAgICAgICAgc3RhdGUgPSBnZW5lcmF0b3IubmV4dChkdXJhdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBkdXJhdGlvbiA+PSBtYXhHZW5lcmF0b3JEdXJhdGlvbiA/IEluZmluaXR5IDogZHVyYXRpb247XG59XG5cbmNvbnN0IGR1cmF0aW9uS2V5cyA9IFtcImR1cmF0aW9uXCIsIFwiYm91bmNlXCJdO1xuY29uc3QgcGh5c2ljc0tleXMgPSBbXCJzdGlmZm5lc3NcIiwgXCJkYW1waW5nXCIsIFwibWFzc1wiXTtcbmZ1bmN0aW9uIGlzU3ByaW5nVHlwZShvcHRpb25zLCBrZXlzKSB7XG4gICAgcmV0dXJuIGtleXMuc29tZSgoa2V5KSA9PiBvcHRpb25zW2tleV0gIT09IHVuZGVmaW5lZCk7XG59XG5mdW5jdGlvbiBnZXRTcHJpbmdPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBsZXQgc3ByaW5nT3B0aW9ucyA9IHtcbiAgICAgICAgdmVsb2NpdHk6IHNwcmluZ0RlZmF1bHRzLnZlbG9jaXR5LFxuICAgICAgICBzdGlmZm5lc3M6IHNwcmluZ0RlZmF1bHRzLnN0aWZmbmVzcyxcbiAgICAgICAgZGFtcGluZzogc3ByaW5nRGVmYXVsdHMuZGFtcGluZyxcbiAgICAgICAgbWFzczogc3ByaW5nRGVmYXVsdHMubWFzcyxcbiAgICAgICAgaXNSZXNvbHZlZEZyb21EdXJhdGlvbjogZmFsc2UsXG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgfTtcbiAgICAvLyBzdGlmZm5lc3MvZGFtcGluZy9tYXNzIG92ZXJyaWRlcyBkdXJhdGlvbi9ib3VuY2VcbiAgICBpZiAoIWlzU3ByaW5nVHlwZShvcHRpb25zLCBwaHlzaWNzS2V5cykgJiZcbiAgICAgICAgaXNTcHJpbmdUeXBlKG9wdGlvbnMsIGR1cmF0aW9uS2V5cykpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMudmlzdWFsRHVyYXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHZpc3VhbER1cmF0aW9uID0gb3B0aW9ucy52aXN1YWxEdXJhdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSAoMiAqIE1hdGguUEkpIC8gKHZpc3VhbER1cmF0aW9uICogMS4yKTtcbiAgICAgICAgICAgIGNvbnN0IHN0aWZmbmVzcyA9IHJvb3QgKiByb290O1xuICAgICAgICAgICAgY29uc3QgZGFtcGluZyA9IDIgKiBjbGFtcCgwLjA1LCAxLCAxIC0gb3B0aW9ucy5ib3VuY2UpICogTWF0aC5zcXJ0KHN0aWZmbmVzcyk7XG4gICAgICAgICAgICBzcHJpbmdPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIC4uLnNwcmluZ09wdGlvbnMsXG4gICAgICAgICAgICAgICAgbWFzczogc3ByaW5nRGVmYXVsdHMubWFzcyxcbiAgICAgICAgICAgICAgICBzdGlmZm5lc3MsXG4gICAgICAgICAgICAgICAgZGFtcGluZyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBkZXJpdmVkID0gZmluZFNwcmluZyhvcHRpb25zKTtcbiAgICAgICAgICAgIHNwcmluZ09wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgLi4uc3ByaW5nT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAuLi5kZXJpdmVkLFxuICAgICAgICAgICAgICAgIG1hc3M6IHNwcmluZ0RlZmF1bHRzLm1hc3MsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc3ByaW5nT3B0aW9ucy5pc1Jlc29sdmVkRnJvbUR1cmF0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3ByaW5nT3B0aW9ucztcbn1cbmZ1bmN0aW9uIHNwcmluZyhvcHRpb25zT3JWaXN1YWxEdXJhdGlvbiA9IHNwcmluZ0RlZmF1bHRzLnZpc3VhbER1cmF0aW9uLCBib3VuY2UgPSBzcHJpbmdEZWZhdWx0cy5ib3VuY2UpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdHlwZW9mIG9wdGlvbnNPclZpc3VhbER1cmF0aW9uICE9PSBcIm9iamVjdFwiXG4gICAgICAgID8ge1xuICAgICAgICAgICAgdmlzdWFsRHVyYXRpb246IG9wdGlvbnNPclZpc3VhbER1cmF0aW9uLFxuICAgICAgICAgICAga2V5ZnJhbWVzOiBbMCwgMV0sXG4gICAgICAgICAgICBib3VuY2UsXG4gICAgICAgIH1cbiAgICAgICAgOiBvcHRpb25zT3JWaXN1YWxEdXJhdGlvbjtcbiAgICBsZXQgeyByZXN0U3BlZWQsIHJlc3REZWx0YSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBvcmlnaW4gPSBvcHRpb25zLmtleWZyYW1lc1swXTtcbiAgICBjb25zdCB0YXJnZXQgPSBvcHRpb25zLmtleWZyYW1lc1tvcHRpb25zLmtleWZyYW1lcy5sZW5ndGggLSAxXTtcbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHRoZSBJdGVyYXRvci1zcGVjIHJldHVybiB2YWx1ZS4gV2UgZW5zdXJlIGl0J3MgbXV0YWJsZSByYXRoZXIgdGhhbiB1c2luZyBhIGdlbmVyYXRvclxuICAgICAqIHRvIHJlZHVjZSBHQyBkdXJpbmcgYW5pbWF0aW9uLlxuICAgICAqL1xuICAgIGNvbnN0IHN0YXRlID0geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9yaWdpbiB9O1xuICAgIGNvbnN0IHsgc3RpZmZuZXNzLCBkYW1waW5nLCBtYXNzLCBkdXJhdGlvbiwgdmVsb2NpdHksIGlzUmVzb2x2ZWRGcm9tRHVyYXRpb24sIH0gPSBnZXRTcHJpbmdPcHRpb25zKHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgdmVsb2NpdHk6IC1taWxsaXNlY29uZHNUb1NlY29uZHMob3B0aW9ucy52ZWxvY2l0eSB8fCAwKSxcbiAgICB9KTtcbiAgICBjb25zdCBpbml0aWFsVmVsb2NpdHkgPSB2ZWxvY2l0eSB8fCAwLjA7XG4gICAgY29uc3QgZGFtcGluZ1JhdGlvID0gZGFtcGluZyAvICgyICogTWF0aC5zcXJ0KHN0aWZmbmVzcyAqIG1hc3MpKTtcbiAgICBjb25zdCBpbml0aWFsRGVsdGEgPSB0YXJnZXQgLSBvcmlnaW47XG4gICAgY29uc3QgdW5kYW1wZWRBbmd1bGFyRnJlcSA9IG1pbGxpc2Vjb25kc1RvU2Vjb25kcyhNYXRoLnNxcnQoc3RpZmZuZXNzIC8gbWFzcykpO1xuICAgIC8qKlxuICAgICAqIElmIHdlJ3JlIHdvcmtpbmcgb24gYSBncmFudWxhciBzY2FsZSwgdXNlIHNtYWxsZXIgZGVmYXVsdHMgZm9yIGRldGVybWluaW5nXG4gICAgICogd2hlbiB0aGUgc3ByaW5nIGlzIGZpbmlzaGVkLlxuICAgICAqXG4gICAgICogVGhlc2UgZGVmYXVsdHMgaGF2ZSBiZWVuIHNlbGVjdGVkIGVtcHJpY2FsbHkgYmFzZWQgb24gd2hhdCBzdHJpa2VzIGEgZ29vZFxuICAgICAqIHJhdGlvIGJldHdlZW4gZmVlbGluZyBnb29kIGFuZCBmaW5pc2hpbmcgYXMgc29vbiBhcyBjaGFuZ2VzIGFyZSBpbXBlcmNlcHRpYmxlLlxuICAgICAqL1xuICAgIGNvbnN0IGlzR3JhbnVsYXJTY2FsZSA9IE1hdGguYWJzKGluaXRpYWxEZWx0YSkgPCA1O1xuICAgIHJlc3RTcGVlZCB8fCAocmVzdFNwZWVkID0gaXNHcmFudWxhclNjYWxlXG4gICAgICAgID8gc3ByaW5nRGVmYXVsdHMucmVzdFNwZWVkLmdyYW51bGFyXG4gICAgICAgIDogc3ByaW5nRGVmYXVsdHMucmVzdFNwZWVkLmRlZmF1bHQpO1xuICAgIHJlc3REZWx0YSB8fCAocmVzdERlbHRhID0gaXNHcmFudWxhclNjYWxlXG4gICAgICAgID8gc3ByaW5nRGVmYXVsdHMucmVzdERlbHRhLmdyYW51bGFyXG4gICAgICAgIDogc3ByaW5nRGVmYXVsdHMucmVzdERlbHRhLmRlZmF1bHQpO1xuICAgIGxldCByZXNvbHZlU3ByaW5nO1xuICAgIGlmIChkYW1waW5nUmF0aW8gPCAxKSB7XG4gICAgICAgIGNvbnN0IGFuZ3VsYXJGcmVxID0gY2FsY0FuZ3VsYXJGcmVxKHVuZGFtcGVkQW5ndWxhckZyZXEsIGRhbXBpbmdSYXRpbyk7XG4gICAgICAgIC8vIFVuZGVyZGFtcGVkIHNwcmluZ1xuICAgICAgICByZXNvbHZlU3ByaW5nID0gKHQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVudmVsb3BlID0gTWF0aC5leHAoLWRhbXBpbmdSYXRpbyAqIHVuZGFtcGVkQW5ndWxhckZyZXEgKiB0KTtcbiAgICAgICAgICAgIHJldHVybiAodGFyZ2V0IC1cbiAgICAgICAgICAgICAgICBlbnZlbG9wZSAqXG4gICAgICAgICAgICAgICAgICAgICgoKGluaXRpYWxWZWxvY2l0eSArXG4gICAgICAgICAgICAgICAgICAgICAgICBkYW1waW5nUmF0aW8gKiB1bmRhbXBlZEFuZ3VsYXJGcmVxICogaW5pdGlhbERlbHRhKSAvXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmd1bGFyRnJlcSkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5zaW4oYW5ndWxhckZyZXEgKiB0KSArXG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsRGVsdGEgKiBNYXRoLmNvcyhhbmd1bGFyRnJlcSAqIHQpKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhbXBpbmdSYXRpbyA9PT0gMSkge1xuICAgICAgICAvLyBDcml0aWNhbGx5IGRhbXBlZCBzcHJpbmdcbiAgICAgICAgcmVzb2x2ZVNwcmluZyA9ICh0KSA9PiB0YXJnZXQgLVxuICAgICAgICAgICAgTWF0aC5leHAoLXVuZGFtcGVkQW5ndWxhckZyZXEgKiB0KSAqXG4gICAgICAgICAgICAgICAgKGluaXRpYWxEZWx0YSArXG4gICAgICAgICAgICAgICAgICAgIChpbml0aWFsVmVsb2NpdHkgKyB1bmRhbXBlZEFuZ3VsYXJGcmVxICogaW5pdGlhbERlbHRhKSAqIHQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gT3ZlcmRhbXBlZCBzcHJpbmdcbiAgICAgICAgY29uc3QgZGFtcGVkQW5ndWxhckZyZXEgPSB1bmRhbXBlZEFuZ3VsYXJGcmVxICogTWF0aC5zcXJ0KGRhbXBpbmdSYXRpbyAqIGRhbXBpbmdSYXRpbyAtIDEpO1xuICAgICAgICByZXNvbHZlU3ByaW5nID0gKHQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVudmVsb3BlID0gTWF0aC5leHAoLWRhbXBpbmdSYXRpbyAqIHVuZGFtcGVkQW5ndWxhckZyZXEgKiB0KTtcbiAgICAgICAgICAgIC8vIFdoZW4gcGVyZm9ybWluZyBzaW5oIG9yIGNvc2ggdmFsdWVzIGNhbiBoaXQgSW5maW5pdHkgc28gd2UgY2FwIHRoZW0gaGVyZVxuICAgICAgICAgICAgY29uc3QgZnJlcUZvclQgPSBNYXRoLm1pbihkYW1wZWRBbmd1bGFyRnJlcSAqIHQsIDMwMCk7XG4gICAgICAgICAgICByZXR1cm4gKHRhcmdldCAtXG4gICAgICAgICAgICAgICAgKGVudmVsb3BlICpcbiAgICAgICAgICAgICAgICAgICAgKChpbml0aWFsVmVsb2NpdHkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZGFtcGluZ1JhdGlvICogdW5kYW1wZWRBbmd1bGFyRnJlcSAqIGluaXRpYWxEZWx0YSkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5zaW5oKGZyZXFGb3JUKSArXG4gICAgICAgICAgICAgICAgICAgICAgICBkYW1wZWRBbmd1bGFyRnJlcSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbERlbHRhICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmNvc2goZnJlcUZvclQpKSkgL1xuICAgICAgICAgICAgICAgICAgICBkYW1wZWRBbmd1bGFyRnJlcSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGdlbmVyYXRvciA9IHtcbiAgICAgICAgY2FsY3VsYXRlZER1cmF0aW9uOiBpc1Jlc29sdmVkRnJvbUR1cmF0aW9uID8gZHVyYXRpb24gfHwgbnVsbCA6IG51bGwsXG4gICAgICAgIG5leHQ6ICh0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gcmVzb2x2ZVNwcmluZyh0KTtcbiAgICAgICAgICAgIGlmICghaXNSZXNvbHZlZEZyb21EdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50VmVsb2NpdHkgPSAwLjA7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogV2Ugb25seSBuZWVkIHRvIGNhbGN1bGF0ZSB2ZWxvY2l0eSBmb3IgdW5kZXItZGFtcGVkIHNwcmluZ3NcbiAgICAgICAgICAgICAgICAgKiBhcyBvdmVyLSBhbmQgY3JpdGljYWxseS1kYW1wZWQgc3ByaW5ncyBjYW4ndCBvdmVyc2hvb3QsIHNvXG4gICAgICAgICAgICAgICAgICogY2hlY2tpbmcgb25seSBmb3IgZGlzcGxhY2VtZW50IGlzIGVub3VnaC5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAoZGFtcGluZ1JhdGlvIDwgMSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VmVsb2NpdHkgPVxuICAgICAgICAgICAgICAgICAgICAgICAgdCA9PT0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gc2Vjb25kc1RvTWlsbGlzZWNvbmRzKGluaXRpYWxWZWxvY2l0eSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGNhbGNHZW5lcmF0b3JWZWxvY2l0eShyZXNvbHZlU3ByaW5nLCB0LCBjdXJyZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaXNCZWxvd1ZlbG9jaXR5VGhyZXNob2xkID0gTWF0aC5hYnMoY3VycmVudFZlbG9jaXR5KSA8PSByZXN0U3BlZWQ7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNCZWxvd0Rpc3BsYWNlbWVudFRocmVzaG9sZCA9IE1hdGguYWJzKHRhcmdldCAtIGN1cnJlbnQpIDw9IHJlc3REZWx0YTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5kb25lID1cbiAgICAgICAgICAgICAgICAgICAgaXNCZWxvd1ZlbG9jaXR5VGhyZXNob2xkICYmIGlzQmVsb3dEaXNwbGFjZW1lbnRUaHJlc2hvbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5kb25lID0gdCA+PSBkdXJhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXRlLnZhbHVlID0gc3RhdGUuZG9uZSA/IHRhcmdldCA6IGN1cnJlbnQ7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgIH0sXG4gICAgICAgIHRvU3RyaW5nOiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjYWxjdWxhdGVkRHVyYXRpb24gPSBNYXRoLm1pbihjYWxjR2VuZXJhdG9yRHVyYXRpb24oZ2VuZXJhdG9yKSwgbWF4R2VuZXJhdG9yRHVyYXRpb24pO1xuICAgICAgICAgICAgY29uc3QgZWFzaW5nID0gZ2VuZXJhdGVMaW5lYXJFYXNpbmcoKHByb2dyZXNzKSA9PiBnZW5lcmF0b3IubmV4dChjYWxjdWxhdGVkRHVyYXRpb24gKiBwcm9ncmVzcykudmFsdWUsIGNhbGN1bGF0ZWREdXJhdGlvbiwgMzApO1xuICAgICAgICAgICAgcmV0dXJuIGNhbGN1bGF0ZWREdXJhdGlvbiArIFwibXMgXCIgKyBlYXNpbmc7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xufVxuXG5mdW5jdGlvbiBpbmVydGlhKHsga2V5ZnJhbWVzLCB2ZWxvY2l0eSA9IDAuMCwgcG93ZXIgPSAwLjgsIHRpbWVDb25zdGFudCA9IDMyNSwgYm91bmNlRGFtcGluZyA9IDEwLCBib3VuY2VTdGlmZm5lc3MgPSA1MDAsIG1vZGlmeVRhcmdldCwgbWluLCBtYXgsIHJlc3REZWx0YSA9IDAuNSwgcmVzdFNwZWVkLCB9KSB7XG4gICAgY29uc3Qgb3JpZ2luID0ga2V5ZnJhbWVzWzBdO1xuICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IG9yaWdpbixcbiAgICB9O1xuICAgIGNvbnN0IGlzT3V0T2ZCb3VuZHMgPSAodikgPT4gKG1pbiAhPT0gdW5kZWZpbmVkICYmIHYgPCBtaW4pIHx8IChtYXggIT09IHVuZGVmaW5lZCAmJiB2ID4gbWF4KTtcbiAgICBjb25zdCBuZWFyZXN0Qm91bmRhcnkgPSAodikgPT4ge1xuICAgICAgICBpZiAobWluID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gbWF4O1xuICAgICAgICBpZiAobWF4ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gbWluO1xuICAgICAgICByZXR1cm4gTWF0aC5hYnMobWluIC0gdikgPCBNYXRoLmFicyhtYXggLSB2KSA/IG1pbiA6IG1heDtcbiAgICB9O1xuICAgIGxldCBhbXBsaXR1ZGUgPSBwb3dlciAqIHZlbG9jaXR5O1xuICAgIGNvbnN0IGlkZWFsID0gb3JpZ2luICsgYW1wbGl0dWRlO1xuICAgIGNvbnN0IHRhcmdldCA9IG1vZGlmeVRhcmdldCA9PT0gdW5kZWZpbmVkID8gaWRlYWwgOiBtb2RpZnlUYXJnZXQoaWRlYWwpO1xuICAgIC8qKlxuICAgICAqIElmIHRoZSB0YXJnZXQgaGFzIGNoYW5nZWQgd2UgbmVlZCB0byByZS1jYWxjdWxhdGUgdGhlIGFtcGxpdHVkZSwgb3RoZXJ3aXNlXG4gICAgICogdGhlIGFuaW1hdGlvbiB3aWxsIHN0YXJ0IGZyb20gdGhlIHdyb25nIHBvc2l0aW9uLlxuICAgICAqL1xuICAgIGlmICh0YXJnZXQgIT09IGlkZWFsKVxuICAgICAgICBhbXBsaXR1ZGUgPSB0YXJnZXQgLSBvcmlnaW47XG4gICAgY29uc3QgY2FsY0RlbHRhID0gKHQpID0+IC1hbXBsaXR1ZGUgKiBNYXRoLmV4cCgtdCAvIHRpbWVDb25zdGFudCk7XG4gICAgY29uc3QgY2FsY0xhdGVzdCA9ICh0KSA9PiB0YXJnZXQgKyBjYWxjRGVsdGEodCk7XG4gICAgY29uc3QgYXBwbHlGcmljdGlvbiA9ICh0KSA9PiB7XG4gICAgICAgIGNvbnN0IGRlbHRhID0gY2FsY0RlbHRhKHQpO1xuICAgICAgICBjb25zdCBsYXRlc3QgPSBjYWxjTGF0ZXN0KHQpO1xuICAgICAgICBzdGF0ZS5kb25lID0gTWF0aC5hYnMoZGVsdGEpIDw9IHJlc3REZWx0YTtcbiAgICAgICAgc3RhdGUudmFsdWUgPSBzdGF0ZS5kb25lID8gdGFyZ2V0IDogbGF0ZXN0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSWRlYWxseSB0aGlzIHdvdWxkIHJlc29sdmUgZm9yIHQgaW4gYSBzdGF0ZWxlc3Mgd2F5LCB3ZSBjb3VsZFxuICAgICAqIGRvIHRoYXQgYnkgYWx3YXlzIHByZWNhbGN1bGF0aW5nIHRoZSBhbmltYXRpb24gYnV0IGFzIHdlIGtub3dcbiAgICAgKiB0aGlzIHdpbGwgYmUgZG9uZSBhbnl3YXkgd2UgY2FuIGFzc3VtZSB0aGF0IHNwcmluZyB3aWxsXG4gICAgICogYmUgZGlzY292ZXJlZCBkdXJpbmcgdGhhdC5cbiAgICAgKi9cbiAgICBsZXQgdGltZVJlYWNoZWRCb3VuZGFyeTtcbiAgICBsZXQgc3ByaW5nJDE7XG4gICAgY29uc3QgY2hlY2tDYXRjaEJvdW5kYXJ5ID0gKHQpID0+IHtcbiAgICAgICAgaWYgKCFpc091dE9mQm91bmRzKHN0YXRlLnZhbHVlKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGltZVJlYWNoZWRCb3VuZGFyeSA9IHQ7XG4gICAgICAgIHNwcmluZyQxID0gc3ByaW5nKHtcbiAgICAgICAgICAgIGtleWZyYW1lczogW3N0YXRlLnZhbHVlLCBuZWFyZXN0Qm91bmRhcnkoc3RhdGUudmFsdWUpXSxcbiAgICAgICAgICAgIHZlbG9jaXR5OiBjYWxjR2VuZXJhdG9yVmVsb2NpdHkoY2FsY0xhdGVzdCwgdCwgc3RhdGUudmFsdWUpLCAvLyBUT0RPOiBUaGlzIHNob3VsZCBiZSBwYXNzaW5nICogMTAwMFxuICAgICAgICAgICAgZGFtcGluZzogYm91bmNlRGFtcGluZyxcbiAgICAgICAgICAgIHN0aWZmbmVzczogYm91bmNlU3RpZmZuZXNzLFxuICAgICAgICAgICAgcmVzdERlbHRhLFxuICAgICAgICAgICAgcmVzdFNwZWVkLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNoZWNrQ2F0Y2hCb3VuZGFyeSgwKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjYWxjdWxhdGVkRHVyYXRpb246IG51bGwsXG4gICAgICAgIG5leHQ6ICh0KSA9PiB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdlIG5lZWQgdG8gcmVzb2x2ZSB0aGUgZnJpY3Rpb24gdG8gZmlndXJlIG91dCBpZiB3ZSBuZWVkIGFcbiAgICAgICAgICAgICAqIHNwcmluZyBidXQgd2UgZG9uJ3Qgd2FudCB0byBkbyB0aGlzIHR3aWNlIHBlciBmcmFtZS4gU28gaGVyZVxuICAgICAgICAgICAgICogd2UgZmxhZyBpZiB3ZSB1cGRhdGVkIGZvciB0aGlzIGZyYW1lIGFuZCBsYXRlciBpZiB3ZSBkaWRcbiAgICAgICAgICAgICAqIHdlIGNhbiBza2lwIGRvaW5nIGl0IGFnYWluLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBsZXQgaGFzVXBkYXRlZEZyYW1lID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIXNwcmluZyQxICYmIHRpbWVSZWFjaGVkQm91bmRhcnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGhhc1VwZGF0ZWRGcmFtZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYXBwbHlGcmljdGlvbih0KTtcbiAgICAgICAgICAgICAgICBjaGVja0NhdGNoQm91bmRhcnkodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHdlIGhhdmUgYSBzcHJpbmcgYW5kIHRoZSBwcm92aWRlZCB0IGlzIGJleW9uZCB0aGUgbW9tZW50IHRoZSBmcmljdGlvblxuICAgICAgICAgICAgICogYW5pbWF0aW9uIGNyb3NzZWQgdGhlIG1pbi9tYXggYm91bmRhcnksIHVzZSB0aGUgc3ByaW5nLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAodGltZVJlYWNoZWRCb3VuZGFyeSAhPT0gdW5kZWZpbmVkICYmIHQgPj0gdGltZVJlYWNoZWRCb3VuZGFyeSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzcHJpbmckMS5uZXh0KHQgLSB0aW1lUmVhY2hlZEJvdW5kYXJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICFoYXNVcGRhdGVkRnJhbWUgJiYgYXBwbHlGcmljdGlvbih0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfTtcbn1cblxuY29uc3QgZWFzZUluID0gLypAX19QVVJFX18qLyBjdWJpY0JlemllcigwLjQyLCAwLCAxLCAxKTtcbmNvbnN0IGVhc2VPdXQgPSAvKkBfX1BVUkVfXyovIGN1YmljQmV6aWVyKDAsIDAsIDAuNTgsIDEpO1xuY29uc3QgZWFzZUluT3V0ID0gLypAX19QVVJFX18qLyBjdWJpY0JlemllcigwLjQyLCAwLCAwLjU4LCAxKTtcblxuY29uc3QgaXNFYXNpbmdBcnJheSA9IChlYXNlKSA9PiB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZWFzZSkgJiYgdHlwZW9mIGVhc2VbMF0gIT09IFwibnVtYmVyXCI7XG59O1xuXG5jb25zdCBpc0JlemllckRlZmluaXRpb24gPSAoZWFzaW5nKSA9PiBBcnJheS5pc0FycmF5KGVhc2luZykgJiYgdHlwZW9mIGVhc2luZ1swXSA9PT0gXCJudW1iZXJcIjtcblxuY29uc3QgZWFzaW5nTG9va3VwID0ge1xuICAgIGxpbmVhcjogbW90aW9uVXRpbHMubm9vcCxcbiAgICBlYXNlSW4sXG4gICAgZWFzZUluT3V0LFxuICAgIGVhc2VPdXQsXG4gICAgY2lyY0luLFxuICAgIGNpcmNJbk91dCxcbiAgICBjaXJjT3V0LFxuICAgIGJhY2tJbixcbiAgICBiYWNrSW5PdXQsXG4gICAgYmFja091dCxcbiAgICBhbnRpY2lwYXRlLFxufTtcbmNvbnN0IGVhc2luZ0RlZmluaXRpb25Ub0Z1bmN0aW9uID0gKGRlZmluaXRpb24pID0+IHtcbiAgICBpZiAoaXNCZXppZXJEZWZpbml0aW9uKGRlZmluaXRpb24pKSB7XG4gICAgICAgIC8vIElmIGN1YmljIGJlemllciBkZWZpbml0aW9uLCBjcmVhdGUgYmV6aWVyIGN1cnZlXG4gICAgICAgIG1vdGlvblV0aWxzLmludmFyaWFudChkZWZpbml0aW9uLmxlbmd0aCA9PT0gNCwgYEN1YmljIGJlemllciBhcnJheXMgbXVzdCBjb250YWluIGZvdXIgbnVtZXJpY2FsIHZhbHVlcy5gKTtcbiAgICAgICAgY29uc3QgW3gxLCB5MSwgeDIsIHkyXSA9IGRlZmluaXRpb247XG4gICAgICAgIHJldHVybiBjdWJpY0Jlemllcih4MSwgeTEsIHgyLCB5Mik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbml0aW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIC8vIEVsc2UgbG9va3VwIGZyb20gdGFibGVcbiAgICAgICAgbW90aW9uVXRpbHMuaW52YXJpYW50KGVhc2luZ0xvb2t1cFtkZWZpbml0aW9uXSAhPT0gdW5kZWZpbmVkLCBgSW52YWxpZCBlYXNpbmcgdHlwZSAnJHtkZWZpbml0aW9ufSdgKTtcbiAgICAgICAgcmV0dXJuIGVhc2luZ0xvb2t1cFtkZWZpbml0aW9uXTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmluaXRpb247XG59O1xuXG4vKipcbiAqIFBpcGVcbiAqIENvbXBvc2Ugb3RoZXIgdHJhbnNmb3JtZXJzIHRvIHJ1biBsaW5lYXJpbHlcbiAqIHBpcGUobWluKDIwKSwgbWF4KDQwKSlcbiAqIEBwYXJhbSAgey4uLmZ1bmN0aW9uc30gdHJhbnNmb3JtZXJzXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn1cbiAqL1xuY29uc3QgY29tYmluZUZ1bmN0aW9ucyA9IChhLCBiKSA9PiAodikgPT4gYihhKHYpKTtcbmNvbnN0IHBpcGUgPSAoLi4udHJhbnNmb3JtZXJzKSA9PiB0cmFuc2Zvcm1lcnMucmVkdWNlKGNvbWJpbmVGdW5jdGlvbnMpO1xuXG4vKlxuICBWYWx1ZSBpbiByYW5nZSBmcm9tIHByb2dyZXNzXG5cbiAgR2l2ZW4gYSBsb3dlciBsaW1pdCBhbmQgYW4gdXBwZXIgbGltaXQsIHdlIHJldHVybiB0aGUgdmFsdWUgd2l0aGluXG4gIHRoYXQgcmFuZ2UgYXMgZXhwcmVzc2VkIGJ5IHByb2dyZXNzICh1c3VhbGx5IGEgbnVtYmVyIGZyb20gMCB0byAxKVxuXG4gIFNvIHByb2dyZXNzID0gMC41IHdvdWxkIGNoYW5nZVxuXG4gIGZyb20gLS0tLS0tLS0gdG9cblxuICB0b1xuXG4gIGZyb20gLS0tLSB0b1xuXG4gIEUuZy4gZnJvbSA9IDEwLCB0byA9IDIwLCBwcm9ncmVzcyA9IDAuNSA9PiAxNVxuXG4gIEBwYXJhbSBbbnVtYmVyXTogTG93ZXIgbGltaXQgb2YgcmFuZ2VcbiAgQHBhcmFtIFtudW1iZXJdOiBVcHBlciBsaW1pdCBvZiByYW5nZVxuICBAcGFyYW0gW251bWJlcl06IFRoZSBwcm9ncmVzcyBiZXR3ZWVuIGxvd2VyIGFuZCB1cHBlciBsaW1pdHMgZXhwcmVzc2VkIDAtMVxuICBAcmV0dXJuIFtudW1iZXJdOiBWYWx1ZSBhcyBjYWxjdWxhdGVkIGZyb20gcHJvZ3Jlc3Mgd2l0aGluIHJhbmdlIChub3QgbGltaXRlZCB3aXRoaW4gcmFuZ2UpXG4qL1xuY29uc3QgbWl4TnVtYmVyJDEgPSAoZnJvbSwgdG8sIHByb2dyZXNzKSA9PiB7XG4gICAgcmV0dXJuIGZyb20gKyAodG8gLSBmcm9tKSAqIHByb2dyZXNzO1xufTtcblxuLy8gQWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL21qYWNrc29uLzUzMTEyNTZcbmZ1bmN0aW9uIGh1ZVRvUmdiKHAsIHEsIHQpIHtcbiAgICBpZiAodCA8IDApXG4gICAgICAgIHQgKz0gMTtcbiAgICBpZiAodCA+IDEpXG4gICAgICAgIHQgLT0gMTtcbiAgICBpZiAodCA8IDEgLyA2KVxuICAgICAgICByZXR1cm4gcCArIChxIC0gcCkgKiA2ICogdDtcbiAgICBpZiAodCA8IDEgLyAyKVxuICAgICAgICByZXR1cm4gcTtcbiAgICBpZiAodCA8IDIgLyAzKVxuICAgICAgICByZXR1cm4gcCArIChxIC0gcCkgKiAoMiAvIDMgLSB0KSAqIDY7XG4gICAgcmV0dXJuIHA7XG59XG5mdW5jdGlvbiBoc2xhVG9SZ2JhKHsgaHVlLCBzYXR1cmF0aW9uLCBsaWdodG5lc3MsIGFscGhhIH0pIHtcbiAgICBodWUgLz0gMzYwO1xuICAgIHNhdHVyYXRpb24gLz0gMTAwO1xuICAgIGxpZ2h0bmVzcyAvPSAxMDA7XG4gICAgbGV0IHJlZCA9IDA7XG4gICAgbGV0IGdyZWVuID0gMDtcbiAgICBsZXQgYmx1ZSA9IDA7XG4gICAgaWYgKCFzYXR1cmF0aW9uKSB7XG4gICAgICAgIHJlZCA9IGdyZWVuID0gYmx1ZSA9IGxpZ2h0bmVzcztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHEgPSBsaWdodG5lc3MgPCAwLjVcbiAgICAgICAgICAgID8gbGlnaHRuZXNzICogKDEgKyBzYXR1cmF0aW9uKVxuICAgICAgICAgICAgOiBsaWdodG5lc3MgKyBzYXR1cmF0aW9uIC0gbGlnaHRuZXNzICogc2F0dXJhdGlvbjtcbiAgICAgICAgY29uc3QgcCA9IDIgKiBsaWdodG5lc3MgLSBxO1xuICAgICAgICByZWQgPSBodWVUb1JnYihwLCBxLCBodWUgKyAxIC8gMyk7XG4gICAgICAgIGdyZWVuID0gaHVlVG9SZ2IocCwgcSwgaHVlKTtcbiAgICAgICAgYmx1ZSA9IGh1ZVRvUmdiKHAsIHEsIGh1ZSAtIDEgLyAzKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVkOiBNYXRoLnJvdW5kKHJlZCAqIDI1NSksXG4gICAgICAgIGdyZWVuOiBNYXRoLnJvdW5kKGdyZWVuICogMjU1KSxcbiAgICAgICAgYmx1ZTogTWF0aC5yb3VuZChibHVlICogMjU1KSxcbiAgICAgICAgYWxwaGEsXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gbWl4SW1tZWRpYXRlKGEsIGIpIHtcbiAgICByZXR1cm4gKHApID0+IChwID4gMCA/IGIgOiBhKTtcbn1cblxuLy8gTGluZWFyIGNvbG9yIHNwYWNlIGJsZW5kaW5nXG4vLyBFeHBsYWluZWQgaHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1MS25xRUNjZzZHd1xuLy8gRGVtb25zdHJhdGVkIGh0dHA6Ly9jb2RlcGVuLmlvL29zdWJsYWtlL3Blbi94R1ZWYU5cbmNvbnN0IG1peExpbmVhckNvbG9yID0gKGZyb20sIHRvLCB2KSA9PiB7XG4gICAgY29uc3QgZnJvbUV4cG8gPSBmcm9tICogZnJvbTtcbiAgICBjb25zdCBleHBvID0gdiAqICh0byAqIHRvIC0gZnJvbUV4cG8pICsgZnJvbUV4cG87XG4gICAgcmV0dXJuIGV4cG8gPCAwID8gMCA6IE1hdGguc3FydChleHBvKTtcbn07XG5jb25zdCBjb2xvclR5cGVzID0gW2hleCwgcmdiYSwgaHNsYV07XG5jb25zdCBnZXRDb2xvclR5cGUgPSAodikgPT4gY29sb3JUeXBlcy5maW5kKCh0eXBlKSA9PiB0eXBlLnRlc3QodikpO1xuZnVuY3Rpb24gYXNSR0JBKGNvbG9yKSB7XG4gICAgY29uc3QgdHlwZSA9IGdldENvbG9yVHlwZShjb2xvcik7XG4gICAgbW90aW9uVXRpbHMud2FybmluZyhCb29sZWFuKHR5cGUpLCBgJyR7Y29sb3J9JyBpcyBub3QgYW4gYW5pbWF0YWJsZSBjb2xvci4gVXNlIHRoZSBlcXVpdmFsZW50IGNvbG9yIGNvZGUgaW5zdGVhZC5gKTtcbiAgICBpZiAoIUJvb2xlYW4odHlwZSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgbW9kZWwgPSB0eXBlLnBhcnNlKGNvbG9yKTtcbiAgICBpZiAodHlwZSA9PT0gaHNsYSkge1xuICAgICAgICAvLyBUT0RPIFJlbW92ZSB0aGlzIGNhc3QgLSBuZWVkZWQgc2luY2UgTW90aW9uJ3Mgc3RyaWN0ZXIgdHlwaW5nXG4gICAgICAgIG1vZGVsID0gaHNsYVRvUmdiYShtb2RlbCk7XG4gICAgfVxuICAgIHJldHVybiBtb2RlbDtcbn1cbmNvbnN0IG1peENvbG9yID0gKGZyb20sIHRvKSA9PiB7XG4gICAgY29uc3QgZnJvbVJHQkEgPSBhc1JHQkEoZnJvbSk7XG4gICAgY29uc3QgdG9SR0JBID0gYXNSR0JBKHRvKTtcbiAgICBpZiAoIWZyb21SR0JBIHx8ICF0b1JHQkEpIHtcbiAgICAgICAgcmV0dXJuIG1peEltbWVkaWF0ZShmcm9tLCB0byk7XG4gICAgfVxuICAgIGNvbnN0IGJsZW5kZWQgPSB7IC4uLmZyb21SR0JBIH07XG4gICAgcmV0dXJuICh2KSA9PiB7XG4gICAgICAgIGJsZW5kZWQucmVkID0gbWl4TGluZWFyQ29sb3IoZnJvbVJHQkEucmVkLCB0b1JHQkEucmVkLCB2KTtcbiAgICAgICAgYmxlbmRlZC5ncmVlbiA9IG1peExpbmVhckNvbG9yKGZyb21SR0JBLmdyZWVuLCB0b1JHQkEuZ3JlZW4sIHYpO1xuICAgICAgICBibGVuZGVkLmJsdWUgPSBtaXhMaW5lYXJDb2xvcihmcm9tUkdCQS5ibHVlLCB0b1JHQkEuYmx1ZSwgdik7XG4gICAgICAgIGJsZW5kZWQuYWxwaGEgPSBtaXhOdW1iZXIkMShmcm9tUkdCQS5hbHBoYSwgdG9SR0JBLmFscGhhLCB2KTtcbiAgICAgICAgcmV0dXJuIHJnYmEudHJhbnNmb3JtKGJsZW5kZWQpO1xuICAgIH07XG59O1xuXG5jb25zdCBpbnZpc2libGVWYWx1ZXMgPSBuZXcgU2V0KFtcIm5vbmVcIiwgXCJoaWRkZW5cIl0pO1xuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBwcm92aWRlZCBhIHByb2dyZXNzIHZhbHVlIGJldHdlZW4gMCBhbmQgMSxcbiAqIHdpbGwgcmV0dXJuIHRoZSBcIm5vbmVcIiBvciBcImhpZGRlblwiIHN0cmluZyBvbmx5IHdoZW4gdGhlIHByb2dyZXNzIGlzIHRoYXQgb2ZcbiAqIHRoZSBvcmlnaW4gb3IgdGFyZ2V0LlxuICovXG5mdW5jdGlvbiBtaXhWaXNpYmlsaXR5KG9yaWdpbiwgdGFyZ2V0KSB7XG4gICAgaWYgKGludmlzaWJsZVZhbHVlcy5oYXMob3JpZ2luKSkge1xuICAgICAgICByZXR1cm4gKHApID0+IChwIDw9IDAgPyBvcmlnaW4gOiB0YXJnZXQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIChwKSA9PiAocCA+PSAxID8gdGFyZ2V0IDogb3JpZ2luKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIG1peE51bWJlcihhLCBiKSB7XG4gICAgcmV0dXJuIChwKSA9PiBtaXhOdW1iZXIkMShhLCBiLCBwKTtcbn1cbmZ1bmN0aW9uIGdldE1peGVyJDEoYSkge1xuICAgIGlmICh0eXBlb2YgYSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gbWl4TnVtYmVyO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgYSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gaXNDU1NWYXJpYWJsZVRva2VuKGEpXG4gICAgICAgICAgICA/IG1peEltbWVkaWF0ZVxuICAgICAgICAgICAgOiBjb2xvci50ZXN0KGEpXG4gICAgICAgICAgICAgICAgPyBtaXhDb2xvclxuICAgICAgICAgICAgICAgIDogbWl4Q29tcGxleDtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgICByZXR1cm4gbWl4QXJyYXk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBhID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHJldHVybiBjb2xvci50ZXN0KGEpID8gbWl4Q29sb3IgOiBtaXhPYmplY3Q7XG4gICAgfVxuICAgIHJldHVybiBtaXhJbW1lZGlhdGU7XG59XG5mdW5jdGlvbiBtaXhBcnJheShhLCBiKSB7XG4gICAgY29uc3Qgb3V0cHV0ID0gWy4uLmFdO1xuICAgIGNvbnN0IG51bVZhbHVlcyA9IG91dHB1dC5sZW5ndGg7XG4gICAgY29uc3QgYmxlbmRWYWx1ZSA9IGEubWFwKCh2LCBpKSA9PiBnZXRNaXhlciQxKHYpKHYsIGJbaV0pKTtcbiAgICByZXR1cm4gKHApID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1WYWx1ZXM7IGkrKykge1xuICAgICAgICAgICAgb3V0cHV0W2ldID0gYmxlbmRWYWx1ZVtpXShwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG59XG5mdW5jdGlvbiBtaXhPYmplY3QoYSwgYikge1xuICAgIGNvbnN0IG91dHB1dCA9IHsgLi4uYSwgLi4uYiB9O1xuICAgIGNvbnN0IGJsZW5kVmFsdWUgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvdXRwdXQpIHtcbiAgICAgICAgaWYgKGFba2V5XSAhPT0gdW5kZWZpbmVkICYmIGJba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBibGVuZFZhbHVlW2tleV0gPSBnZXRNaXhlciQxKGFba2V5XSkoYVtrZXldLCBiW2tleV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAodikgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBibGVuZFZhbHVlKSB7XG4gICAgICAgICAgICBvdXRwdXRba2V5XSA9IGJsZW5kVmFsdWVba2V5XSh2KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG59XG5mdW5jdGlvbiBtYXRjaE9yZGVyKG9yaWdpbiwgdGFyZ2V0KSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IG9yZGVyZWRPcmlnaW4gPSBbXTtcbiAgICBjb25zdCBwb2ludGVycyA9IHsgY29sb3I6IDAsIHZhcjogMCwgbnVtYmVyOiAwIH07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YXJnZXQudmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0YXJnZXQudHlwZXNbaV07XG4gICAgICAgIGNvbnN0IG9yaWdpbkluZGV4ID0gb3JpZ2luLmluZGV4ZXNbdHlwZV1bcG9pbnRlcnNbdHlwZV1dO1xuICAgICAgICBjb25zdCBvcmlnaW5WYWx1ZSA9IChfYSA9IG9yaWdpbi52YWx1ZXNbb3JpZ2luSW5kZXhdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICBvcmRlcmVkT3JpZ2luW2ldID0gb3JpZ2luVmFsdWU7XG4gICAgICAgIHBvaW50ZXJzW3R5cGVdKys7XG4gICAgfVxuICAgIHJldHVybiBvcmRlcmVkT3JpZ2luO1xufVxuY29uc3QgbWl4Q29tcGxleCA9IChvcmlnaW4sIHRhcmdldCkgPT4ge1xuICAgIGNvbnN0IHRlbXBsYXRlID0gY29tcGxleC5jcmVhdGVUcmFuc2Zvcm1lcih0YXJnZXQpO1xuICAgIGNvbnN0IG9yaWdpblN0YXRzID0gYW5hbHlzZUNvbXBsZXhWYWx1ZShvcmlnaW4pO1xuICAgIGNvbnN0IHRhcmdldFN0YXRzID0gYW5hbHlzZUNvbXBsZXhWYWx1ZSh0YXJnZXQpO1xuICAgIGNvbnN0IGNhbkludGVycG9sYXRlID0gb3JpZ2luU3RhdHMuaW5kZXhlcy52YXIubGVuZ3RoID09PSB0YXJnZXRTdGF0cy5pbmRleGVzLnZhci5sZW5ndGggJiZcbiAgICAgICAgb3JpZ2luU3RhdHMuaW5kZXhlcy5jb2xvci5sZW5ndGggPT09IHRhcmdldFN0YXRzLmluZGV4ZXMuY29sb3IubGVuZ3RoICYmXG4gICAgICAgIG9yaWdpblN0YXRzLmluZGV4ZXMubnVtYmVyLmxlbmd0aCA+PSB0YXJnZXRTdGF0cy5pbmRleGVzLm51bWJlci5sZW5ndGg7XG4gICAgaWYgKGNhbkludGVycG9sYXRlKSB7XG4gICAgICAgIGlmICgoaW52aXNpYmxlVmFsdWVzLmhhcyhvcmlnaW4pICYmXG4gICAgICAgICAgICAhdGFyZ2V0U3RhdHMudmFsdWVzLmxlbmd0aCkgfHxcbiAgICAgICAgICAgIChpbnZpc2libGVWYWx1ZXMuaGFzKHRhcmdldCkgJiZcbiAgICAgICAgICAgICAgICAhb3JpZ2luU3RhdHMudmFsdWVzLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBtaXhWaXNpYmlsaXR5KG9yaWdpbiwgdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGlwZShtaXhBcnJheShtYXRjaE9yZGVyKG9yaWdpblN0YXRzLCB0YXJnZXRTdGF0cyksIHRhcmdldFN0YXRzLnZhbHVlcyksIHRlbXBsYXRlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG1vdGlvblV0aWxzLndhcm5pbmcodHJ1ZSwgYENvbXBsZXggdmFsdWVzICcke29yaWdpbn0nIGFuZCAnJHt0YXJnZXR9JyB0b28gZGlmZmVyZW50IHRvIG1peC4gRW5zdXJlIGFsbCBjb2xvcnMgYXJlIG9mIHRoZSBzYW1lIHR5cGUsIGFuZCB0aGF0IGVhY2ggY29udGFpbnMgdGhlIHNhbWUgcXVhbnRpdHkgb2YgbnVtYmVyIGFuZCBjb2xvciB2YWx1ZXMuIEZhbGxpbmcgYmFjayB0byBpbnN0YW50IHRyYW5zaXRpb24uYCk7XG4gICAgICAgIHJldHVybiBtaXhJbW1lZGlhdGUob3JpZ2luLCB0YXJnZXQpO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIG1peChmcm9tLCB0bywgcCkge1xuICAgIGlmICh0eXBlb2YgZnJvbSA9PT0gXCJudW1iZXJcIiAmJlxuICAgICAgICB0eXBlb2YgdG8gPT09IFwibnVtYmVyXCIgJiZcbiAgICAgICAgdHlwZW9mIHAgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIG1peE51bWJlciQxKGZyb20sIHRvLCBwKTtcbiAgICB9XG4gICAgY29uc3QgbWl4ZXIgPSBnZXRNaXhlciQxKGZyb20pO1xuICAgIHJldHVybiBtaXhlcihmcm9tLCB0byk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU1peGVycyhvdXRwdXQsIGVhc2UsIGN1c3RvbU1peGVyKSB7XG4gICAgY29uc3QgbWl4ZXJzID0gW107XG4gICAgY29uc3QgbWl4ZXJGYWN0b3J5ID0gY3VzdG9tTWl4ZXIgfHwgbWl4O1xuICAgIGNvbnN0IG51bU1peGVycyA9IG91dHB1dC5sZW5ndGggLSAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtTWl4ZXJzOyBpKyspIHtcbiAgICAgICAgbGV0IG1peGVyID0gbWl4ZXJGYWN0b3J5KG91dHB1dFtpXSwgb3V0cHV0W2kgKyAxXSk7XG4gICAgICAgIGlmIChlYXNlKSB7XG4gICAgICAgICAgICBjb25zdCBlYXNpbmdGdW5jdGlvbiA9IEFycmF5LmlzQXJyYXkoZWFzZSkgPyBlYXNlW2ldIHx8IG1vdGlvblV0aWxzLm5vb3AgOiBlYXNlO1xuICAgICAgICAgICAgbWl4ZXIgPSBwaXBlKGVhc2luZ0Z1bmN0aW9uLCBtaXhlcik7XG4gICAgICAgIH1cbiAgICAgICAgbWl4ZXJzLnB1c2gobWl4ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gbWl4ZXJzO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBmdW5jdGlvbiB0aGF0IG1hcHMgZnJvbSBhIG51bWVyaWNhbCBpbnB1dCBhcnJheSB0byBhIGdlbmVyaWMgb3V0cHV0IGFycmF5LlxuICpcbiAqIEFjY2VwdHM6XG4gKiAgIC0gTnVtYmVyc1xuICogICAtIENvbG9ycyAoaGV4LCBoc2wsIGhzbGEsIHJnYiwgcmdiYSlcbiAqICAgLSBDb21wbGV4IChjb21iaW5hdGlvbnMgb2Ygb25lIG9yIG1vcmUgbnVtYmVycyBvciBzdHJpbmdzKVxuICpcbiAqIGBgYGpzeFxuICogY29uc3QgbWl4Q29sb3IgPSBpbnRlcnBvbGF0ZShbMCwgMV0sIFsnI2ZmZicsICcjMDAwJ10pXG4gKlxuICogbWl4Q29sb3IoMC41KSAvLyAncmdiYSgxMjgsIDEyOCwgMTI4LCAxKSdcbiAqIGBgYFxuICpcbiAqIFRPRE8gUmV2aXN0IHRoaXMgYXBwcm9hY2ggb25jZSB3ZSd2ZSBtb3ZlZCB0byBkYXRhIG1vZGVscyBmb3IgdmFsdWVzLFxuICogcHJvYmFibHkgbm90IG5lZWRlZCB0byBwcmVnZW5lcmF0ZSBtaXhlciBmdW5jdGlvbnMuXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZShpbnB1dCwgb3V0cHV0LCB7IGNsYW1wOiBpc0NsYW1wID0gdHJ1ZSwgZWFzZSwgbWl4ZXIgfSA9IHt9KSB7XG4gICAgY29uc3QgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgbW90aW9uVXRpbHMuaW52YXJpYW50KGlucHV0TGVuZ3RoID09PSBvdXRwdXQubGVuZ3RoLCBcIkJvdGggaW5wdXQgYW5kIG91dHB1dCByYW5nZXMgbXVzdCBiZSB0aGUgc2FtZSBsZW5ndGhcIik7XG4gICAgLyoqXG4gICAgICogSWYgd2UncmUgb25seSBwcm92aWRlZCBhIHNpbmdsZSBpbnB1dCwgd2UgY2FuIGp1c3QgbWFrZSBhIGZ1bmN0aW9uXG4gICAgICogdGhhdCByZXR1cm5zIHRoZSBvdXRwdXQuXG4gICAgICovXG4gICAgaWYgKGlucHV0TGVuZ3RoID09PSAxKVxuICAgICAgICByZXR1cm4gKCkgPT4gb3V0cHV0WzBdO1xuICAgIGlmIChpbnB1dExlbmd0aCA9PT0gMiAmJiBpbnB1dFswXSA9PT0gaW5wdXRbMV0pXG4gICAgICAgIHJldHVybiAoKSA9PiBvdXRwdXRbMV07XG4gICAgLy8gSWYgaW5wdXQgcnVucyBoaWdoZXN0IC0+IGxvd2VzdCwgcmV2ZXJzZSBib3RoIGFycmF5c1xuICAgIGlmIChpbnB1dFswXSA+IGlucHV0W2lucHV0TGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgaW5wdXQgPSBbLi4uaW5wdXRdLnJldmVyc2UoKTtcbiAgICAgICAgb3V0cHV0ID0gWy4uLm91dHB1dF0ucmV2ZXJzZSgpO1xuICAgIH1cbiAgICBjb25zdCBtaXhlcnMgPSBjcmVhdGVNaXhlcnMob3V0cHV0LCBlYXNlLCBtaXhlcik7XG4gICAgY29uc3QgbnVtTWl4ZXJzID0gbWl4ZXJzLmxlbmd0aDtcbiAgICBjb25zdCBpbnRlcnBvbGF0b3IgPSAodikgPT4ge1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGlmIChudW1NaXhlcnMgPiAxKSB7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IGlucHV0Lmxlbmd0aCAtIDI7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh2IDwgaW5wdXRbaSArIDFdKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9ncmVzc0luUmFuZ2UgPSBwcm9ncmVzcyhpbnB1dFtpXSwgaW5wdXRbaSArIDFdLCB2KTtcbiAgICAgICAgcmV0dXJuIG1peGVyc1tpXShwcm9ncmVzc0luUmFuZ2UpO1xuICAgIH07XG4gICAgcmV0dXJuIGlzQ2xhbXBcbiAgICAgICAgPyAodikgPT4gaW50ZXJwb2xhdG9yKGNsYW1wKGlucHV0WzBdLCBpbnB1dFtpbnB1dExlbmd0aCAtIDFdLCB2KSlcbiAgICAgICAgOiBpbnRlcnBvbGF0b3I7XG59XG5cbmZ1bmN0aW9uIGZpbGxPZmZzZXQob2Zmc2V0LCByZW1haW5pbmcpIHtcbiAgICBjb25zdCBtaW4gPSBvZmZzZXRbb2Zmc2V0Lmxlbmd0aCAtIDFdO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IHJlbWFpbmluZzsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldFByb2dyZXNzID0gcHJvZ3Jlc3MoMCwgcmVtYWluaW5nLCBpKTtcbiAgICAgICAgb2Zmc2V0LnB1c2gobWl4TnVtYmVyJDEobWluLCAxLCBvZmZzZXRQcm9ncmVzcykpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZGVmYXVsdE9mZnNldCQxKGFycikge1xuICAgIGNvbnN0IG9mZnNldCA9IFswXTtcbiAgICBmaWxsT2Zmc2V0KG9mZnNldCwgYXJyLmxlbmd0aCAtIDEpO1xuICAgIHJldHVybiBvZmZzZXQ7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRPZmZzZXRUb1RpbWVzKG9mZnNldCwgZHVyYXRpb24pIHtcbiAgICByZXR1cm4gb2Zmc2V0Lm1hcCgobykgPT4gbyAqIGR1cmF0aW9uKTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdEVhc2luZyQxKHZhbHVlcywgZWFzaW5nKSB7XG4gICAgcmV0dXJuIHZhbHVlcy5tYXAoKCkgPT4gZWFzaW5nIHx8IGVhc2VJbk91dCkuc3BsaWNlKDAsIHZhbHVlcy5sZW5ndGggLSAxKTtcbn1cbmZ1bmN0aW9uIGtleWZyYW1lcyh7IGR1cmF0aW9uID0gMzAwLCBrZXlmcmFtZXM6IGtleWZyYW1lVmFsdWVzLCB0aW1lcywgZWFzZSA9IFwiZWFzZUluT3V0XCIsIH0pIHtcbiAgICAvKipcbiAgICAgKiBFYXNpbmcgZnVuY3Rpb25zIGNhbiBiZSBleHRlcm5hbGx5IGRlZmluZWQgYXMgc3RyaW5ncy4gSGVyZSB3ZSBjb252ZXJ0IHRoZW1cbiAgICAgKiBpbnRvIGFjdHVhbCBmdW5jdGlvbnMuXG4gICAgICovXG4gICAgY29uc3QgZWFzaW5nRnVuY3Rpb25zID0gaXNFYXNpbmdBcnJheShlYXNlKVxuICAgICAgICA/IGVhc2UubWFwKGVhc2luZ0RlZmluaXRpb25Ub0Z1bmN0aW9uKVxuICAgICAgICA6IGVhc2luZ0RlZmluaXRpb25Ub0Z1bmN0aW9uKGVhc2UpO1xuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIEl0ZXJhdG9yLXNwZWMgcmV0dXJuIHZhbHVlLiBXZSBlbnN1cmUgaXQncyBtdXRhYmxlIHJhdGhlciB0aGFuIHVzaW5nIGEgZ2VuZXJhdG9yXG4gICAgICogdG8gcmVkdWNlIEdDIGR1cmluZyBhbmltYXRpb24uXG4gICAgICovXG4gICAgY29uc3Qgc3RhdGUgPSB7XG4gICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICB2YWx1ZToga2V5ZnJhbWVWYWx1ZXNbMF0sXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSB0aW1lcyBhcnJheSBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgMC0xIG9mZnNldHNcbiAgICAgKi9cbiAgICBjb25zdCBhYnNvbHV0ZVRpbWVzID0gY29udmVydE9mZnNldFRvVGltZXMoXG4gICAgLy8gT25seSB1c2UgdGhlIHByb3ZpZGVkIG9mZnNldHMgaWYgdGhleSdyZSB0aGUgY29ycmVjdCBsZW5ndGhcbiAgICAvLyBUT0RPIE1heWJlIHdlIHNob3VsZCB3YXJuIGhlcmUgaWYgdGhlcmUncyBhIGxlbmd0aCBtaXNtYXRjaFxuICAgIHRpbWVzICYmIHRpbWVzLmxlbmd0aCA9PT0ga2V5ZnJhbWVWYWx1ZXMubGVuZ3RoXG4gICAgICAgID8gdGltZXNcbiAgICAgICAgOiBkZWZhdWx0T2Zmc2V0JDEoa2V5ZnJhbWVWYWx1ZXMpLCBkdXJhdGlvbik7XG4gICAgY29uc3QgbWFwVGltZVRvS2V5ZnJhbWUgPSBpbnRlcnBvbGF0ZShhYnNvbHV0ZVRpbWVzLCBrZXlmcmFtZVZhbHVlcywge1xuICAgICAgICBlYXNlOiBBcnJheS5pc0FycmF5KGVhc2luZ0Z1bmN0aW9ucylcbiAgICAgICAgICAgID8gZWFzaW5nRnVuY3Rpb25zXG4gICAgICAgICAgICA6IGRlZmF1bHRFYXNpbmckMShrZXlmcmFtZVZhbHVlcywgZWFzaW5nRnVuY3Rpb25zKSxcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjYWxjdWxhdGVkRHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgICBuZXh0OiAodCkgPT4ge1xuICAgICAgICAgICAgc3RhdGUudmFsdWUgPSBtYXBUaW1lVG9LZXlmcmFtZSh0KTtcbiAgICAgICAgICAgIHN0YXRlLmRvbmUgPSB0ID49IGR1cmF0aW9uO1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICB9LFxuICAgIH07XG59XG5cbmNvbnN0IGZyYW1lbG9vcERyaXZlciA9ICh1cGRhdGUpID0+IHtcbiAgICBjb25zdCBwYXNzVGltZXN0YW1wID0gKHsgdGltZXN0YW1wIH0pID0+IHVwZGF0ZSh0aW1lc3RhbXApO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiAoKSA9PiBmcmFtZS51cGRhdGUocGFzc1RpbWVzdGFtcCwgdHJ1ZSksXG4gICAgICAgIHN0b3A6ICgpID0+IGNhbmNlbEZyYW1lKHBhc3NUaW1lc3RhbXApLFxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgd2UncmUgcHJvY2Vzc2luZyB0aGlzIGZyYW1lIHdlIGNhbiB1c2UgdGhlXG4gICAgICAgICAqIGZyYW1lbG9ja2VkIHRpbWVzdGFtcCB0byBrZWVwIHRoaW5ncyBpbiBzeW5jLlxuICAgICAgICAgKi9cbiAgICAgICAgbm93OiAoKSA9PiAoZnJhbWVEYXRhLmlzUHJvY2Vzc2luZyA/IGZyYW1lRGF0YS50aW1lc3RhbXAgOiB0aW1lLm5vdygpKSxcbiAgICB9O1xufTtcblxuY29uc3QgZ2VuZXJhdG9ycyA9IHtcbiAgICBkZWNheTogaW5lcnRpYSxcbiAgICBpbmVydGlhLFxuICAgIHR3ZWVuOiBrZXlmcmFtZXMsXG4gICAga2V5ZnJhbWVzOiBrZXlmcmFtZXMsXG4gICAgc3ByaW5nLFxufTtcbmNvbnN0IHBlcmNlbnRUb1Byb2dyZXNzID0gKHBlcmNlbnQpID0+IHBlcmNlbnQgLyAxMDA7XG4vKipcbiAqIEFuaW1hdGlvbiB0aGF0IHJ1bnMgb24gdGhlIG1haW4gdGhyZWFkLiBEZXNpZ25lZCB0byBiZSBXQUFQSS1zcGVjIGluIHRoZSBzdWJzZXQgb2ZcbiAqIGZlYXR1cmVzIHdlIGV4cG9zZSBwdWJsaWNhbGx5LiBNb3N0bHkgdGhlIGNvbXBhdGliaWxpdHkgaXMgdG8gZW5zdXJlIHZpc3VhbCBpZGVudGl0eVxuICogYmV0d2VlbiBib3RoIFdBQVBJIGFuZCBtYWluIHRocmVhZCBhbmltYXRpb25zLlxuICovXG5jbGFzcyBNYWluVGhyZWFkQW5pbWF0aW9uIGV4dGVuZHMgQmFzZUFuaW1hdGlvbiB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0aW1lIGF0IHdoaWNoIHRoZSBhbmltYXRpb24gd2FzIHBhdXNlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaG9sZFRpbWUgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRpbWUgYXQgd2hpY2ggdGhlIGFuaW1hdGlvbiB3YXMgY2FuY2VsbGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jYW5jZWxUaW1lID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjdXJyZW50IHRpbWUgb2YgdGhlIGFuaW1hdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3VycmVudFRpbWUgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogUGxheWJhY2sgc3BlZWQgYXMgYSBmYWN0b3IuIDAgd291bGQgYmUgc3RvcHBlZCwgLTEgcmV2ZXJzZSBhbmQgMiBkb3VibGUgc3BlZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBsYXliYWNrU3BlZWQgPSAxO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHN0YXRlIG9mIHRoZSBhbmltYXRpb24gdG8gYXBwbHkgd2hlbiB0aGUgYW5pbWF0aW9uIGlzIHJlc29sdmVkLiBUaGlzXG4gICAgICAgICAqIGFsbG93cyBjYWxscyB0byB0aGUgcHVibGljIEFQSSB0byBjb250cm9sIHRoZSBhbmltYXRpb24gYmVmb3JlIGl0IGlzIHJlc29sdmVkLFxuICAgICAgICAgKiB3aXRob3V0IHVzIGhhdmluZyB0byByZXNvbHZlIGl0IGZpcnN0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wZW5kaW5nUGxheVN0YXRlID0gXCJydW5uaW5nXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGltZSBhdCB3aGljaCB0aGUgYW5pbWF0aW9uIHdhcyBzdGFydGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFydFRpbWUgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YXRlID0gXCJpZGxlXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBpcyBib3VuZCB0byB0aGUgaW5zdGFuY2UgdG8gZml4IGEgcGF0dGVybiB3aGVyZVxuICAgICAgICAgKiBhbmltYXRpb24uc3RvcCBpcyByZXR1cm5lZCBhcyBhIHJlZmVyZW5jZSBmcm9tIGEgdXNlRWZmZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdG9wID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlci5jYW5jZWwoKTtcbiAgICAgICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBcImlkbGVcIilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLnRlYXJkb3duKCk7XG4gICAgICAgICAgICBjb25zdCB7IG9uU3RvcCB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAgICAgb25TdG9wICYmIG9uU3RvcCgpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB7IG5hbWUsIG1vdGlvblZhbHVlLCBlbGVtZW50LCBrZXlmcmFtZXMgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgY29uc3QgS2V5ZnJhbWVSZXNvbHZlciQxID0gKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZWxlbWVudC5LZXlmcmFtZVJlc29sdmVyKSB8fCBLZXlmcmFtZVJlc29sdmVyO1xuICAgICAgICBjb25zdCBvblJlc29sdmVkID0gKHJlc29sdmVkS2V5ZnJhbWVzLCBmaW5hbEtleWZyYW1lKSA9PiB0aGlzLm9uS2V5ZnJhbWVzUmVzb2x2ZWQocmVzb2x2ZWRLZXlmcmFtZXMsIGZpbmFsS2V5ZnJhbWUpO1xuICAgICAgICB0aGlzLnJlc29sdmVyID0gbmV3IEtleWZyYW1lUmVzb2x2ZXIkMShrZXlmcmFtZXMsIG9uUmVzb2x2ZWQsIG5hbWUsIG1vdGlvblZhbHVlLCBlbGVtZW50KTtcbiAgICAgICAgdGhpcy5yZXNvbHZlci5zY2hlZHVsZVJlc29sdmUoKTtcbiAgICB9XG4gICAgZmxhdHRlbigpIHtcbiAgICAgICAgc3VwZXIuZmxhdHRlbigpO1xuICAgICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IHJlc29sdmVkIHRoZSBhbmltYXRpb24sIHJlLWluaXRpYWxpc2UgaXRcbiAgICAgICAgaWYgKHRoaXMuX3Jlc29sdmVkKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuX3Jlc29sdmVkLCB0aGlzLmluaXRQbGF5YmFjayh0aGlzLl9yZXNvbHZlZC5rZXlmcmFtZXMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbml0UGxheWJhY2soa2V5ZnJhbWVzJDEpIHtcbiAgICAgICAgY29uc3QgeyB0eXBlID0gXCJrZXlmcmFtZXNcIiwgcmVwZWF0ID0gMCwgcmVwZWF0RGVsYXkgPSAwLCByZXBlYXRUeXBlLCB2ZWxvY2l0eSA9IDAsIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGdlbmVyYXRvckZhY3RvcnkgPSBpc0dlbmVyYXRvcih0eXBlKVxuICAgICAgICAgICAgPyB0eXBlXG4gICAgICAgICAgICA6IGdlbmVyYXRvcnNbdHlwZV0gfHwga2V5ZnJhbWVzO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgb3VyIGdlbmVyYXRvciBkb2Vzbid0IHN1cHBvcnQgbWl4aW5nIG51bWJlcnMsIHdlIG5lZWQgdG8gcmVwbGFjZSBrZXlmcmFtZXMgd2l0aFxuICAgICAgICAgKiBbMCwgMTAwXSBhbmQgdGhlbiBtYWtlIGEgZnVuY3Rpb24gdGhhdCBtYXBzIHRoYXQgdG8gdGhlIGFjdHVhbCBrZXlmcmFtZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIDEwMCBpcyBjaG9zZW4gaW5zdGVhZCBvZiAxIGFzIGl0IHdvcmtzIG5pY2VyIHdpdGggc3ByaW5nIGFuaW1hdGlvbnMuXG4gICAgICAgICAqL1xuICAgICAgICBsZXQgbWFwUGVyY2VudFRvS2V5ZnJhbWVzO1xuICAgICAgICBsZXQgbWlycm9yZWRHZW5lcmF0b3I7XG4gICAgICAgIGlmIChnZW5lcmF0b3JGYWN0b3J5ICE9PSBrZXlmcmFtZXMgJiZcbiAgICAgICAgICAgIHR5cGVvZiBrZXlmcmFtZXMkMVswXSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICAgIG1vdGlvblV0aWxzLmludmFyaWFudChrZXlmcmFtZXMkMS5sZW5ndGggPT09IDIsIGBPbmx5IHR3byBrZXlmcmFtZXMgY3VycmVudGx5IHN1cHBvcnRlZCB3aXRoIHNwcmluZyBhbmQgaW5lcnRpYSBhbmltYXRpb25zLiBUcnlpbmcgdG8gYW5pbWF0ZSAke2tleWZyYW1lcyQxfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWFwUGVyY2VudFRvS2V5ZnJhbWVzID0gcGlwZShwZXJjZW50VG9Qcm9ncmVzcywgbWl4KGtleWZyYW1lcyQxWzBdLCBrZXlmcmFtZXMkMVsxXSkpO1xuICAgICAgICAgICAga2V5ZnJhbWVzJDEgPSBbMCwgMTAwXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBnZW5lcmF0b3IgPSBnZW5lcmF0b3JGYWN0b3J5KHsgLi4udGhpcy5vcHRpb25zLCBrZXlmcmFtZXM6IGtleWZyYW1lcyQxIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgd2UgaGF2ZSBhIG1pcnJvciByZXBlYXQgdHlwZSB3ZSBuZWVkIHRvIGNyZWF0ZSBhIHNlY29uZCBnZW5lcmF0b3IgdGhhdCBvdXRwdXRzIHRoZVxuICAgICAgICAgKiBtaXJyb3JlZCAobm90IHJldmVyc2VkKSBhbmltYXRpb24gYW5kIGxhdGVyIHBpbmcgcG9uZyBiZXR3ZWVuIHRoZSB0d28gZ2VuZXJhdG9ycy5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChyZXBlYXRUeXBlID09PSBcIm1pcnJvclwiKSB7XG4gICAgICAgICAgICBtaXJyb3JlZEdlbmVyYXRvciA9IGdlbmVyYXRvckZhY3Rvcnkoe1xuICAgICAgICAgICAgICAgIC4uLnRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgICAgICBrZXlmcmFtZXM6IFsuLi5rZXlmcmFtZXMkMV0ucmV2ZXJzZSgpLFxuICAgICAgICAgICAgICAgIHZlbG9jaXR5OiAtdmVsb2NpdHksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgZHVyYXRpb24gaXMgdW5kZWZpbmVkIGFuZCB3ZSBoYXZlIHJlcGVhdCBvcHRpb25zLFxuICAgICAgICAgKiB3ZSBuZWVkIHRvIGNhbGN1bGF0ZSBhIGR1cmF0aW9uIGZyb20gdGhlIGdlbmVyYXRvci5cbiAgICAgICAgICpcbiAgICAgICAgICogV2Ugc2V0IGl0IHRvIHRoZSBnZW5lcmF0b3IgaXRzZWxmIHRvIGNhY2hlIHRoZSBkdXJhdGlvbi5cbiAgICAgICAgICogQW55IHRpbWVsaW5lIHJlc29sdmVyIHdpbGwgbmVlZCB0byBoYXZlIGFscmVhZHkgcHJlY2FsY3VsYXRlZFxuICAgICAgICAgKiB0aGUgZHVyYXRpb24gYnkgdGhpcyBzdGVwLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGdlbmVyYXRvci5jYWxjdWxhdGVkRHVyYXRpb24gPT09IG51bGwpIHtcbiAgICAgICAgICAgIGdlbmVyYXRvci5jYWxjdWxhdGVkRHVyYXRpb24gPSBjYWxjR2VuZXJhdG9yRHVyYXRpb24oZ2VuZXJhdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGNhbGN1bGF0ZWREdXJhdGlvbiB9ID0gZ2VuZXJhdG9yO1xuICAgICAgICBjb25zdCByZXNvbHZlZER1cmF0aW9uID0gY2FsY3VsYXRlZER1cmF0aW9uICsgcmVwZWF0RGVsYXk7XG4gICAgICAgIGNvbnN0IHRvdGFsRHVyYXRpb24gPSByZXNvbHZlZER1cmF0aW9uICogKHJlcGVhdCArIDEpIC0gcmVwZWF0RGVsYXk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBnZW5lcmF0b3IsXG4gICAgICAgICAgICBtaXJyb3JlZEdlbmVyYXRvcixcbiAgICAgICAgICAgIG1hcFBlcmNlbnRUb0tleWZyYW1lcyxcbiAgICAgICAgICAgIGNhbGN1bGF0ZWREdXJhdGlvbixcbiAgICAgICAgICAgIHJlc29sdmVkRHVyYXRpb24sXG4gICAgICAgICAgICB0b3RhbER1cmF0aW9uLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBvblBvc3RSZXNvbHZlZCgpIHtcbiAgICAgICAgY29uc3QgeyBhdXRvcGxheSA9IHRydWUgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgdGhpcy5wbGF5KCk7XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdQbGF5U3RhdGUgPT09IFwicGF1c2VkXCIgfHwgIWF1dG9wbGF5KSB7XG4gICAgICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5wZW5kaW5nUGxheVN0YXRlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRpY2sodGltZXN0YW1wLCBzYW1wbGUgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCB7IHJlc29sdmVkIH0gPSB0aGlzO1xuICAgICAgICAvLyBJZiB0aGUgYW5pbWF0aW9ucyBoYXMgZmFpbGVkIHRvIHJlc29sdmUsIHJldHVybiB0aGUgZmluYWwga2V5ZnJhbWUuXG4gICAgICAgIGlmICghcmVzb2x2ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsga2V5ZnJhbWVzIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZToga2V5ZnJhbWVzW2tleWZyYW1lcy5sZW5ndGggLSAxXSB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgZmluYWxLZXlmcmFtZSwgZ2VuZXJhdG9yLCBtaXJyb3JlZEdlbmVyYXRvciwgbWFwUGVyY2VudFRvS2V5ZnJhbWVzLCBrZXlmcmFtZXMsIGNhbGN1bGF0ZWREdXJhdGlvbiwgdG90YWxEdXJhdGlvbiwgcmVzb2x2ZWREdXJhdGlvbiwgfSA9IHJlc29sdmVkO1xuICAgICAgICBpZiAodGhpcy5zdGFydFRpbWUgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZ2VuZXJhdG9yLm5leHQoMCk7XG4gICAgICAgIGNvbnN0IHsgZGVsYXksIHJlcGVhdCwgcmVwZWF0VHlwZSwgcmVwZWF0RGVsYXksIG9uVXBkYXRlIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgdGltZXN0YW1wcyBjYW4gY29tZSB0aHJvdWdoIGFzIGxvd2VyIHRoYW5cbiAgICAgICAgICogdGhlIHN0YXJ0VGltZSBhcyBzZXQgYnkgcGVyZm9ybWFuY2Uubm93KCkuIEhlcmUgd2UgcHJldmVudCB0aGlzLFxuICAgICAgICAgKiB0aG91Z2ggaW4gdGhlIGZ1dHVyZSBpdCBjb3VsZCBiZSBwb3NzaWJsZSB0byBtYWtlIHNldHRpbmcgc3RhcnRUaW1lXG4gICAgICAgICAqIGEgcGVuZGluZyBvcGVyYXRpb24gdGhhdCBnZXRzIHJlc29sdmVkIGhlcmUuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodGhpcy5zcGVlZCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRUaW1lID0gTWF0aC5taW4odGhpcy5zdGFydFRpbWUsIHRpbWVzdGFtcCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zcGVlZCA8IDApIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRUaW1lID0gTWF0aC5taW4odGltZXN0YW1wIC0gdG90YWxEdXJhdGlvbiAvIHRoaXMuc3BlZWQsIHRoaXMuc3RhcnRUaW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgY3VycmVudFRpbWVcbiAgICAgICAgaWYgKHNhbXBsZSkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50VGltZSA9IHRpbWVzdGFtcDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmhvbGRUaW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRUaW1lID0gdGhpcy5ob2xkVGltZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFJvdW5kaW5nIHRoZSB0aW1lIGJlY2F1c2UgZmxvYXRpbmcgcG9pbnQgYXJpdGhtZXRpYyBpcyBub3QgYWx3YXlzIGFjY3VyYXRlLCBlLmcuIDMwMDAuMzY3IC0gMTAwMC4zNjcgPVxuICAgICAgICAgICAgLy8gMjAwMC4wMDAwMDAwMDAwMDAyLiBUaGlzIGlzIGEgcHJvYmxlbSB3aGVuIHdlIGFyZSBjb21wYXJpbmcgdGhlIGN1cnJlbnRUaW1lIHdpdGggdGhlIGR1cmF0aW9uLCBmb3JcbiAgICAgICAgICAgIC8vIGV4YW1wbGUuXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRUaW1lID1cbiAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKHRpbWVzdGFtcCAtIHRoaXMuc3RhcnRUaW1lKSAqIHRoaXMuc3BlZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmViYXNlIG9uIGRlbGF5XG4gICAgICAgIGNvbnN0IHRpbWVXaXRob3V0RGVsYXkgPSB0aGlzLmN1cnJlbnRUaW1lIC0gZGVsYXkgKiAodGhpcy5zcGVlZCA+PSAwID8gMSA6IC0xKTtcbiAgICAgICAgY29uc3QgaXNJbkRlbGF5UGhhc2UgPSB0aGlzLnNwZWVkID49IDBcbiAgICAgICAgICAgID8gdGltZVdpdGhvdXREZWxheSA8IDBcbiAgICAgICAgICAgIDogdGltZVdpdGhvdXREZWxheSA+IHRvdGFsRHVyYXRpb247XG4gICAgICAgIHRoaXMuY3VycmVudFRpbWUgPSBNYXRoLm1heCh0aW1lV2l0aG91dERlbGF5LCAwKTtcbiAgICAgICAgLy8gSWYgdGhpcyBhbmltYXRpb24gaGFzIGZpbmlzaGVkLCBzZXQgdGhlIGN1cnJlbnQgdGltZSAgdG8gdGhlIHRvdGFsIGR1cmF0aW9uLlxuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gXCJmaW5pc2hlZFwiICYmIHRoaXMuaG9sZFRpbWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFRpbWUgPSB0b3RhbER1cmF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGxldCBlbGFwc2VkID0gdGhpcy5jdXJyZW50VGltZTtcbiAgICAgICAgbGV0IGZyYW1lR2VuZXJhdG9yID0gZ2VuZXJhdG9yO1xuICAgICAgICBpZiAocmVwZWF0KSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCB0aGUgY3VycmVudCBwcm9ncmVzcyAoMC0xKSBvZiB0aGUgYW5pbWF0aW9uLiBJZiB0IGlzID5cbiAgICAgICAgICAgICAqIHRoYW4gZHVyYXRpb24gd2UnbGwgZ2V0IHZhbHVlcyBsaWtlIDIuNSAobWlkd2F5IHRocm91Z2ggdGhlXG4gICAgICAgICAgICAgKiB0aGlyZCBpdGVyYXRpb24pXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IHByb2dyZXNzID0gTWF0aC5taW4odGhpcy5jdXJyZW50VGltZSwgdG90YWxEdXJhdGlvbikgLyByZXNvbHZlZER1cmF0aW9uO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQgdGhlIGN1cnJlbnQgaXRlcmF0aW9uICgwIGluZGV4ZWQpLiBGb3IgaW5zdGFuY2UgdGhlIGZsb29yIG9mXG4gICAgICAgICAgICAgKiAyLjUgaXMgMi5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRJdGVyYXRpb24gPSBNYXRoLmZsb29yKHByb2dyZXNzKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0IHRoZSBjdXJyZW50IHByb2dyZXNzIG9mIHRoZSBpdGVyYXRpb24gYnkgdGFraW5nIHRoZSByZW1haW5kZXJcbiAgICAgICAgICAgICAqIHNvIDIuNSBpcyAwLjUgdGhyb3VnaCBpdGVyYXRpb24gMlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBsZXQgaXRlcmF0aW9uUHJvZ3Jlc3MgPSBwcm9ncmVzcyAlIDEuMDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgaXRlcmF0aW9uIHByb2dyZXNzIGlzIDEgd2UgY291bnQgdGhhdCBhcyB0aGUgZW5kXG4gICAgICAgICAgICAgKiBvZiB0aGUgcHJldmlvdXMgaXRlcmF0aW9uLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoIWl0ZXJhdGlvblByb2dyZXNzICYmIHByb2dyZXNzID49IDEpIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRpb25Qcm9ncmVzcyA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVyYXRpb25Qcm9ncmVzcyA9PT0gMSAmJiBjdXJyZW50SXRlcmF0aW9uLS07XG4gICAgICAgICAgICBjdXJyZW50SXRlcmF0aW9uID0gTWF0aC5taW4oY3VycmVudEl0ZXJhdGlvbiwgcmVwZWF0ICsgMSk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldmVyc2UgcHJvZ3Jlc3MgaWYgd2UncmUgbm90IHJ1bm5pbmcgaW4gXCJub3JtYWxcIiBkaXJlY3Rpb25cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgaXNPZGRJdGVyYXRpb24gPSBCb29sZWFuKGN1cnJlbnRJdGVyYXRpb24gJSAyKTtcbiAgICAgICAgICAgIGlmIChpc09kZEl0ZXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChyZXBlYXRUeXBlID09PSBcInJldmVyc2VcIikge1xuICAgICAgICAgICAgICAgICAgICBpdGVyYXRpb25Qcm9ncmVzcyA9IDEgLSBpdGVyYXRpb25Qcm9ncmVzcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcGVhdERlbGF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVyYXRpb25Qcm9ncmVzcyAtPSByZXBlYXREZWxheSAvIHJlc29sdmVkRHVyYXRpb247XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVwZWF0VHlwZSA9PT0gXCJtaXJyb3JcIikge1xuICAgICAgICAgICAgICAgICAgICBmcmFtZUdlbmVyYXRvciA9IG1pcnJvcmVkR2VuZXJhdG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsYXBzZWQgPSBjbGFtcCgwLCAxLCBpdGVyYXRpb25Qcm9ncmVzcykgKiByZXNvbHZlZER1cmF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB3ZSdyZSBpbiBuZWdhdGl2ZSB0aW1lLCBzZXQgc3RhdGUgYXMgdGhlIGluaXRpYWwga2V5ZnJhbWUuXG4gICAgICAgICAqIFRoaXMgcHJldmVudHMgZGVsYXk6IHgsIGR1cmF0aW9uOiAwIGFuaW1hdGlvbnMgZnJvbSBmaW5pc2hpbmdcbiAgICAgICAgICogaW5zdGFudGx5LlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3Qgc3RhdGUgPSBpc0luRGVsYXlQaGFzZVxuICAgICAgICAgICAgPyB7IGRvbmU6IGZhbHNlLCB2YWx1ZToga2V5ZnJhbWVzWzBdIH1cbiAgICAgICAgICAgIDogZnJhbWVHZW5lcmF0b3IubmV4dChlbGFwc2VkKTtcbiAgICAgICAgaWYgKG1hcFBlcmNlbnRUb0tleWZyYW1lcykge1xuICAgICAgICAgICAgc3RhdGUudmFsdWUgPSBtYXBQZXJjZW50VG9LZXlmcmFtZXMoc3RhdGUudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IGRvbmUgfSA9IHN0YXRlO1xuICAgICAgICBpZiAoIWlzSW5EZWxheVBoYXNlICYmIGNhbGN1bGF0ZWREdXJhdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZG9uZSA9XG4gICAgICAgICAgICAgICAgdGhpcy5zcGVlZCA+PSAwXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5jdXJyZW50VGltZSA+PSB0b3RhbER1cmF0aW9uXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5jdXJyZW50VGltZSA8PSAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzQW5pbWF0aW9uRmluaXNoZWQgPSB0aGlzLmhvbGRUaW1lID09PSBudWxsICYmXG4gICAgICAgICAgICAodGhpcy5zdGF0ZSA9PT0gXCJmaW5pc2hlZFwiIHx8ICh0aGlzLnN0YXRlID09PSBcInJ1bm5pbmdcIiAmJiBkb25lKSk7XG4gICAgICAgIGlmIChpc0FuaW1hdGlvbkZpbmlzaGVkICYmIGZpbmFsS2V5ZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3RhdGUudmFsdWUgPSBnZXRGaW5hbEtleWZyYW1lKGtleWZyYW1lcywgdGhpcy5vcHRpb25zLCBmaW5hbEtleWZyYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25VcGRhdGUpIHtcbiAgICAgICAgICAgIG9uVXBkYXRlKHN0YXRlLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBbmltYXRpb25GaW5pc2hlZCkge1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIGdldCBkdXJhdGlvbigpIHtcbiAgICAgICAgY29uc3QgeyByZXNvbHZlZCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHJlc29sdmVkID8gbWlsbGlzZWNvbmRzVG9TZWNvbmRzKHJlc29sdmVkLmNhbGN1bGF0ZWREdXJhdGlvbikgOiAwO1xuICAgIH1cbiAgICBnZXQgdGltZSgpIHtcbiAgICAgICAgcmV0dXJuIG1pbGxpc2Vjb25kc1RvU2Vjb25kcyh0aGlzLmN1cnJlbnRUaW1lKTtcbiAgICB9XG4gICAgc2V0IHRpbWUobmV3VGltZSkge1xuICAgICAgICBuZXdUaW1lID0gc2Vjb25kc1RvTWlsbGlzZWNvbmRzKG5ld1RpbWUpO1xuICAgICAgICB0aGlzLmN1cnJlbnRUaW1lID0gbmV3VGltZTtcbiAgICAgICAgaWYgKHRoaXMuaG9sZFRpbWUgIT09IG51bGwgfHwgdGhpcy5zcGVlZCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5ob2xkVGltZSA9IG5ld1RpbWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5kcml2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRUaW1lID0gdGhpcy5kcml2ZXIubm93KCkgLSBuZXdUaW1lIC8gdGhpcy5zcGVlZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgc3BlZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBsYXliYWNrU3BlZWQ7XG4gICAgfVxuICAgIHNldCBzcGVlZChuZXdTcGVlZCkge1xuICAgICAgICBjb25zdCBoYXNDaGFuZ2VkID0gdGhpcy5wbGF5YmFja1NwZWVkICE9PSBuZXdTcGVlZDtcbiAgICAgICAgdGhpcy5wbGF5YmFja1NwZWVkID0gbmV3U3BlZWQ7XG4gICAgICAgIGlmIChoYXNDaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLnRpbWUgPSBtaWxsaXNlY29uZHNUb1NlY29uZHModGhpcy5jdXJyZW50VGltZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGxheSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJlc29sdmVyLmlzU2NoZWR1bGVkKSB7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmVyLnJlc3VtZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fcmVzb2x2ZWQpIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ1BsYXlTdGF0ZSA9IFwicnVubmluZ1wiO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzU3RvcHBlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgeyBkcml2ZXIgPSBmcmFtZWxvb3BEcml2ZXIsIG9uUGxheSwgc3RhcnRUaW1lIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGlmICghdGhpcy5kcml2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZHJpdmVyID0gZHJpdmVyKCh0aW1lc3RhbXApID0+IHRoaXMudGljayh0aW1lc3RhbXApKTtcbiAgICAgICAgfVxuICAgICAgICBvblBsYXkgJiYgb25QbGF5KCk7XG4gICAgICAgIGNvbnN0IG5vdyA9IHRoaXMuZHJpdmVyLm5vdygpO1xuICAgICAgICBpZiAodGhpcy5ob2xkVGltZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydFRpbWUgPSBub3cgLSB0aGlzLmhvbGRUaW1lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLnN0YXJ0VGltZSkge1xuICAgICAgICAgICAgdGhpcy5zdGFydFRpbWUgPSBzdGFydFRpbWUgIT09IG51bGwgJiYgc3RhcnRUaW1lICE9PSB2b2lkIDAgPyBzdGFydFRpbWUgOiB0aGlzLmNhbGNTdGFydFRpbWUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXRlID09PSBcImZpbmlzaGVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRUaW1lID0gbm93O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBcImZpbmlzaGVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRmluaXNoZWRQcm9taXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYW5jZWxUaW1lID0gdGhpcy5zdGFydFRpbWU7XG4gICAgICAgIHRoaXMuaG9sZFRpbWUgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHBsYXlTdGF0ZSB0byBydW5uaW5nIG9ubHkgYWZ0ZXIgd2UndmUgdXNlZCBpdCBpblxuICAgICAgICAgKiB0aGUgcHJldmlvdXMgbG9naWMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YXRlID0gXCJydW5uaW5nXCI7XG4gICAgICAgIHRoaXMuZHJpdmVyLnN0YXJ0KCk7XG4gICAgfVxuICAgIHBhdXNlKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghdGhpcy5fcmVzb2x2ZWQpIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ1BsYXlTdGF0ZSA9IFwicGF1c2VkXCI7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IFwicGF1c2VkXCI7XG4gICAgICAgIHRoaXMuaG9sZFRpbWUgPSAoX2EgPSB0aGlzLmN1cnJlbnRUaW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgIH1cbiAgICBjb21wbGV0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFwicnVubmluZ1wiKSB7XG4gICAgICAgICAgICB0aGlzLnBsYXkoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBlbmRpbmdQbGF5U3RhdGUgPSB0aGlzLnN0YXRlID0gXCJmaW5pc2hlZFwiO1xuICAgICAgICB0aGlzLmhvbGRUaW1lID0gbnVsbDtcbiAgICB9XG4gICAgZmluaXNoKCkge1xuICAgICAgICB0aGlzLnRlYXJkb3duKCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBcImZpbmlzaGVkXCI7XG4gICAgICAgIGNvbnN0IHsgb25Db21wbGV0ZSB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUoKTtcbiAgICB9XG4gICAgY2FuY2VsKCkge1xuICAgICAgICBpZiAodGhpcy5jYW5jZWxUaW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnRpY2sodGhpcy5jYW5jZWxUaW1lKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRlYXJkb3duKCk7XG4gICAgICAgIHRoaXMudXBkYXRlRmluaXNoZWRQcm9taXNlKCk7XG4gICAgfVxuICAgIHRlYXJkb3duKCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gXCJpZGxlXCI7XG4gICAgICAgIHRoaXMuc3RvcERyaXZlcigpO1xuICAgICAgICB0aGlzLnJlc29sdmVGaW5pc2hlZFByb21pc2UoKTtcbiAgICAgICAgdGhpcy51cGRhdGVGaW5pc2hlZFByb21pc2UoKTtcbiAgICAgICAgdGhpcy5zdGFydFRpbWUgPSB0aGlzLmNhbmNlbFRpbWUgPSBudWxsO1xuICAgICAgICB0aGlzLnJlc29sdmVyLmNhbmNlbCgpO1xuICAgIH1cbiAgICBzdG9wRHJpdmVyKCkge1xuICAgICAgICBpZiAoIXRoaXMuZHJpdmVyKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmRyaXZlci5zdG9wKCk7XG4gICAgICAgIHRoaXMuZHJpdmVyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBzYW1wbGUodGltZSkge1xuICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzLnRpY2sodGltZSwgdHJ1ZSk7XG4gICAgfVxufVxuLy8gTGVnYWN5IGludGVyZmFjZVxuZnVuY3Rpb24gYW5pbWF0ZVZhbHVlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IE1haW5UaHJlYWRBbmltYXRpb24ob3B0aW9ucyk7XG59XG5cbi8qKlxuICogQSBsaXN0IG9mIHZhbHVlcyB0aGF0IGNhbiBiZSBoYXJkd2FyZS1hY2NlbGVyYXRlZC5cbiAqL1xuY29uc3QgYWNjZWxlcmF0ZWRWYWx1ZXMgPSBuZXcgU2V0KFtcbiAgICBcIm9wYWNpdHlcIixcbiAgICBcImNsaXBQYXRoXCIsXG4gICAgXCJmaWx0ZXJcIixcbiAgICBcInRyYW5zZm9ybVwiLFxuICAgIC8vIFRPRE86IENhbiBiZSBhY2NlbGVyYXRlZCBidXQgY3VycmVudGx5IGRpc2FibGVkIHVudGlsIGh0dHBzOi8vaXNzdWVzLmNocm9taXVtLm9yZy9pc3N1ZXMvNDE0OTEwOTggaXMgcmVzb2x2ZWRcbiAgICAvLyBvciB1bnRpbCB3ZSBpbXBsZW1lbnQgc3VwcG9ydCBmb3IgbGluZWFyKCkgZWFzaW5nLlxuICAgIC8vIFwiYmFja2dyb3VuZC1jb2xvclwiXG5dKTtcblxuZnVuY3Rpb24gbWVtbyhjYWxsYmFjaykge1xuICAgIGxldCByZXN1bHQ7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVzdWx0ID0gY2FsbGJhY2soKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufVxuXG4vKipcbiAqIEFkZCB0aGUgYWJpbGl0eSBmb3IgdGVzdCBzdWl0ZXMgdG8gbWFudWFsbHkgc2V0IHN1cHBvcnQgZmxhZ3NcbiAqIHRvIGJldHRlciB0ZXN0IG1vcmUgZW52aXJvbm1lbnRzLlxuICovXG5jb25zdCBzdXBwb3J0c0ZsYWdzID0ge1xuICAgIGxpbmVhckVhc2luZzogdW5kZWZpbmVkLFxufTtcblxuZnVuY3Rpb24gbWVtb1N1cHBvcnRzKGNhbGxiYWNrLCBzdXBwb3J0c0ZsYWcpIHtcbiAgICBjb25zdCBtZW1vaXplZCA9IG1lbW8oY2FsbGJhY2spO1xuICAgIHJldHVybiAoKSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IHN1cHBvcnRzRmxhZ3Nbc3VwcG9ydHNGbGFnXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbWVtb2l6ZWQoKTsgfTtcbn1cblxuY29uc3Qgc3VwcG9ydHNMaW5lYXJFYXNpbmcgPSAvKkBfX1BVUkVfXyovIG1lbW9TdXBwb3J0cygoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgZG9jdW1lbnRcbiAgICAgICAgICAgIC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpXG4gICAgICAgICAgICAuYW5pbWF0ZSh7IG9wYWNpdHk6IDAgfSwgeyBlYXNpbmc6IFwibGluZWFyKDAsIDEpXCIgfSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59LCBcImxpbmVhckVhc2luZ1wiKTtcblxuZnVuY3Rpb24gaXNXYWFwaVN1cHBvcnRlZEVhc2luZyhlYXNpbmcpIHtcbiAgICByZXR1cm4gQm9vbGVhbigodHlwZW9mIGVhc2luZyA9PT0gXCJmdW5jdGlvblwiICYmIHN1cHBvcnRzTGluZWFyRWFzaW5nKCkpIHx8XG4gICAgICAgICFlYXNpbmcgfHxcbiAgICAgICAgKHR5cGVvZiBlYXNpbmcgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgIChlYXNpbmcgaW4gc3VwcG9ydGVkV2FhcGlFYXNpbmcgfHwgc3VwcG9ydHNMaW5lYXJFYXNpbmcoKSkpIHx8XG4gICAgICAgIGlzQmV6aWVyRGVmaW5pdGlvbihlYXNpbmcpIHx8XG4gICAgICAgIChBcnJheS5pc0FycmF5KGVhc2luZykgJiYgZWFzaW5nLmV2ZXJ5KGlzV2FhcGlTdXBwb3J0ZWRFYXNpbmcpKSk7XG59XG5jb25zdCBjdWJpY0JlemllckFzU3RyaW5nID0gKFthLCBiLCBjLCBkXSkgPT4gYGN1YmljLWJlemllcigke2F9LCAke2J9LCAke2N9LCAke2R9KWA7XG5jb25zdCBzdXBwb3J0ZWRXYWFwaUVhc2luZyA9IHtcbiAgICBsaW5lYXI6IFwibGluZWFyXCIsXG4gICAgZWFzZTogXCJlYXNlXCIsXG4gICAgZWFzZUluOiBcImVhc2UtaW5cIixcbiAgICBlYXNlT3V0OiBcImVhc2Utb3V0XCIsXG4gICAgZWFzZUluT3V0OiBcImVhc2UtaW4tb3V0XCIsXG4gICAgY2lyY0luOiAvKkBfX1BVUkVfXyovIGN1YmljQmV6aWVyQXNTdHJpbmcoWzAsIDAuNjUsIDAuNTUsIDFdKSxcbiAgICBjaXJjT3V0OiAvKkBfX1BVUkVfXyovIGN1YmljQmV6aWVyQXNTdHJpbmcoWzAuNTUsIDAsIDEsIDAuNDVdKSxcbiAgICBiYWNrSW46IC8qQF9fUFVSRV9fKi8gY3ViaWNCZXppZXJBc1N0cmluZyhbMC4zMSwgMC4wMSwgMC42NiwgLTAuNTldKSxcbiAgICBiYWNrT3V0OiAvKkBfX1BVUkVfXyovIGN1YmljQmV6aWVyQXNTdHJpbmcoWzAuMzMsIDEuNTMsIDAuNjksIDAuOTldKSxcbn07XG5mdW5jdGlvbiBtYXBFYXNpbmdUb05hdGl2ZUVhc2luZyhlYXNpbmcsIGR1cmF0aW9uKSB7XG4gICAgaWYgKCFlYXNpbmcpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGVhc2luZyA9PT0gXCJmdW5jdGlvblwiICYmIHN1cHBvcnRzTGluZWFyRWFzaW5nKCkpIHtcbiAgICAgICAgcmV0dXJuIGdlbmVyYXRlTGluZWFyRWFzaW5nKGVhc2luZywgZHVyYXRpb24pO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0JlemllckRlZmluaXRpb24oZWFzaW5nKSkge1xuICAgICAgICByZXR1cm4gY3ViaWNCZXppZXJBc1N0cmluZyhlYXNpbmcpO1xuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGVhc2luZykpIHtcbiAgICAgICAgcmV0dXJuIGVhc2luZy5tYXAoKHNlZ21lbnRFYXNpbmcpID0+IG1hcEVhc2luZ1RvTmF0aXZlRWFzaW5nKHNlZ21lbnRFYXNpbmcsIGR1cmF0aW9uKSB8fFxuICAgICAgICAgICAgc3VwcG9ydGVkV2FhcGlFYXNpbmcuZWFzZU91dCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gc3VwcG9ydGVkV2FhcGlFYXNpbmdbZWFzaW5nXTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0V2FhcGlBbmltYXRpb24oZWxlbWVudCwgdmFsdWVOYW1lLCBrZXlmcmFtZXMsIHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDMwMCwgcmVwZWF0ID0gMCwgcmVwZWF0VHlwZSA9IFwibG9vcFwiLCBlYXNlID0gXCJlYXNlSW5PdXRcIiwgdGltZXMsIH0gPSB7fSkge1xuICAgIGNvbnN0IGtleWZyYW1lT3B0aW9ucyA9IHsgW3ZhbHVlTmFtZV06IGtleWZyYW1lcyB9O1xuICAgIGlmICh0aW1lcylcbiAgICAgICAga2V5ZnJhbWVPcHRpb25zLm9mZnNldCA9IHRpbWVzO1xuICAgIGNvbnN0IGVhc2luZyA9IG1hcEVhc2luZ1RvTmF0aXZlRWFzaW5nKGVhc2UsIGR1cmF0aW9uKTtcbiAgICAvKipcbiAgICAgKiBJZiB0aGlzIGlzIGFuIGVhc2luZyBhcnJheSwgYXBwbHkgdG8ga2V5ZnJhbWVzLCBub3QgYW5pbWF0aW9uIGFzIGEgd2hvbGVcbiAgICAgKi9cbiAgICBpZiAoQXJyYXkuaXNBcnJheShlYXNpbmcpKVxuICAgICAgICBrZXlmcmFtZU9wdGlvbnMuZWFzaW5nID0gZWFzaW5nO1xuICAgIHJldHVybiBlbGVtZW50LmFuaW1hdGUoa2V5ZnJhbWVPcHRpb25zLCB7XG4gICAgICAgIGRlbGF5LFxuICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgZWFzaW5nOiAhQXJyYXkuaXNBcnJheShlYXNpbmcpID8gZWFzaW5nIDogXCJsaW5lYXJcIixcbiAgICAgICAgZmlsbDogXCJib3RoXCIsXG4gICAgICAgIGl0ZXJhdGlvbnM6IHJlcGVhdCArIDEsXG4gICAgICAgIGRpcmVjdGlvbjogcmVwZWF0VHlwZSA9PT0gXCJyZXZlcnNlXCIgPyBcImFsdGVybmF0ZVwiIDogXCJub3JtYWxcIixcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gYXR0YWNoVGltZWxpbmUoYW5pbWF0aW9uLCB0aW1lbGluZSkge1xuICAgIGFuaW1hdGlvbi50aW1lbGluZSA9IHRpbWVsaW5lO1xuICAgIGFuaW1hdGlvbi5vbmZpbmlzaCA9IG51bGw7XG59XG5cbmNvbnN0IHN1cHBvcnRzV2FhcGkgPSAvKkBfX1BVUkVfXyovIG1lbW8oKCkgPT4gT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoRWxlbWVudC5wcm90b3R5cGUsIFwiYW5pbWF0ZVwiKSk7XG5cbi8qKlxuICogMTBtcyBpcyBjaG9zZW4gaGVyZSBhcyBpdCBzdHJpa2VzIGEgYmFsYW5jZSBiZXR3ZWVuIHNtb290aFxuICogcmVzdWx0cyAobW9yZSB0aGFuIG9uZSBrZXlmcmFtZSBwZXIgZnJhbWUgYXQgNjBmcHMpIGFuZFxuICoga2V5ZnJhbWUgcXVhbnRpdHkuXG4gKi9cbmNvbnN0IHNhbXBsZURlbHRhID0gMTA7IC8vbXNcbi8qKlxuICogSW1wbGVtZW50IGEgcHJhY3RpY2FsIG1heCBkdXJhdGlvbiBmb3Iga2V5ZnJhbWUgZ2VuZXJhdGlvblxuICogdG8gcHJldmVudCBpbmZpbml0ZSBsb29wc1xuICovXG5jb25zdCBtYXhEdXJhdGlvbiA9IDIwMDAwO1xuLyoqXG4gKiBDaGVjayBpZiBhbiBhbmltYXRpb24gY2FuIHJ1biBuYXRpdmVseSB2aWEgV0FBUEkgb3IgcmVxdWlyZXMgcHJlZ2VuZXJhdGVkIGtleWZyYW1lcy5cbiAqIFdBQVBJIGRvZXNuJ3Qgc3VwcG9ydCBzcHJpbmcgb3IgZnVuY3Rpb24gZWFzaW5ncyBzbyB3ZSBydW4gdGhlc2UgYXMgSlMgYW5pbWF0aW9uIGJlZm9yZVxuICogaGFuZGluZyBvZmYuXG4gKi9cbmZ1bmN0aW9uIHJlcXVpcmVzUHJlZ2VuZXJhdGVkS2V5ZnJhbWVzKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKGlzR2VuZXJhdG9yKG9wdGlvbnMudHlwZSkgfHxcbiAgICAgICAgb3B0aW9ucy50eXBlID09PSBcInNwcmluZ1wiIHx8XG4gICAgICAgICFpc1dhYXBpU3VwcG9ydGVkRWFzaW5nKG9wdGlvbnMuZWFzZSkpO1xufVxuZnVuY3Rpb24gcHJlZ2VuZXJhdGVLZXlmcmFtZXMoa2V5ZnJhbWVzLCBvcHRpb25zKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbWFpbi10aHJlYWQgYW5pbWF0aW9uIHRvIHByZWdlbmVyYXRlIGtleWZyYW1lcy5cbiAgICAgKiBXZSBzYW1wbGUgdGhpcyBhdCByZWd1bGFyIGludGVydmFscyB0byBnZW5lcmF0ZSBrZXlmcmFtZXMgdGhhdCB3ZSB0aGVuXG4gICAgICogbGluZWFybHkgaW50ZXJwb2xhdGUgYmV0d2Vlbi5cbiAgICAgKi9cbiAgICBjb25zdCBzYW1wbGVBbmltYXRpb24gPSBuZXcgTWFpblRocmVhZEFuaW1hdGlvbih7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIGtleWZyYW1lcyxcbiAgICAgICAgcmVwZWF0OiAwLFxuICAgICAgICBkZWxheTogMCxcbiAgICAgICAgaXNHZW5lcmF0b3I6IHRydWUsXG4gICAgfSk7XG4gICAgbGV0IHN0YXRlID0geyBkb25lOiBmYWxzZSwgdmFsdWU6IGtleWZyYW1lc1swXSB9O1xuICAgIGNvbnN0IHByZWdlbmVyYXRlZEtleWZyYW1lcyA9IFtdO1xuICAgIC8qKlxuICAgICAqIEJhaWwgYWZ0ZXIgMjAgc2Vjb25kcyBvZiBwcmUtZ2VuZXJhdGVkIGtleWZyYW1lcyBhcyBpdCdzIGxpa2VseVxuICAgICAqIHdlJ3JlIGhlYWRpbmcgZm9yIGFuIGluZmluaXRlIGxvb3AuXG4gICAgICovXG4gICAgbGV0IHQgPSAwO1xuICAgIHdoaWxlICghc3RhdGUuZG9uZSAmJiB0IDwgbWF4RHVyYXRpb24pIHtcbiAgICAgICAgc3RhdGUgPSBzYW1wbGVBbmltYXRpb24uc2FtcGxlKHQpO1xuICAgICAgICBwcmVnZW5lcmF0ZWRLZXlmcmFtZXMucHVzaChzdGF0ZS52YWx1ZSk7XG4gICAgICAgIHQgKz0gc2FtcGxlRGVsdGE7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHRpbWVzOiB1bmRlZmluZWQsXG4gICAgICAgIGtleWZyYW1lczogcHJlZ2VuZXJhdGVkS2V5ZnJhbWVzLFxuICAgICAgICBkdXJhdGlvbjogdCAtIHNhbXBsZURlbHRhLFxuICAgICAgICBlYXNlOiBcImxpbmVhclwiLFxuICAgIH07XG59XG5jb25zdCB1bnN1cHBvcnRlZEVhc2luZ0Z1bmN0aW9ucyA9IHtcbiAgICBhbnRpY2lwYXRlLFxuICAgIGJhY2tJbk91dCxcbiAgICBjaXJjSW5PdXQsXG59O1xuZnVuY3Rpb24gaXNVbnN1cHBvcnRlZEVhc2Uoa2V5KSB7XG4gICAgcmV0dXJuIGtleSBpbiB1bnN1cHBvcnRlZEVhc2luZ0Z1bmN0aW9ucztcbn1cbmNsYXNzIEFjY2VsZXJhdGVkQW5pbWF0aW9uIGV4dGVuZHMgQmFzZUFuaW1hdGlvbiB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcbiAgICAgICAgY29uc3QgeyBuYW1lLCBtb3Rpb25WYWx1ZSwgZWxlbWVudCwga2V5ZnJhbWVzIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIHRoaXMucmVzb2x2ZXIgPSBuZXcgRE9NS2V5ZnJhbWVzUmVzb2x2ZXIoa2V5ZnJhbWVzLCAocmVzb2x2ZWRLZXlmcmFtZXMsIGZpbmFsS2V5ZnJhbWUpID0+IHRoaXMub25LZXlmcmFtZXNSZXNvbHZlZChyZXNvbHZlZEtleWZyYW1lcywgZmluYWxLZXlmcmFtZSksIG5hbWUsIG1vdGlvblZhbHVlLCBlbGVtZW50KTtcbiAgICAgICAgdGhpcy5yZXNvbHZlci5zY2hlZHVsZVJlc29sdmUoKTtcbiAgICB9XG4gICAgaW5pdFBsYXliYWNrKGtleWZyYW1lcywgZmluYWxLZXlmcmFtZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCB7IGR1cmF0aW9uID0gMzAwLCB0aW1lcywgZWFzZSwgdHlwZSwgbW90aW9uVmFsdWUsIG5hbWUsIHN0YXJ0VGltZSwgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGVsZW1lbnQgaGFzIHNpbmNlIGJlZW4gdW5tb3VudGVkLCByZXR1cm4gZmFsc2UgdG8gaW5kaWNhdGVcbiAgICAgICAgICogdGhlIGFuaW1hdGlvbiBmYWlsZWQgdG8gaW5pdGlhbGlzZWQuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoISgoX2EgPSBtb3Rpb25WYWx1ZS5vd25lcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmN1cnJlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZSB1c2VyIGhhcyBwcm92aWRlZCBhbiBlYXNpbmcgZnVuY3Rpb24gbmFtZSB0aGF0IGlzbid0IHN1cHBvcnRlZFxuICAgICAgICAgKiBieSBXQUFQSSAobGlrZSBcImFudGljaXBhdGVcIiksIHdlIG5lZWQgdG8gcHJvdmlkZSB0aGUgY29ycmVzc3BvbmRpbmdcbiAgICAgICAgICogZnVuY3Rpb24uIFRoaXMgd2lsbCBsYXRlciBnZXQgY29udmVydGVkIHRvIGEgbGluZWFyKCkgZWFzaW5nIGZ1bmN0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHR5cGVvZiBlYXNlID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICBzdXBwb3J0c0xpbmVhckVhc2luZygpICYmXG4gICAgICAgICAgICBpc1Vuc3VwcG9ydGVkRWFzZShlYXNlKSkge1xuICAgICAgICAgICAgZWFzZSA9IHVuc3VwcG9ydGVkRWFzaW5nRnVuY3Rpb25zW2Vhc2VdO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGlzIGFuaW1hdGlvbiBuZWVkcyBwcmUtZ2VuZXJhdGVkIGtleWZyYW1lcyB0aGVuIGdlbmVyYXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHJlcXVpcmVzUHJlZ2VuZXJhdGVkS2V5ZnJhbWVzKHRoaXMub3B0aW9ucykpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgb25Db21wbGV0ZSwgb25VcGRhdGUsIG1vdGlvblZhbHVlLCBlbGVtZW50LCAuLi5vcHRpb25zIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgICAgICBjb25zdCBwcmVnZW5lcmF0ZWRBbmltYXRpb24gPSBwcmVnZW5lcmF0ZUtleWZyYW1lcyhrZXlmcmFtZXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAga2V5ZnJhbWVzID0gcHJlZ2VuZXJhdGVkQW5pbWF0aW9uLmtleWZyYW1lcztcbiAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYSB2ZXJ5IHNob3J0IGFuaW1hdGlvbiwgZW5zdXJlIHdlIGhhdmVcbiAgICAgICAgICAgIC8vIGF0IGxlYXN0IHR3byBrZXlmcmFtZXMgdG8gYW5pbWF0ZSBiZXR3ZWVuIGFzIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgICAgICAvLyBjYW4ndCBhbmltYXRlIGJldHdlZW4gYSBzaW5nbGUga2V5ZnJhbWUuXG4gICAgICAgICAgICBpZiAoa2V5ZnJhbWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGtleWZyYW1lc1sxXSA9IGtleWZyYW1lc1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGR1cmF0aW9uID0gcHJlZ2VuZXJhdGVkQW5pbWF0aW9uLmR1cmF0aW9uO1xuICAgICAgICAgICAgdGltZXMgPSBwcmVnZW5lcmF0ZWRBbmltYXRpb24udGltZXM7XG4gICAgICAgICAgICBlYXNlID0gcHJlZ2VuZXJhdGVkQW5pbWF0aW9uLmVhc2U7XG4gICAgICAgICAgICB0eXBlID0gXCJrZXlmcmFtZXNcIjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhbmltYXRpb24gPSBzdGFydFdhYXBpQW5pbWF0aW9uKG1vdGlvblZhbHVlLm93bmVyLmN1cnJlbnQsIG5hbWUsIGtleWZyYW1lcywgeyAuLi50aGlzLm9wdGlvbnMsIGR1cmF0aW9uLCB0aW1lcywgZWFzZSB9KTtcbiAgICAgICAgLy8gT3ZlcnJpZGUgdGhlIGJyb3dzZXIgY2FsY3VsYXRlZCBzdGFydFRpbWUgd2l0aCBvbmUgc3luY2hyb25pc2VkIHRvIG90aGVyIEpTXG4gICAgICAgIC8vIGFuZCBXQUFQSSBhbmltYXRpb25zIHN0YXJ0aW5nIHRoaXMgZXZlbnQgbG9vcC5cbiAgICAgICAgYW5pbWF0aW9uLnN0YXJ0VGltZSA9IHN0YXJ0VGltZSAhPT0gbnVsbCAmJiBzdGFydFRpbWUgIT09IHZvaWQgMCA/IHN0YXJ0VGltZSA6IHRoaXMuY2FsY1N0YXJ0VGltZSgpO1xuICAgICAgICBpZiAodGhpcy5wZW5kaW5nVGltZWxpbmUpIHtcbiAgICAgICAgICAgIGF0dGFjaFRpbWVsaW5lKGFuaW1hdGlvbiwgdGhpcy5wZW5kaW5nVGltZWxpbmUpO1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nVGltZWxpbmUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFByZWZlciB0aGUgYG9uZmluaXNoYCBwcm9wIGFzIGl0J3MgbW9yZSB3aWRlbHkgc3VwcG9ydGVkIHRoYW5cbiAgICAgICAgICAgICAqIHRoZSBgZmluaXNoZWRgIHByb21pc2UuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogSGVyZSwgd2Ugc3luY2hyb25vdXNseSBzZXQgdGhlIHByb3ZpZGVkIE1vdGlvblZhbHVlIHRvIHRoZSBlbmRcbiAgICAgICAgICAgICAqIGtleWZyYW1lLiBJZiB3ZSBkaWRuJ3QsIHdoZW4gdGhlIFdBQVBJIGFuaW1hdGlvbiBpcyBmaW5pc2hlZCBpdCB3b3VsZFxuICAgICAgICAgICAgICogYmUgcmVtb3ZlZCBmcm9tIHRoZSBlbGVtZW50IHdoaWNoIHdvdWxkIHRoZW4gcmV2ZXJ0IHRvIGl0cyBvbGQgc3R5bGVzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBhbmltYXRpb24ub25maW5pc2ggPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBvbkNvbXBsZXRlIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgICAgICAgICAgbW90aW9uVmFsdWUuc2V0KGdldEZpbmFsS2V5ZnJhbWUoa2V5ZnJhbWVzLCB0aGlzLm9wdGlvbnMsIGZpbmFsS2V5ZnJhbWUpKTtcbiAgICAgICAgICAgICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZUZpbmlzaGVkUHJvbWlzZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYW5pbWF0aW9uLFxuICAgICAgICAgICAgZHVyYXRpb24sXG4gICAgICAgICAgICB0aW1lcyxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBlYXNlLFxuICAgICAgICAgICAga2V5ZnJhbWVzOiBrZXlmcmFtZXMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldCBkdXJhdGlvbigpIHtcbiAgICAgICAgY29uc3QgeyByZXNvbHZlZCB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFyZXNvbHZlZClcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBjb25zdCB7IGR1cmF0aW9uIH0gPSByZXNvbHZlZDtcbiAgICAgICAgcmV0dXJuIG1pbGxpc2Vjb25kc1RvU2Vjb25kcyhkdXJhdGlvbik7XG4gICAgfVxuICAgIGdldCB0aW1lKCkge1xuICAgICAgICBjb25zdCB7IHJlc29sdmVkIH0gPSB0aGlzO1xuICAgICAgICBpZiAoIXJlc29sdmVkKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGNvbnN0IHsgYW5pbWF0aW9uIH0gPSByZXNvbHZlZDtcbiAgICAgICAgcmV0dXJuIG1pbGxpc2Vjb25kc1RvU2Vjb25kcyhhbmltYXRpb24uY3VycmVudFRpbWUgfHwgMCk7XG4gICAgfVxuICAgIHNldCB0aW1lKG5ld1RpbWUpIHtcbiAgICAgICAgY29uc3QgeyByZXNvbHZlZCB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFyZXNvbHZlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgeyBhbmltYXRpb24gfSA9IHJlc29sdmVkO1xuICAgICAgICBhbmltYXRpb24uY3VycmVudFRpbWUgPSBzZWNvbmRzVG9NaWxsaXNlY29uZHMobmV3VGltZSk7XG4gICAgfVxuICAgIGdldCBzcGVlZCgpIHtcbiAgICAgICAgY29uc3QgeyByZXNvbHZlZCB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFyZXNvbHZlZClcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICBjb25zdCB7IGFuaW1hdGlvbiB9ID0gcmVzb2x2ZWQ7XG4gICAgICAgIHJldHVybiBhbmltYXRpb24ucGxheWJhY2tSYXRlO1xuICAgIH1cbiAgICBzZXQgc3BlZWQobmV3U3BlZWQpIHtcbiAgICAgICAgY29uc3QgeyByZXNvbHZlZCB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFyZXNvbHZlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgeyBhbmltYXRpb24gfSA9IHJlc29sdmVkO1xuICAgICAgICBhbmltYXRpb24ucGxheWJhY2tSYXRlID0gbmV3U3BlZWQ7XG4gICAgfVxuICAgIGdldCBzdGF0ZSgpIHtcbiAgICAgICAgY29uc3QgeyByZXNvbHZlZCB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFyZXNvbHZlZClcbiAgICAgICAgICAgIHJldHVybiBcImlkbGVcIjtcbiAgICAgICAgY29uc3QgeyBhbmltYXRpb24gfSA9IHJlc29sdmVkO1xuICAgICAgICByZXR1cm4gYW5pbWF0aW9uLnBsYXlTdGF0ZTtcbiAgICB9XG4gICAgZ2V0IHN0YXJ0VGltZSgpIHtcbiAgICAgICAgY29uc3QgeyByZXNvbHZlZCB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFyZXNvbHZlZClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjb25zdCB7IGFuaW1hdGlvbiB9ID0gcmVzb2x2ZWQ7XG4gICAgICAgIC8vIENvZXJjZSB0byBudW1iZXIgYXMgVHlwZVNjcmlwdCBpbmNvcnJlY3RseSB0eXBlcyB0aGlzXG4gICAgICAgIC8vIGFzIENTU051bWJlcmlzaFxuICAgICAgICByZXR1cm4gYW5pbWF0aW9uLnN0YXJ0VGltZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVwbGFjZSB0aGUgZGVmYXVsdCBEb2N1bWVudFRpbWVsaW5lIHdpdGggYW5vdGhlciBBbmltYXRpb25UaW1lbGluZS5cbiAgICAgKiBDdXJyZW50bHkgdXNlZCBmb3Igc2Nyb2xsIGFuaW1hdGlvbnMuXG4gICAgICovXG4gICAgYXR0YWNoVGltZWxpbmUodGltZWxpbmUpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9yZXNvbHZlZCkge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nVGltZWxpbmUgPSB0aW1lbGluZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcmVzb2x2ZWQgfSA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoIXJlc29sdmVkKVxuICAgICAgICAgICAgICAgIHJldHVybiBtb3Rpb25VdGlscy5ub29wO1xuICAgICAgICAgICAgY29uc3QgeyBhbmltYXRpb24gfSA9IHJlc29sdmVkO1xuICAgICAgICAgICAgYXR0YWNoVGltZWxpbmUoYW5pbWF0aW9uLCB0aW1lbGluZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vdGlvblV0aWxzLm5vb3A7XG4gICAgfVxuICAgIHBsYXkoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzU3RvcHBlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgeyByZXNvbHZlZCB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFyZXNvbHZlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgeyBhbmltYXRpb24gfSA9IHJlc29sdmVkO1xuICAgICAgICBpZiAoYW5pbWF0aW9uLnBsYXlTdGF0ZSA9PT0gXCJmaW5pc2hlZFwiKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUZpbmlzaGVkUHJvbWlzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGFuaW1hdGlvbi5wbGF5KCk7XG4gICAgfVxuICAgIHBhdXNlKCkge1xuICAgICAgICBjb25zdCB7IHJlc29sdmVkIH0gPSB0aGlzO1xuICAgICAgICBpZiAoIXJlc29sdmVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB7IGFuaW1hdGlvbiB9ID0gcmVzb2x2ZWQ7XG4gICAgICAgIGFuaW1hdGlvbi5wYXVzZSgpO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICB0aGlzLnJlc29sdmVyLmNhbmNlbCgpO1xuICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBcImlkbGVcIilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5yZXNvbHZlRmluaXNoZWRQcm9taXNlKCk7XG4gICAgICAgIHRoaXMudXBkYXRlRmluaXNoZWRQcm9taXNlKCk7XG4gICAgICAgIGNvbnN0IHsgcmVzb2x2ZWQgfSA9IHRoaXM7XG4gICAgICAgIGlmICghcmVzb2x2ZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHsgYW5pbWF0aW9uLCBrZXlmcmFtZXMsIGR1cmF0aW9uLCB0eXBlLCBlYXNlLCB0aW1lcyB9ID0gcmVzb2x2ZWQ7XG4gICAgICAgIGlmIChhbmltYXRpb24ucGxheVN0YXRlID09PSBcImlkbGVcIiB8fFxuICAgICAgICAgICAgYW5pbWF0aW9uLnBsYXlTdGF0ZSA9PT0gXCJmaW5pc2hlZFwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdBQVBJIGRvZXNuJ3QgbmF0aXZlbHkgaGF2ZSBhbnkgaW50ZXJydXB0aW9uIGNhcGFiaWxpdGllcy5cbiAgICAgICAgICpcbiAgICAgICAgICogUmF0aGVyIHRoYW4gcmVhZCBjb21taXRlZCBzdHlsZXMgYmFjayBvdXQgb2YgdGhlIERPTSwgd2UgY2FuXG4gICAgICAgICAqIGNyZWF0ZSBhIHJlbmRlcmxlc3MgSlMgYW5pbWF0aW9uIGFuZCBzYW1wbGUgaXQgdHdpY2UgdG8gY2FsY3VsYXRlXG4gICAgICAgICAqIGl0cyBjdXJyZW50IHZhbHVlLCBcInByZXZpb3VzXCIgdmFsdWUsIGFuZCB0aGVyZWZvcmUgYWxsb3dcbiAgICAgICAgICogTW90aW9uIHRvIGNhbGN1bGF0ZSB2ZWxvY2l0eSBmb3IgYW55IHN1YnNlcXVlbnQgYW5pbWF0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHRoaXMudGltZSkge1xuICAgICAgICAgICAgY29uc3QgeyBtb3Rpb25WYWx1ZSwgb25VcGRhdGUsIG9uQ29tcGxldGUsIGVsZW1lbnQsIC4uLm9wdGlvbnMgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IHNhbXBsZUFuaW1hdGlvbiA9IG5ldyBNYWluVGhyZWFkQW5pbWF0aW9uKHtcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgICAgIGtleWZyYW1lcyxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgIGVhc2UsXG4gICAgICAgICAgICAgICAgdGltZXMsXG4gICAgICAgICAgICAgICAgaXNHZW5lcmF0b3I6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHNhbXBsZVRpbWUgPSBzZWNvbmRzVG9NaWxsaXNlY29uZHModGhpcy50aW1lKTtcbiAgICAgICAgICAgIG1vdGlvblZhbHVlLnNldFdpdGhWZWxvY2l0eShzYW1wbGVBbmltYXRpb24uc2FtcGxlKHNhbXBsZVRpbWUgLSBzYW1wbGVEZWx0YSkudmFsdWUsIHNhbXBsZUFuaW1hdGlvbi5zYW1wbGUoc2FtcGxlVGltZSkudmFsdWUsIHNhbXBsZURlbHRhKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IG9uU3RvcCB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBvblN0b3AgJiYgb25TdG9wKCk7XG4gICAgICAgIHRoaXMuY2FuY2VsKCk7XG4gICAgfVxuICAgIGNvbXBsZXRlKCkge1xuICAgICAgICBjb25zdCB7IHJlc29sdmVkIH0gPSB0aGlzO1xuICAgICAgICBpZiAoIXJlc29sdmVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICByZXNvbHZlZC5hbmltYXRpb24uZmluaXNoKCk7XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgY29uc3QgeyByZXNvbHZlZCB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFyZXNvbHZlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmVzb2x2ZWQuYW5pbWF0aW9uLmNhbmNlbCgpO1xuICAgIH1cbiAgICBzdGF0aWMgc3VwcG9ydHMob3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IG1vdGlvblZhbHVlLCBuYW1lLCByZXBlYXREZWxheSwgcmVwZWF0VHlwZSwgZGFtcGluZywgdHlwZSB9ID0gb3B0aW9ucztcbiAgICAgICAgcmV0dXJuIChzdXBwb3J0c1dhYXBpKCkgJiZcbiAgICAgICAgICAgIG5hbWUgJiZcbiAgICAgICAgICAgIGFjY2VsZXJhdGVkVmFsdWVzLmhhcyhuYW1lKSAmJlxuICAgICAgICAgICAgbW90aW9uVmFsdWUgJiZcbiAgICAgICAgICAgIG1vdGlvblZhbHVlLm93bmVyICYmXG4gICAgICAgICAgICBtb3Rpb25WYWx1ZS5vd25lci5jdXJyZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiZcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgd2UncmUgb3V0cHV0dGluZyB2YWx1ZXMgdG8gb25VcGRhdGUgdGhlbiB3ZSBjYW4ndCB1c2UgV0FBUEkgYXMgdGhlcmUnc1xuICAgICAgICAgICAgICogbm8gd2F5IHRvIHJlYWQgdGhlIHZhbHVlIGZyb20gV0FBUEkgZXZlcnkgZnJhbWUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICFtb3Rpb25WYWx1ZS5vd25lci5nZXRQcm9wcygpLm9uVXBkYXRlICYmXG4gICAgICAgICAgICAhcmVwZWF0RGVsYXkgJiZcbiAgICAgICAgICAgIHJlcGVhdFR5cGUgIT09IFwibWlycm9yXCIgJiZcbiAgICAgICAgICAgIGRhbXBpbmcgIT09IDAgJiZcbiAgICAgICAgICAgIHR5cGUgIT09IFwiaW5lcnRpYVwiKTtcbiAgICB9XG59XG5cbmNvbnN0IHN1cHBvcnRzU2Nyb2xsVGltZWxpbmUgPSBtZW1vKCgpID0+IHdpbmRvdy5TY3JvbGxUaW1lbGluZSAhPT0gdW5kZWZpbmVkKTtcblxuY2xhc3MgR3JvdXBQbGF5YmFja0NvbnRyb2xzIHtcbiAgICBjb25zdHJ1Y3RvcihhbmltYXRpb25zKSB7XG4gICAgICAgIC8vIEJvdW5kIHRvIGFjY29tb2RhdGUgY29tbW9uIGByZXR1cm4gYW5pbWF0aW9uLnN0b3BgIHBhdHRlcm5cbiAgICAgICAgdGhpcy5zdG9wID0gKCkgPT4gdGhpcy5ydW5BbGwoXCJzdG9wXCIpO1xuICAgICAgICB0aGlzLmFuaW1hdGlvbnMgPSBhbmltYXRpb25zLmZpbHRlcihCb29sZWFuKTtcbiAgICB9XG4gICAgdGhlbihvblJlc29sdmUsIG9uUmVqZWN0KSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbCh0aGlzLmFuaW1hdGlvbnMpLnRoZW4ob25SZXNvbHZlKS5jYXRjaChvblJlamVjdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRPRE86IEZpbHRlciBvdXQgY2FuY2VsbGVkIG9yIHN0b3BwZWQgYW5pbWF0aW9ucyBiZWZvcmUgcmV0dXJuaW5nXG4gICAgICovXG4gICAgZ2V0QWxsKHByb3BOYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFuaW1hdGlvbnNbMF1bcHJvcE5hbWVdO1xuICAgIH1cbiAgICBzZXRBbGwocHJvcE5hbWUsIG5ld1ZhbHVlKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5hbmltYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbnNbaV1bcHJvcE5hbWVdID0gbmV3VmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXR0YWNoVGltZWxpbmUodGltZWxpbmUsIGZhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbnMgPSB0aGlzLmFuaW1hdGlvbnMubWFwKChhbmltYXRpb24pID0+IHtcbiAgICAgICAgICAgIGlmIChzdXBwb3J0c1Njcm9sbFRpbWVsaW5lKCkgJiYgYW5pbWF0aW9uLmF0dGFjaFRpbWVsaW5lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFuaW1hdGlvbi5hdHRhY2hUaW1lbGluZSh0aW1lbGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsbGJhY2soYW5pbWF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb25zLmZvckVhY2goKGNhbmNlbCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGNhbmNlbCAmJiBjYW5jZWwoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGlvbnNbaV0uc3RvcCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldCB0aW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRBbGwoXCJ0aW1lXCIpO1xuICAgIH1cbiAgICBzZXQgdGltZSh0aW1lKSB7XG4gICAgICAgIHRoaXMuc2V0QWxsKFwidGltZVwiLCB0aW1lKTtcbiAgICB9XG4gICAgZ2V0IHNwZWVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRBbGwoXCJzcGVlZFwiKTtcbiAgICB9XG4gICAgc2V0IHNwZWVkKHNwZWVkKSB7XG4gICAgICAgIHRoaXMuc2V0QWxsKFwic3BlZWRcIiwgc3BlZWQpO1xuICAgIH1cbiAgICBnZXQgc3RhcnRUaW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRBbGwoXCJzdGFydFRpbWVcIik7XG4gICAgfVxuICAgIGdldCBkdXJhdGlvbigpIHtcbiAgICAgICAgbGV0IG1heCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5hbmltYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIHRoaXMuYW5pbWF0aW9uc1tpXS5kdXJhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9XG4gICAgcnVuQWxsKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgdGhpcy5hbmltYXRpb25zLmZvckVhY2goKGNvbnRyb2xzKSA9PiBjb250cm9sc1ttZXRob2ROYW1lXSgpKTtcbiAgICB9XG4gICAgZmxhdHRlbigpIHtcbiAgICAgICAgdGhpcy5ydW5BbGwoXCJmbGF0dGVuXCIpO1xuICAgIH1cbiAgICBwbGF5KCkge1xuICAgICAgICB0aGlzLnJ1bkFsbChcInBsYXlcIik7XG4gICAgfVxuICAgIHBhdXNlKCkge1xuICAgICAgICB0aGlzLnJ1bkFsbChcInBhdXNlXCIpO1xuICAgIH1cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIHRoaXMucnVuQWxsKFwiY2FuY2VsXCIpO1xuICAgIH1cbiAgICBjb21wbGV0ZSgpIHtcbiAgICAgICAgdGhpcy5ydW5BbGwoXCJjb21wbGV0ZVwiKTtcbiAgICB9XG59XG5cbi8qKlxuICogRGVjaWRlIHdoZXRoZXIgYSB0cmFuc2l0aW9uIGlzIGRlZmluZWQgb24gYSBnaXZlbiBUcmFuc2l0aW9uLlxuICogVGhpcyBmaWx0ZXJzIG91dCBvcmNoZXN0cmF0aW9uIG9wdGlvbnMgYW5kIHJldHVybnMgdHJ1ZVxuICogaWYgYW55IG9wdGlvbnMgYXJlIGxlZnQuXG4gKi9cbmZ1bmN0aW9uIGlzVHJhbnNpdGlvbkRlZmluZWQoeyB3aGVuLCBkZWxheTogX2RlbGF5LCBkZWxheUNoaWxkcmVuLCBzdGFnZ2VyQ2hpbGRyZW4sIHN0YWdnZXJEaXJlY3Rpb24sIHJlcGVhdCwgcmVwZWF0VHlwZSwgcmVwZWF0RGVsYXksIGZyb20sIGVsYXBzZWQsIC4uLnRyYW5zaXRpb24gfSkge1xuICAgIHJldHVybiAhIU9iamVjdC5rZXlzKHRyYW5zaXRpb24pLmxlbmd0aDtcbn1cblxuY29uc3QgYW5pbWF0ZU1vdGlvblZhbHVlID0gKG5hbWUsIHZhbHVlLCB0YXJnZXQsIHRyYW5zaXRpb24gPSB7fSwgZWxlbWVudCwgaXNIYW5kb2ZmKSA9PiAob25Db21wbGV0ZSkgPT4ge1xuICAgIGNvbnN0IHZhbHVlVHJhbnNpdGlvbiA9IGdldFZhbHVlVHJhbnNpdGlvbiQxKHRyYW5zaXRpb24sIG5hbWUpIHx8IHt9O1xuICAgIC8qKlxuICAgICAqIE1vc3QgdHJhbnNpdGlvbiB2YWx1ZXMgYXJlIGN1cnJlbnRseSBjb21wbGV0ZWx5IG92ZXJ3cml0dGVuIGJ5IHZhbHVlLXNwZWNpZmljXG4gICAgICogdHJhbnNpdGlvbnMuIEluIHRoZSBmdXR1cmUgaXQnZCBiZSBuaWNlciB0byBibGVuZCB0aGVzZSB0cmFuc2l0aW9ucy4gQnV0IGZvciBub3dcbiAgICAgKiBkZWxheSBhY3R1YWxseSBkb2VzIGluaGVyaXQgZnJvbSB0aGUgcm9vdCB0cmFuc2l0aW9uIGlmIG5vdCB2YWx1ZS1zcGVjaWZpYy5cbiAgICAgKi9cbiAgICBjb25zdCBkZWxheSA9IHZhbHVlVHJhbnNpdGlvbi5kZWxheSB8fCB0cmFuc2l0aW9uLmRlbGF5IHx8IDA7XG4gICAgLyoqXG4gICAgICogRWxhcHNlZCBpc24ndCBhIHB1YmxpYyB0cmFuc2l0aW9uIG9wdGlvbiBidXQgY2FuIGJlIHBhc3NlZCB0aHJvdWdoIGZyb21cbiAgICAgKiBvcHRpbWl6ZWQgYXBwZWFyIGVmZmVjdHMgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqL1xuICAgIGxldCB7IGVsYXBzZWQgPSAwIH0gPSB0cmFuc2l0aW9uO1xuICAgIGVsYXBzZWQgPSBlbGFwc2VkIC0gc2Vjb25kc1RvTWlsbGlzZWNvbmRzKGRlbGF5KTtcbiAgICBsZXQgb3B0aW9ucyA9IHtcbiAgICAgICAga2V5ZnJhbWVzOiBBcnJheS5pc0FycmF5KHRhcmdldCkgPyB0YXJnZXQgOiBbbnVsbCwgdGFyZ2V0XSxcbiAgICAgICAgZWFzZTogXCJlYXNlT3V0XCIsXG4gICAgICAgIHZlbG9jaXR5OiB2YWx1ZS5nZXRWZWxvY2l0eSgpLFxuICAgICAgICAuLi52YWx1ZVRyYW5zaXRpb24sXG4gICAgICAgIGRlbGF5OiAtZWxhcHNlZCxcbiAgICAgICAgb25VcGRhdGU6ICh2KSA9PiB7XG4gICAgICAgICAgICB2YWx1ZS5zZXQodik7XG4gICAgICAgICAgICB2YWx1ZVRyYW5zaXRpb24ub25VcGRhdGUgJiYgdmFsdWVUcmFuc2l0aW9uLm9uVXBkYXRlKHYpO1xuICAgICAgICB9LFxuICAgICAgICBvbkNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgICAgICBvbkNvbXBsZXRlKCk7XG4gICAgICAgICAgICB2YWx1ZVRyYW5zaXRpb24ub25Db21wbGV0ZSAmJiB2YWx1ZVRyYW5zaXRpb24ub25Db21wbGV0ZSgpO1xuICAgICAgICB9LFxuICAgICAgICBuYW1lLFxuICAgICAgICBtb3Rpb25WYWx1ZTogdmFsdWUsXG4gICAgICAgIGVsZW1lbnQ6IGlzSGFuZG9mZiA/IHVuZGVmaW5lZCA6IGVsZW1lbnQsXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJZiB0aGVyZSdzIG5vIHRyYW5zaXRpb24gZGVmaW5lZCBmb3IgdGhpcyB2YWx1ZSwgd2UgY2FuIGdlbmVyYXRlXG4gICAgICogdW5xaXVlIHRyYW5zaXRpb24gc2V0dGluZ3MgZm9yIHRoaXMgdmFsdWUuXG4gICAgICovXG4gICAgaWYgKCFpc1RyYW5zaXRpb25EZWZpbmVkKHZhbHVlVHJhbnNpdGlvbikpIHtcbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAuLi5nZXREZWZhdWx0VHJhbnNpdGlvbihuYW1lLCBvcHRpb25zKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQm90aCBXQUFQSSBhbmQgb3VyIGludGVybmFsIGFuaW1hdGlvbiBmdW5jdGlvbnMgdXNlIGR1cmF0aW9uc1xuICAgICAqIGFzIGRlZmluZWQgYnkgbWlsbGlzZWNvbmRzLCB3aGlsZSBvdXIgZXh0ZXJuYWwgQVBJIGRlZmluZXMgdGhlbVxuICAgICAqIGFzIHNlY29uZHMuXG4gICAgICovXG4gICAgaWYgKG9wdGlvbnMuZHVyYXRpb24pIHtcbiAgICAgICAgb3B0aW9ucy5kdXJhdGlvbiA9IHNlY29uZHNUb01pbGxpc2Vjb25kcyhvcHRpb25zLmR1cmF0aW9uKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucmVwZWF0RGVsYXkpIHtcbiAgICAgICAgb3B0aW9ucy5yZXBlYXREZWxheSA9IHNlY29uZHNUb01pbGxpc2Vjb25kcyhvcHRpb25zLnJlcGVhdERlbGF5KTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZnJvbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdGlvbnMua2V5ZnJhbWVzWzBdID0gb3B0aW9ucy5mcm9tO1xuICAgIH1cbiAgICBsZXQgc2hvdWxkU2tpcCA9IGZhbHNlO1xuICAgIGlmIChvcHRpb25zLnR5cGUgPT09IGZhbHNlIHx8XG4gICAgICAgIChvcHRpb25zLmR1cmF0aW9uID09PSAwICYmICFvcHRpb25zLnJlcGVhdERlbGF5KSkge1xuICAgICAgICBvcHRpb25zLmR1cmF0aW9uID0gMDtcbiAgICAgICAgaWYgKG9wdGlvbnMuZGVsYXkgPT09IDApIHtcbiAgICAgICAgICAgIHNob3VsZFNraXAgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpbnN0YW50QW5pbWF0aW9uU3RhdGUuY3VycmVudCB8fFxuICAgICAgICBNb3Rpb25HbG9iYWxDb25maWcuc2tpcEFuaW1hdGlvbnMpIHtcbiAgICAgICAgc2hvdWxkU2tpcCA9IHRydWU7XG4gICAgICAgIG9wdGlvbnMuZHVyYXRpb24gPSAwO1xuICAgICAgICBvcHRpb25zLmRlbGF5ID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgd2UgY2FuIG9yIG11c3Qgc2tpcCBjcmVhdGluZyB0aGUgYW5pbWF0aW9uLCBhbmQgYXBwbHkgb25seVxuICAgICAqIHRoZSBmaW5hbCBrZXlmcmFtZSwgZG8gc28uIFdlIGFsc28gY2hlY2sgb25jZSBrZXlmcmFtZXMgYXJlIHJlc29sdmVkIGJ1dFxuICAgICAqIHRoaXMgZWFybHkgY2hlY2sgcHJldmVudHMgdGhlIG5lZWQgdG8gY3JlYXRlIGFuIGFuaW1hdGlvbiBhdCBhbGwuXG4gICAgICovXG4gICAgaWYgKHNob3VsZFNraXAgJiYgIWlzSGFuZG9mZiAmJiB2YWx1ZS5nZXQoKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGZpbmFsS2V5ZnJhbWUgPSBnZXRGaW5hbEtleWZyYW1lKG9wdGlvbnMua2V5ZnJhbWVzLCB2YWx1ZVRyYW5zaXRpb24pO1xuICAgICAgICBpZiAoZmluYWxLZXlmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmcmFtZS51cGRhdGUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMub25VcGRhdGUoZmluYWxLZXlmcmFtZSk7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5vbkNvbXBsZXRlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFdlIHN0aWxsIHdhbnQgdG8gcmV0dXJuIHNvbWUgYW5pbWF0aW9uIGNvbnRyb2xzIGhlcmUgcmF0aGVyXG4gICAgICAgICAgICAvLyB0aGFuIHJldHVybmluZyB1bmRlZmluZWRcbiAgICAgICAgICAgIHJldHVybiBuZXcgR3JvdXBQbGF5YmFja0NvbnRyb2xzKFtdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbmltYXRlIHZpYSBXQUFQSSBpZiBwb3NzaWJsZS4gSWYgdGhpcyBpcyBhIGhhbmRvZmYgYW5pbWF0aW9uLCB0aGUgb3B0aW1pc2VkIGFuaW1hdGlvbiB3aWxsIGJlIHJ1bm5pbmcgdmlhXG4gICAgICogV0FBUEkuIFRoZXJlZm9yZSwgdGhpcyBhbmltYXRpb24gbXVzdCBiZSBKUyB0byBlbnN1cmUgaXQgcnVucyBcInVuZGVyXCIgdGhlXG4gICAgICogb3B0aW1pc2VkIGFuaW1hdGlvbi5cbiAgICAgKi9cbiAgICBpZiAoIWlzSGFuZG9mZiAmJiBBY2NlbGVyYXRlZEFuaW1hdGlvbi5zdXBwb3J0cyhvcHRpb25zKSkge1xuICAgICAgICByZXR1cm4gbmV3IEFjY2VsZXJhdGVkQW5pbWF0aW9uKG9wdGlvbnMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYWluVGhyZWFkQW5pbWF0aW9uKG9wdGlvbnMpO1xuICAgIH1cbn07XG5cbmNvbnN0IGlzQ3VzdG9tVmFsdWUgPSAodikgPT4ge1xuICAgIHJldHVybiBCb29sZWFuKHYgJiYgdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdi5taXggJiYgdi50b1ZhbHVlKTtcbn07XG5jb25zdCByZXNvbHZlRmluYWxWYWx1ZUluS2V5ZnJhbWVzID0gKHYpID0+IHtcbiAgICAvLyBUT0RPIG1heWJlIHRocm93IGlmIHYubGVuZ3RoIC0gMSBpcyBwbGFjZWhvbGRlciB0b2tlbj9cbiAgICByZXR1cm4gaXNLZXlmcmFtZXNUYXJnZXQodikgPyB2W3YubGVuZ3RoIC0gMV0gfHwgMCA6IHY7XG59O1xuXG5mdW5jdGlvbiBhZGRVbmlxdWVJdGVtKGFyciwgaXRlbSkge1xuICAgIGlmIChhcnIuaW5kZXhPZihpdGVtKSA9PT0gLTEpXG4gICAgICAgIGFyci5wdXNoKGl0ZW0pO1xufVxuZnVuY3Rpb24gcmVtb3ZlSXRlbShhcnIsIGl0ZW0pIHtcbiAgICBjb25zdCBpbmRleCA9IGFyci5pbmRleE9mKGl0ZW0pO1xuICAgIGlmIChpbmRleCA+IC0xKVxuICAgICAgICBhcnIuc3BsaWNlKGluZGV4LCAxKTtcbn1cbi8vIEFkYXB0ZWQgZnJvbSBhcnJheS1tb3ZlXG5mdW5jdGlvbiBtb3ZlSXRlbShbLi4uYXJyXSwgZnJvbUluZGV4LCB0b0luZGV4KSB7XG4gICAgY29uc3Qgc3RhcnRJbmRleCA9IGZyb21JbmRleCA8IDAgPyBhcnIubGVuZ3RoICsgZnJvbUluZGV4IDogZnJvbUluZGV4O1xuICAgIGlmIChzdGFydEluZGV4ID49IDAgJiYgc3RhcnRJbmRleCA8IGFyci5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgZW5kSW5kZXggPSB0b0luZGV4IDwgMCA/IGFyci5sZW5ndGggKyB0b0luZGV4IDogdG9JbmRleDtcbiAgICAgICAgY29uc3QgW2l0ZW1dID0gYXJyLnNwbGljZShmcm9tSW5kZXgsIDEpO1xuICAgICAgICBhcnIuc3BsaWNlKGVuZEluZGV4LCAwLCBpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn1cblxuY2xhc3MgU3Vic2NyaXB0aW9uTWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IFtdO1xuICAgIH1cbiAgICBhZGQoaGFuZGxlcikge1xuICAgICAgICBhZGRVbmlxdWVJdGVtKHRoaXMuc3Vic2NyaXB0aW9ucywgaGFuZGxlcik7XG4gICAgICAgIHJldHVybiAoKSA9PiByZW1vdmVJdGVtKHRoaXMuc3Vic2NyaXB0aW9ucywgaGFuZGxlcik7XG4gICAgfVxuICAgIG5vdGlmeShhLCBiLCBjKSB7XG4gICAgICAgIGNvbnN0IG51bVN1YnNjcmlwdGlvbnMgPSB0aGlzLnN1YnNjcmlwdGlvbnMubGVuZ3RoO1xuICAgICAgICBpZiAoIW51bVN1YnNjcmlwdGlvbnMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChudW1TdWJzY3JpcHRpb25zID09PSAxKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHRoZXJlJ3Mgb25seSBhIHNpbmdsZSBoYW5kbGVyIHdlIGNhbiBqdXN0IGNhbGwgaXQgd2l0aG91dCBpbnZva2luZyBhIGxvb3AuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uc1swXShhLCBiLCBjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtU3Vic2NyaXB0aW9uczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQ2hlY2sgd2hldGhlciB0aGUgaGFuZGxlciBleGlzdHMgYmVmb3JlIGZpcmluZyBhcyBpdCdzIHBvc3NpYmxlXG4gICAgICAgICAgICAgICAgICogdGhlIHN1YnNjcmlwdGlvbnMgd2VyZSBtb2RpZmllZCBkdXJpbmcgdGhpcyBsb29wIHJ1bm5pbmcuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlciA9IHRoaXMuc3Vic2NyaXB0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICBoYW5kbGVyICYmIGhhbmRsZXIoYSwgYiwgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0U2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3Vic2NyaXB0aW9ucy5sZW5ndGg7XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMubGVuZ3RoID0gMDtcbiAgICB9XG59XG5cbi8qKlxuICogTWF4aW11bSB0aW1lIGJldHdlZW4gdGhlIHZhbHVlIG9mIHR3byBmcmFtZXMsIGJleW9uZCB3aGljaCB3ZVxuICogYXNzdW1lIHRoZSB2ZWxvY2l0eSBoYXMgc2luY2UgYmVlbiAwLlxuICovXG5jb25zdCBNQVhfVkVMT0NJVFlfREVMVEEgPSAzMDtcbmNvbnN0IGlzRmxvYXQgPSAodmFsdWUpID0+IHtcbiAgICByZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQodmFsdWUpKTtcbn07XG5jb25zdCBjb2xsZWN0TW90aW9uVmFsdWVzID0ge1xuICAgIGN1cnJlbnQ6IHVuZGVmaW5lZCxcbn07XG4vKipcbiAqIGBNb3Rpb25WYWx1ZWAgaXMgdXNlZCB0byB0cmFjayB0aGUgc3RhdGUgYW5kIHZlbG9jaXR5IG9mIG1vdGlvbiB2YWx1ZXMuXG4gKlxuICogQHB1YmxpY1xuICovXG5jbGFzcyBNb3Rpb25WYWx1ZSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGluaXQgLSBUaGUgaW5pdGlhdGluZyB2YWx1ZVxuICAgICAqIEBwYXJhbSBjb25maWcgLSBPcHRpb25hbCBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICAgKlxuICAgICAqIC0gIGB0cmFuc2Zvcm1lcmA6IEEgZnVuY3Rpb24gdG8gdHJhbnNmb3JtIGluY29taW5nIHZhbHVlcyB3aXRoLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaW5pdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIHdpbGwgYmUgcmVwbGFjZWQgYnkgdGhlIGJ1aWxkIHN0ZXAgd2l0aCB0aGUgbGF0ZXN0IHZlcnNpb24gbnVtYmVyLlxuICAgICAgICAgKiBXaGVuIE1vdGlvblZhbHVlcyBhcmUgcHJvdmlkZWQgdG8gbW90aW9uIGNvbXBvbmVudHMsIHdhcm4gaWYgdmVyc2lvbnMgYXJlIG1peGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52ZXJzaW9uID0gXCIxMS4xNS4wXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmFja3Mgd2hldGhlciB0aGlzIHZhbHVlIGNhbiBvdXRwdXQgYSB2ZWxvY2l0eS4gQ3VycmVudGx5IHRoaXMgaXMgb25seSB0cnVlXG4gICAgICAgICAqIGlmIHRoZSB2YWx1ZSBpcyBudW1lcmljYWwsIGJ1dCB3ZSBtaWdodCBiZSBhYmxlIHRvIHdpZGVuIHRoZSBzY29wZSBoZXJlIGFuZCBzdXBwb3J0XG4gICAgICAgICAqIG90aGVyIHZhbHVlIHR5cGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2FuVHJhY2tWZWxvY2l0eSA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBvYmplY3QgY29udGFpbmluZyBhIFN1YnNjcmlwdGlvbk1hbmFnZXIgZm9yIGVhY2ggYWN0aXZlIGV2ZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ldmVudHMgPSB7fTtcbiAgICAgICAgdGhpcy51cGRhdGVBbmROb3RpZnkgPSAodiwgcmVuZGVyID0gdHJ1ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFRpbWUgPSB0aW1lLm5vdygpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB3ZSdyZSB1cGRhdGluZyB0aGUgdmFsdWUgZHVyaW5nIGFub3RoZXIgZnJhbWUgb3IgZXZlbnRsb29wXG4gICAgICAgICAgICAgKiB0aGFuIHRoZSBwcmV2aW91cyBmcmFtZSwgdGhlbiB0aGUgd2Ugc2V0IHRoZSBwcmV2aW91cyBmcmFtZSB2YWx1ZVxuICAgICAgICAgICAgICogdG8gY3VycmVudC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHRoaXMudXBkYXRlZEF0ICE9PSBjdXJyZW50VGltZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0UHJldkZyYW1lVmFsdWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHJldiA9IHRoaXMuY3VycmVudDtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudCh2KTtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB1cGRhdGUgc3Vic2NyaWJlcnNcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnQgIT09IHRoaXMucHJldiAmJiB0aGlzLmV2ZW50cy5jaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5jaGFuZ2Uubm90aWZ5KHRoaXMuY3VycmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVcGRhdGUgcmVuZGVyIHN1YnNjcmliZXJzXG4gICAgICAgICAgICBpZiAocmVuZGVyICYmIHRoaXMuZXZlbnRzLnJlbmRlclJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5yZW5kZXJSZXF1ZXN0Lm5vdGlmeSh0aGlzLmN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhc0FuaW1hdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2V0Q3VycmVudChpbml0KTtcbiAgICAgICAgdGhpcy5vd25lciA9IG9wdGlvbnMub3duZXI7XG4gICAgfVxuICAgIHNldEN1cnJlbnQoY3VycmVudCkge1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSBjdXJyZW50O1xuICAgICAgICB0aGlzLnVwZGF0ZWRBdCA9IHRpbWUubm93KCk7XG4gICAgICAgIGlmICh0aGlzLmNhblRyYWNrVmVsb2NpdHkgPT09IG51bGwgJiYgY3VycmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmNhblRyYWNrVmVsb2NpdHkgPSBpc0Zsb2F0KHRoaXMuY3VycmVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0UHJldkZyYW1lVmFsdWUocHJldkZyYW1lVmFsdWUgPSB0aGlzLmN1cnJlbnQpIHtcbiAgICAgICAgdGhpcy5wcmV2RnJhbWVWYWx1ZSA9IHByZXZGcmFtZVZhbHVlO1xuICAgICAgICB0aGlzLnByZXZVcGRhdGVkQXQgPSB0aGlzLnVwZGF0ZWRBdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBub3RpZmllZCB3aGVuIHRoZSBgTW90aW9uVmFsdWVgIGlzIHVwZGF0ZWQuXG4gICAgICpcbiAgICAgKiBJdCByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsIHdpbGwgY2FuY2VsIHRoZSBzdWJzY3JpcHRpb24uXG4gICAgICpcbiAgICAgKiBXaGVuIGNhbGxpbmcgYG9uQ2hhbmdlYCBpbnNpZGUgYSBSZWFjdCBjb21wb25lbnQsIGl0IHNob3VsZCBiZSB3cmFwcGVkIHdpdGggdGhlXG4gICAgICogYHVzZUVmZmVjdGAgaG9vay4gQXMgaXQgcmV0dXJucyBhbiB1bnN1YnNjcmliZSBmdW5jdGlvbiwgdGhpcyBzaG91bGQgYmUgcmV0dXJuZWRcbiAgICAgKiBmcm9tIHRoZSBgdXNlRWZmZWN0YCBmdW5jdGlvbiB0byBlbnN1cmUgeW91IGRvbid0IGFkZCBkdXBsaWNhdGUgc3Vic2NyaWJlcnMuLlxuICAgICAqXG4gICAgICogYGBganN4XG4gICAgICogZXhwb3J0IGNvbnN0IE15Q29tcG9uZW50ID0gKCkgPT4ge1xuICAgICAqICAgY29uc3QgeCA9IHVzZU1vdGlvblZhbHVlKDApXG4gICAgICogICBjb25zdCB5ID0gdXNlTW90aW9uVmFsdWUoMClcbiAgICAgKiAgIGNvbnN0IG9wYWNpdHkgPSB1c2VNb3Rpb25WYWx1ZSgxKVxuICAgICAqXG4gICAgICogICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAqICAgICBmdW5jdGlvbiB1cGRhdGVPcGFjaXR5KCkge1xuICAgICAqICAgICAgIGNvbnN0IG1heFhZID0gTWF0aC5tYXgoeC5nZXQoKSwgeS5nZXQoKSlcbiAgICAgKiAgICAgICBjb25zdCBuZXdPcGFjaXR5ID0gdHJhbnNmb3JtKG1heFhZLCBbMCwgMTAwXSwgWzEsIDBdKVxuICAgICAqICAgICAgIG9wYWNpdHkuc2V0KG5ld09wYWNpdHkpXG4gICAgICogICAgIH1cbiAgICAgKlxuICAgICAqICAgICBjb25zdCB1bnN1YnNjcmliZVggPSB4Lm9uKFwiY2hhbmdlXCIsIHVwZGF0ZU9wYWNpdHkpXG4gICAgICogICAgIGNvbnN0IHVuc3Vic2NyaWJlWSA9IHkub24oXCJjaGFuZ2VcIiwgdXBkYXRlT3BhY2l0eSlcbiAgICAgKlxuICAgICAqICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAqICAgICAgIHVuc3Vic2NyaWJlWCgpXG4gICAgICogICAgICAgdW5zdWJzY3JpYmVZKClcbiAgICAgKiAgICAgfVxuICAgICAqICAgfSwgW10pXG4gICAgICpcbiAgICAgKiAgIHJldHVybiA8bW90aW9uLmRpdiBzdHlsZT17eyB4IH19IC8+XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHN1YnNjcmliZXIgLSBBIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgdGhlIGxhdGVzdCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyBBIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLCB3aWxsIGNhbmNlbCB0aGlzIHN1YnNjcmlwdGlvbi5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgb25DaGFuZ2Uoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKGZhbHNlLCBgdmFsdWUub25DaGFuZ2UoY2FsbGJhY2spIGlzIGRlcHJlY2F0ZWQuIFN3aXRjaCB0byB2YWx1ZS5vbihcImNoYW5nZVwiLCBjYWxsYmFjaykuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMub24oXCJjaGFuZ2VcIiwgc3Vic2NyaXB0aW9uKTtcbiAgICB9XG4gICAgb24oZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIXRoaXMuZXZlbnRzW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0gPSBuZXcgU3Vic2NyaXB0aW9uTWFuYWdlcigpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gdGhpcy5ldmVudHNbZXZlbnROYW1lXS5hZGQoY2FsbGJhY2spO1xuICAgICAgICBpZiAoZXZlbnROYW1lID09PSBcImNoYW5nZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogSWYgd2UgaGF2ZSBubyBtb3JlIGNoYW5nZSBsaXN0ZW5lcnMgYnkgdGhlIHN0YXJ0XG4gICAgICAgICAgICAgICAgICogb2YgdGhlIG5leHQgZnJhbWUsIHN0b3AgYWN0aXZlIGFuaW1hdGlvbnMuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnJhbWUucmVhZCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5ldmVudHMuY2hhbmdlLmdldFNpemUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuc3Vic2NyaWJlO1xuICAgIH1cbiAgICBjbGVhckxpc3RlbmVycygpIHtcbiAgICAgICAgZm9yIChjb25zdCBldmVudE1hbmFnZXJzIGluIHRoaXMuZXZlbnRzKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50c1tldmVudE1hbmFnZXJzXS5jbGVhcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIGEgcGFzc2l2ZSBlZmZlY3QgdG8gdGhlIGBNb3Rpb25WYWx1ZWAuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBhdHRhY2gocGFzc2l2ZUVmZmVjdCwgc3RvcFBhc3NpdmVFZmZlY3QpIHtcbiAgICAgICAgdGhpcy5wYXNzaXZlRWZmZWN0ID0gcGFzc2l2ZUVmZmVjdDtcbiAgICAgICAgdGhpcy5zdG9wUGFzc2l2ZUVmZmVjdCA9IHN0b3BQYXNzaXZlRWZmZWN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzdGF0ZSBvZiB0aGUgYE1vdGlvblZhbHVlYC5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICpcbiAgICAgKiBgYGBqc3hcbiAgICAgKiBjb25zdCB4ID0gdXNlTW90aW9uVmFsdWUoMClcbiAgICAgKiB4LnNldCgxMClcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBsYXRlc3QgLSBMYXRlc3QgdmFsdWUgdG8gc2V0LlxuICAgICAqIEBwYXJhbSByZW5kZXIgLSBXaGV0aGVyIHRvIG5vdGlmeSByZW5kZXIgc3Vic2NyaWJlcnMuIERlZmF1bHRzIHRvIGB0cnVlYFxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHNldCh2LCByZW5kZXIgPSB0cnVlKSB7XG4gICAgICAgIGlmICghcmVuZGVyIHx8ICF0aGlzLnBhc3NpdmVFZmZlY3QpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQW5kTm90aWZ5KHYsIHJlbmRlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBhc3NpdmVFZmZlY3QodiwgdGhpcy51cGRhdGVBbmROb3RpZnkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldFdpdGhWZWxvY2l0eShwcmV2LCBjdXJyZW50LCBkZWx0YSkge1xuICAgICAgICB0aGlzLnNldChjdXJyZW50KTtcbiAgICAgICAgdGhpcy5wcmV2ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnByZXZGcmFtZVZhbHVlID0gcHJldjtcbiAgICAgICAgdGhpcy5wcmV2VXBkYXRlZEF0ID0gdGhpcy51cGRhdGVkQXQgLSBkZWx0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBzdGF0ZSBvZiB0aGUgYE1vdGlvblZhbHVlYCwgc3RvcHBpbmcgYW55IGFjdGl2ZSBhbmltYXRpb25zLFxuICAgICAqIGVmZmVjdHMsIGFuZCByZXNldHMgdmVsb2NpdHkgdG8gYDBgLlxuICAgICAqL1xuICAgIGp1bXAodiwgZW5kQW5pbWF0aW9uID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZUFuZE5vdGlmeSh2KTtcbiAgICAgICAgdGhpcy5wcmV2ID0gdjtcbiAgICAgICAgdGhpcy5wcmV2VXBkYXRlZEF0ID0gdGhpcy5wcmV2RnJhbWVWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZW5kQW5pbWF0aW9uICYmIHRoaXMuc3RvcCgpO1xuICAgICAgICBpZiAodGhpcy5zdG9wUGFzc2l2ZUVmZmVjdClcbiAgICAgICAgICAgIHRoaXMuc3RvcFBhc3NpdmVFZmZlY3QoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGF0ZXN0IHN0YXRlIG9mIGBNb3Rpb25WYWx1ZWBcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIC0gVGhlIGxhdGVzdCBzdGF0ZSBvZiBgTW90aW9uVmFsdWVgXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgZ2V0KCkge1xuICAgICAgICBpZiAoY29sbGVjdE1vdGlvblZhbHVlcy5jdXJyZW50KSB7XG4gICAgICAgICAgICBjb2xsZWN0TW90aW9uVmFsdWVzLmN1cnJlbnQucHVzaCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgZ2V0UHJldmlvdXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZXY7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxhdGVzdCB2ZWxvY2l0eSBvZiBgTW90aW9uVmFsdWVgXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyAtIFRoZSBsYXRlc3QgdmVsb2NpdHkgb2YgYE1vdGlvblZhbHVlYC4gUmV0dXJucyBgMGAgaWYgdGhlIHN0YXRlIGlzIG5vbi1udW1lcmljYWwuXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgZ2V0VmVsb2NpdHkoKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gdGltZS5ub3coKTtcbiAgICAgICAgaWYgKCF0aGlzLmNhblRyYWNrVmVsb2NpdHkgfHxcbiAgICAgICAgICAgIHRoaXMucHJldkZyYW1lVmFsdWUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgY3VycmVudFRpbWUgLSB0aGlzLnVwZGF0ZWRBdCA+IE1BWF9WRUxPQ0lUWV9ERUxUQSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVsdGEgPSBNYXRoLm1pbih0aGlzLnVwZGF0ZWRBdCAtIHRoaXMucHJldlVwZGF0ZWRBdCwgTUFYX1ZFTE9DSVRZX0RFTFRBKTtcbiAgICAgICAgLy8gQ2FzdHMgYmVjYXVzZSBvZiBwYXJzZUZsb2F0J3MgcG9vciB0eXBpbmdcbiAgICAgICAgcmV0dXJuIHZlbG9jaXR5UGVyU2Vjb25kKHBhcnNlRmxvYXQodGhpcy5jdXJyZW50KSAtXG4gICAgICAgICAgICBwYXJzZUZsb2F0KHRoaXMucHJldkZyYW1lVmFsdWUpLCBkZWx0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIG5ldyBhbmltYXRpb24gdG8gY29udHJvbCB0aGlzIGBNb3Rpb25WYWx1ZWAuIE9ubHkgb25lXG4gICAgICogYW5pbWF0aW9uIGNhbiBkcml2ZSBhIGBNb3Rpb25WYWx1ZWAgYXQgb25lIHRpbWUuXG4gICAgICpcbiAgICAgKiBgYGBqc3hcbiAgICAgKiB2YWx1ZS5zdGFydCgpXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYW5pbWF0aW9uIC0gQSBmdW5jdGlvbiB0aGF0IHN0YXJ0cyB0aGUgcHJvdmlkZWQgYW5pbWF0aW9uXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzdGFydChzdGFydEFuaW1hdGlvbikge1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmhhc0FuaW1hdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uID0gc3RhcnRBbmltYXRpb24ocmVzb2x2ZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5ldmVudHMuYW5pbWF0aW9uU3RhcnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5hbmltYXRpb25TdGFydC5ub3RpZnkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5ldmVudHMuYW5pbWF0aW9uQ29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5hbmltYXRpb25Db21wbGV0ZS5ub3RpZnkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2xlYXJBbmltYXRpb24oKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3AgdGhlIGN1cnJlbnRseSBhY3RpdmUgYW5pbWF0aW9uLlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICh0aGlzLmFuaW1hdGlvbikge1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb24uc3RvcCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRzLmFuaW1hdGlvbkNhbmNlbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLmFuaW1hdGlvbkNhbmNlbC5ub3RpZnkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsZWFyQW5pbWF0aW9uKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoaXMgdmFsdWUgaXMgY3VycmVudGx5IGFuaW1hdGluZy5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBpc0FuaW1hdGluZygpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5hbmltYXRpb247XG4gICAgfVxuICAgIGNsZWFyQW5pbWF0aW9uKCkge1xuICAgICAgICBkZWxldGUgdGhpcy5hbmltYXRpb247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc3Ryb3kgYW5kIGNsZWFuIHVwIHN1YnNjcmliZXJzIHRvIHRoaXMgYE1vdGlvblZhbHVlYC5cbiAgICAgKlxuICAgICAqIFRoZSBgTW90aW9uVmFsdWVgIGhvb2tzIGxpa2UgYHVzZU1vdGlvblZhbHVlYCBhbmQgYHVzZVRyYW5zZm9ybWAgYXV0b21hdGljYWxseVxuICAgICAqIGhhbmRsZSB0aGUgbGlmZWN5Y2xlIG9mIHRoZSByZXR1cm5lZCBgTW90aW9uVmFsdWVgLCBzbyB0aGlzIG1ldGhvZCBpcyBvbmx5IG5lY2Vzc2FyeSBpZiB5b3UndmUgbWFudWFsbHlcbiAgICAgKiBjcmVhdGVkIGEgYE1vdGlvblZhbHVlYCB2aWEgdGhlIGBtb3Rpb25WYWx1ZWAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5jbGVhckxpc3RlbmVycygpO1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgaWYgKHRoaXMuc3RvcFBhc3NpdmVFZmZlY3QpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcFBhc3NpdmVFZmZlY3QoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIG1vdGlvblZhbHVlKGluaXQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IE1vdGlvblZhbHVlKGluaXQsIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIFNldCBWaXN1YWxFbGVtZW50J3MgTW90aW9uVmFsdWUsIGNyZWF0aW5nIGEgbmV3IE1vdGlvblZhbHVlIGZvciBpdCBpZlxuICogaXQgZG9lc24ndCBleGlzdC5cbiAqL1xuZnVuY3Rpb24gc2V0TW90aW9uVmFsdWUodmlzdWFsRWxlbWVudCwga2V5LCB2YWx1ZSkge1xuICAgIGlmICh2aXN1YWxFbGVtZW50Lmhhc1ZhbHVlKGtleSkpIHtcbiAgICAgICAgdmlzdWFsRWxlbWVudC5nZXRWYWx1ZShrZXkpLnNldCh2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2aXN1YWxFbGVtZW50LmFkZFZhbHVlKGtleSwgbW90aW9uVmFsdWUodmFsdWUpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXRUYXJnZXQodmlzdWFsRWxlbWVudCwgZGVmaW5pdGlvbikge1xuICAgIGNvbnN0IHJlc29sdmVkID0gcmVzb2x2ZVZhcmlhbnQodmlzdWFsRWxlbWVudCwgZGVmaW5pdGlvbik7XG4gICAgbGV0IHsgdHJhbnNpdGlvbkVuZCA9IHt9LCB0cmFuc2l0aW9uID0ge30sIC4uLnRhcmdldCB9ID0gcmVzb2x2ZWQgfHwge307XG4gICAgdGFyZ2V0ID0geyAuLi50YXJnZXQsIC4uLnRyYW5zaXRpb25FbmQgfTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB0YXJnZXQpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSByZXNvbHZlRmluYWxWYWx1ZUluS2V5ZnJhbWVzKHRhcmdldFtrZXldKTtcbiAgICAgICAgc2V0TW90aW9uVmFsdWUodmlzdWFsRWxlbWVudCwga2V5LCB2YWx1ZSk7XG4gICAgfVxufVxuXG4vKipcbiAqIENvbnZlcnQgY2FtZWxDYXNlIHRvIGRhc2gtY2FzZSBwcm9wZXJ0aWVzLlxuICovXG5jb25zdCBjYW1lbFRvRGFzaCA9IChzdHIpID0+IHN0ci5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9ndSwgXCIkMS0kMlwiKS50b0xvd2VyQ2FzZSgpO1xuXG5jb25zdCBvcHRpbWl6ZWRBcHBlYXJEYXRhSWQgPSBcImZyYW1lckFwcGVhcklkXCI7XG5jb25zdCBvcHRpbWl6ZWRBcHBlYXJEYXRhQXR0cmlidXRlID0gXCJkYXRhLVwiICsgY2FtZWxUb0Rhc2gob3B0aW1pemVkQXBwZWFyRGF0YUlkKTtcblxuZnVuY3Rpb24gZ2V0T3B0aW1pc2VkQXBwZWFySWQodmlzdWFsRWxlbWVudCkge1xuICAgIHJldHVybiB2aXN1YWxFbGVtZW50LnByb3BzW29wdGltaXplZEFwcGVhckRhdGFBdHRyaWJ1dGVdO1xufVxuXG5jb25zdCBpc01vdGlvblZhbHVlID0gKHZhbHVlKSA9PiBCb29sZWFuKHZhbHVlICYmIHZhbHVlLmdldFZlbG9jaXR5KTtcblxuZnVuY3Rpb24gaXNXaWxsQ2hhbmdlTW90aW9uVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gQm9vbGVhbihpc01vdGlvblZhbHVlKHZhbHVlKSAmJiB2YWx1ZS5hZGQpO1xufVxuXG5mdW5jdGlvbiBhZGRWYWx1ZVRvV2lsbENoYW5nZSh2aXN1YWxFbGVtZW50LCBrZXkpIHtcbiAgICBjb25zdCB3aWxsQ2hhbmdlID0gdmlzdWFsRWxlbWVudC5nZXRWYWx1ZShcIndpbGxDaGFuZ2VcIik7XG4gICAgLyoqXG4gICAgICogSXQgY291bGQgYmUgdGhhdCBhIHVzZXIgaGFzIHNldCB3aWxsQ2hhbmdlIHRvIGEgcmVndWxhciBNb3Rpb25WYWx1ZSxcbiAgICAgKiBpbiB3aGljaCBjYXNlIHdlIGNhbid0IGFkZCB0aGUgdmFsdWUgdG8gaXQuXG4gICAgICovXG4gICAgaWYgKGlzV2lsbENoYW5nZU1vdGlvblZhbHVlKHdpbGxDaGFuZ2UpKSB7XG4gICAgICAgIHJldHVybiB3aWxsQ2hhbmdlLmFkZChrZXkpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBEZWNpZGUgd2hldGhlciB3ZSBzaG91bGQgYmxvY2sgdGhpcyBhbmltYXRpb24uIFByZXZpb3VzbHksIHdlIGFjaGlldmVkIHRoaXNcbiAqIGp1c3QgYnkgY2hlY2tpbmcgd2hldGhlciB0aGUga2V5IHdhcyBsaXN0ZWQgaW4gcHJvdGVjdGVkS2V5cywgYnV0IHRoaXNcbiAqIHBvc2VkIHByb2JsZW1zIGlmIGFuIGFuaW1hdGlvbiB3YXMgdHJpZ2dlcmVkIGJ5IGFmdGVyQ2hpbGRyZW4gYW5kIHByb3RlY3RlZEtleXNcbiAqIGhhZCBiZWVuIHNldCB0byB0cnVlIGluIHRoZSBtZWFudGltZS5cbiAqL1xuZnVuY3Rpb24gc2hvdWxkQmxvY2tBbmltYXRpb24oeyBwcm90ZWN0ZWRLZXlzLCBuZWVkc0FuaW1hdGluZyB9LCBrZXkpIHtcbiAgICBjb25zdCBzaG91bGRCbG9jayA9IHByb3RlY3RlZEtleXMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBuZWVkc0FuaW1hdGluZ1trZXldICE9PSB0cnVlO1xuICAgIG5lZWRzQW5pbWF0aW5nW2tleV0gPSBmYWxzZTtcbiAgICByZXR1cm4gc2hvdWxkQmxvY2s7XG59XG5mdW5jdGlvbiBhbmltYXRlVGFyZ2V0KHZpc3VhbEVsZW1lbnQsIHRhcmdldEFuZFRyYW5zaXRpb24sIHsgZGVsYXkgPSAwLCB0cmFuc2l0aW9uT3ZlcnJpZGUsIHR5cGUgfSA9IHt9KSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCB7IHRyYW5zaXRpb24gPSB2aXN1YWxFbGVtZW50LmdldERlZmF1bHRUcmFuc2l0aW9uKCksIHRyYW5zaXRpb25FbmQsIC4uLnRhcmdldCB9ID0gdGFyZ2V0QW5kVHJhbnNpdGlvbjtcbiAgICBpZiAodHJhbnNpdGlvbk92ZXJyaWRlKVxuICAgICAgICB0cmFuc2l0aW9uID0gdHJhbnNpdGlvbk92ZXJyaWRlO1xuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSBbXTtcbiAgICBjb25zdCBhbmltYXRpb25UeXBlU3RhdGUgPSB0eXBlICYmXG4gICAgICAgIHZpc3VhbEVsZW1lbnQuYW5pbWF0aW9uU3RhdGUgJiZcbiAgICAgICAgdmlzdWFsRWxlbWVudC5hbmltYXRpb25TdGF0ZS5nZXRTdGF0ZSgpW3R5cGVdO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHRhcmdldCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHZpc3VhbEVsZW1lbnQuZ2V0VmFsdWUoa2V5LCAoX2EgPSB2aXN1YWxFbGVtZW50LmxhdGVzdFZhbHVlc1trZXldKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsKTtcbiAgICAgICAgY29uc3QgdmFsdWVUYXJnZXQgPSB0YXJnZXRba2V5XTtcbiAgICAgICAgaWYgKHZhbHVlVGFyZ2V0ID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIChhbmltYXRpb25UeXBlU3RhdGUgJiZcbiAgICAgICAgICAgICAgICBzaG91bGRCbG9ja0FuaW1hdGlvbihhbmltYXRpb25UeXBlU3RhdGUsIGtleSkpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZVRyYW5zaXRpb24gPSB7XG4gICAgICAgICAgICBkZWxheSxcbiAgICAgICAgICAgIC4uLmdldFZhbHVlVHJhbnNpdGlvbiQxKHRyYW5zaXRpb24gfHwge30sIGtleSksXG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGlzIGlzIHRoZSBmaXJzdCB0aW1lIGEgdmFsdWUgaXMgYmVpbmcgYW5pbWF0ZWQsIGNoZWNrXG4gICAgICAgICAqIHRvIHNlZSBpZiB3ZSdyZSBoYW5kbGluZyBvZmYgZnJvbSBhbiBleGlzdGluZyBhbmltYXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICBsZXQgaXNIYW5kb2ZmID0gZmFsc2U7XG4gICAgICAgIGlmICh3aW5kb3cuTW90aW9uSGFuZG9mZkFuaW1hdGlvbikge1xuICAgICAgICAgICAgY29uc3QgYXBwZWFySWQgPSBnZXRPcHRpbWlzZWRBcHBlYXJJZCh2aXN1YWxFbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChhcHBlYXJJZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHdpbmRvdy5Nb3Rpb25IYW5kb2ZmQW5pbWF0aW9uKGFwcGVhcklkLCBrZXksIGZyYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRUaW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlVHJhbnNpdGlvbi5zdGFydFRpbWUgPSBzdGFydFRpbWU7XG4gICAgICAgICAgICAgICAgICAgIGlzSGFuZG9mZiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFkZFZhbHVlVG9XaWxsQ2hhbmdlKHZpc3VhbEVsZW1lbnQsIGtleSk7XG4gICAgICAgIHZhbHVlLnN0YXJ0KGFuaW1hdGVNb3Rpb25WYWx1ZShrZXksIHZhbHVlLCB2YWx1ZVRhcmdldCwgdmlzdWFsRWxlbWVudC5zaG91bGRSZWR1Y2VNb3Rpb24gJiYgdHJhbnNmb3JtUHJvcHMuaGFzKGtleSlcbiAgICAgICAgICAgID8geyB0eXBlOiBmYWxzZSB9XG4gICAgICAgICAgICA6IHZhbHVlVHJhbnNpdGlvbiwgdmlzdWFsRWxlbWVudCwgaXNIYW5kb2ZmKSk7XG4gICAgICAgIGNvbnN0IGFuaW1hdGlvbiA9IHZhbHVlLmFuaW1hdGlvbjtcbiAgICAgICAgaWYgKGFuaW1hdGlvbikge1xuICAgICAgICAgICAgYW5pbWF0aW9ucy5wdXNoKGFuaW1hdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRyYW5zaXRpb25FbmQpIHtcbiAgICAgICAgUHJvbWlzZS5hbGwoYW5pbWF0aW9ucykudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBmcmFtZS51cGRhdGUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyYW5zaXRpb25FbmQgJiYgc2V0VGFyZ2V0KHZpc3VhbEVsZW1lbnQsIHRyYW5zaXRpb25FbmQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYW5pbWF0aW9ucztcbn1cblxuZnVuY3Rpb24gYW5pbWF0ZVZhcmlhbnQodmlzdWFsRWxlbWVudCwgdmFyaWFudCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHJlc29sdmVkID0gcmVzb2x2ZVZhcmlhbnQodmlzdWFsRWxlbWVudCwgdmFyaWFudCwgb3B0aW9ucy50eXBlID09PSBcImV4aXRcIlxuICAgICAgICA/IChfYSA9IHZpc3VhbEVsZW1lbnQucHJlc2VuY2VDb250ZXh0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY3VzdG9tXG4gICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICBsZXQgeyB0cmFuc2l0aW9uID0gdmlzdWFsRWxlbWVudC5nZXREZWZhdWx0VHJhbnNpdGlvbigpIHx8IHt9IH0gPSByZXNvbHZlZCB8fCB7fTtcbiAgICBpZiAob3B0aW9ucy50cmFuc2l0aW9uT3ZlcnJpZGUpIHtcbiAgICAgICAgdHJhbnNpdGlvbiA9IG9wdGlvbnMudHJhbnNpdGlvbk92ZXJyaWRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB3ZSBoYXZlIGEgdmFyaWFudCwgY3JlYXRlIGEgY2FsbGJhY2sgdGhhdCBydW5zIGl0IGFzIGFuIGFuaW1hdGlvbi5cbiAgICAgKiBPdGhlcndpc2UsIHdlIHJlc29sdmUgYSBQcm9taXNlIGltbWVkaWF0ZWx5IGZvciBhIGNvbXBvc2FibGUgbm8tb3AuXG4gICAgICovXG4gICAgY29uc3QgZ2V0QW5pbWF0aW9uID0gcmVzb2x2ZWRcbiAgICAgICAgPyAoKSA9PiBQcm9taXNlLmFsbChhbmltYXRlVGFyZ2V0KHZpc3VhbEVsZW1lbnQsIHJlc29sdmVkLCBvcHRpb25zKSlcbiAgICAgICAgOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAvKipcbiAgICAgKiBJZiB3ZSBoYXZlIGNoaWxkcmVuLCBjcmVhdGUgYSBjYWxsYmFjayB0aGF0IHJ1bnMgYWxsIHRoZWlyIGFuaW1hdGlvbnMuXG4gICAgICogT3RoZXJ3aXNlLCB3ZSByZXNvbHZlIGEgUHJvbWlzZSBpbW1lZGlhdGVseSBmb3IgYSBjb21wb3NhYmxlIG5vLW9wLlxuICAgICAqL1xuICAgIGNvbnN0IGdldENoaWxkQW5pbWF0aW9ucyA9IHZpc3VhbEVsZW1lbnQudmFyaWFudENoaWxkcmVuICYmIHZpc3VhbEVsZW1lbnQudmFyaWFudENoaWxkcmVuLnNpemVcbiAgICAgICAgPyAoZm9yd2FyZERlbGF5ID0gMCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBkZWxheUNoaWxkcmVuID0gMCwgc3RhZ2dlckNoaWxkcmVuLCBzdGFnZ2VyRGlyZWN0aW9uLCB9ID0gdHJhbnNpdGlvbjtcbiAgICAgICAgICAgIHJldHVybiBhbmltYXRlQ2hpbGRyZW4odmlzdWFsRWxlbWVudCwgdmFyaWFudCwgZGVsYXlDaGlsZHJlbiArIGZvcndhcmREZWxheSwgc3RhZ2dlckNoaWxkcmVuLCBzdGFnZ2VyRGlyZWN0aW9uLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICA6ICgpID0+IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIC8qKlxuICAgICAqIElmIHRoZSB0cmFuc2l0aW9uIGV4cGxpY2l0bHkgZGVmaW5lcyBhIFwid2hlblwiIG9wdGlvbiwgd2UgbmVlZCB0byByZXNvbHZlIGVpdGhlclxuICAgICAqIHRoaXMgYW5pbWF0aW9uIG9yIGFsbCBjaGlsZHJlbiBhbmltYXRpb25zIGJlZm9yZSBwbGF5aW5nIHRoZSBvdGhlci5cbiAgICAgKi9cbiAgICBjb25zdCB7IHdoZW4gfSA9IHRyYW5zaXRpb247XG4gICAgaWYgKHdoZW4pIHtcbiAgICAgICAgY29uc3QgW2ZpcnN0LCBsYXN0XSA9IHdoZW4gPT09IFwiYmVmb3JlQ2hpbGRyZW5cIlxuICAgICAgICAgICAgPyBbZ2V0QW5pbWF0aW9uLCBnZXRDaGlsZEFuaW1hdGlvbnNdXG4gICAgICAgICAgICA6IFtnZXRDaGlsZEFuaW1hdGlvbnMsIGdldEFuaW1hdGlvbl07XG4gICAgICAgIHJldHVybiBmaXJzdCgpLnRoZW4oKCkgPT4gbGFzdCgpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbZ2V0QW5pbWF0aW9uKCksIGdldENoaWxkQW5pbWF0aW9ucyhvcHRpb25zLmRlbGF5KV0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFuaW1hdGVDaGlsZHJlbih2aXN1YWxFbGVtZW50LCB2YXJpYW50LCBkZWxheUNoaWxkcmVuID0gMCwgc3RhZ2dlckNoaWxkcmVuID0gMCwgc3RhZ2dlckRpcmVjdGlvbiA9IDEsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBhbmltYXRpb25zID0gW107XG4gICAgY29uc3QgbWF4U3RhZ2dlckR1cmF0aW9uID0gKHZpc3VhbEVsZW1lbnQudmFyaWFudENoaWxkcmVuLnNpemUgLSAxKSAqIHN0YWdnZXJDaGlsZHJlbjtcbiAgICBjb25zdCBnZW5lcmF0ZVN0YWdnZXJEdXJhdGlvbiA9IHN0YWdnZXJEaXJlY3Rpb24gPT09IDFcbiAgICAgICAgPyAoaSA9IDApID0+IGkgKiBzdGFnZ2VyQ2hpbGRyZW5cbiAgICAgICAgOiAoaSA9IDApID0+IG1heFN0YWdnZXJEdXJhdGlvbiAtIGkgKiBzdGFnZ2VyQ2hpbGRyZW47XG4gICAgQXJyYXkuZnJvbSh2aXN1YWxFbGVtZW50LnZhcmlhbnRDaGlsZHJlbilcbiAgICAgICAgLnNvcnQoc29ydEJ5VHJlZU9yZGVyKVxuICAgICAgICAuZm9yRWFjaCgoY2hpbGQsIGkpID0+IHtcbiAgICAgICAgY2hpbGQubm90aWZ5KFwiQW5pbWF0aW9uU3RhcnRcIiwgdmFyaWFudCk7XG4gICAgICAgIGFuaW1hdGlvbnMucHVzaChhbmltYXRlVmFyaWFudChjaGlsZCwgdmFyaWFudCwge1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGRlbGF5OiBkZWxheUNoaWxkcmVuICsgZ2VuZXJhdGVTdGFnZ2VyRHVyYXRpb24oaSksXG4gICAgICAgIH0pLnRoZW4oKCkgPT4gY2hpbGQubm90aWZ5KFwiQW5pbWF0aW9uQ29tcGxldGVcIiwgdmFyaWFudCkpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoYW5pbWF0aW9ucyk7XG59XG5mdW5jdGlvbiBzb3J0QnlUcmVlT3JkZXIoYSwgYikge1xuICAgIHJldHVybiBhLnNvcnROb2RlUG9zaXRpb24oYik7XG59XG5cbmZ1bmN0aW9uIGFuaW1hdGVWaXN1YWxFbGVtZW50KHZpc3VhbEVsZW1lbnQsIGRlZmluaXRpb24sIG9wdGlvbnMgPSB7fSkge1xuICAgIHZpc3VhbEVsZW1lbnQubm90aWZ5KFwiQW5pbWF0aW9uU3RhcnRcIiwgZGVmaW5pdGlvbik7XG4gICAgbGV0IGFuaW1hdGlvbjtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShkZWZpbml0aW9uKSkge1xuICAgICAgICBjb25zdCBhbmltYXRpb25zID0gZGVmaW5pdGlvbi5tYXAoKHZhcmlhbnQpID0+IGFuaW1hdGVWYXJpYW50KHZpc3VhbEVsZW1lbnQsIHZhcmlhbnQsIG9wdGlvbnMpKTtcbiAgICAgICAgYW5pbWF0aW9uID0gUHJvbWlzZS5hbGwoYW5pbWF0aW9ucyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbml0aW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGFuaW1hdGlvbiA9IGFuaW1hdGVWYXJpYW50KHZpc3VhbEVsZW1lbnQsIGRlZmluaXRpb24sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgcmVzb2x2ZWREZWZpbml0aW9uID0gdHlwZW9mIGRlZmluaXRpb24gPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgPyByZXNvbHZlVmFyaWFudCh2aXN1YWxFbGVtZW50LCBkZWZpbml0aW9uLCBvcHRpb25zLmN1c3RvbSlcbiAgICAgICAgICAgIDogZGVmaW5pdGlvbjtcbiAgICAgICAgYW5pbWF0aW9uID0gUHJvbWlzZS5hbGwoYW5pbWF0ZVRhcmdldCh2aXN1YWxFbGVtZW50LCByZXNvbHZlZERlZmluaXRpb24sIG9wdGlvbnMpKTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1hdGlvbi50aGVuKCgpID0+IHtcbiAgICAgICAgdmlzdWFsRWxlbWVudC5ub3RpZnkoXCJBbmltYXRpb25Db21wbGV0ZVwiLCBkZWZpbml0aW9uKTtcbiAgICB9KTtcbn1cblxuY29uc3QgbnVtVmFyaWFudFByb3BzID0gdmFyaWFudFByb3BzLmxlbmd0aDtcbmZ1bmN0aW9uIGdldFZhcmlhbnRDb250ZXh0KHZpc3VhbEVsZW1lbnQpIHtcbiAgICBpZiAoIXZpc3VhbEVsZW1lbnQpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgaWYgKCF2aXN1YWxFbGVtZW50LmlzQ29udHJvbGxpbmdWYXJpYW50cykge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gdmlzdWFsRWxlbWVudC5wYXJlbnRcbiAgICAgICAgICAgID8gZ2V0VmFyaWFudENvbnRleHQodmlzdWFsRWxlbWVudC5wYXJlbnQpIHx8IHt9XG4gICAgICAgICAgICA6IHt9O1xuICAgICAgICBpZiAodmlzdWFsRWxlbWVudC5wcm9wcy5pbml0aWFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnRleHQuaW5pdGlhbCA9IHZpc3VhbEVsZW1lbnQucHJvcHMuaW5pdGlhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udGV4dDtcbiAgICB9XG4gICAgY29uc3QgY29udGV4dCA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtVmFyaWFudFByb3BzOyBpKyspIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IHZhcmlhbnRQcm9wc1tpXTtcbiAgICAgICAgY29uc3QgcHJvcCA9IHZpc3VhbEVsZW1lbnQucHJvcHNbbmFtZV07XG4gICAgICAgIGlmIChpc1ZhcmlhbnRMYWJlbChwcm9wKSB8fCBwcm9wID09PSBmYWxzZSkge1xuICAgICAgICAgICAgY29udGV4dFtuYW1lXSA9IHByb3A7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbmNvbnN0IHJldmVyc2VQcmlvcml0eU9yZGVyID0gWy4uLnZhcmlhbnRQcmlvcml0eU9yZGVyXS5yZXZlcnNlKCk7XG5jb25zdCBudW1BbmltYXRpb25UeXBlcyA9IHZhcmlhbnRQcmlvcml0eU9yZGVyLmxlbmd0aDtcbmZ1bmN0aW9uIGFuaW1hdGVMaXN0KHZpc3VhbEVsZW1lbnQpIHtcbiAgICByZXR1cm4gKGFuaW1hdGlvbnMpID0+IFByb21pc2UuYWxsKGFuaW1hdGlvbnMubWFwKCh7IGFuaW1hdGlvbiwgb3B0aW9ucyB9KSA9PiBhbmltYXRlVmlzdWFsRWxlbWVudCh2aXN1YWxFbGVtZW50LCBhbmltYXRpb24sIG9wdGlvbnMpKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVBbmltYXRpb25TdGF0ZSh2aXN1YWxFbGVtZW50KSB7XG4gICAgbGV0IGFuaW1hdGUgPSBhbmltYXRlTGlzdCh2aXN1YWxFbGVtZW50KTtcbiAgICBsZXQgc3RhdGUgPSBjcmVhdGVTdGF0ZSgpO1xuICAgIGxldCBpc0luaXRpYWxSZW5kZXIgPSB0cnVlO1xuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSB1c2VkIHRvIHJlZHVjZSB0aGUgYW5pbWF0aW9uIGRlZmluaXRpb25zIGZvclxuICAgICAqIGVhY2ggYWN0aXZlIGFuaW1hdGlvbiB0eXBlIGludG8gYW4gb2JqZWN0IG9mIHJlc29sdmVkIHZhbHVlcyBmb3IgaXQuXG4gICAgICovXG4gICAgY29uc3QgYnVpbGRSZXNvbHZlZFR5cGVWYWx1ZXMgPSAodHlwZSkgPT4gKGFjYywgZGVmaW5pdGlvbikgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkID0gcmVzb2x2ZVZhcmlhbnQodmlzdWFsRWxlbWVudCwgZGVmaW5pdGlvbiwgdHlwZSA9PT0gXCJleGl0XCJcbiAgICAgICAgICAgID8gKF9hID0gdmlzdWFsRWxlbWVudC5wcmVzZW5jZUNvbnRleHQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jdXN0b21cbiAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKHJlc29sdmVkKSB7XG4gICAgICAgICAgICBjb25zdCB7IHRyYW5zaXRpb24sIHRyYW5zaXRpb25FbmQsIC4uLnRhcmdldCB9ID0gcmVzb2x2ZWQ7XG4gICAgICAgICAgICBhY2MgPSB7IC4uLmFjYywgLi4udGFyZ2V0LCAuLi50cmFuc2l0aW9uRW5kIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMganVzdCBhbGxvd3MgdXMgdG8gaW5qZWN0IG1vY2tlZCBhbmltYXRpb24gZnVuY3Rpb25zXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0QW5pbWF0ZUZ1bmN0aW9uKG1ha2VBbmltYXRvcikge1xuICAgICAgICBhbmltYXRlID0gbWFrZUFuaW1hdG9yKHZpc3VhbEVsZW1lbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGVuIHdlIHJlY2VpdmUgbmV3IHByb3BzLCB3ZSBuZWVkIHRvOlxuICAgICAqIDEuIENyZWF0ZSBhIGxpc3Qgb2YgcHJvdGVjdGVkIGtleXMgZm9yIGVhY2ggdHlwZS4gVGhpcyBpcyBhIGRpcmVjdG9yeSBvZlxuICAgICAqICAgIHZhbHVlIGtleXMgdGhhdCBhcmUgY3VycmVudGx5IGJlaW5nIFwiaGFuZGxlZFwiIGJ5IHR5cGVzIG9mIGEgaGlnaGVyIHByaW9yaXR5XG4gICAgICogICAgc28gdGhhdCB3aGVuZXZlciBhbiBhbmltYXRpb24gaXMgcGxheWVkIG9mIGEgZ2l2ZW4gdHlwZSwgdGhlc2UgdmFsdWVzIGFyZVxuICAgICAqICAgIHByb3RlY3RlZCBmcm9tIGJlaW5nIGFuaW1hdGVkLlxuICAgICAqIDIuIERldGVybWluZSBpZiBhbiBhbmltYXRpb24gdHlwZSBuZWVkcyBhbmltYXRpbmcuXG4gICAgICogMy4gRGV0ZXJtaW5lIGlmIGFueSB2YWx1ZXMgaGF2ZSBiZWVuIHJlbW92ZWQgZnJvbSBhIHR5cGUgYW5kIGZpZ3VyZSBvdXRcbiAgICAgKiAgICB3aGF0IHRvIGFuaW1hdGUgdGhvc2UgdG8uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYW5pbWF0ZUNoYW5nZXMoY2hhbmdlZEFjdGl2ZVR5cGUpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gdmlzdWFsRWxlbWVudDtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IGdldFZhcmlhbnRDb250ZXh0KHZpc3VhbEVsZW1lbnQucGFyZW50KSB8fCB7fTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbGlzdCBvZiBhbmltYXRpb25zIHRoYXQgd2UnbGwgYnVpbGQgaW50byBhcyB3ZSBpdGVyYXRlIHRocm91Z2ggdGhlIGFuaW1hdGlvblxuICAgICAgICAgKiB0eXBlcy4gVGhpcyB3aWxsIGdldCBleGVjdXRlZCBhdCB0aGUgZW5kIG9mIHRoZSBmdW5jdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGFuaW1hdGlvbnMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEtlZXAgdHJhY2sgb2Ygd2hpY2ggdmFsdWVzIGhhdmUgYmVlbiByZW1vdmVkLiBUaGVuLCBhcyB3ZSBoaXQgbG93ZXIgcHJpb3JpdHlcbiAgICAgICAgICogYW5pbWF0aW9uIHR5cGVzLCB3ZSBjYW4gY2hlY2sgaWYgdGhleSBjb250YWluIHJlbW92ZWQgdmFsdWVzIGFuZCBhbmltYXRlIHRvIHRoYXQuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCByZW1vdmVkS2V5cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgZGljdGlvbmFyeSBvZiBhbGwgZW5jb3VudGVyZWQga2V5cy4gVGhpcyBpcyBhbiBvYmplY3QgdG8gbGV0IHVzIGJ1aWxkIGludG8gYW5kXG4gICAgICAgICAqIGNvcHkgaXQgd2l0aG91dCBpdGVyYXRpb24uIEVhY2ggdGltZSB3ZSBoaXQgYW4gYW5pbWF0aW9uIHR5cGUgd2Ugc2V0IGl0cyBwcm90ZWN0ZWRcbiAgICAgICAgICoga2V5cyAtIHRoZSBrZXlzIGl0cyBub3QgYWxsb3dlZCB0byBhbmltYXRlIC0gdG8gdGhlIGxhdGVzdCB2ZXJzaW9uIG9mIHRoaXMgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IGVuY291bnRlcmVkS2V5cyA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgYSB2YXJpYW50IGhhcyBiZWVuIHJlbW92ZWQgYXQgYSBnaXZlbiBpbmRleCwgYW5kIHRoaXMgY29tcG9uZW50IGlzIGNvbnRyb2xsaW5nXG4gICAgICAgICAqIHZhcmlhbnQgYW5pbWF0aW9ucywgd2Ugd2FudCB0byBlbnN1cmUgbG93ZXItcHJpb3JpdHkgdmFyaWFudHMgYXJlIGZvcmNlZCB0byBhbmltYXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IHJlbW92ZWRWYXJpYW50SW5kZXggPSBJbmZpbml0eTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEl0ZXJhdGUgdGhyb3VnaCBhbGwgYW5pbWF0aW9uIHR5cGVzIGluIHJldmVyc2UgcHJpb3JpdHkgb3JkZXIuIEZvciBlYWNoLCB3ZSB3YW50IHRvXG4gICAgICAgICAqIGRldGVjdCB3aGljaCB2YWx1ZXMgaXQncyBoYW5kbGluZyBhbmQgd2hldGhlciBvciBub3QgdGhleSd2ZSBjaGFuZ2VkIChhbmQgdGhlcmVmb3JlXG4gICAgICAgICAqIG5lZWQgdG8gYmUgYW5pbWF0ZWQpLiBJZiBhbnkgdmFsdWVzIGhhdmUgYmVlbiByZW1vdmVkLCB3ZSB3YW50IHRvIGRldGVjdCB0aG9zZSBpblxuICAgICAgICAgKiBsb3dlciBwcmlvcml0eSBwcm9wcyBhbmQgZmxhZyBmb3IgYW5pbWF0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1BbmltYXRpb25UeXBlczsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gcmV2ZXJzZVByaW9yaXR5T3JkZXJbaV07XG4gICAgICAgICAgICBjb25zdCB0eXBlU3RhdGUgPSBzdGF0ZVt0eXBlXTtcbiAgICAgICAgICAgIGNvbnN0IHByb3AgPSBwcm9wc1t0eXBlXSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBwcm9wc1t0eXBlXVxuICAgICAgICAgICAgICAgIDogY29udGV4dFt0eXBlXTtcbiAgICAgICAgICAgIGNvbnN0IHByb3BJc1ZhcmlhbnQgPSBpc1ZhcmlhbnRMYWJlbChwcm9wKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgdGhpcyB0eXBlIGhhcyAqanVzdCogY2hhbmdlZCBpc0FjdGl2ZSBzdGF0dXMsIHNldCBhY3RpdmVEZWx0YVxuICAgICAgICAgICAgICogdG8gdGhhdCBzdGF0dXMuIE90aGVyd2lzZSBzZXQgdG8gbnVsbC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgYWN0aXZlRGVsdGEgPSB0eXBlID09PSBjaGFuZ2VkQWN0aXZlVHlwZSA/IHR5cGVTdGF0ZS5pc0FjdGl2ZSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoYWN0aXZlRGVsdGEgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgIHJlbW92ZWRWYXJpYW50SW5kZXggPSBpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB0aGlzIHByb3AgaXMgYW4gaW5oZXJpdGVkIHZhcmlhbnQsIHJhdGhlciB0aGFuIGJlZW4gc2V0IGRpcmVjdGx5IG9uIHRoZVxuICAgICAgICAgICAgICogY29tcG9uZW50IGl0c2VsZiwgd2Ugd2FudCB0byBtYWtlIHN1cmUgd2UgYWxsb3cgdGhlIHBhcmVudCB0byB0cmlnZ2VyIGFuaW1hdGlvbnMuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogVE9ETzogQ2FuIHByb2JhYmx5IGNoYW5nZSB0aGlzIHRvIGEgIWlzQ29udHJvbGxpbmdWYXJpYW50cyBjaGVja1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBsZXQgaXNJbmhlcml0ZWQgPSBwcm9wID09PSBjb250ZXh0W3R5cGVdICYmXG4gICAgICAgICAgICAgICAgcHJvcCAhPT0gcHJvcHNbdHlwZV0gJiZcbiAgICAgICAgICAgICAgICBwcm9wSXNWYXJpYW50O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoaXNJbmhlcml0ZWQgJiZcbiAgICAgICAgICAgICAgICBpc0luaXRpYWxSZW5kZXIgJiZcbiAgICAgICAgICAgICAgICB2aXN1YWxFbGVtZW50Lm1hbnVhbGx5QW5pbWF0ZU9uTW91bnQpIHtcbiAgICAgICAgICAgICAgICBpc0luaGVyaXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTZXQgYWxsIGVuY291bnRlcmVkIGtleXMgc28gZmFyIGFzIHRoZSBwcm90ZWN0ZWQga2V5cyBmb3IgdGhpcyB0eXBlLiBUaGlzIHdpbGxcbiAgICAgICAgICAgICAqIGJlIGFueSBrZXkgdGhhdCBoYXMgYmVlbiBhbmltYXRlZCBvciBvdGhlcndpc2UgaGFuZGxlZCBieSBhY3RpdmUsIGhpZ2hlci1wcmlvcnRpeSB0eXBlcy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdHlwZVN0YXRlLnByb3RlY3RlZEtleXMgPSB7IC4uLmVuY291bnRlcmVkS2V5cyB9O1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UgY2FuIHNraXAgYW5hbHlzaW5nIHRoaXMgcHJvcCBlYXJseVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgLy8gSWYgaXQgaXNuJ3QgYWN0aXZlIGFuZCBoYXNuJ3QgKmp1c3QqIGJlZW4gc2V0IGFzIGluYWN0aXZlXG4gICAgICAgICAgICAoIXR5cGVTdGF0ZS5pc0FjdGl2ZSAmJiBhY3RpdmVEZWx0YSA9PT0gbnVsbCkgfHxcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBkaWRuJ3QgYW5kIGRvbid0IGhhdmUgYW55IGRlZmluZWQgcHJvcCBmb3IgdGhpcyBhbmltYXRpb24gdHlwZVxuICAgICAgICAgICAgICAgICghcHJvcCAmJiAhdHlwZVN0YXRlLnByZXZQcm9wKSB8fFxuICAgICAgICAgICAgICAgIC8vIE9yIGlmIHRoZSBwcm9wIGRvZXNuJ3QgZGVmaW5lIGFuIGFuaW1hdGlvblxuICAgICAgICAgICAgICAgIGlzQW5pbWF0aW9uQ29udHJvbHMocHJvcCkgfHxcbiAgICAgICAgICAgICAgICB0eXBlb2YgcHJvcCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQXMgd2UgZ28gbG9vayB0aHJvdWdoIHRoZSB2YWx1ZXMgZGVmaW5lZCBvbiB0aGlzIHR5cGUsIGlmIHdlIGRldGVjdFxuICAgICAgICAgICAgICogYSBjaGFuZ2VkIHZhbHVlIG9yIGEgdmFsdWUgdGhhdCB3YXMgcmVtb3ZlZCBpbiBhIGhpZ2hlciBwcmlvcml0eSwgd2Ugc2V0XG4gICAgICAgICAgICAgKiB0aGlzIHRvIHRydWUgYW5kIGFkZCB0aGlzIHByb3AgdG8gdGhlIGFuaW1hdGlvbiBsaXN0LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCB2YXJpYW50RGlkQ2hhbmdlID0gY2hlY2tWYXJpYW50c0RpZENoYW5nZSh0eXBlU3RhdGUucHJldlByb3AsIHByb3ApO1xuICAgICAgICAgICAgbGV0IHNob3VsZEFuaW1hdGVUeXBlID0gdmFyaWFudERpZENoYW5nZSB8fFxuICAgICAgICAgICAgICAgIC8vIElmIHdlJ3JlIG1ha2luZyB0aGlzIHZhcmlhbnQgYWN0aXZlLCB3ZSB3YW50IHRvIGFsd2F5cyBtYWtlIGl0IGFjdGl2ZVxuICAgICAgICAgICAgICAgICh0eXBlID09PSBjaGFuZ2VkQWN0aXZlVHlwZSAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlU3RhdGUuaXNBY3RpdmUgJiZcbiAgICAgICAgICAgICAgICAgICAgIWlzSW5oZXJpdGVkICYmXG4gICAgICAgICAgICAgICAgICAgIHByb3BJc1ZhcmlhbnQpIHx8XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVtb3ZlZCBhIGhpZ2hlci1wcmlvcml0eSB2YXJpYW50IChpIGlzIGluIHJldmVyc2Ugb3JkZXIpXG4gICAgICAgICAgICAgICAgKGkgPiByZW1vdmVkVmFyaWFudEluZGV4ICYmIHByb3BJc1ZhcmlhbnQpO1xuICAgICAgICAgICAgbGV0IGhhbmRsZWRSZW1vdmVkVmFsdWVzID0gZmFsc2U7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEFzIGFuaW1hdGlvbnMgY2FuIGJlIHNldCBhcyB2YXJpYW50IGxpc3RzLCB2YXJpYW50cyBvciB0YXJnZXQgb2JqZWN0cywgd2VcbiAgICAgICAgICAgICAqIGNvZXJjZSBldmVyeXRoaW5nIHRvIGFuIGFycmF5IGlmIGl0IGlzbid0IG9uZSBhbHJlYWR5XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IGRlZmluaXRpb25MaXN0ID0gQXJyYXkuaXNBcnJheShwcm9wKSA/IHByb3AgOiBbcHJvcF07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEJ1aWxkIGFuIG9iamVjdCBvZiBhbGwgdGhlIHJlc29sdmVkIHZhbHVlcy4gV2UnbGwgdXNlIHRoaXMgaW4gdGhlIHN1YnNlcXVlbnRcbiAgICAgICAgICAgICAqIGFuaW1hdGVDaGFuZ2VzIGNhbGxzIHRvIGRldGVybWluZSB3aGV0aGVyIGEgdmFsdWUgaGFzIGNoYW5nZWQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGxldCByZXNvbHZlZFZhbHVlcyA9IGRlZmluaXRpb25MaXN0LnJlZHVjZShidWlsZFJlc29sdmVkVHlwZVZhbHVlcyh0eXBlKSwge30pO1xuICAgICAgICAgICAgaWYgKGFjdGl2ZURlbHRhID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICByZXNvbHZlZFZhbHVlcyA9IHt9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBOb3cgd2UgbmVlZCB0byBsb29wIHRocm91Z2ggYWxsIHRoZSBrZXlzIGluIHRoZSBwcmV2IHByb3AgYW5kIHRoaXMgcHJvcCxcbiAgICAgICAgICAgICAqIGFuZCBkZWNpZGU6XG4gICAgICAgICAgICAgKiAxLiBJZiB0aGUgdmFsdWUgaGFzIGNoYW5nZWQsIGFuZCBuZWVkcyBhbmltYXRpbmdcbiAgICAgICAgICAgICAqIDIuIElmIGl0IGhhcyBiZWVuIHJlbW92ZWQsIGFuZCBuZWVkcyBhZGRpbmcgdG8gdGhlIHJlbW92ZWRLZXlzIHNldFxuICAgICAgICAgICAgICogMy4gSWYgaXQgaGFzIGJlZW4gcmVtb3ZlZCBpbiBhIGhpZ2hlciBwcmlvcml0eSB0eXBlIGFuZCBuZWVkcyBhbmltYXRpbmdcbiAgICAgICAgICAgICAqIDQuIElmIGl0IGhhc24ndCBiZWVuIHJlbW92ZWQgaW4gYSBoaWdoZXIgcHJpb3JpdHkgYnV0IGhhc24ndCBjaGFuZ2VkLCBhbmRcbiAgICAgICAgICAgICAqICAgIG5lZWRzIGFkZGluZyB0byB0aGUgdHlwZSdzIHByb3RlY3RlZEtleXMgbGlzdC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgeyBwcmV2UmVzb2x2ZWRWYWx1ZXMgPSB7fSB9ID0gdHlwZVN0YXRlO1xuICAgICAgICAgICAgY29uc3QgYWxsS2V5cyA9IHtcbiAgICAgICAgICAgICAgICAuLi5wcmV2UmVzb2x2ZWRWYWx1ZXMsXG4gICAgICAgICAgICAgICAgLi4ucmVzb2x2ZWRWYWx1ZXMsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgbWFya1RvQW5pbWF0ZSA9IChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBzaG91bGRBbmltYXRlVHlwZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHJlbW92ZWRLZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZWRSZW1vdmVkVmFsdWVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZEtleXMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHR5cGVTdGF0ZS5uZWVkc0FuaW1hdGluZ1trZXldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBtb3Rpb25WYWx1ZSA9IHZpc3VhbEVsZW1lbnQuZ2V0VmFsdWUoa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAobW90aW9uVmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIG1vdGlvblZhbHVlLmxpdmVTdHlsZSA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGFsbEtleXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gcmVzb2x2ZWRWYWx1ZXNba2V5XTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2ID0gcHJldlJlc29sdmVkVmFsdWVzW2tleV07XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBoYW5kbGVkIHRoaXMgd2UgY2FuIGp1c3Qgc2tpcCBhaGVhZFxuICAgICAgICAgICAgICAgIGlmIChlbmNvdW50ZXJlZEtleXMuaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogSWYgdGhlIHZhbHVlIGhhcyBjaGFuZ2VkLCB3ZSBwcm9iYWJseSB3YW50IHRvIGFuaW1hdGUgaXQuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlSGFzQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChpc0tleWZyYW1lc1RhcmdldChuZXh0KSAmJiBpc0tleWZyYW1lc1RhcmdldChwcmV2KSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZUhhc0NoYW5nZWQgPSAhc2hhbGxvd0NvbXBhcmUobmV4dCwgcHJldik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZUhhc0NoYW5nZWQgPSBuZXh0ICE9PSBwcmV2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWVIYXNDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ICE9PSB1bmRlZmluZWQgJiYgbmV4dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgbmV4dCBpcyBkZWZpbmVkIGFuZCBkb2Vzbid0IGVxdWFsIHByZXYsIGl0IG5lZWRzIGFuaW1hdGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFya1RvQW5pbWF0ZShrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgaXQncyB1bmRlZmluZWQsIGl0J3MgYmVlbiByZW1vdmVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZEtleXMuYWRkKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobmV4dCAhPT0gdW5kZWZpbmVkICYmIHJlbW92ZWRLZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBJZiBuZXh0IGhhc24ndCBjaGFuZ2VkIGFuZCBpdCBpc24ndCB1bmRlZmluZWQsIHdlIHdhbnQgdG8gY2hlY2sgaWYgaXQnc1xuICAgICAgICAgICAgICAgICAgICAgKiBiZWVuIHJlbW92ZWQgYnkgYSBoaWdoZXIgcHJpb3JpdHlcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIG1hcmtUb0FuaW1hdGUoa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBJZiBpdCBoYXNuJ3QgY2hhbmdlZCwgd2UgYWRkIGl0IHRvIHRoZSBsaXN0IG9mIHByb3RlY3RlZCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICogdG8gZW5zdXJlIGl0IGRvZXNuJ3QgZ2V0IGFuaW1hdGVkLlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgdHlwZVN0YXRlLnByb3RlY3RlZEtleXNba2V5XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBVcGRhdGUgdGhlIHR5cGVTdGF0ZSBzbyBuZXh0IHRpbWUgYW5pbWF0ZUNoYW5nZXMgaXMgY2FsbGVkIHdlIGNhbiBjb21wYXJlIHRoZVxuICAgICAgICAgICAgICogbGF0ZXN0IHByb3AgYW5kIHJlc29sdmVkVmFsdWVzIHRvIHRoZXNlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0eXBlU3RhdGUucHJldlByb3AgPSBwcm9wO1xuICAgICAgICAgICAgdHlwZVN0YXRlLnByZXZSZXNvbHZlZFZhbHVlcyA9IHJlc29sdmVkVmFsdWVzO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAodHlwZVN0YXRlLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgZW5jb3VudGVyZWRLZXlzID0geyAuLi5lbmNvdW50ZXJlZEtleXMsIC4uLnJlc29sdmVkVmFsdWVzIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNJbml0aWFsUmVuZGVyICYmIHZpc3VhbEVsZW1lbnQuYmxvY2tJbml0aWFsQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgc2hvdWxkQW5pbWF0ZVR5cGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgdGhpcyBpcyBhbiBpbmhlcml0ZWQgcHJvcCB3ZSB3YW50IHRvIHNraXAgdGhpcyBhbmltYXRpb25cbiAgICAgICAgICAgICAqIHVubGVzcyB0aGUgaW5oZXJpdGVkIHZhcmlhbnRzIGhhdmVuJ3QgY2hhbmdlZCBvbiB0aGlzIHJlbmRlci5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3Qgd2lsbEFuaW1hdGVWaWFQYXJlbnQgPSBpc0luaGVyaXRlZCAmJiB2YXJpYW50RGlkQ2hhbmdlO1xuICAgICAgICAgICAgY29uc3QgbmVlZHNBbmltYXRpbmcgPSAhd2lsbEFuaW1hdGVWaWFQYXJlbnQgfHwgaGFuZGxlZFJlbW92ZWRWYWx1ZXM7XG4gICAgICAgICAgICBpZiAoc2hvdWxkQW5pbWF0ZVR5cGUgJiYgbmVlZHNBbmltYXRpbmcpIHtcbiAgICAgICAgICAgICAgICBhbmltYXRpb25zLnB1c2goLi4uZGVmaW5pdGlvbkxpc3QubWFwKChhbmltYXRpb24pID0+ICh7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbjogYW5pbWF0aW9uLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiB7IHR5cGUgfSxcbiAgICAgICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGVyZSBhcmUgc29tZSByZW1vdmVkIHZhbHVlIHRoYXQgaGF2ZW4ndCBiZWVuIGRlYWx0IHdpdGgsXG4gICAgICAgICAqIHdlIG5lZWQgdG8gY3JlYXRlIGEgbmV3IGFuaW1hdGlvbiB0aGF0IGZhbGxzIGJhY2sgZWl0aGVyIHRvIHRoZSB2YWx1ZVxuICAgICAgICAgKiBkZWZpbmVkIGluIHRoZSBzdHlsZSBwcm9wLCBvciB0aGUgbGFzdCByZWFkIHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHJlbW92ZWRLZXlzLnNpemUpIHtcbiAgICAgICAgICAgIGNvbnN0IGZhbGxiYWNrQW5pbWF0aW9uID0ge307XG4gICAgICAgICAgICByZW1vdmVkS2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmYWxsYmFja1RhcmdldCA9IHZpc3VhbEVsZW1lbnQuZ2V0QmFzZVRhcmdldChrZXkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vdGlvblZhbHVlID0gdmlzdWFsRWxlbWVudC5nZXRWYWx1ZShrZXkpO1xuICAgICAgICAgICAgICAgIGlmIChtb3Rpb25WYWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgbW90aW9uVmFsdWUubGl2ZVN0eWxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gQG1hdHRncGVycnkgdG8gZmlndXJlIGlmIHdlIHNob3VsZCBkbyBzb21ldGhpbmcgaGVyZVxuICAgICAgICAgICAgICAgIGZhbGxiYWNrQW5pbWF0aW9uW2tleV0gPSBmYWxsYmFja1RhcmdldCAhPT0gbnVsbCAmJiBmYWxsYmFja1RhcmdldCAhPT0gdm9pZCAwID8gZmFsbGJhY2tUYXJnZXQgOiBudWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhbmltYXRpb25zLnB1c2goeyBhbmltYXRpb246IGZhbGxiYWNrQW5pbWF0aW9uIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzaG91bGRBbmltYXRlID0gQm9vbGVhbihhbmltYXRpb25zLmxlbmd0aCk7XG4gICAgICAgIGlmIChpc0luaXRpYWxSZW5kZXIgJiZcbiAgICAgICAgICAgIChwcm9wcy5pbml0aWFsID09PSBmYWxzZSB8fCBwcm9wcy5pbml0aWFsID09PSBwcm9wcy5hbmltYXRlKSAmJlxuICAgICAgICAgICAgIXZpc3VhbEVsZW1lbnQubWFudWFsbHlBbmltYXRlT25Nb3VudCkge1xuICAgICAgICAgICAgc2hvdWxkQW5pbWF0ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlzSW5pdGlhbFJlbmRlciA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gc2hvdWxkQW5pbWF0ZSA/IGFuaW1hdGUoYW5pbWF0aW9ucykgOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbmdlIHdoZXRoZXIgYSBjZXJ0YWluIGFuaW1hdGlvbiB0eXBlIGlzIGFjdGl2ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRBY3RpdmUodHlwZSwgaXNBY3RpdmUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBJZiB0aGUgYWN0aXZlIHN0YXRlIGhhc24ndCBjaGFuZ2VkLCB3ZSBjYW4gc2FmZWx5IGRvIG5vdGhpbmcgaGVyZVxuICAgICAgICBpZiAoc3RhdGVbdHlwZV0uaXNBY3RpdmUgPT09IGlzQWN0aXZlKVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAvLyBQcm9wYWdhdGUgYWN0aXZlIGNoYW5nZSB0byBjaGlsZHJlblxuICAgICAgICAoX2EgPSB2aXN1YWxFbGVtZW50LnZhcmlhbnRDaGlsZHJlbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvckVhY2goKGNoaWxkKSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IGNoaWxkLmFuaW1hdGlvblN0YXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0QWN0aXZlKHR5cGUsIGlzQWN0aXZlKTsgfSk7XG4gICAgICAgIHN0YXRlW3R5cGVdLmlzQWN0aXZlID0gaXNBY3RpdmU7XG4gICAgICAgIGNvbnN0IGFuaW1hdGlvbnMgPSBhbmltYXRlQ2hhbmdlcyh0eXBlKTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc3RhdGUpIHtcbiAgICAgICAgICAgIHN0YXRlW2tleV0ucHJvdGVjdGVkS2V5cyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbmltYXRpb25zO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBhbmltYXRlQ2hhbmdlcyxcbiAgICAgICAgc2V0QWN0aXZlLFxuICAgICAgICBzZXRBbmltYXRlRnVuY3Rpb24sXG4gICAgICAgIGdldFN0YXRlOiAoKSA9PiBzdGF0ZSxcbiAgICAgICAgcmVzZXQ6ICgpID0+IHtcbiAgICAgICAgICAgIHN0YXRlID0gY3JlYXRlU3RhdGUoKTtcbiAgICAgICAgICAgIGlzSW5pdGlhbFJlbmRlciA9IHRydWU7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNoZWNrVmFyaWFudHNEaWRDaGFuZ2UocHJldiwgbmV4dCkge1xuICAgIGlmICh0eXBlb2YgbmV4dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gbmV4dCAhPT0gcHJldjtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShuZXh0KSkge1xuICAgICAgICByZXR1cm4gIXNoYWxsb3dDb21wYXJlKG5leHQsIHByZXYpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjcmVhdGVUeXBlU3RhdGUoaXNBY3RpdmUgPSBmYWxzZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGlzQWN0aXZlLFxuICAgICAgICBwcm90ZWN0ZWRLZXlzOiB7fSxcbiAgICAgICAgbmVlZHNBbmltYXRpbmc6IHt9LFxuICAgICAgICBwcmV2UmVzb2x2ZWRWYWx1ZXM6IHt9LFxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVTdGF0ZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBhbmltYXRlOiBjcmVhdGVUeXBlU3RhdGUodHJ1ZSksXG4gICAgICAgIHdoaWxlSW5WaWV3OiBjcmVhdGVUeXBlU3RhdGUoKSxcbiAgICAgICAgd2hpbGVIb3ZlcjogY3JlYXRlVHlwZVN0YXRlKCksXG4gICAgICAgIHdoaWxlVGFwOiBjcmVhdGVUeXBlU3RhdGUoKSxcbiAgICAgICAgd2hpbGVEcmFnOiBjcmVhdGVUeXBlU3RhdGUoKSxcbiAgICAgICAgd2hpbGVGb2N1czogY3JlYXRlVHlwZVN0YXRlKCksXG4gICAgICAgIGV4aXQ6IGNyZWF0ZVR5cGVTdGF0ZSgpLFxuICAgIH07XG59XG5cbmNsYXNzIEZlYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG5vZGUpIHtcbiAgICAgICAgdGhpcy5pc01vdW50ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICB9XG4gICAgdXBkYXRlKCkgeyB9XG59XG5cbmNsYXNzIEFuaW1hdGlvbkZlYXR1cmUgZXh0ZW5kcyBGZWF0dXJlIHtcbiAgICAvKipcbiAgICAgKiBXZSBkeW5hbWljYWxseSBnZW5lcmF0ZSB0aGUgQW5pbWF0aW9uU3RhdGUgbWFuYWdlciBhcyBpdCBjb250YWlucyBhIHJlZmVyZW5jZVxuICAgICAqIHRvIHRoZSB1bmRlcmx5aW5nIGFuaW1hdGlvbiBsaWJyYXJ5LiBXZSBvbmx5IHdhbnQgdG8gbG9hZCB0aGF0IGlmIHdlIGxvYWQgdGhpcyxcbiAgICAgKiBzbyBwZW9wbGUgY2FuIG9wdGlvbmFsbHkgY29kZSBzcGxpdCBpdCBvdXQgdXNpbmcgdGhlIGBtYCBjb21wb25lbnQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iobm9kZSkge1xuICAgICAgICBzdXBlcihub2RlKTtcbiAgICAgICAgbm9kZS5hbmltYXRpb25TdGF0ZSB8fCAobm9kZS5hbmltYXRpb25TdGF0ZSA9IGNyZWF0ZUFuaW1hdGlvblN0YXRlKG5vZGUpKTtcbiAgICB9XG4gICAgdXBkYXRlQW5pbWF0aW9uQ29udHJvbHNTdWJzY3JpcHRpb24oKSB7XG4gICAgICAgIGNvbnN0IHsgYW5pbWF0ZSB9ID0gdGhpcy5ub2RlLmdldFByb3BzKCk7XG4gICAgICAgIGlmIChpc0FuaW1hdGlvbkNvbnRyb2xzKGFuaW1hdGUpKSB7XG4gICAgICAgICAgICB0aGlzLnVubW91bnRDb250cm9scyA9IGFuaW1hdGUuc3Vic2NyaWJlKHRoaXMubm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlIGFueSBwcm92aWRlZCBBbmltYXRpb25Db250cm9scyB0byB0aGUgY29tcG9uZW50J3MgVmlzdWFsRWxlbWVudFxuICAgICAqL1xuICAgIG1vdW50KCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUFuaW1hdGlvbkNvbnRyb2xzU3Vic2NyaXB0aW9uKCk7XG4gICAgfVxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgY29uc3QgeyBhbmltYXRlIH0gPSB0aGlzLm5vZGUuZ2V0UHJvcHMoKTtcbiAgICAgICAgY29uc3QgeyBhbmltYXRlOiBwcmV2QW5pbWF0ZSB9ID0gdGhpcy5ub2RlLnByZXZQcm9wcyB8fCB7fTtcbiAgICAgICAgaWYgKGFuaW1hdGUgIT09IHByZXZBbmltYXRlKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUFuaW1hdGlvbkNvbnRyb2xzU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdW5tb3VudCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLm5vZGUuYW5pbWF0aW9uU3RhdGUucmVzZXQoKTtcbiAgICAgICAgKF9hID0gdGhpcy51bm1vdW50Q29udHJvbHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMpO1xuICAgIH1cbn1cblxubGV0IGlkJDIgPSAwO1xuY2xhc3MgRXhpdEFuaW1hdGlvbkZlYXR1cmUgZXh0ZW5kcyBGZWF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5pZCA9IGlkJDIrKztcbiAgICB9XG4gICAgdXBkYXRlKCkge1xuICAgICAgICBpZiAoIXRoaXMubm9kZS5wcmVzZW5jZUNvbnRleHQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHsgaXNQcmVzZW50LCBvbkV4aXRDb21wbGV0ZSB9ID0gdGhpcy5ub2RlLnByZXNlbmNlQ29udGV4dDtcbiAgICAgICAgY29uc3QgeyBpc1ByZXNlbnQ6IHByZXZJc1ByZXNlbnQgfSA9IHRoaXMubm9kZS5wcmV2UHJlc2VuY2VDb250ZXh0IHx8IHt9O1xuICAgICAgICBpZiAoIXRoaXMubm9kZS5hbmltYXRpb25TdGF0ZSB8fCBpc1ByZXNlbnQgPT09IHByZXZJc1ByZXNlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleGl0QW5pbWF0aW9uID0gdGhpcy5ub2RlLmFuaW1hdGlvblN0YXRlLnNldEFjdGl2ZShcImV4aXRcIiwgIWlzUHJlc2VudCk7XG4gICAgICAgIGlmIChvbkV4aXRDb21wbGV0ZSAmJiAhaXNQcmVzZW50KSB7XG4gICAgICAgICAgICBleGl0QW5pbWF0aW9uLnRoZW4oKCkgPT4gb25FeGl0Q29tcGxldGUodGhpcy5pZCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1vdW50KCkge1xuICAgICAgICBjb25zdCB7IHJlZ2lzdGVyIH0gPSB0aGlzLm5vZGUucHJlc2VuY2VDb250ZXh0IHx8IHt9O1xuICAgICAgICBpZiAocmVnaXN0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMudW5tb3VudCA9IHJlZ2lzdGVyKHRoaXMuaWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVubW91bnQoKSB7IH1cbn1cblxuY29uc3QgYW5pbWF0aW9ucyA9IHtcbiAgICBhbmltYXRpb246IHtcbiAgICAgICAgRmVhdHVyZTogQW5pbWF0aW9uRmVhdHVyZSxcbiAgICB9LFxuICAgIGV4aXQ6IHtcbiAgICAgICAgRmVhdHVyZTogRXhpdEFuaW1hdGlvbkZlYXR1cmUsXG4gICAgfSxcbn07XG5cbmZ1bmN0aW9uIGV4dHJhY3RFdmVudEluZm8oZXZlbnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBwb2ludDoge1xuICAgICAgICAgICAgeDogZXZlbnQucGFnZVgsXG4gICAgICAgICAgICB5OiBldmVudC5wYWdlWSxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuY29uc3QgYWRkUG9pbnRlckluZm8gPSAoaGFuZGxlcikgPT4ge1xuICAgIHJldHVybiAoZXZlbnQpID0+IG1vdGlvbkRvbS5pc1ByaW1hcnlQb2ludGVyKGV2ZW50KSAmJiBoYW5kbGVyKGV2ZW50LCBleHRyYWN0RXZlbnRJbmZvKGV2ZW50KSk7XG59O1xuXG5mdW5jdGlvbiBhZGREb21FdmVudCh0YXJnZXQsIGV2ZW50TmFtZSwgaGFuZGxlciwgb3B0aW9ucyA9IHsgcGFzc2l2ZTogdHJ1ZSB9KSB7XG4gICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICByZXR1cm4gKCkgPT4gdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyKTtcbn1cblxuZnVuY3Rpb24gYWRkUG9pbnRlckV2ZW50KHRhcmdldCwgZXZlbnROYW1lLCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGFkZERvbUV2ZW50KHRhcmdldCwgZXZlbnROYW1lLCBhZGRQb2ludGVySW5mbyhoYW5kbGVyKSwgb3B0aW9ucyk7XG59XG5cbmNvbnN0IGRpc3RhbmNlID0gKGEsIGIpID0+IE1hdGguYWJzKGEgLSBiKTtcbmZ1bmN0aW9uIGRpc3RhbmNlMkQoYSwgYikge1xuICAgIC8vIE11bHRpLWRpbWVuc2lvbmFsXG4gICAgY29uc3QgeERlbHRhID0gZGlzdGFuY2UoYS54LCBiLngpO1xuICAgIGNvbnN0IHlEZWx0YSA9IGRpc3RhbmNlKGEueSwgYi55KTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHhEZWx0YSAqKiAyICsgeURlbHRhICoqIDIpO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jbGFzcyBQYW5TZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3RvcihldmVudCwgaGFuZGxlcnMsIHsgdHJhbnNmb3JtUGFnZVBvaW50LCBjb250ZXh0V2luZG93LCBkcmFnU25hcFRvT3JpZ2luID0gZmFsc2UsIH0gPSB7fSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YXJ0RXZlbnQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxhc3RNb3ZlRXZlbnQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxhc3RNb3ZlRXZlbnRJbmZvID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbnRleHRXaW5kb3cgPSB3aW5kb3c7XG4gICAgICAgIHRoaXMudXBkYXRlUG9pbnQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoISh0aGlzLmxhc3RNb3ZlRXZlbnQgJiYgdGhpcy5sYXN0TW92ZUV2ZW50SW5mbykpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgaW5mbyA9IGdldFBhbkluZm8odGhpcy5sYXN0TW92ZUV2ZW50SW5mbywgdGhpcy5oaXN0b3J5KTtcbiAgICAgICAgICAgIGNvbnN0IGlzUGFuU3RhcnRlZCA9IHRoaXMuc3RhcnRFdmVudCAhPT0gbnVsbDtcbiAgICAgICAgICAgIC8vIE9ubHkgc3RhcnQgcGFubmluZyBpZiB0aGUgb2Zmc2V0IGlzIGxhcmdlciB0aGFuIDMgcGl4ZWxzLiBJZiB3ZSBtYWtlIGl0XG4gICAgICAgICAgICAvLyBhbnkgbGFyZ2VyIHRoYW4gdGhpcyB3ZSdsbCB3YW50IHRvIHJlc2V0IHRoZSBwb2ludGVyIGhpc3RvcnlcbiAgICAgICAgICAgIC8vIG9uIHRoZSBmaXJzdCB1cGRhdGUgdG8gYXZvaWQgdmlzdWFsIHNuYXBwaW5nIHRvIHRoZSBjdXJzb2UuXG4gICAgICAgICAgICBjb25zdCBpc0Rpc3RhbmNlUGFzdFRocmVzaG9sZCA9IGRpc3RhbmNlMkQoaW5mby5vZmZzZXQsIHsgeDogMCwgeTogMCB9KSA+PSAzO1xuICAgICAgICAgICAgaWYgKCFpc1BhblN0YXJ0ZWQgJiYgIWlzRGlzdGFuY2VQYXN0VGhyZXNob2xkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IHsgcG9pbnQgfSA9IGluZm87XG4gICAgICAgICAgICBjb25zdCB7IHRpbWVzdGFtcCB9ID0gZnJhbWVEYXRhO1xuICAgICAgICAgICAgdGhpcy5oaXN0b3J5LnB1c2goeyAuLi5wb2ludCwgdGltZXN0YW1wIH0pO1xuICAgICAgICAgICAgY29uc3QgeyBvblN0YXJ0LCBvbk1vdmUgfSA9IHRoaXMuaGFuZGxlcnM7XG4gICAgICAgICAgICBpZiAoIWlzUGFuU3RhcnRlZCkge1xuICAgICAgICAgICAgICAgIG9uU3RhcnQgJiYgb25TdGFydCh0aGlzLmxhc3RNb3ZlRXZlbnQsIGluZm8pO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRFdmVudCA9IHRoaXMubGFzdE1vdmVFdmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uTW92ZSAmJiBvbk1vdmUodGhpcy5sYXN0TW92ZUV2ZW50LCBpbmZvKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVQb2ludGVyTW92ZSA9IChldmVudCwgaW5mbykgPT4ge1xuICAgICAgICAgICAgdGhpcy5sYXN0TW92ZUV2ZW50ID0gZXZlbnQ7XG4gICAgICAgICAgICB0aGlzLmxhc3RNb3ZlRXZlbnRJbmZvID0gdHJhbnNmb3JtUG9pbnQoaW5mbywgdGhpcy50cmFuc2Zvcm1QYWdlUG9pbnQpO1xuICAgICAgICAgICAgLy8gVGhyb3R0bGUgbW91c2UgbW92ZSBldmVudCB0byBvbmNlIHBlciBmcmFtZVxuICAgICAgICAgICAgZnJhbWUudXBkYXRlKHRoaXMudXBkYXRlUG9pbnQsIHRydWUpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVBvaW50ZXJVcCA9IChldmVudCwgaW5mbykgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbmQoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgb25FbmQsIG9uU2Vzc2lvbkVuZCwgcmVzdW1lQW5pbWF0aW9uIH0gPSB0aGlzLmhhbmRsZXJzO1xuICAgICAgICAgICAgaWYgKHRoaXMuZHJhZ1NuYXBUb09yaWdpbilcbiAgICAgICAgICAgICAgICByZXN1bWVBbmltYXRpb24gJiYgcmVzdW1lQW5pbWF0aW9uKCk7XG4gICAgICAgICAgICBpZiAoISh0aGlzLmxhc3RNb3ZlRXZlbnQgJiYgdGhpcy5sYXN0TW92ZUV2ZW50SW5mbykpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgcGFuSW5mbyA9IGdldFBhbkluZm8oZXZlbnQudHlwZSA9PT0gXCJwb2ludGVyY2FuY2VsXCJcbiAgICAgICAgICAgICAgICA/IHRoaXMubGFzdE1vdmVFdmVudEluZm9cbiAgICAgICAgICAgICAgICA6IHRyYW5zZm9ybVBvaW50KGluZm8sIHRoaXMudHJhbnNmb3JtUGFnZVBvaW50KSwgdGhpcy5oaXN0b3J5KTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXJ0RXZlbnQgJiYgb25FbmQpIHtcbiAgICAgICAgICAgICAgICBvbkVuZChldmVudCwgcGFuSW5mbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvblNlc3Npb25FbmQgJiYgb25TZXNzaW9uRW5kKGV2ZW50LCBwYW5JbmZvKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBtb3JlIHRoYW4gb25lIHRvdWNoLCBkb24ndCBzdGFydCBkZXRlY3RpbmcgdGhpcyBnZXN0dXJlXG4gICAgICAgIGlmICghbW90aW9uRG9tLmlzUHJpbWFyeVBvaW50ZXIoZXZlbnQpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmRyYWdTbmFwVG9PcmlnaW4gPSBkcmFnU25hcFRvT3JpZ2luO1xuICAgICAgICB0aGlzLmhhbmRsZXJzID0gaGFuZGxlcnM7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtUGFnZVBvaW50ID0gdHJhbnNmb3JtUGFnZVBvaW50O1xuICAgICAgICB0aGlzLmNvbnRleHRXaW5kb3cgPSBjb250ZXh0V2luZG93IHx8IHdpbmRvdztcbiAgICAgICAgY29uc3QgaW5mbyA9IGV4dHJhY3RFdmVudEluZm8oZXZlbnQpO1xuICAgICAgICBjb25zdCBpbml0aWFsSW5mbyA9IHRyYW5zZm9ybVBvaW50KGluZm8sIHRoaXMudHJhbnNmb3JtUGFnZVBvaW50KTtcbiAgICAgICAgY29uc3QgeyBwb2ludCB9ID0gaW5pdGlhbEluZm87XG4gICAgICAgIGNvbnN0IHsgdGltZXN0YW1wIH0gPSBmcmFtZURhdGE7XG4gICAgICAgIHRoaXMuaGlzdG9yeSA9IFt7IC4uLnBvaW50LCB0aW1lc3RhbXAgfV07XG4gICAgICAgIGNvbnN0IHsgb25TZXNzaW9uU3RhcnQgfSA9IGhhbmRsZXJzO1xuICAgICAgICBvblNlc3Npb25TdGFydCAmJlxuICAgICAgICAgICAgb25TZXNzaW9uU3RhcnQoZXZlbnQsIGdldFBhbkluZm8oaW5pdGlhbEluZm8sIHRoaXMuaGlzdG9yeSkpO1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVycyA9IHBpcGUoYWRkUG9pbnRlckV2ZW50KHRoaXMuY29udGV4dFdpbmRvdywgXCJwb2ludGVybW92ZVwiLCB0aGlzLmhhbmRsZVBvaW50ZXJNb3ZlKSwgYWRkUG9pbnRlckV2ZW50KHRoaXMuY29udGV4dFdpbmRvdywgXCJwb2ludGVydXBcIiwgdGhpcy5oYW5kbGVQb2ludGVyVXApLCBhZGRQb2ludGVyRXZlbnQodGhpcy5jb250ZXh0V2luZG93LCBcInBvaW50ZXJjYW5jZWxcIiwgdGhpcy5oYW5kbGVQb2ludGVyVXApKTtcbiAgICB9XG4gICAgdXBkYXRlSGFuZGxlcnMoaGFuZGxlcnMpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IGhhbmRsZXJzO1xuICAgIH1cbiAgICBlbmQoKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzICYmIHRoaXMucmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICAgIGNhbmNlbEZyYW1lKHRoaXMudXBkYXRlUG9pbnQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybVBvaW50KGluZm8sIHRyYW5zZm9ybVBhZ2VQb2ludCkge1xuICAgIHJldHVybiB0cmFuc2Zvcm1QYWdlUG9pbnQgPyB7IHBvaW50OiB0cmFuc2Zvcm1QYWdlUG9pbnQoaW5mby5wb2ludCkgfSA6IGluZm87XG59XG5mdW5jdGlvbiBzdWJ0cmFjdFBvaW50KGEsIGIpIHtcbiAgICByZXR1cm4geyB4OiBhLnggLSBiLngsIHk6IGEueSAtIGIueSB9O1xufVxuZnVuY3Rpb24gZ2V0UGFuSW5mbyh7IHBvaW50IH0sIGhpc3RvcnkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBwb2ludCxcbiAgICAgICAgZGVsdGE6IHN1YnRyYWN0UG9pbnQocG9pbnQsIGxhc3REZXZpY2VQb2ludChoaXN0b3J5KSksXG4gICAgICAgIG9mZnNldDogc3VidHJhY3RQb2ludChwb2ludCwgc3RhcnREZXZpY2VQb2ludChoaXN0b3J5KSksXG4gICAgICAgIHZlbG9jaXR5OiBnZXRWZWxvY2l0eShoaXN0b3J5LCAwLjEpLFxuICAgIH07XG59XG5mdW5jdGlvbiBzdGFydERldmljZVBvaW50KGhpc3RvcnkpIHtcbiAgICByZXR1cm4gaGlzdG9yeVswXTtcbn1cbmZ1bmN0aW9uIGxhc3REZXZpY2VQb2ludChoaXN0b3J5KSB7XG4gICAgcmV0dXJuIGhpc3RvcnlbaGlzdG9yeS5sZW5ndGggLSAxXTtcbn1cbmZ1bmN0aW9uIGdldFZlbG9jaXR5KGhpc3RvcnksIHRpbWVEZWx0YSkge1xuICAgIGlmIChoaXN0b3J5Lmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIHsgeDogMCwgeTogMCB9O1xuICAgIH1cbiAgICBsZXQgaSA9IGhpc3RvcnkubGVuZ3RoIC0gMTtcbiAgICBsZXQgdGltZXN0YW1wZWRQb2ludCA9IG51bGw7XG4gICAgY29uc3QgbGFzdFBvaW50ID0gbGFzdERldmljZVBvaW50KGhpc3RvcnkpO1xuICAgIHdoaWxlIChpID49IDApIHtcbiAgICAgICAgdGltZXN0YW1wZWRQb2ludCA9IGhpc3RvcnlbaV07XG4gICAgICAgIGlmIChsYXN0UG9pbnQudGltZXN0YW1wIC0gdGltZXN0YW1wZWRQb2ludC50aW1lc3RhbXAgPlxuICAgICAgICAgICAgc2Vjb25kc1RvTWlsbGlzZWNvbmRzKHRpbWVEZWx0YSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGktLTtcbiAgICB9XG4gICAgaWYgKCF0aW1lc3RhbXBlZFBvaW50KSB7XG4gICAgICAgIHJldHVybiB7IHg6IDAsIHk6IDAgfTtcbiAgICB9XG4gICAgY29uc3QgdGltZSA9IG1pbGxpc2Vjb25kc1RvU2Vjb25kcyhsYXN0UG9pbnQudGltZXN0YW1wIC0gdGltZXN0YW1wZWRQb2ludC50aW1lc3RhbXApO1xuICAgIGlmICh0aW1lID09PSAwKSB7XG4gICAgICAgIHJldHVybiB7IHg6IDAsIHk6IDAgfTtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudFZlbG9jaXR5ID0ge1xuICAgICAgICB4OiAobGFzdFBvaW50LnggLSB0aW1lc3RhbXBlZFBvaW50LngpIC8gdGltZSxcbiAgICAgICAgeTogKGxhc3RQb2ludC55IC0gdGltZXN0YW1wZWRQb2ludC55KSAvIHRpbWUsXG4gICAgfTtcbiAgICBpZiAoY3VycmVudFZlbG9jaXR5LnggPT09IEluZmluaXR5KSB7XG4gICAgICAgIGN1cnJlbnRWZWxvY2l0eS54ID0gMDtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRWZWxvY2l0eS55ID09PSBJbmZpbml0eSkge1xuICAgICAgICBjdXJyZW50VmVsb2NpdHkueSA9IDA7XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50VmVsb2NpdHk7XG59XG5cbmZ1bmN0aW9uIGlzUmVmT2JqZWN0KHJlZikge1xuICAgIHJldHVybiAocmVmICYmXG4gICAgICAgIHR5cGVvZiByZWYgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlZiwgXCJjdXJyZW50XCIpKTtcbn1cblxuY29uc3QgU0NBTEVfUFJFQ0lTSU9OID0gMC4wMDAxO1xuY29uc3QgU0NBTEVfTUlOID0gMSAtIFNDQUxFX1BSRUNJU0lPTjtcbmNvbnN0IFNDQUxFX01BWCA9IDEgKyBTQ0FMRV9QUkVDSVNJT047XG5jb25zdCBUUkFOU0xBVEVfUFJFQ0lTSU9OID0gMC4wMTtcbmNvbnN0IFRSQU5TTEFURV9NSU4gPSAwIC0gVFJBTlNMQVRFX1BSRUNJU0lPTjtcbmNvbnN0IFRSQU5TTEFURV9NQVggPSAwICsgVFJBTlNMQVRFX1BSRUNJU0lPTjtcbmZ1bmN0aW9uIGNhbGNMZW5ndGgoYXhpcykge1xuICAgIHJldHVybiBheGlzLm1heCAtIGF4aXMubWluO1xufVxuZnVuY3Rpb24gaXNOZWFyKHZhbHVlLCB0YXJnZXQsIG1heERpc3RhbmNlKSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKHZhbHVlIC0gdGFyZ2V0KSA8PSBtYXhEaXN0YW5jZTtcbn1cbmZ1bmN0aW9uIGNhbGNBeGlzRGVsdGEoZGVsdGEsIHNvdXJjZSwgdGFyZ2V0LCBvcmlnaW4gPSAwLjUpIHtcbiAgICBkZWx0YS5vcmlnaW4gPSBvcmlnaW47XG4gICAgZGVsdGEub3JpZ2luUG9pbnQgPSBtaXhOdW1iZXIkMShzb3VyY2UubWluLCBzb3VyY2UubWF4LCBkZWx0YS5vcmlnaW4pO1xuICAgIGRlbHRhLnNjYWxlID0gY2FsY0xlbmd0aCh0YXJnZXQpIC8gY2FsY0xlbmd0aChzb3VyY2UpO1xuICAgIGRlbHRhLnRyYW5zbGF0ZSA9XG4gICAgICAgIG1peE51bWJlciQxKHRhcmdldC5taW4sIHRhcmdldC5tYXgsIGRlbHRhLm9yaWdpbikgLSBkZWx0YS5vcmlnaW5Qb2ludDtcbiAgICBpZiAoKGRlbHRhLnNjYWxlID49IFNDQUxFX01JTiAmJiBkZWx0YS5zY2FsZSA8PSBTQ0FMRV9NQVgpIHx8XG4gICAgICAgIGlzTmFOKGRlbHRhLnNjYWxlKSkge1xuICAgICAgICBkZWx0YS5zY2FsZSA9IDEuMDtcbiAgICB9XG4gICAgaWYgKChkZWx0YS50cmFuc2xhdGUgPj0gVFJBTlNMQVRFX01JTiAmJlxuICAgICAgICBkZWx0YS50cmFuc2xhdGUgPD0gVFJBTlNMQVRFX01BWCkgfHxcbiAgICAgICAgaXNOYU4oZGVsdGEudHJhbnNsYXRlKSkge1xuICAgICAgICBkZWx0YS50cmFuc2xhdGUgPSAwLjA7XG4gICAgfVxufVxuZnVuY3Rpb24gY2FsY0JveERlbHRhKGRlbHRhLCBzb3VyY2UsIHRhcmdldCwgb3JpZ2luKSB7XG4gICAgY2FsY0F4aXNEZWx0YShkZWx0YS54LCBzb3VyY2UueCwgdGFyZ2V0LngsIG9yaWdpbiA/IG9yaWdpbi5vcmlnaW5YIDogdW5kZWZpbmVkKTtcbiAgICBjYWxjQXhpc0RlbHRhKGRlbHRhLnksIHNvdXJjZS55LCB0YXJnZXQueSwgb3JpZ2luID8gb3JpZ2luLm9yaWdpblkgOiB1bmRlZmluZWQpO1xufVxuZnVuY3Rpb24gY2FsY1JlbGF0aXZlQXhpcyh0YXJnZXQsIHJlbGF0aXZlLCBwYXJlbnQpIHtcbiAgICB0YXJnZXQubWluID0gcGFyZW50Lm1pbiArIHJlbGF0aXZlLm1pbjtcbiAgICB0YXJnZXQubWF4ID0gdGFyZ2V0Lm1pbiArIGNhbGNMZW5ndGgocmVsYXRpdmUpO1xufVxuZnVuY3Rpb24gY2FsY1JlbGF0aXZlQm94KHRhcmdldCwgcmVsYXRpdmUsIHBhcmVudCkge1xuICAgIGNhbGNSZWxhdGl2ZUF4aXModGFyZ2V0LngsIHJlbGF0aXZlLngsIHBhcmVudC54KTtcbiAgICBjYWxjUmVsYXRpdmVBeGlzKHRhcmdldC55LCByZWxhdGl2ZS55LCBwYXJlbnQueSk7XG59XG5mdW5jdGlvbiBjYWxjUmVsYXRpdmVBeGlzUG9zaXRpb24odGFyZ2V0LCBsYXlvdXQsIHBhcmVudCkge1xuICAgIHRhcmdldC5taW4gPSBsYXlvdXQubWluIC0gcGFyZW50Lm1pbjtcbiAgICB0YXJnZXQubWF4ID0gdGFyZ2V0Lm1pbiArIGNhbGNMZW5ndGgobGF5b3V0KTtcbn1cbmZ1bmN0aW9uIGNhbGNSZWxhdGl2ZVBvc2l0aW9uKHRhcmdldCwgbGF5b3V0LCBwYXJlbnQpIHtcbiAgICBjYWxjUmVsYXRpdmVBeGlzUG9zaXRpb24odGFyZ2V0LngsIGxheW91dC54LCBwYXJlbnQueCk7XG4gICAgY2FsY1JlbGF0aXZlQXhpc1Bvc2l0aW9uKHRhcmdldC55LCBsYXlvdXQueSwgcGFyZW50LnkpO1xufVxuXG4vKipcbiAqIEFwcGx5IGNvbnN0cmFpbnRzIHRvIGEgcG9pbnQuIFRoZXNlIGNvbnN0cmFpbnRzIGFyZSBib3RoIHBoeXNpY2FsIGFsb25nIGFuXG4gKiBheGlzLCBhbmQgYW4gZWxhc3RpYyBmYWN0b3IgdGhhdCBkZXRlcm1pbmVzIGhvdyBtdWNoIHRvIGNvbnN0cmFpbiB0aGUgcG9pbnRcbiAqIGJ5IGlmIGl0IGRvZXMgbGllIG91dHNpZGUgdGhlIGRlZmluZWQgcGFyYW1ldGVycy5cbiAqL1xuZnVuY3Rpb24gYXBwbHlDb25zdHJhaW50cyhwb2ludCwgeyBtaW4sIG1heCB9LCBlbGFzdGljKSB7XG4gICAgaWYgKG1pbiAhPT0gdW5kZWZpbmVkICYmIHBvaW50IDwgbWluKSB7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgYSBtaW4gcG9pbnQgZGVmaW5lZCwgYW5kIHRoaXMgaXMgb3V0c2lkZSBvZiB0aGF0LCBjb25zdHJhaW5cbiAgICAgICAgcG9pbnQgPSBlbGFzdGljXG4gICAgICAgICAgICA/IG1peE51bWJlciQxKG1pbiwgcG9pbnQsIGVsYXN0aWMubWluKVxuICAgICAgICAgICAgOiBNYXRoLm1heChwb2ludCwgbWluKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobWF4ICE9PSB1bmRlZmluZWQgJiYgcG9pbnQgPiBtYXgpIHtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIG1heCBwb2ludCBkZWZpbmVkLCBhbmQgdGhpcyBpcyBvdXRzaWRlIG9mIHRoYXQsIGNvbnN0cmFpblxuICAgICAgICBwb2ludCA9IGVsYXN0aWNcbiAgICAgICAgICAgID8gbWl4TnVtYmVyJDEobWF4LCBwb2ludCwgZWxhc3RpYy5tYXgpXG4gICAgICAgICAgICA6IE1hdGgubWluKHBvaW50LCBtYXgpO1xuICAgIH1cbiAgICByZXR1cm4gcG9pbnQ7XG59XG4vKipcbiAqIENhbGN1bGF0ZSBjb25zdHJhaW50cyBpbiB0ZXJtcyBvZiB0aGUgdmlld3BvcnQgd2hlbiBkZWZpbmVkIHJlbGF0aXZlbHkgdG8gdGhlXG4gKiBtZWFzdXJlZCBheGlzLiBUaGlzIGlzIG1lYXN1cmVkIGZyb20gdGhlIG5lYXJlc3QgZWRnZSwgc28gYSBtYXggY29uc3RyYWludCBvZiAyMDBcbiAqIG9uIGFuIGF4aXMgd2l0aCBhIG1heCB2YWx1ZSBvZiAzMDAgd291bGQgcmV0dXJuIGEgY29uc3RyYWludCBvZiA1MDAgLSBheGlzIGxlbmd0aFxuICovXG5mdW5jdGlvbiBjYWxjUmVsYXRpdmVBeGlzQ29uc3RyYWludHMoYXhpcywgbWluLCBtYXgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBtaW46IG1pbiAhPT0gdW5kZWZpbmVkID8gYXhpcy5taW4gKyBtaW4gOiB1bmRlZmluZWQsXG4gICAgICAgIG1heDogbWF4ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYXhpcy5tYXggKyBtYXggLSAoYXhpcy5tYXggLSBheGlzLm1pbilcbiAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgIH07XG59XG4vKipcbiAqIENhbGN1bGF0ZSBjb25zdHJhaW50cyBpbiB0ZXJtcyBvZiB0aGUgdmlld3BvcnQgd2hlblxuICogZGVmaW5lZCByZWxhdGl2ZWx5IHRvIHRoZSBtZWFzdXJlZCBib3VuZGluZyBib3guXG4gKi9cbmZ1bmN0aW9uIGNhbGNSZWxhdGl2ZUNvbnN0cmFpbnRzKGxheW91dEJveCwgeyB0b3AsIGxlZnQsIGJvdHRvbSwgcmlnaHQgfSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IGNhbGNSZWxhdGl2ZUF4aXNDb25zdHJhaW50cyhsYXlvdXRCb3gueCwgbGVmdCwgcmlnaHQpLFxuICAgICAgICB5OiBjYWxjUmVsYXRpdmVBeGlzQ29uc3RyYWludHMobGF5b3V0Qm94LnksIHRvcCwgYm90dG9tKSxcbiAgICB9O1xufVxuLyoqXG4gKiBDYWxjdWxhdGUgdmlld3BvcnQgY29uc3RyYWludHMgd2hlbiBkZWZpbmVkIGFzIGFub3RoZXIgdmlld3BvcnQtcmVsYXRpdmUgYXhpc1xuICovXG5mdW5jdGlvbiBjYWxjVmlld3BvcnRBeGlzQ29uc3RyYWludHMobGF5b3V0QXhpcywgY29uc3RyYWludHNBeGlzKSB7XG4gICAgbGV0IG1pbiA9IGNvbnN0cmFpbnRzQXhpcy5taW4gLSBsYXlvdXRBeGlzLm1pbjtcbiAgICBsZXQgbWF4ID0gY29uc3RyYWludHNBeGlzLm1heCAtIGxheW91dEF4aXMubWF4O1xuICAgIC8vIElmIHRoZSBjb25zdHJhaW50cyBheGlzIGlzIGFjdHVhbGx5IHNtYWxsZXIgdGhhbiB0aGUgbGF5b3V0IGF4aXMgdGhlbiB3ZSBjYW5cbiAgICAvLyBmbGlwIHRoZSBjb25zdHJhaW50c1xuICAgIGlmIChjb25zdHJhaW50c0F4aXMubWF4IC0gY29uc3RyYWludHNBeGlzLm1pbiA8XG4gICAgICAgIGxheW91dEF4aXMubWF4IC0gbGF5b3V0QXhpcy5taW4pIHtcbiAgICAgICAgW21pbiwgbWF4XSA9IFttYXgsIG1pbl07XG4gICAgfVxuICAgIHJldHVybiB7IG1pbiwgbWF4IH07XG59XG4vKipcbiAqIENhbGN1bGF0ZSB2aWV3cG9ydCBjb25zdHJhaW50cyB3aGVuIGRlZmluZWQgYXMgYW5vdGhlciB2aWV3cG9ydC1yZWxhdGl2ZSBib3hcbiAqL1xuZnVuY3Rpb24gY2FsY1ZpZXdwb3J0Q29uc3RyYWludHMobGF5b3V0Qm94LCBjb25zdHJhaW50c0JveCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IGNhbGNWaWV3cG9ydEF4aXNDb25zdHJhaW50cyhsYXlvdXRCb3gueCwgY29uc3RyYWludHNCb3gueCksXG4gICAgICAgIHk6IGNhbGNWaWV3cG9ydEF4aXNDb25zdHJhaW50cyhsYXlvdXRCb3gueSwgY29uc3RyYWludHNCb3gueSksXG4gICAgfTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlIGEgdHJhbnNmb3JtIG9yaWdpbiByZWxhdGl2ZSB0byB0aGUgc291cmNlIGF4aXMsIGJldHdlZW4gMC0xLCB0aGF0IHJlc3VsdHNcbiAqIGluIGFuIGFzdGhldGljYWxseSBwbGVhc2luZyBzY2FsZS90cmFuc2Zvcm0gbmVlZGVkIHRvIHByb2plY3QgZnJvbSBzb3VyY2UgdG8gdGFyZ2V0LlxuICovXG5mdW5jdGlvbiBjYWxjT3JpZ2luJDEoc291cmNlLCB0YXJnZXQpIHtcbiAgICBsZXQgb3JpZ2luID0gMC41O1xuICAgIGNvbnN0IHNvdXJjZUxlbmd0aCA9IGNhbGNMZW5ndGgoc291cmNlKTtcbiAgICBjb25zdCB0YXJnZXRMZW5ndGggPSBjYWxjTGVuZ3RoKHRhcmdldCk7XG4gICAgaWYgKHRhcmdldExlbmd0aCA+IHNvdXJjZUxlbmd0aCkge1xuICAgICAgICBvcmlnaW4gPSBwcm9ncmVzcyh0YXJnZXQubWluLCB0YXJnZXQubWF4IC0gc291cmNlTGVuZ3RoLCBzb3VyY2UubWluKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc291cmNlTGVuZ3RoID4gdGFyZ2V0TGVuZ3RoKSB7XG4gICAgICAgIG9yaWdpbiA9IHByb2dyZXNzKHNvdXJjZS5taW4sIHNvdXJjZS5tYXggLSB0YXJnZXRMZW5ndGgsIHRhcmdldC5taW4pO1xuICAgIH1cbiAgICByZXR1cm4gY2xhbXAoMCwgMSwgb3JpZ2luKTtcbn1cbi8qKlxuICogUmViYXNlIHRoZSBjYWxjdWxhdGVkIHZpZXdwb3J0IGNvbnN0cmFpbnRzIHJlbGF0aXZlIHRvIHRoZSBsYXlvdXQubWluIHBvaW50LlxuICovXG5mdW5jdGlvbiByZWJhc2VBeGlzQ29uc3RyYWludHMobGF5b3V0LCBjb25zdHJhaW50cykge1xuICAgIGNvbnN0IHJlbGF0aXZlQ29uc3RyYWludHMgPSB7fTtcbiAgICBpZiAoY29uc3RyYWludHMubWluICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVsYXRpdmVDb25zdHJhaW50cy5taW4gPSBjb25zdHJhaW50cy5taW4gLSBsYXlvdXQubWluO1xuICAgIH1cbiAgICBpZiAoY29uc3RyYWludHMubWF4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVsYXRpdmVDb25zdHJhaW50cy5tYXggPSBjb25zdHJhaW50cy5tYXggLSBsYXlvdXQubWluO1xuICAgIH1cbiAgICByZXR1cm4gcmVsYXRpdmVDb25zdHJhaW50cztcbn1cbmNvbnN0IGRlZmF1bHRFbGFzdGljID0gMC4zNTtcbi8qKlxuICogQWNjZXB0cyBhIGRyYWdFbGFzdGljIHByb3AgYW5kIHJldHVybnMgcmVzb2x2ZWQgZWxhc3RpYyB2YWx1ZXMgZm9yIGVhY2ggYXhpcy5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZURyYWdFbGFzdGljKGRyYWdFbGFzdGljID0gZGVmYXVsdEVsYXN0aWMpIHtcbiAgICBpZiAoZHJhZ0VsYXN0aWMgPT09IGZhbHNlKSB7XG4gICAgICAgIGRyYWdFbGFzdGljID0gMDtcbiAgICB9XG4gICAgZWxzZSBpZiAoZHJhZ0VsYXN0aWMgPT09IHRydWUpIHtcbiAgICAgICAgZHJhZ0VsYXN0aWMgPSBkZWZhdWx0RWxhc3RpYztcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogcmVzb2x2ZUF4aXNFbGFzdGljKGRyYWdFbGFzdGljLCBcImxlZnRcIiwgXCJyaWdodFwiKSxcbiAgICAgICAgeTogcmVzb2x2ZUF4aXNFbGFzdGljKGRyYWdFbGFzdGljLCBcInRvcFwiLCBcImJvdHRvbVwiKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gcmVzb2x2ZUF4aXNFbGFzdGljKGRyYWdFbGFzdGljLCBtaW5MYWJlbCwgbWF4TGFiZWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBtaW46IHJlc29sdmVQb2ludEVsYXN0aWMoZHJhZ0VsYXN0aWMsIG1pbkxhYmVsKSxcbiAgICAgICAgbWF4OiByZXNvbHZlUG9pbnRFbGFzdGljKGRyYWdFbGFzdGljLCBtYXhMYWJlbCksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVQb2ludEVsYXN0aWMoZHJhZ0VsYXN0aWMsIGxhYmVsKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBkcmFnRWxhc3RpYyA9PT0gXCJudW1iZXJcIlxuICAgICAgICA/IGRyYWdFbGFzdGljXG4gICAgICAgIDogZHJhZ0VsYXN0aWNbbGFiZWxdIHx8IDA7XG59XG5cbmNvbnN0IGNyZWF0ZUF4aXNEZWx0YSA9ICgpID0+ICh7XG4gICAgdHJhbnNsYXRlOiAwLFxuICAgIHNjYWxlOiAxLFxuICAgIG9yaWdpbjogMCxcbiAgICBvcmlnaW5Qb2ludDogMCxcbn0pO1xuY29uc3QgY3JlYXRlRGVsdGEgPSAoKSA9PiAoe1xuICAgIHg6IGNyZWF0ZUF4aXNEZWx0YSgpLFxuICAgIHk6IGNyZWF0ZUF4aXNEZWx0YSgpLFxufSk7XG5jb25zdCBjcmVhdGVBeGlzID0gKCkgPT4gKHsgbWluOiAwLCBtYXg6IDAgfSk7XG5jb25zdCBjcmVhdGVCb3ggPSAoKSA9PiAoe1xuICAgIHg6IGNyZWF0ZUF4aXMoKSxcbiAgICB5OiBjcmVhdGVBeGlzKCksXG59KTtcblxuZnVuY3Rpb24gZWFjaEF4aXMoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gW2NhbGxiYWNrKFwieFwiKSwgY2FsbGJhY2soXCJ5XCIpXTtcbn1cblxuLyoqXG4gKiBCb3VuZGluZyBib3hlcyB0ZW5kIHRvIGJlIGRlZmluZWQgYXMgdG9wLCBsZWZ0LCByaWdodCwgYm90dG9tLiBGb3IgdmFyaW91cyBvcGVyYXRpb25zXG4gKiBpdCdzIGVhc2llciB0byBjb25zaWRlciBlYWNoIGF4aXMgaW5kaXZpZHVhbGx5LiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYSBib3VuZGluZyBib3hcbiAqIGFzIGEgbWFwIG9mIHNpbmdsZS1heGlzIG1pbi9tYXggdmFsdWVzLlxuICovXG5mdW5jdGlvbiBjb252ZXJ0Qm91bmRpbmdCb3hUb0JveCh7IHRvcCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgfSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IHsgbWluOiBsZWZ0LCBtYXg6IHJpZ2h0IH0sXG4gICAgICAgIHk6IHsgbWluOiB0b3AsIG1heDogYm90dG9tIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRCb3hUb0JvdW5kaW5nQm94KHsgeCwgeSB9KSB7XG4gICAgcmV0dXJuIHsgdG9wOiB5Lm1pbiwgcmlnaHQ6IHgubWF4LCBib3R0b206IHkubWF4LCBsZWZ0OiB4Lm1pbiB9O1xufVxuLyoqXG4gKiBBcHBsaWVzIGEgVHJhbnNmb3JtUG9pbnQgZnVuY3Rpb24gdG8gYSBib3VuZGluZyBib3guIFRyYW5zZm9ybVBvaW50IGlzIHVzdWFsbHkgYSBmdW5jdGlvblxuICogcHJvdmlkZWQgYnkgRnJhbWVyIHRvIGFsbG93IG1lYXN1cmVkIHBvaW50cyB0byBiZSBjb3JyZWN0ZWQgZm9yIGRldmljZSBzY2FsaW5nLiBUaGlzIGlzIHVzZWRcbiAqIHdoZW4gbWVhc3VyaW5nIERPTSBlbGVtZW50cyBhbmQgRE9NIGV2ZW50IHBvaW50cy5cbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtQm94UG9pbnRzKHBvaW50LCB0cmFuc2Zvcm1Qb2ludCkge1xuICAgIGlmICghdHJhbnNmb3JtUG9pbnQpXG4gICAgICAgIHJldHVybiBwb2ludDtcbiAgICBjb25zdCB0b3BMZWZ0ID0gdHJhbnNmb3JtUG9pbnQoeyB4OiBwb2ludC5sZWZ0LCB5OiBwb2ludC50b3AgfSk7XG4gICAgY29uc3QgYm90dG9tUmlnaHQgPSB0cmFuc2Zvcm1Qb2ludCh7IHg6IHBvaW50LnJpZ2h0LCB5OiBwb2ludC5ib3R0b20gfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiB0b3BMZWZ0LnksXG4gICAgICAgIGxlZnQ6IHRvcExlZnQueCxcbiAgICAgICAgYm90dG9tOiBib3R0b21SaWdodC55LFxuICAgICAgICByaWdodDogYm90dG9tUmlnaHQueCxcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBpc0lkZW50aXR5U2NhbGUoc2NhbGUpIHtcbiAgICByZXR1cm4gc2NhbGUgPT09IHVuZGVmaW5lZCB8fCBzY2FsZSA9PT0gMTtcbn1cbmZ1bmN0aW9uIGhhc1NjYWxlKHsgc2NhbGUsIHNjYWxlWCwgc2NhbGVZIH0pIHtcbiAgICByZXR1cm4gKCFpc0lkZW50aXR5U2NhbGUoc2NhbGUpIHx8XG4gICAgICAgICFpc0lkZW50aXR5U2NhbGUoc2NhbGVYKSB8fFxuICAgICAgICAhaXNJZGVudGl0eVNjYWxlKHNjYWxlWSkpO1xufVxuZnVuY3Rpb24gaGFzVHJhbnNmb3JtKHZhbHVlcykge1xuICAgIHJldHVybiAoaGFzU2NhbGUodmFsdWVzKSB8fFxuICAgICAgICBoYXMyRFRyYW5zbGF0ZSh2YWx1ZXMpIHx8XG4gICAgICAgIHZhbHVlcy56IHx8XG4gICAgICAgIHZhbHVlcy5yb3RhdGUgfHxcbiAgICAgICAgdmFsdWVzLnJvdGF0ZVggfHxcbiAgICAgICAgdmFsdWVzLnJvdGF0ZVkgfHxcbiAgICAgICAgdmFsdWVzLnNrZXdYIHx8XG4gICAgICAgIHZhbHVlcy5za2V3WSk7XG59XG5mdW5jdGlvbiBoYXMyRFRyYW5zbGF0ZSh2YWx1ZXMpIHtcbiAgICByZXR1cm4gaXMyRFRyYW5zbGF0ZSh2YWx1ZXMueCkgfHwgaXMyRFRyYW5zbGF0ZSh2YWx1ZXMueSk7XG59XG5mdW5jdGlvbiBpczJEVHJhbnNsYXRlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICYmIHZhbHVlICE9PSBcIjAlXCI7XG59XG5cbi8qKlxuICogU2NhbGVzIGEgcG9pbnQgYmFzZWQgb24gYSBmYWN0b3IgYW5kIGFuIG9yaWdpblBvaW50XG4gKi9cbmZ1bmN0aW9uIHNjYWxlUG9pbnQocG9pbnQsIHNjYWxlLCBvcmlnaW5Qb2ludCkge1xuICAgIGNvbnN0IGRpc3RhbmNlRnJvbU9yaWdpbiA9IHBvaW50IC0gb3JpZ2luUG9pbnQ7XG4gICAgY29uc3Qgc2NhbGVkID0gc2NhbGUgKiBkaXN0YW5jZUZyb21PcmlnaW47XG4gICAgcmV0dXJuIG9yaWdpblBvaW50ICsgc2NhbGVkO1xufVxuLyoqXG4gKiBBcHBsaWVzIGEgdHJhbnNsYXRlL3NjYWxlIGRlbHRhIHRvIGEgcG9pbnRcbiAqL1xuZnVuY3Rpb24gYXBwbHlQb2ludERlbHRhKHBvaW50LCB0cmFuc2xhdGUsIHNjYWxlLCBvcmlnaW5Qb2ludCwgYm94U2NhbGUpIHtcbiAgICBpZiAoYm94U2NhbGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwb2ludCA9IHNjYWxlUG9pbnQocG9pbnQsIGJveFNjYWxlLCBvcmlnaW5Qb2ludCk7XG4gICAgfVxuICAgIHJldHVybiBzY2FsZVBvaW50KHBvaW50LCBzY2FsZSwgb3JpZ2luUG9pbnQpICsgdHJhbnNsYXRlO1xufVxuLyoqXG4gKiBBcHBsaWVzIGEgdHJhbnNsYXRlL3NjYWxlIGRlbHRhIHRvIGFuIGF4aXNcbiAqL1xuZnVuY3Rpb24gYXBwbHlBeGlzRGVsdGEoYXhpcywgdHJhbnNsYXRlID0gMCwgc2NhbGUgPSAxLCBvcmlnaW5Qb2ludCwgYm94U2NhbGUpIHtcbiAgICBheGlzLm1pbiA9IGFwcGx5UG9pbnREZWx0YShheGlzLm1pbiwgdHJhbnNsYXRlLCBzY2FsZSwgb3JpZ2luUG9pbnQsIGJveFNjYWxlKTtcbiAgICBheGlzLm1heCA9IGFwcGx5UG9pbnREZWx0YShheGlzLm1heCwgdHJhbnNsYXRlLCBzY2FsZSwgb3JpZ2luUG9pbnQsIGJveFNjYWxlKTtcbn1cbi8qKlxuICogQXBwbGllcyBhIHRyYW5zbGF0ZS9zY2FsZSBkZWx0YSB0byBhIGJveFxuICovXG5mdW5jdGlvbiBhcHBseUJveERlbHRhKGJveCwgeyB4LCB5IH0pIHtcbiAgICBhcHBseUF4aXNEZWx0YShib3gueCwgeC50cmFuc2xhdGUsIHguc2NhbGUsIHgub3JpZ2luUG9pbnQpO1xuICAgIGFwcGx5QXhpc0RlbHRhKGJveC55LCB5LnRyYW5zbGF0ZSwgeS5zY2FsZSwgeS5vcmlnaW5Qb2ludCk7XG59XG5jb25zdCBUUkVFX1NDQUxFX1NOQVBfTUlOID0gMC45OTk5OTk5OTk5OTk7XG5jb25zdCBUUkVFX1NDQUxFX1NOQVBfTUFYID0gMS4wMDAwMDAwMDAwMDAxO1xuLyoqXG4gKiBBcHBseSBhIHRyZWUgb2YgZGVsdGFzIHRvIGEgYm94LiBXZSBkbyB0aGlzIHRvIGNhbGN1bGF0ZSB0aGUgZWZmZWN0IG9mIGFsbCB0aGUgdHJhbnNmb3Jtc1xuICogaW4gYSB0cmVlIHVwb24gb3VyIGJveCBiZWZvcmUgdGhlbiBjYWxjdWxhdGluZyBob3cgdG8gcHJvamVjdCBpdCBpbnRvIG91ciBkZXNpcmVkIHZpZXdwb3J0LXJlbGF0aXZlIGJveFxuICpcbiAqIFRoaXMgaXMgdGhlIGZpbmFsIG5lc3RlZCBsb29wIHdpdGhpbiB1cGRhdGVMYXlvdXREZWx0YSBmb3IgZnV0dXJlIHJlZmFjdG9yaW5nXG4gKi9cbmZ1bmN0aW9uIGFwcGx5VHJlZURlbHRhcyhib3gsIHRyZWVTY2FsZSwgdHJlZVBhdGgsIGlzU2hhcmVkVHJhbnNpdGlvbiA9IGZhbHNlKSB7XG4gICAgY29uc3QgdHJlZUxlbmd0aCA9IHRyZWVQYXRoLmxlbmd0aDtcbiAgICBpZiAoIXRyZWVMZW5ndGgpXG4gICAgICAgIHJldHVybjtcbiAgICAvLyBSZXNldCB0aGUgdHJlZVNjYWxlXG4gICAgdHJlZVNjYWxlLnggPSB0cmVlU2NhbGUueSA9IDE7XG4gICAgbGV0IG5vZGU7XG4gICAgbGV0IGRlbHRhO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJlZUxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5vZGUgPSB0cmVlUGF0aFtpXTtcbiAgICAgICAgZGVsdGEgPSBub2RlLnByb2plY3Rpb25EZWx0YTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRPRE86IFByZWZlciB0byByZW1vdmUgdGhpcywgYnV0IGN1cnJlbnRseSB3ZSBoYXZlIG1vdGlvbiBjb21wb25lbnRzIHdpdGhcbiAgICAgICAgICogZGlzcGxheTogY29udGVudHMgaW4gRnJhbWVyLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgeyB2aXN1YWxFbGVtZW50IH0gPSBub2RlLm9wdGlvbnM7XG4gICAgICAgIGlmICh2aXN1YWxFbGVtZW50ICYmXG4gICAgICAgICAgICB2aXN1YWxFbGVtZW50LnByb3BzLnN0eWxlICYmXG4gICAgICAgICAgICB2aXN1YWxFbGVtZW50LnByb3BzLnN0eWxlLmRpc3BsYXkgPT09IFwiY29udGVudHNcIikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU2hhcmVkVHJhbnNpdGlvbiAmJlxuICAgICAgICAgICAgbm9kZS5vcHRpb25zLmxheW91dFNjcm9sbCAmJlxuICAgICAgICAgICAgbm9kZS5zY3JvbGwgJiZcbiAgICAgICAgICAgIG5vZGUgIT09IG5vZGUucm9vdCkge1xuICAgICAgICAgICAgdHJhbnNmb3JtQm94KGJveCwge1xuICAgICAgICAgICAgICAgIHg6IC1ub2RlLnNjcm9sbC5vZmZzZXQueCxcbiAgICAgICAgICAgICAgICB5OiAtbm9kZS5zY3JvbGwub2Zmc2V0LnksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVsdGEpIHtcbiAgICAgICAgICAgIC8vIEluY29wb3JhdGUgZWFjaCBhbmNlc3RvcidzIHNjYWxlIGludG8gYSBjdWxtdWxhdGl2ZSB0cmVlU2NhbGUgZm9yIHRoaXMgY29tcG9uZW50XG4gICAgICAgICAgICB0cmVlU2NhbGUueCAqPSBkZWx0YS54LnNjYWxlO1xuICAgICAgICAgICAgdHJlZVNjYWxlLnkgKj0gZGVsdGEueS5zY2FsZTtcbiAgICAgICAgICAgIC8vIEFwcGx5IGVhY2ggYW5jZXN0b3IncyBjYWxjdWxhdGVkIGRlbHRhIGludG8gdGhpcyBjb21wb25lbnQncyByZWNvcmRlZCBsYXlvdXQgYm94XG4gICAgICAgICAgICBhcHBseUJveERlbHRhKGJveCwgZGVsdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1NoYXJlZFRyYW5zaXRpb24gJiYgaGFzVHJhbnNmb3JtKG5vZGUubGF0ZXN0VmFsdWVzKSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtQm94KGJveCwgbm9kZS5sYXRlc3RWYWx1ZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNuYXAgdHJlZSBzY2FsZSBiYWNrIHRvIDEgaWYgaXQncyB3aXRoaW4gYSBub24tcGVyY2VpdmFibGUgdGhyZXNob2xkLlxuICAgICAqIFRoaXMgd2lsbCBoZWxwIHJlZHVjZSB1c2VsZXNzIHNjYWxlcyBnZXR0aW5nIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIGlmICh0cmVlU2NhbGUueCA8IFRSRUVfU0NBTEVfU05BUF9NQVggJiZcbiAgICAgICAgdHJlZVNjYWxlLnggPiBUUkVFX1NDQUxFX1NOQVBfTUlOKSB7XG4gICAgICAgIHRyZWVTY2FsZS54ID0gMS4wO1xuICAgIH1cbiAgICBpZiAodHJlZVNjYWxlLnkgPCBUUkVFX1NDQUxFX1NOQVBfTUFYICYmXG4gICAgICAgIHRyZWVTY2FsZS55ID4gVFJFRV9TQ0FMRV9TTkFQX01JTikge1xuICAgICAgICB0cmVlU2NhbGUueSA9IDEuMDtcbiAgICB9XG59XG5mdW5jdGlvbiB0cmFuc2xhdGVBeGlzKGF4aXMsIGRpc3RhbmNlKSB7XG4gICAgYXhpcy5taW4gPSBheGlzLm1pbiArIGRpc3RhbmNlO1xuICAgIGF4aXMubWF4ID0gYXhpcy5tYXggKyBkaXN0YW5jZTtcbn1cbi8qKlxuICogQXBwbHkgYSB0cmFuc2Zvcm0gdG8gYW4gYXhpcyBmcm9tIHRoZSBsYXRlc3QgcmVzb2x2ZWQgbW90aW9uIHZhbHVlcy5cbiAqIFRoaXMgZnVuY3Rpb24gYmFzaWNhbGx5IGFjdHMgYXMgYSBicmlkZ2UgYmV0d2VlbiBhIGZsYXQgbW90aW9uIHZhbHVlIG1hcFxuICogYW5kIGFwcGx5QXhpc0RlbHRhXG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybUF4aXMoYXhpcywgYXhpc1RyYW5zbGF0ZSwgYXhpc1NjYWxlLCBib3hTY2FsZSwgYXhpc09yaWdpbiA9IDAuNSkge1xuICAgIGNvbnN0IG9yaWdpblBvaW50ID0gbWl4TnVtYmVyJDEoYXhpcy5taW4sIGF4aXMubWF4LCBheGlzT3JpZ2luKTtcbiAgICAvLyBBcHBseSB0aGUgYXhpcyBkZWx0YSB0byB0aGUgZmluYWwgYXhpc1xuICAgIGFwcGx5QXhpc0RlbHRhKGF4aXMsIGF4aXNUcmFuc2xhdGUsIGF4aXNTY2FsZSwgb3JpZ2luUG9pbnQsIGJveFNjYWxlKTtcbn1cbi8qKlxuICogQXBwbHkgYSB0cmFuc2Zvcm0gdG8gYSBib3ggZnJvbSB0aGUgbGF0ZXN0IHJlc29sdmVkIG1vdGlvbiB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybUJveChib3gsIHRyYW5zZm9ybSkge1xuICAgIHRyYW5zZm9ybUF4aXMoYm94LngsIHRyYW5zZm9ybS54LCB0cmFuc2Zvcm0uc2NhbGVYLCB0cmFuc2Zvcm0uc2NhbGUsIHRyYW5zZm9ybS5vcmlnaW5YKTtcbiAgICB0cmFuc2Zvcm1BeGlzKGJveC55LCB0cmFuc2Zvcm0ueSwgdHJhbnNmb3JtLnNjYWxlWSwgdHJhbnNmb3JtLnNjYWxlLCB0cmFuc2Zvcm0ub3JpZ2luWSk7XG59XG5cbmZ1bmN0aW9uIG1lYXN1cmVWaWV3cG9ydEJveChpbnN0YW5jZSwgdHJhbnNmb3JtUG9pbnQpIHtcbiAgICByZXR1cm4gY29udmVydEJvdW5kaW5nQm94VG9Cb3godHJhbnNmb3JtQm94UG9pbnRzKGluc3RhbmNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCB0cmFuc2Zvcm1Qb2ludCkpO1xufVxuZnVuY3Rpb24gbWVhc3VyZVBhZ2VCb3goZWxlbWVudCwgcm9vdFByb2plY3Rpb25Ob2RlLCB0cmFuc2Zvcm1QYWdlUG9pbnQpIHtcbiAgICBjb25zdCB2aWV3cG9ydEJveCA9IG1lYXN1cmVWaWV3cG9ydEJveChlbGVtZW50LCB0cmFuc2Zvcm1QYWdlUG9pbnQpO1xuICAgIGNvbnN0IHsgc2Nyb2xsIH0gPSByb290UHJvamVjdGlvbk5vZGU7XG4gICAgaWYgKHNjcm9sbCkge1xuICAgICAgICB0cmFuc2xhdGVBeGlzKHZpZXdwb3J0Qm94LngsIHNjcm9sbC5vZmZzZXQueCk7XG4gICAgICAgIHRyYW5zbGF0ZUF4aXModmlld3BvcnRCb3gueSwgc2Nyb2xsLm9mZnNldC55KTtcbiAgICB9XG4gICAgcmV0dXJuIHZpZXdwb3J0Qm94O1xufVxuXG4vLyBGaXhlcyBodHRwczovL2dpdGh1Yi5jb20vbW90aW9uZGl2aXNpb24vbW90aW9uL2lzc3Vlcy8yMjcwXG5jb25zdCBnZXRDb250ZXh0V2luZG93ID0gKHsgY3VycmVudCB9KSA9PiB7XG4gICAgcmV0dXJuIGN1cnJlbnQgPyBjdXJyZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgOiBudWxsO1xufTtcblxuY29uc3QgZWxlbWVudERyYWdDb250cm9scyA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbiAqXG4gKi9cbi8vIGxldCBsYXRlc3RQb2ludGVyRXZlbnQ6IFBvaW50ZXJFdmVudFxuY2xhc3MgVmlzdWFsRWxlbWVudERyYWdDb250cm9scyB7XG4gICAgY29uc3RydWN0b3IodmlzdWFsRWxlbWVudCkge1xuICAgICAgICB0aGlzLm9wZW5EcmFnTG9jayA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmN1cnJlbnREaXJlY3Rpb24gPSBudWxsO1xuICAgICAgICB0aGlzLm9yaWdpblBvaW50ID0geyB4OiAwLCB5OiAwIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcGVybWl0dGVkIGJvdW5kYXJpZXMgb2YgdHJhdmVsLCBpbiBwaXhlbHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbnN0cmFpbnRzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGFzTXV0YXRlZENvbnN0cmFpbnRzID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcGVyLWF4aXMgcmVzb2x2ZWQgZWxhc3RpYyB2YWx1ZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVsYXN0aWMgPSBjcmVhdGVCb3goKTtcbiAgICAgICAgdGhpcy52aXN1YWxFbGVtZW50ID0gdmlzdWFsRWxlbWVudDtcbiAgICB9XG4gICAgc3RhcnQob3JpZ2luRXZlbnQsIHsgc25hcFRvQ3Vyc29yID0gZmFsc2UgfSA9IHt9KSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEb24ndCBzdGFydCBkcmFnZ2luZyBpZiB0aGlzIGNvbXBvbmVudCBpcyBleGl0aW5nXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCB7IHByZXNlbmNlQ29udGV4dCB9ID0gdGhpcy52aXN1YWxFbGVtZW50O1xuICAgICAgICBpZiAocHJlc2VuY2VDb250ZXh0ICYmIHByZXNlbmNlQ29udGV4dC5pc1ByZXNlbnQgPT09IGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBvblNlc3Npb25TdGFydCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBkcmFnU25hcFRvT3JpZ2luIH0gPSB0aGlzLmdldFByb3BzKCk7XG4gICAgICAgICAgICAvLyBTdG9wIG9yIHBhdXNlIGFueSBhbmltYXRpb25zIG9uIGJvdGggYXhpcyB2YWx1ZXMgaW1tZWRpYXRlbHkuIFRoaXMgYWxsb3dzIHRoZSB1c2VyIHRvIHRocm93IGFuZCBjYXRjaFxuICAgICAgICAgICAgLy8gdGhlIGNvbXBvbmVudC5cbiAgICAgICAgICAgIGRyYWdTbmFwVG9PcmlnaW4gPyB0aGlzLnBhdXNlQW5pbWF0aW9uKCkgOiB0aGlzLnN0b3BBbmltYXRpb24oKTtcbiAgICAgICAgICAgIGlmIChzbmFwVG9DdXJzb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNuYXBUb0N1cnNvcihleHRyYWN0RXZlbnRJbmZvKGV2ZW50KS5wb2ludCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9uU3RhcnQgPSAoZXZlbnQsIGluZm8pID0+IHtcbiAgICAgICAgICAgIC8vIEF0dGVtcHQgdG8gZ3JhYiB0aGUgZ2xvYmFsIGRyYWcgZ2VzdHVyZSBsb2NrIC0gbWF5YmUgbWFrZSB0aGlzIHBhcnQgb2YgUGFuU2Vzc2lvblxuICAgICAgICAgICAgY29uc3QgeyBkcmFnLCBkcmFnUHJvcGFnYXRpb24sIG9uRHJhZ1N0YXJ0IH0gPSB0aGlzLmdldFByb3BzKCk7XG4gICAgICAgICAgICBpZiAoZHJhZyAmJiAhZHJhZ1Byb3BhZ2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3BlbkRyYWdMb2NrKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wZW5EcmFnTG9jaygpO1xuICAgICAgICAgICAgICAgIHRoaXMub3BlbkRyYWdMb2NrID0gbW90aW9uRG9tLnNldERyYWdMb2NrKGRyYWcpO1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGRvbiAndCBoYXZlIHRoZSBsb2NrLCBkb24ndCBzdGFydCBkcmFnZ2luZ1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5vcGVuRHJhZ0xvY2spXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnREaXJlY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlQ29uc3RyYWludHMoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnZpc3VhbEVsZW1lbnQucHJvamVjdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMudmlzdWFsRWxlbWVudC5wcm9qZWN0aW9uLmlzQW5pbWF0aW9uQmxvY2tlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy52aXN1YWxFbGVtZW50LnByb2plY3Rpb24udGFyZ2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZWNvcmQgZ2VzdHVyZSBvcmlnaW5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZWFjaEF4aXMoKGF4aXMpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuZ2V0QXhpc01vdGlvblZhbHVlKGF4aXMpLmdldCgpIHx8IDA7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogSWYgdGhlIE1vdGlvblZhbHVlIGlzIGEgcGVyY2VudGFnZSB2YWx1ZSBjb252ZXJ0IHRvIHB4XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKHBlcmNlbnQudGVzdChjdXJyZW50KSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHByb2plY3Rpb24gfSA9IHRoaXMudmlzdWFsRWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2plY3Rpb24gJiYgcHJvamVjdGlvbi5sYXlvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lYXN1cmVkQXhpcyA9IHByb2plY3Rpb24ubGF5b3V0LmxheW91dEJveFtheGlzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZWFzdXJlZEF4aXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBjYWxjTGVuZ3RoKG1lYXN1cmVkQXhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGxlbmd0aCAqIChwYXJzZUZsb2F0KGN1cnJlbnQpIC8gMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLm9yaWdpblBvaW50W2F4aXNdID0gY3VycmVudDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gRmlyZSBvbkRyYWdTdGFydCBldmVudFxuICAgICAgICAgICAgaWYgKG9uRHJhZ1N0YXJ0KSB7XG4gICAgICAgICAgICAgICAgZnJhbWUucG9zdFJlbmRlcigoKSA9PiBvbkRyYWdTdGFydChldmVudCwgaW5mbykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkVmFsdWVUb1dpbGxDaGFuZ2UodGhpcy52aXN1YWxFbGVtZW50LCBcInRyYW5zZm9ybVwiKTtcbiAgICAgICAgICAgIGNvbnN0IHsgYW5pbWF0aW9uU3RhdGUgfSA9IHRoaXMudmlzdWFsRWxlbWVudDtcbiAgICAgICAgICAgIGFuaW1hdGlvblN0YXRlICYmIGFuaW1hdGlvblN0YXRlLnNldEFjdGl2ZShcIndoaWxlRHJhZ1wiLCB0cnVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb25Nb3ZlID0gKGV2ZW50LCBpbmZvKSA9PiB7XG4gICAgICAgICAgICAvLyBsYXRlc3RQb2ludGVyRXZlbnQgPSBldmVudFxuICAgICAgICAgICAgY29uc3QgeyBkcmFnUHJvcGFnYXRpb24sIGRyYWdEaXJlY3Rpb25Mb2NrLCBvbkRpcmVjdGlvbkxvY2ssIG9uRHJhZywgfSA9IHRoaXMuZ2V0UHJvcHMoKTtcbiAgICAgICAgICAgIC8vIElmIHdlIGRpZG4ndCBzdWNjZXNzZnVsbHkgcmVjZWl2ZSB0aGUgZ2VzdHVyZSBsb2NrLCBlYXJseSByZXR1cm4uXG4gICAgICAgICAgICBpZiAoIWRyYWdQcm9wYWdhdGlvbiAmJiAhdGhpcy5vcGVuRHJhZ0xvY2spXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgeyBvZmZzZXQgfSA9IGluZm87XG4gICAgICAgICAgICAvLyBBdHRlbXB0IHRvIGRldGVjdCBkcmFnIGRpcmVjdGlvbiBpZiBkaXJlY3Rpb25Mb2NrIGlzIHRydWVcbiAgICAgICAgICAgIGlmIChkcmFnRGlyZWN0aW9uTG9jayAmJiB0aGlzLmN1cnJlbnREaXJlY3Rpb24gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnREaXJlY3Rpb24gPSBnZXRDdXJyZW50RGlyZWN0aW9uKG9mZnNldCk7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UndmUgc3VjY2Vzc2Z1bGx5IHNldCBhIGRpcmVjdGlvbiwgbm90aWZ5IGxpc3RlbmVyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudERpcmVjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBvbkRpcmVjdGlvbkxvY2sgJiYgb25EaXJlY3Rpb25Mb2NrKHRoaXMuY3VycmVudERpcmVjdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBlYWNoIHBvaW50IHdpdGggdGhlIGxhdGVzdCBwb3NpdGlvblxuICAgICAgICAgICAgdGhpcy51cGRhdGVBeGlzKFwieFwiLCBpbmZvLnBvaW50LCBvZmZzZXQpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVBeGlzKFwieVwiLCBpbmZvLnBvaW50LCBvZmZzZXQpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZGVhbGx5IHdlIHdvdWxkIGxlYXZlIHRoZSByZW5kZXJlciB0byBmaXJlIG5hdHVyYWxseSBhdCB0aGUgZW5kIG9mXG4gICAgICAgICAgICAgKiB0aGlzIGZyYW1lIGJ1dCBpZiB0aGUgZWxlbWVudCBpcyBhYm91dCB0byBjaGFuZ2UgbGF5b3V0IGFzIHRoZSByZXN1bHRcbiAgICAgICAgICAgICAqIG9mIGEgcmUtcmVuZGVyIHdlIHdhbnQgdG8gZW5zdXJlIHRoZSBicm93c2VyIGNhbiByZWFkIHRoZSBsYXRlc3RcbiAgICAgICAgICAgICAqIGJvdW5kaW5nIGJveCB0byBlbnN1cmUgdGhlIHBvaW50ZXIgYW5kIGVsZW1lbnQgZG9uJ3QgZmFsbCBvdXQgb2Ygc3luYy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy52aXN1YWxFbGVtZW50LnJlbmRlcigpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGlzIG11c3QgZmlyZSBhZnRlciB0aGUgcmVuZGVyIGNhbGwgYXMgaXQgbWlnaHQgdHJpZ2dlciBhIHN0YXRlXG4gICAgICAgICAgICAgKiBjaGFuZ2Ugd2hpY2ggaXRzZWxmIG1pZ2h0IHRyaWdnZXIgYSBsYXlvdXQgdXBkYXRlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBvbkRyYWcgJiYgb25EcmFnKGV2ZW50LCBpbmZvKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb25TZXNzaW9uRW5kID0gKGV2ZW50LCBpbmZvKSA9PiB0aGlzLnN0b3AoZXZlbnQsIGluZm8pO1xuICAgICAgICBjb25zdCByZXN1bWVBbmltYXRpb24gPSAoKSA9PiBlYWNoQXhpcygoYXhpcykgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QW5pbWF0aW9uU3RhdGUoYXhpcykgPT09IFwicGF1c2VkXCIgJiZcbiAgICAgICAgICAgICAgICAoKF9hID0gdGhpcy5nZXRBeGlzTW90aW9uVmFsdWUoYXhpcykuYW5pbWF0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGxheSgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHsgZHJhZ1NuYXBUb09yaWdpbiB9ID0gdGhpcy5nZXRQcm9wcygpO1xuICAgICAgICB0aGlzLnBhblNlc3Npb24gPSBuZXcgUGFuU2Vzc2lvbihvcmlnaW5FdmVudCwge1xuICAgICAgICAgICAgb25TZXNzaW9uU3RhcnQsXG4gICAgICAgICAgICBvblN0YXJ0LFxuICAgICAgICAgICAgb25Nb3ZlLFxuICAgICAgICAgICAgb25TZXNzaW9uRW5kLFxuICAgICAgICAgICAgcmVzdW1lQW5pbWF0aW9uLFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1QYWdlUG9pbnQ6IHRoaXMudmlzdWFsRWxlbWVudC5nZXRUcmFuc2Zvcm1QYWdlUG9pbnQoKSxcbiAgICAgICAgICAgIGRyYWdTbmFwVG9PcmlnaW4sXG4gICAgICAgICAgICBjb250ZXh0V2luZG93OiBnZXRDb250ZXh0V2luZG93KHRoaXMudmlzdWFsRWxlbWVudCksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdG9wKGV2ZW50LCBpbmZvKSB7XG4gICAgICAgIGNvbnN0IGlzRHJhZ2dpbmcgPSB0aGlzLmlzRHJhZ2dpbmc7XG4gICAgICAgIHRoaXMuY2FuY2VsKCk7XG4gICAgICAgIGlmICghaXNEcmFnZ2luZylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgeyB2ZWxvY2l0eSB9ID0gaW5mbztcbiAgICAgICAgdGhpcy5zdGFydEFuaW1hdGlvbih2ZWxvY2l0eSk7XG4gICAgICAgIGNvbnN0IHsgb25EcmFnRW5kIH0gPSB0aGlzLmdldFByb3BzKCk7XG4gICAgICAgIGlmIChvbkRyYWdFbmQpIHtcbiAgICAgICAgICAgIGZyYW1lLnBvc3RSZW5kZXIoKCkgPT4gb25EcmFnRW5kKGV2ZW50LCBpbmZvKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FuY2VsKCkge1xuICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgeyBwcm9qZWN0aW9uLCBhbmltYXRpb25TdGF0ZSB9ID0gdGhpcy52aXN1YWxFbGVtZW50O1xuICAgICAgICBpZiAocHJvamVjdGlvbikge1xuICAgICAgICAgICAgcHJvamVjdGlvbi5pc0FuaW1hdGlvbkJsb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhblNlc3Npb24gJiYgdGhpcy5wYW5TZXNzaW9uLmVuZCgpO1xuICAgICAgICB0aGlzLnBhblNlc3Npb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHsgZHJhZ1Byb3BhZ2F0aW9uIH0gPSB0aGlzLmdldFByb3BzKCk7XG4gICAgICAgIGlmICghZHJhZ1Byb3BhZ2F0aW9uICYmIHRoaXMub3BlbkRyYWdMb2NrKSB7XG4gICAgICAgICAgICB0aGlzLm9wZW5EcmFnTG9jaygpO1xuICAgICAgICAgICAgdGhpcy5vcGVuRHJhZ0xvY2sgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGFuaW1hdGlvblN0YXRlICYmIGFuaW1hdGlvblN0YXRlLnNldEFjdGl2ZShcIndoaWxlRHJhZ1wiLCBmYWxzZSk7XG4gICAgfVxuICAgIHVwZGF0ZUF4aXMoYXhpcywgX3BvaW50LCBvZmZzZXQpIHtcbiAgICAgICAgY29uc3QgeyBkcmFnIH0gPSB0aGlzLmdldFByb3BzKCk7XG4gICAgICAgIC8vIElmIHdlJ3JlIG5vdCBkcmFnZ2luZyB0aGlzIGF4aXMsIGRvIGFuIGVhcmx5IHJldHVybi5cbiAgICAgICAgaWYgKCFvZmZzZXQgfHwgIXNob3VsZERyYWcoYXhpcywgZHJhZywgdGhpcy5jdXJyZW50RGlyZWN0aW9uKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgYXhpc1ZhbHVlID0gdGhpcy5nZXRBeGlzTW90aW9uVmFsdWUoYXhpcyk7XG4gICAgICAgIGxldCBuZXh0ID0gdGhpcy5vcmlnaW5Qb2ludFtheGlzXSArIG9mZnNldFtheGlzXTtcbiAgICAgICAgLy8gQXBwbHkgY29uc3RyYWludHNcbiAgICAgICAgaWYgKHRoaXMuY29uc3RyYWludHMgJiYgdGhpcy5jb25zdHJhaW50c1theGlzXSkge1xuICAgICAgICAgICAgbmV4dCA9IGFwcGx5Q29uc3RyYWludHMobmV4dCwgdGhpcy5jb25zdHJhaW50c1theGlzXSwgdGhpcy5lbGFzdGljW2F4aXNdKTtcbiAgICAgICAgfVxuICAgICAgICBheGlzVmFsdWUuc2V0KG5leHQpO1xuICAgIH1cbiAgICByZXNvbHZlQ29uc3RyYWludHMoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgeyBkcmFnQ29uc3RyYWludHMsIGRyYWdFbGFzdGljIH0gPSB0aGlzLmdldFByb3BzKCk7XG4gICAgICAgIGNvbnN0IGxheW91dCA9IHRoaXMudmlzdWFsRWxlbWVudC5wcm9qZWN0aW9uICYmXG4gICAgICAgICAgICAhdGhpcy52aXN1YWxFbGVtZW50LnByb2plY3Rpb24ubGF5b3V0XG4gICAgICAgICAgICA/IHRoaXMudmlzdWFsRWxlbWVudC5wcm9qZWN0aW9uLm1lYXN1cmUoZmFsc2UpXG4gICAgICAgICAgICA6IChfYSA9IHRoaXMudmlzdWFsRWxlbWVudC5wcm9qZWN0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGF5b3V0O1xuICAgICAgICBjb25zdCBwcmV2Q29uc3RyYWludHMgPSB0aGlzLmNvbnN0cmFpbnRzO1xuICAgICAgICBpZiAoZHJhZ0NvbnN0cmFpbnRzICYmIGlzUmVmT2JqZWN0KGRyYWdDb25zdHJhaW50cykpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jb25zdHJhaW50cykge1xuICAgICAgICAgICAgICAgIHRoaXMuY29uc3RyYWludHMgPSB0aGlzLnJlc29sdmVSZWZDb25zdHJhaW50cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGRyYWdDb25zdHJhaW50cyAmJiBsYXlvdXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN0cmFpbnRzID0gY2FsY1JlbGF0aXZlQ29uc3RyYWludHMobGF5b3V0LmxheW91dEJveCwgZHJhZ0NvbnN0cmFpbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY29uc3RyYWludHMgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVsYXN0aWMgPSByZXNvbHZlRHJhZ0VsYXN0aWMoZHJhZ0VsYXN0aWMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgd2UncmUgb3V0cHV0dGluZyB0byBleHRlcm5hbCBNb3Rpb25WYWx1ZXMsIHdlIHdhbnQgdG8gcmViYXNlIHRoZSBtZWFzdXJlZCBjb25zdHJhaW50c1xuICAgICAgICAgKiBmcm9tIHZpZXdwb3J0LXJlbGF0aXZlIHRvIGNvbXBvbmVudC1yZWxhdGl2ZS5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChwcmV2Q29uc3RyYWludHMgIT09IHRoaXMuY29uc3RyYWludHMgJiZcbiAgICAgICAgICAgIGxheW91dCAmJlxuICAgICAgICAgICAgdGhpcy5jb25zdHJhaW50cyAmJlxuICAgICAgICAgICAgIXRoaXMuaGFzTXV0YXRlZENvbnN0cmFpbnRzKSB7XG4gICAgICAgICAgICBlYWNoQXhpcygoYXhpcykgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnN0cmFpbnRzICE9PSBmYWxzZSAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldEF4aXNNb3Rpb25WYWx1ZShheGlzKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnN0cmFpbnRzW2F4aXNdID0gcmViYXNlQXhpc0NvbnN0cmFpbnRzKGxheW91dC5sYXlvdXRCb3hbYXhpc10sIHRoaXMuY29uc3RyYWludHNbYXhpc10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlc29sdmVSZWZDb25zdHJhaW50cygpIHtcbiAgICAgICAgY29uc3QgeyBkcmFnQ29uc3RyYWludHM6IGNvbnN0cmFpbnRzLCBvbk1lYXN1cmVEcmFnQ29uc3RyYWludHMgfSA9IHRoaXMuZ2V0UHJvcHMoKTtcbiAgICAgICAgaWYgKCFjb25zdHJhaW50cyB8fCAhaXNSZWZPYmplY3QoY29uc3RyYWludHMpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBjb25zdHJhaW50c0VsZW1lbnQgPSBjb25zdHJhaW50cy5jdXJyZW50O1xuICAgICAgICBtb3Rpb25VdGlscy5pbnZhcmlhbnQoY29uc3RyYWludHNFbGVtZW50ICE9PSBudWxsLCBcIklmIGBkcmFnQ29uc3RyYWludHNgIGlzIHNldCBhcyBhIFJlYWN0IHJlZiwgdGhhdCByZWYgbXVzdCBiZSBwYXNzZWQgdG8gYW5vdGhlciBjb21wb25lbnQncyBgcmVmYCBwcm9wLlwiKTtcbiAgICAgICAgY29uc3QgeyBwcm9qZWN0aW9uIH0gPSB0aGlzLnZpc3VhbEVsZW1lbnQ7XG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgaWYgKCFwcm9qZWN0aW9uIHx8ICFwcm9qZWN0aW9uLmxheW91dClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgY29uc3RyYWludHNCb3ggPSBtZWFzdXJlUGFnZUJveChjb25zdHJhaW50c0VsZW1lbnQsIHByb2plY3Rpb24ucm9vdCwgdGhpcy52aXN1YWxFbGVtZW50LmdldFRyYW5zZm9ybVBhZ2VQb2ludCgpKTtcbiAgICAgICAgbGV0IG1lYXN1cmVkQ29uc3RyYWludHMgPSBjYWxjVmlld3BvcnRDb25zdHJhaW50cyhwcm9qZWN0aW9uLmxheW91dC5sYXlvdXRCb3gsIGNvbnN0cmFpbnRzQm94KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZXJlJ3MgYW4gb25NZWFzdXJlRHJhZ0NvbnN0cmFpbnRzIGxpc3RlbmVyIHdlIGNhbGwgaXQgYW5kXG4gICAgICAgICAqIGlmIGRpZmZlcmVudCBjb25zdHJhaW50cyBhcmUgcmV0dXJuZWQsIHNldCBjb25zdHJhaW50cyB0byB0aGF0XG4gICAgICAgICAqL1xuICAgICAgICBpZiAob25NZWFzdXJlRHJhZ0NvbnN0cmFpbnRzKSB7XG4gICAgICAgICAgICBjb25zdCB1c2VyQ29uc3RyYWludHMgPSBvbk1lYXN1cmVEcmFnQ29uc3RyYWludHMoY29udmVydEJveFRvQm91bmRpbmdCb3gobWVhc3VyZWRDb25zdHJhaW50cykpO1xuICAgICAgICAgICAgdGhpcy5oYXNNdXRhdGVkQ29uc3RyYWludHMgPSAhIXVzZXJDb25zdHJhaW50cztcbiAgICAgICAgICAgIGlmICh1c2VyQ29uc3RyYWludHMpIHtcbiAgICAgICAgICAgICAgICBtZWFzdXJlZENvbnN0cmFpbnRzID0gY29udmVydEJvdW5kaW5nQm94VG9Cb3godXNlckNvbnN0cmFpbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVhc3VyZWRDb25zdHJhaW50cztcbiAgICB9XG4gICAgc3RhcnRBbmltYXRpb24odmVsb2NpdHkpIHtcbiAgICAgICAgY29uc3QgeyBkcmFnLCBkcmFnTW9tZW50dW0sIGRyYWdFbGFzdGljLCBkcmFnVHJhbnNpdGlvbiwgZHJhZ1NuYXBUb09yaWdpbiwgb25EcmFnVHJhbnNpdGlvbkVuZCwgfSA9IHRoaXMuZ2V0UHJvcHMoKTtcbiAgICAgICAgY29uc3QgY29uc3RyYWludHMgPSB0aGlzLmNvbnN0cmFpbnRzIHx8IHt9O1xuICAgICAgICBjb25zdCBtb21lbnR1bUFuaW1hdGlvbnMgPSBlYWNoQXhpcygoYXhpcykgPT4ge1xuICAgICAgICAgICAgaWYgKCFzaG91bGREcmFnKGF4aXMsIGRyYWcsIHRoaXMuY3VycmVudERpcmVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdHJhbnNpdGlvbiA9IChjb25zdHJhaW50cyAmJiBjb25zdHJhaW50c1theGlzXSkgfHwge307XG4gICAgICAgICAgICBpZiAoZHJhZ1NuYXBUb09yaWdpbilcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uID0geyBtaW46IDAsIG1heDogMCB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBPdmVyZGFtcCB0aGUgYm91bmRhcnkgc3ByaW5nIGlmIGBkcmFnRWxhc3RpY2AgaXMgZGlzYWJsZWQuIFRoZXJlJ3Mgc3RpbGwgYSBmcmFtZVxuICAgICAgICAgICAgICogb2Ygc3ByaW5nIGFuaW1hdGlvbnMgc28gd2Ugc2hvdWxkIGxvb2sgaW50byBhZGRpbmcgYSBkaXNhYmxlIHNwcmluZyBvcHRpb24gdG8gYGluZXJ0aWFgLlxuICAgICAgICAgICAgICogV2UgY291bGQgZG8gc29tZXRoaW5nIGhlcmUgd2hlcmUgd2UgYWZmZWN0IHRoZSBgYm91bmNlU3RpZmZuZXNzYCBhbmQgYGJvdW5jZURhbXBpbmdgXG4gICAgICAgICAgICAgKiB1c2luZyB0aGUgdmFsdWUgb2YgYGRyYWdFbGFzdGljYC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgYm91bmNlU3RpZmZuZXNzID0gZHJhZ0VsYXN0aWMgPyAyMDAgOiAxMDAwMDAwO1xuICAgICAgICAgICAgY29uc3QgYm91bmNlRGFtcGluZyA9IGRyYWdFbGFzdGljID8gNDAgOiAxMDAwMDAwMDtcbiAgICAgICAgICAgIGNvbnN0IGluZXJ0aWEgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJpbmVydGlhXCIsXG4gICAgICAgICAgICAgICAgdmVsb2NpdHk6IGRyYWdNb21lbnR1bSA/IHZlbG9jaXR5W2F4aXNdIDogMCxcbiAgICAgICAgICAgICAgICBib3VuY2VTdGlmZm5lc3MsXG4gICAgICAgICAgICAgICAgYm91bmNlRGFtcGluZyxcbiAgICAgICAgICAgICAgICB0aW1lQ29uc3RhbnQ6IDc1MCxcbiAgICAgICAgICAgICAgICByZXN0RGVsdGE6IDEsXG4gICAgICAgICAgICAgICAgcmVzdFNwZWVkOiAxMCxcbiAgICAgICAgICAgICAgICAuLi5kcmFnVHJhbnNpdGlvbixcbiAgICAgICAgICAgICAgICAuLi50cmFuc2l0aW9uLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIElmIHdlJ3JlIG5vdCBhbmltYXRpbmcgb24gYW4gZXh0ZXJuYWxseS1wcm92aWRlZCBgTW90aW9uVmFsdWVgIHdlIGNhbiB1c2UgdGhlXG4gICAgICAgICAgICAvLyBjb21wb25lbnQncyBhbmltYXRpb24gY29udHJvbHMgd2hpY2ggd2lsbCBoYW5kbGUgaW50ZXJhY3Rpb25zIHdpdGggd2hpbGVIb3ZlciAoZXRjKSxcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSB3ZSBqdXN0IGhhdmUgdG8gYW5pbWF0ZSB0aGUgYE1vdGlvblZhbHVlYCBpdHNlbGYuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydEF4aXNWYWx1ZUFuaW1hdGlvbihheGlzLCBpbmVydGlhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFJ1biBhbGwgYW5pbWF0aW9ucyBhbmQgdGhlbiByZXNvbHZlIHRoZSBuZXcgZHJhZyBjb25zdHJhaW50cy5cbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKG1vbWVudHVtQW5pbWF0aW9ucykudGhlbihvbkRyYWdUcmFuc2l0aW9uRW5kKTtcbiAgICB9XG4gICAgc3RhcnRBeGlzVmFsdWVBbmltYXRpb24oYXhpcywgdHJhbnNpdGlvbikge1xuICAgICAgICBjb25zdCBheGlzVmFsdWUgPSB0aGlzLmdldEF4aXNNb3Rpb25WYWx1ZShheGlzKTtcbiAgICAgICAgYWRkVmFsdWVUb1dpbGxDaGFuZ2UodGhpcy52aXN1YWxFbGVtZW50LCBheGlzKTtcbiAgICAgICAgcmV0dXJuIGF4aXNWYWx1ZS5zdGFydChhbmltYXRlTW90aW9uVmFsdWUoYXhpcywgYXhpc1ZhbHVlLCAwLCB0cmFuc2l0aW9uLCB0aGlzLnZpc3VhbEVsZW1lbnQsIGZhbHNlKSk7XG4gICAgfVxuICAgIHN0b3BBbmltYXRpb24oKSB7XG4gICAgICAgIGVhY2hBeGlzKChheGlzKSA9PiB0aGlzLmdldEF4aXNNb3Rpb25WYWx1ZShheGlzKS5zdG9wKCkpO1xuICAgIH1cbiAgICBwYXVzZUFuaW1hdGlvbigpIHtcbiAgICAgICAgZWFjaEF4aXMoKGF4aXMpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gdGhpcy5nZXRBeGlzTW90aW9uVmFsdWUoYXhpcykuYW5pbWF0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGF1c2UoKTsgfSk7XG4gICAgfVxuICAgIGdldEFuaW1hdGlvblN0YXRlKGF4aXMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5nZXRBeGlzTW90aW9uVmFsdWUoYXhpcykuYW5pbWF0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERyYWcgd29ya3MgZGlmZmVyZW50bHkgZGVwZW5kaW5nIG9uIHdoaWNoIHByb3BzIGFyZSBwcm92aWRlZC5cbiAgICAgKlxuICAgICAqIC0gSWYgX2RyYWdYIGFuZCBfZHJhZ1kgYXJlIHByb3ZpZGVkLCB3ZSBvdXRwdXQgdGhlIGdlc3R1cmUgZGVsdGEgZGlyZWN0bHkgdG8gdGhvc2UgbW90aW9uIHZhbHVlcy5cbiAgICAgKiAtIE90aGVyd2lzZSwgd2UgYXBwbHkgdGhlIGRlbHRhIHRvIHRoZSB4L3kgbW90aW9uIHZhbHVlcy5cbiAgICAgKi9cbiAgICBnZXRBeGlzTW90aW9uVmFsdWUoYXhpcykge1xuICAgICAgICBjb25zdCBkcmFnS2V5ID0gYF9kcmFnJHtheGlzLnRvVXBwZXJDYXNlKCl9YDtcbiAgICAgICAgY29uc3QgcHJvcHMgPSB0aGlzLnZpc3VhbEVsZW1lbnQuZ2V0UHJvcHMoKTtcbiAgICAgICAgY29uc3QgZXh0ZXJuYWxNb3Rpb25WYWx1ZSA9IHByb3BzW2RyYWdLZXldO1xuICAgICAgICByZXR1cm4gZXh0ZXJuYWxNb3Rpb25WYWx1ZVxuICAgICAgICAgICAgPyBleHRlcm5hbE1vdGlvblZhbHVlXG4gICAgICAgICAgICA6IHRoaXMudmlzdWFsRWxlbWVudC5nZXRWYWx1ZShheGlzLCAocHJvcHMuaW5pdGlhbFxuICAgICAgICAgICAgICAgID8gcHJvcHMuaW5pdGlhbFtheGlzXVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKSB8fCAwKTtcbiAgICB9XG4gICAgc25hcFRvQ3Vyc29yKHBvaW50KSB7XG4gICAgICAgIGVhY2hBeGlzKChheGlzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGRyYWcgfSA9IHRoaXMuZ2V0UHJvcHMoKTtcbiAgICAgICAgICAgIC8vIElmIHdlJ3JlIG5vdCBkcmFnZ2luZyB0aGlzIGF4aXMsIGRvIGFuIGVhcmx5IHJldHVybi5cbiAgICAgICAgICAgIGlmICghc2hvdWxkRHJhZyhheGlzLCBkcmFnLCB0aGlzLmN1cnJlbnREaXJlY3Rpb24pKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IHsgcHJvamVjdGlvbiB9ID0gdGhpcy52aXN1YWxFbGVtZW50O1xuICAgICAgICAgICAgY29uc3QgYXhpc1ZhbHVlID0gdGhpcy5nZXRBeGlzTW90aW9uVmFsdWUoYXhpcyk7XG4gICAgICAgICAgICBpZiAocHJvamVjdGlvbiAmJiBwcm9qZWN0aW9uLmxheW91dCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbWluLCBtYXggfSA9IHByb2plY3Rpb24ubGF5b3V0LmxheW91dEJveFtheGlzXTtcbiAgICAgICAgICAgICAgICBheGlzVmFsdWUuc2V0KHBvaW50W2F4aXNdIC0gbWl4TnVtYmVyJDEobWluLCBtYXgsIDAuNSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hlbiB0aGUgdmlld3BvcnQgcmVzaXplcyB3ZSB3YW50IHRvIGNoZWNrIGlmIHRoZSBtZWFzdXJlZCBjb25zdHJhaW50c1xuICAgICAqIGhhdmUgY2hhbmdlZCBhbmQsIGlmIHNvLCByZXBvc2l0aW9uIHRoZSBlbGVtZW50IHdpdGhpbiB0aG9zZSBuZXcgY29uc3RyYWludHNcbiAgICAgKiByZWxhdGl2ZSB0byB3aGVyZSBpdCB3YXMgYmVmb3JlIHRoZSByZXNpemUuXG4gICAgICovXG4gICAgc2NhbGVQb3NpdGlvbldpdGhpbkNvbnN0cmFpbnRzKCkge1xuICAgICAgICBpZiAoIXRoaXMudmlzdWFsRWxlbWVudC5jdXJyZW50KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB7IGRyYWcsIGRyYWdDb25zdHJhaW50cyB9ID0gdGhpcy5nZXRQcm9wcygpO1xuICAgICAgICBjb25zdCB7IHByb2plY3Rpb24gfSA9IHRoaXMudmlzdWFsRWxlbWVudDtcbiAgICAgICAgaWYgKCFpc1JlZk9iamVjdChkcmFnQ29uc3RyYWludHMpIHx8ICFwcm9qZWN0aW9uIHx8ICF0aGlzLmNvbnN0cmFpbnRzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3RvcCBjdXJyZW50IGFuaW1hdGlvbnMgYXMgdGhlcmUgY2FuIGJlIHZpc3VhbCBnbGl0Y2hpbmcgaWYgd2UgdHJ5IHRvIGRvXG4gICAgICAgICAqIHRoaXMgbWlkLWFuaW1hdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdG9wQW5pbWF0aW9uKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWNvcmQgdGhlIHJlbGF0aXZlIHBvc2l0aW9uIG9mIHRoZSBkcmFnZ2VkIGVsZW1lbnQgcmVsYXRpdmUgdG8gdGhlXG4gICAgICAgICAqIGNvbnN0cmFpbnRzIGJveCBhbmQgc2F2ZSBhcyBhIHByb2dyZXNzIHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgYm94UHJvZ3Jlc3MgPSB7IHg6IDAsIHk6IDAgfTtcbiAgICAgICAgZWFjaEF4aXMoKGF4aXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGF4aXNWYWx1ZSA9IHRoaXMuZ2V0QXhpc01vdGlvblZhbHVlKGF4aXMpO1xuICAgICAgICAgICAgaWYgKGF4aXNWYWx1ZSAmJiB0aGlzLmNvbnN0cmFpbnRzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhdGVzdCA9IGF4aXNWYWx1ZS5nZXQoKTtcbiAgICAgICAgICAgICAgICBib3hQcm9ncmVzc1theGlzXSA9IGNhbGNPcmlnaW4kMSh7IG1pbjogbGF0ZXN0LCBtYXg6IGxhdGVzdCB9LCB0aGlzLmNvbnN0cmFpbnRzW2F4aXNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgdGhlIGxheW91dCBvZiB0aGlzIGVsZW1lbnQgYW5kIHJlc29sdmUgdGhlIGxhdGVzdCBkcmFnIGNvbnN0cmFpbnRzXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCB7IHRyYW5zZm9ybVRlbXBsYXRlIH0gPSB0aGlzLnZpc3VhbEVsZW1lbnQuZ2V0UHJvcHMoKTtcbiAgICAgICAgdGhpcy52aXN1YWxFbGVtZW50LmN1cnJlbnQuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtVGVtcGxhdGVcbiAgICAgICAgICAgID8gdHJhbnNmb3JtVGVtcGxhdGUoe30sIFwiXCIpXG4gICAgICAgICAgICA6IFwibm9uZVwiO1xuICAgICAgICBwcm9qZWN0aW9uLnJvb3QgJiYgcHJvamVjdGlvbi5yb290LnVwZGF0ZVNjcm9sbCgpO1xuICAgICAgICBwcm9qZWN0aW9uLnVwZGF0ZUxheW91dCgpO1xuICAgICAgICB0aGlzLnJlc29sdmVDb25zdHJhaW50cygpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRm9yIGVhY2ggYXhpcywgY2FsY3VsYXRlIHRoZSBjdXJyZW50IHByb2dyZXNzIG9mIHRoZSBsYXlvdXQgYXhpc1xuICAgICAgICAgKiB3aXRoaW4gdGhlIG5ldyBjb25zdHJhaW50cy5cbiAgICAgICAgICovXG4gICAgICAgIGVhY2hBeGlzKChheGlzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXNob3VsZERyYWcoYXhpcywgZHJhZywgbnVsbCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDYWxjdWxhdGUgYSBuZXcgdHJhbnNmb3JtIGJhc2VkIG9uIHRoZSBwcmV2aW91cyBib3ggcHJvZ3Jlc3NcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgYXhpc1ZhbHVlID0gdGhpcy5nZXRBeGlzTW90aW9uVmFsdWUoYXhpcyk7XG4gICAgICAgICAgICBjb25zdCB7IG1pbiwgbWF4IH0gPSB0aGlzLmNvbnN0cmFpbnRzW2F4aXNdO1xuICAgICAgICAgICAgYXhpc1ZhbHVlLnNldChtaXhOdW1iZXIkMShtaW4sIG1heCwgYm94UHJvZ3Jlc3NbYXhpc10pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFkZExpc3RlbmVycygpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpc3VhbEVsZW1lbnQuY3VycmVudClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZWxlbWVudERyYWdDb250cm9scy5zZXQodGhpcy52aXN1YWxFbGVtZW50LCB0aGlzKTtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMudmlzdWFsRWxlbWVudC5jdXJyZW50O1xuICAgICAgICAvKipcbiAgICAgICAgICogQXR0YWNoIGEgcG9pbnRlcmRvd24gZXZlbnQgbGlzdGVuZXIgb24gdGhpcyBET00gZWxlbWVudCB0byBpbml0aWF0ZSBkcmFnIHRyYWNraW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3Qgc3RvcFBvaW50ZXJMaXN0ZW5lciA9IGFkZFBvaW50ZXJFdmVudChlbGVtZW50LCBcInBvaW50ZXJkb3duXCIsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBkcmFnLCBkcmFnTGlzdGVuZXIgPSB0cnVlIH0gPSB0aGlzLmdldFByb3BzKCk7XG4gICAgICAgICAgICBkcmFnICYmIGRyYWdMaXN0ZW5lciAmJiB0aGlzLnN0YXJ0KGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG1lYXN1cmVEcmFnQ29uc3RyYWludHMgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGRyYWdDb25zdHJhaW50cyB9ID0gdGhpcy5nZXRQcm9wcygpO1xuICAgICAgICAgICAgaWYgKGlzUmVmT2JqZWN0KGRyYWdDb25zdHJhaW50cykgJiYgZHJhZ0NvbnN0cmFpbnRzLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN0cmFpbnRzID0gdGhpcy5yZXNvbHZlUmVmQ29uc3RyYWludHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgeyBwcm9qZWN0aW9uIH0gPSB0aGlzLnZpc3VhbEVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IHN0b3BNZWFzdXJlTGF5b3V0TGlzdGVuZXIgPSBwcm9qZWN0aW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJtZWFzdXJlXCIsIG1lYXN1cmVEcmFnQ29uc3RyYWludHMpO1xuICAgICAgICBpZiAocHJvamVjdGlvbiAmJiAhcHJvamVjdGlvbi5sYXlvdXQpIHtcbiAgICAgICAgICAgIHByb2plY3Rpb24ucm9vdCAmJiBwcm9qZWN0aW9uLnJvb3QudXBkYXRlU2Nyb2xsKCk7XG4gICAgICAgICAgICBwcm9qZWN0aW9uLnVwZGF0ZUxheW91dCgpO1xuICAgICAgICB9XG4gICAgICAgIGZyYW1lLnJlYWQobWVhc3VyZURyYWdDb25zdHJhaW50cyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBdHRhY2ggYSB3aW5kb3cgcmVzaXplIGxpc3RlbmVyIHRvIHNjYWxlIHRoZSBkcmFnZ2FibGUgdGFyZ2V0IHdpdGhpbiBpdHMgZGVmaW5lZFxuICAgICAgICAgKiBjb25zdHJhaW50cyBhcyB0aGUgd2luZG93IHJlc2l6ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBzdG9wUmVzaXplTGlzdGVuZXIgPSBhZGREb21FdmVudCh3aW5kb3csIFwicmVzaXplXCIsICgpID0+IHRoaXMuc2NhbGVQb3NpdGlvbldpdGhpbkNvbnN0cmFpbnRzKCkpO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlIGVsZW1lbnQncyBsYXlvdXQgY2hhbmdlcywgY2FsY3VsYXRlIHRoZSBkZWx0YSBhbmQgYXBwbHkgdGhhdCB0b1xuICAgICAgICAgKiB0aGUgZHJhZyBnZXN0dXJlJ3Mgb3JpZ2luIHBvaW50LlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3Qgc3RvcExheW91dFVwZGF0ZUxpc3RlbmVyID0gcHJvamVjdGlvbi5hZGRFdmVudExpc3RlbmVyKFwiZGlkVXBkYXRlXCIsICgoeyBkZWx0YSwgaGFzTGF5b3V0Q2hhbmdlZCB9KSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0RyYWdnaW5nICYmIGhhc0xheW91dENoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBlYWNoQXhpcygoYXhpcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtb3Rpb25WYWx1ZSA9IHRoaXMuZ2V0QXhpc01vdGlvblZhbHVlKGF4aXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1vdGlvblZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9yaWdpblBvaW50W2F4aXNdICs9IGRlbHRhW2F4aXNdLnRyYW5zbGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgbW90aW9uVmFsdWUuc2V0KG1vdGlvblZhbHVlLmdldCgpICsgZGVsdGFbYXhpc10udHJhbnNsYXRlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpc3VhbEVsZW1lbnQucmVuZGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHN0b3BSZXNpemVMaXN0ZW5lcigpO1xuICAgICAgICAgICAgc3RvcFBvaW50ZXJMaXN0ZW5lcigpO1xuICAgICAgICAgICAgc3RvcE1lYXN1cmVMYXlvdXRMaXN0ZW5lcigpO1xuICAgICAgICAgICAgc3RvcExheW91dFVwZGF0ZUxpc3RlbmVyICYmIHN0b3BMYXlvdXRVcGRhdGVMaXN0ZW5lcigpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRQcm9wcygpIHtcbiAgICAgICAgY29uc3QgcHJvcHMgPSB0aGlzLnZpc3VhbEVsZW1lbnQuZ2V0UHJvcHMoKTtcbiAgICAgICAgY29uc3QgeyBkcmFnID0gZmFsc2UsIGRyYWdEaXJlY3Rpb25Mb2NrID0gZmFsc2UsIGRyYWdQcm9wYWdhdGlvbiA9IGZhbHNlLCBkcmFnQ29uc3RyYWludHMgPSBmYWxzZSwgZHJhZ0VsYXN0aWMgPSBkZWZhdWx0RWxhc3RpYywgZHJhZ01vbWVudHVtID0gdHJ1ZSwgfSA9IHByb3BzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgICAgICBkcmFnLFxuICAgICAgICAgICAgZHJhZ0RpcmVjdGlvbkxvY2ssXG4gICAgICAgICAgICBkcmFnUHJvcGFnYXRpb24sXG4gICAgICAgICAgICBkcmFnQ29uc3RyYWludHMsXG4gICAgICAgICAgICBkcmFnRWxhc3RpYyxcbiAgICAgICAgICAgIGRyYWdNb21lbnR1bSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBzaG91bGREcmFnKGRpcmVjdGlvbiwgZHJhZywgY3VycmVudERpcmVjdGlvbikge1xuICAgIHJldHVybiAoKGRyYWcgPT09IHRydWUgfHwgZHJhZyA9PT0gZGlyZWN0aW9uKSAmJlxuICAgICAgICAoY3VycmVudERpcmVjdGlvbiA9PT0gbnVsbCB8fCBjdXJyZW50RGlyZWN0aW9uID09PSBkaXJlY3Rpb24pKTtcbn1cbi8qKlxuICogQmFzZWQgb24gYW4geC95IG9mZnNldCBkZXRlcm1pbmUgdGhlIGN1cnJlbnQgZHJhZyBkaXJlY3Rpb24uIElmIGJvdGggYXhpcycgb2Zmc2V0cyBhcmUgbG93ZXJcbiAqIHRoYW4gdGhlIHByb3ZpZGVkIHRocmVzaG9sZCwgcmV0dXJuIGBudWxsYC5cbiAqXG4gKiBAcGFyYW0gb2Zmc2V0IC0gVGhlIHgveSBvZmZzZXQgZnJvbSBvcmlnaW4uXG4gKiBAcGFyYW0gbG9ja1RocmVzaG9sZCAtIChPcHRpb25hbCkgLSB0aGUgbWluaW11bSBhYnNvbHV0ZSBvZmZzZXQgYmVmb3JlIHdlIGNhbiBkZXRlcm1pbmUgYSBkcmFnIGRpcmVjdGlvbi5cbiAqL1xuZnVuY3Rpb24gZ2V0Q3VycmVudERpcmVjdGlvbihvZmZzZXQsIGxvY2tUaHJlc2hvbGQgPSAxMCkge1xuICAgIGxldCBkaXJlY3Rpb24gPSBudWxsO1xuICAgIGlmIChNYXRoLmFicyhvZmZzZXQueSkgPiBsb2NrVGhyZXNob2xkKSB7XG4gICAgICAgIGRpcmVjdGlvbiA9IFwieVwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChNYXRoLmFicyhvZmZzZXQueCkgPiBsb2NrVGhyZXNob2xkKSB7XG4gICAgICAgIGRpcmVjdGlvbiA9IFwieFwiO1xuICAgIH1cbiAgICByZXR1cm4gZGlyZWN0aW9uO1xufVxuXG5jbGFzcyBEcmFnR2VzdHVyZSBleHRlbmRzIEZlYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG5vZGUpIHtcbiAgICAgICAgc3VwZXIobm9kZSk7XG4gICAgICAgIHRoaXMucmVtb3ZlR3JvdXBDb250cm9scyA9IG1vdGlvblV0aWxzLm5vb3A7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzID0gbW90aW9uVXRpbHMubm9vcDtcbiAgICAgICAgdGhpcy5jb250cm9scyA9IG5ldyBWaXN1YWxFbGVtZW50RHJhZ0NvbnRyb2xzKG5vZGUpO1xuICAgIH1cbiAgICBtb3VudCgpIHtcbiAgICAgICAgLy8gSWYgd2UndmUgYmVlbiBwcm92aWRlZCBhIERyYWdDb250cm9scyBmb3IgbWFudWFsIGNvbnRyb2wgb3ZlciB0aGUgZHJhZyBnZXN0dXJlLFxuICAgICAgICAvLyBzdWJzY3JpYmUgdGhpcyBjb21wb25lbnQgdG8gaXQgb24gbW91bnQuXG4gICAgICAgIGNvbnN0IHsgZHJhZ0NvbnRyb2xzIH0gPSB0aGlzLm5vZGUuZ2V0UHJvcHMoKTtcbiAgICAgICAgaWYgKGRyYWdDb250cm9scykge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVHcm91cENvbnRyb2xzID0gZHJhZ0NvbnRyb2xzLnN1YnNjcmliZSh0aGlzLmNvbnRyb2xzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVycyA9IHRoaXMuY29udHJvbHMuYWRkTGlzdGVuZXJzKCkgfHwgbW90aW9uVXRpbHMubm9vcDtcbiAgICB9XG4gICAgdW5tb3VudCgpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVHcm91cENvbnRyb2xzKCk7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgfVxufVxuXG5jb25zdCBhc3luY0hhbmRsZXIgPSAoaGFuZGxlcikgPT4gKGV2ZW50LCBpbmZvKSA9PiB7XG4gICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgZnJhbWUucG9zdFJlbmRlcigoKSA9PiBoYW5kbGVyKGV2ZW50LCBpbmZvKSk7XG4gICAgfVxufTtcbmNsYXNzIFBhbkdlc3R1cmUgZXh0ZW5kcyBGZWF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5yZW1vdmVQb2ludGVyRG93bkxpc3RlbmVyID0gbW90aW9uVXRpbHMubm9vcDtcbiAgICB9XG4gICAgb25Qb2ludGVyRG93bihwb2ludGVyRG93bkV2ZW50KSB7XG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IG5ldyBQYW5TZXNzaW9uKHBvaW50ZXJEb3duRXZlbnQsIHRoaXMuY3JlYXRlUGFuSGFuZGxlcnMoKSwge1xuICAgICAgICAgICAgdHJhbnNmb3JtUGFnZVBvaW50OiB0aGlzLm5vZGUuZ2V0VHJhbnNmb3JtUGFnZVBvaW50KCksXG4gICAgICAgICAgICBjb250ZXh0V2luZG93OiBnZXRDb250ZXh0V2luZG93KHRoaXMubm9kZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjcmVhdGVQYW5IYW5kbGVycygpIHtcbiAgICAgICAgY29uc3QgeyBvblBhblNlc3Npb25TdGFydCwgb25QYW5TdGFydCwgb25QYW4sIG9uUGFuRW5kIH0gPSB0aGlzLm5vZGUuZ2V0UHJvcHMoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9uU2Vzc2lvblN0YXJ0OiBhc3luY0hhbmRsZXIob25QYW5TZXNzaW9uU3RhcnQpLFxuICAgICAgICAgICAgb25TdGFydDogYXN5bmNIYW5kbGVyKG9uUGFuU3RhcnQpLFxuICAgICAgICAgICAgb25Nb3ZlOiBvblBhbixcbiAgICAgICAgICAgIG9uRW5kOiAoZXZlbnQsIGluZm8pID0+IHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5zZXNzaW9uO1xuICAgICAgICAgICAgICAgIGlmIChvblBhbkVuZCkge1xuICAgICAgICAgICAgICAgICAgICBmcmFtZS5wb3N0UmVuZGVyKCgpID0+IG9uUGFuRW5kKGV2ZW50LCBpbmZvKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgbW91bnQoKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlUG9pbnRlckRvd25MaXN0ZW5lciA9IGFkZFBvaW50ZXJFdmVudCh0aGlzLm5vZGUuY3VycmVudCwgXCJwb2ludGVyZG93blwiLCAoZXZlbnQpID0+IHRoaXMub25Qb2ludGVyRG93bihldmVudCkpO1xuICAgIH1cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIHRoaXMuc2Vzc2lvbiAmJiB0aGlzLnNlc3Npb24udXBkYXRlSGFuZGxlcnModGhpcy5jcmVhdGVQYW5IYW5kbGVycygpKTtcbiAgICB9XG4gICAgdW5tb3VudCgpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVQb2ludGVyRG93bkxpc3RlbmVyKCk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbiAmJiB0aGlzLnNlc3Npb24uZW5kKCk7XG4gICAgfVxufVxuXG5jb25zdCBib3JkZXJzID0gW1wiVG9wTGVmdFwiLCBcIlRvcFJpZ2h0XCIsIFwiQm90dG9tTGVmdFwiLCBcIkJvdHRvbVJpZ2h0XCJdO1xuY29uc3QgbnVtQm9yZGVycyA9IGJvcmRlcnMubGVuZ3RoO1xuY29uc3QgYXNOdW1iZXIgPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlRmxvYXQodmFsdWUpIDogdmFsdWU7XG5jb25zdCBpc1B4ID0gKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgfHwgcHgudGVzdCh2YWx1ZSk7XG5mdW5jdGlvbiBtaXhWYWx1ZXModGFyZ2V0LCBmb2xsb3csIGxlYWQsIHByb2dyZXNzLCBzaG91bGRDcm9zc2ZhZGVPcGFjaXR5LCBpc09ubHlNZW1iZXIpIHtcbiAgICBpZiAoc2hvdWxkQ3Jvc3NmYWRlT3BhY2l0eSkge1xuICAgICAgICB0YXJnZXQub3BhY2l0eSA9IG1peE51bWJlciQxKDAsIFxuICAgICAgICAvLyBUT0RPIFJlaW5zdGF0ZSB0aGlzIGlmIG9ubHkgY2hpbGRcbiAgICAgICAgbGVhZC5vcGFjaXR5ICE9PSB1bmRlZmluZWQgPyBsZWFkLm9wYWNpdHkgOiAxLCBlYXNlQ3Jvc3NmYWRlSW4ocHJvZ3Jlc3MpKTtcbiAgICAgICAgdGFyZ2V0Lm9wYWNpdHlFeGl0ID0gbWl4TnVtYmVyJDEoZm9sbG93Lm9wYWNpdHkgIT09IHVuZGVmaW5lZCA/IGZvbGxvdy5vcGFjaXR5IDogMSwgMCwgZWFzZUNyb3NzZmFkZU91dChwcm9ncmVzcykpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc09ubHlNZW1iZXIpIHtcbiAgICAgICAgdGFyZ2V0Lm9wYWNpdHkgPSBtaXhOdW1iZXIkMShmb2xsb3cub3BhY2l0eSAhPT0gdW5kZWZpbmVkID8gZm9sbG93Lm9wYWNpdHkgOiAxLCBsZWFkLm9wYWNpdHkgIT09IHVuZGVmaW5lZCA/IGxlYWQub3BhY2l0eSA6IDEsIHByb2dyZXNzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWl4IGJvcmRlciByYWRpdXNcbiAgICAgKi9cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUJvcmRlcnM7IGkrKykge1xuICAgICAgICBjb25zdCBib3JkZXJMYWJlbCA9IGBib3JkZXIke2JvcmRlcnNbaV19UmFkaXVzYDtcbiAgICAgICAgbGV0IGZvbGxvd1JhZGl1cyA9IGdldFJhZGl1cyhmb2xsb3csIGJvcmRlckxhYmVsKTtcbiAgICAgICAgbGV0IGxlYWRSYWRpdXMgPSBnZXRSYWRpdXMobGVhZCwgYm9yZGVyTGFiZWwpO1xuICAgICAgICBpZiAoZm9sbG93UmFkaXVzID09PSB1bmRlZmluZWQgJiYgbGVhZFJhZGl1cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGZvbGxvd1JhZGl1cyB8fCAoZm9sbG93UmFkaXVzID0gMCk7XG4gICAgICAgIGxlYWRSYWRpdXMgfHwgKGxlYWRSYWRpdXMgPSAwKTtcbiAgICAgICAgY29uc3QgY2FuTWl4ID0gZm9sbG93UmFkaXVzID09PSAwIHx8XG4gICAgICAgICAgICBsZWFkUmFkaXVzID09PSAwIHx8XG4gICAgICAgICAgICBpc1B4KGZvbGxvd1JhZGl1cykgPT09IGlzUHgobGVhZFJhZGl1cyk7XG4gICAgICAgIGlmIChjYW5NaXgpIHtcbiAgICAgICAgICAgIHRhcmdldFtib3JkZXJMYWJlbF0gPSBNYXRoLm1heChtaXhOdW1iZXIkMShhc051bWJlcihmb2xsb3dSYWRpdXMpLCBhc051bWJlcihsZWFkUmFkaXVzKSwgcHJvZ3Jlc3MpLCAwKTtcbiAgICAgICAgICAgIGlmIChwZXJjZW50LnRlc3QobGVhZFJhZGl1cykgfHwgcGVyY2VudC50ZXN0KGZvbGxvd1JhZGl1cykpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbYm9yZGVyTGFiZWxdICs9IFwiJVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0W2JvcmRlckxhYmVsXSA9IGxlYWRSYWRpdXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTWl4IHJvdGF0aW9uXG4gICAgICovXG4gICAgaWYgKGZvbGxvdy5yb3RhdGUgfHwgbGVhZC5yb3RhdGUpIHtcbiAgICAgICAgdGFyZ2V0LnJvdGF0ZSA9IG1peE51bWJlciQxKGZvbGxvdy5yb3RhdGUgfHwgMCwgbGVhZC5yb3RhdGUgfHwgMCwgcHJvZ3Jlc3MpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFJhZGl1cyh2YWx1ZXMsIHJhZGl1c05hbWUpIHtcbiAgICByZXR1cm4gdmFsdWVzW3JhZGl1c05hbWVdICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyB2YWx1ZXNbcmFkaXVzTmFtZV1cbiAgICAgICAgOiB2YWx1ZXMuYm9yZGVyUmFkaXVzO1xufVxuLy8gLyoqXG4vLyAgKiBXZSBvbmx5IHdhbnQgdG8gbWl4IHRoZSBiYWNrZ3JvdW5kIGNvbG9yIGlmIHRoZXJlJ3MgYSBmb2xsb3cgZWxlbWVudFxuLy8gICogdGhhdCB3ZSdyZSBub3QgY3Jvc3NmYWRpbmcgb3BhY2l0eSBiZXR3ZWVuLiBGb3IgaW5zdGFuY2Ugd2l0aCBzd2l0Y2hcbi8vICAqIEFuaW1hdGVTaGFyZWRMYXlvdXQgYW5pbWF0aW9ucywgdGhpcyBoZWxwcyB0aGUgaWxsdXNpb24gb2YgYSBjb250aW51b3VzXG4vLyAgKiBlbGVtZW50IGJlaW5nIGFuaW1hdGVkIGJ1dCBhbHNvIGN1dHMgZG93biBvbiB0aGUgbnVtYmVyIG9mIHBhaW50cyB0cmlnZ2VyZWRcbi8vICAqIGZvciBlbGVtZW50cyB3aGVyZSBvcGFjaXR5IGlzIGRvaW5nIHRoYXQgd29yayBmb3IgdXMuXG4vLyAgKi9cbi8vIGlmIChcbi8vICAgICAhaGFzRm9sbG93RWxlbWVudCAmJlxuLy8gICAgIGxhdGVzdExlYWRWYWx1ZXMuYmFja2dyb3VuZENvbG9yICYmXG4vLyAgICAgbGF0ZXN0Rm9sbG93VmFsdWVzLmJhY2tncm91bmRDb2xvclxuLy8gKSB7XG4vLyAgICAgLyoqXG4vLyAgICAgICogVGhpcyBpc24ndCBpZGVhbCBwZXJmb3JtYW5jZS13aXNlIGFzIG1peENvbG9yIGlzIGNyZWF0aW5nIGEgbmV3IGZ1bmN0aW9uIGV2ZXJ5IGZyYW1lLlxuLy8gICAgICAqIFdlIGNvdWxkIHByb2JhYmx5IGNyZWF0ZSBhIG1peGVyIHRoYXQgcnVucyBhdCB0aGUgc3RhcnQgb2YgdGhlIGFuaW1hdGlvbiBidXRcbi8vICAgICAgKiB0aGUgaWRlYSBiZWhpbmQgdGhlIGNyb3NzZmFkZXIgaXMgdGhhdCBpdCBydW5zIGR5bmFtaWNhbGx5IGJldHdlZW4gdHdvIHBvdGVudGlhbGx5XG4vLyAgICAgICogY2hhbmdpbmcgdGFyZ2V0cyAoaWUgb3BhY2l0eSBvciBib3JkZXJSYWRpdXMgbWF5IGJlIGFuaW1hdGluZyBpbmRlcGVuZGVudGx5IHZpYSB2YXJpYW50cylcbi8vICAgICAgKi9cbi8vICAgICBsZWFkU3RhdGUuYmFja2dyb3VuZENvbG9yID0gZm9sbG93U3RhdGUuYmFja2dyb3VuZENvbG9yID0gbWl4Q29sb3IoXG4vLyAgICAgICAgIGxhdGVzdEZvbGxvd1ZhbHVlcy5iYWNrZ3JvdW5kQ29sb3IgYXMgc3RyaW5nLFxuLy8gICAgICAgICBsYXRlc3RMZWFkVmFsdWVzLmJhY2tncm91bmRDb2xvciBhcyBzdHJpbmdcbi8vICAgICApKHApXG4vLyB9XG5jb25zdCBlYXNlQ3Jvc3NmYWRlSW4gPSAvKkBfX1BVUkVfXyovIGNvbXByZXNzKDAsIDAuNSwgY2lyY091dCk7XG5jb25zdCBlYXNlQ3Jvc3NmYWRlT3V0ID0gLypAX19QVVJFX18qLyBjb21wcmVzcygwLjUsIDAuOTUsIG1vdGlvblV0aWxzLm5vb3ApO1xuZnVuY3Rpb24gY29tcHJlc3MobWluLCBtYXgsIGVhc2luZykge1xuICAgIHJldHVybiAocCkgPT4ge1xuICAgICAgICAvLyBDb3VsZCByZXBsYWNlIGlmcyB3aXRoIGNsYW1wXG4gICAgICAgIGlmIChwIDwgbWluKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGlmIChwID4gbWF4KVxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIHJldHVybiBlYXNpbmcocHJvZ3Jlc3MobWluLCBtYXgsIHApKTtcbiAgICB9O1xufVxuXG4vKipcbiAqIFJlc2V0IGFuIGF4aXMgdG8gdGhlIHByb3ZpZGVkIG9yaWdpbiBib3guXG4gKlxuICogVGhpcyBpcyBhIG11dGF0aXZlIG9wZXJhdGlvbi5cbiAqL1xuZnVuY3Rpb24gY29weUF4aXNJbnRvKGF4aXMsIG9yaWdpbkF4aXMpIHtcbiAgICBheGlzLm1pbiA9IG9yaWdpbkF4aXMubWluO1xuICAgIGF4aXMubWF4ID0gb3JpZ2luQXhpcy5tYXg7XG59XG4vKipcbiAqIFJlc2V0IGEgYm94IHRvIHRoZSBwcm92aWRlZCBvcmlnaW4gYm94LlxuICpcbiAqIFRoaXMgaXMgYSBtdXRhdGl2ZSBvcGVyYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGNvcHlCb3hJbnRvKGJveCwgb3JpZ2luQm94KSB7XG4gICAgY29weUF4aXNJbnRvKGJveC54LCBvcmlnaW5Cb3gueCk7XG4gICAgY29weUF4aXNJbnRvKGJveC55LCBvcmlnaW5Cb3gueSk7XG59XG4vKipcbiAqIFJlc2V0IGEgZGVsdGEgdG8gdGhlIHByb3ZpZGVkIG9yaWdpbiBib3guXG4gKlxuICogVGhpcyBpcyBhIG11dGF0aXZlIG9wZXJhdGlvbi5cbiAqL1xuZnVuY3Rpb24gY29weUF4aXNEZWx0YUludG8oZGVsdGEsIG9yaWdpbkRlbHRhKSB7XG4gICAgZGVsdGEudHJhbnNsYXRlID0gb3JpZ2luRGVsdGEudHJhbnNsYXRlO1xuICAgIGRlbHRhLnNjYWxlID0gb3JpZ2luRGVsdGEuc2NhbGU7XG4gICAgZGVsdGEub3JpZ2luUG9pbnQgPSBvcmlnaW5EZWx0YS5vcmlnaW5Qb2ludDtcbiAgICBkZWx0YS5vcmlnaW4gPSBvcmlnaW5EZWx0YS5vcmlnaW47XG59XG5cbi8qKlxuICogUmVtb3ZlIGEgZGVsdGEgZnJvbSBhIHBvaW50LiBUaGlzIGlzIGVzc2VudGlhbGx5IHRoZSBzdGVwcyBvZiBhcHBseVBvaW50RGVsdGEgaW4gcmV2ZXJzZVxuICovXG5mdW5jdGlvbiByZW1vdmVQb2ludERlbHRhKHBvaW50LCB0cmFuc2xhdGUsIHNjYWxlLCBvcmlnaW5Qb2ludCwgYm94U2NhbGUpIHtcbiAgICBwb2ludCAtPSB0cmFuc2xhdGU7XG4gICAgcG9pbnQgPSBzY2FsZVBvaW50KHBvaW50LCAxIC8gc2NhbGUsIG9yaWdpblBvaW50KTtcbiAgICBpZiAoYm94U2NhbGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwb2ludCA9IHNjYWxlUG9pbnQocG9pbnQsIDEgLyBib3hTY2FsZSwgb3JpZ2luUG9pbnQpO1xuICAgIH1cbiAgICByZXR1cm4gcG9pbnQ7XG59XG4vKipcbiAqIFJlbW92ZSBhIGRlbHRhIGZyb20gYW4gYXhpcy4gVGhpcyBpcyBlc3NlbnRpYWxseSB0aGUgc3RlcHMgb2YgYXBwbHlBeGlzRGVsdGEgaW4gcmV2ZXJzZVxuICovXG5mdW5jdGlvbiByZW1vdmVBeGlzRGVsdGEoYXhpcywgdHJhbnNsYXRlID0gMCwgc2NhbGUgPSAxLCBvcmlnaW4gPSAwLjUsIGJveFNjYWxlLCBvcmlnaW5BeGlzID0gYXhpcywgc291cmNlQXhpcyA9IGF4aXMpIHtcbiAgICBpZiAocGVyY2VudC50ZXN0KHRyYW5zbGF0ZSkpIHtcbiAgICAgICAgdHJhbnNsYXRlID0gcGFyc2VGbG9hdCh0cmFuc2xhdGUpO1xuICAgICAgICBjb25zdCByZWxhdGl2ZVByb2dyZXNzID0gbWl4TnVtYmVyJDEoc291cmNlQXhpcy5taW4sIHNvdXJjZUF4aXMubWF4LCB0cmFuc2xhdGUgLyAxMDApO1xuICAgICAgICB0cmFuc2xhdGUgPSByZWxhdGl2ZVByb2dyZXNzIC0gc291cmNlQXhpcy5taW47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdHJhbnNsYXRlICE9PSBcIm51bWJlclwiKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IG9yaWdpblBvaW50ID0gbWl4TnVtYmVyJDEob3JpZ2luQXhpcy5taW4sIG9yaWdpbkF4aXMubWF4LCBvcmlnaW4pO1xuICAgIGlmIChheGlzID09PSBvcmlnaW5BeGlzKVxuICAgICAgICBvcmlnaW5Qb2ludCAtPSB0cmFuc2xhdGU7XG4gICAgYXhpcy5taW4gPSByZW1vdmVQb2ludERlbHRhKGF4aXMubWluLCB0cmFuc2xhdGUsIHNjYWxlLCBvcmlnaW5Qb2ludCwgYm94U2NhbGUpO1xuICAgIGF4aXMubWF4ID0gcmVtb3ZlUG9pbnREZWx0YShheGlzLm1heCwgdHJhbnNsYXRlLCBzY2FsZSwgb3JpZ2luUG9pbnQsIGJveFNjYWxlKTtcbn1cbi8qKlxuICogUmVtb3ZlIGEgdHJhbnNmb3JtcyBmcm9tIGFuIGF4aXMuIFRoaXMgaXMgZXNzZW50aWFsbHkgdGhlIHN0ZXBzIG9mIGFwcGx5QXhpc1RyYW5zZm9ybXMgaW4gcmV2ZXJzZVxuICogYW5kIGFjdHMgYXMgYSBicmlkZ2UgYmV0d2VlbiBtb3Rpb24gdmFsdWVzIGFuZCByZW1vdmVBeGlzRGVsdGFcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQXhpc1RyYW5zZm9ybXMoYXhpcywgdHJhbnNmb3JtcywgW2tleSwgc2NhbGVLZXksIG9yaWdpbktleV0sIG9yaWdpbiwgc291cmNlQXhpcykge1xuICAgIHJlbW92ZUF4aXNEZWx0YShheGlzLCB0cmFuc2Zvcm1zW2tleV0sIHRyYW5zZm9ybXNbc2NhbGVLZXldLCB0cmFuc2Zvcm1zW29yaWdpbktleV0sIHRyYW5zZm9ybXMuc2NhbGUsIG9yaWdpbiwgc291cmNlQXhpcyk7XG59XG4vKipcbiAqIFRoZSBuYW1lcyBvZiB0aGUgbW90aW9uIHZhbHVlcyB3ZSB3YW50IHRvIGFwcGx5IGFzIHRyYW5zbGF0aW9uLCBzY2FsZSBhbmQgb3JpZ2luLlxuICovXG5jb25zdCB4S2V5cyA9IFtcInhcIiwgXCJzY2FsZVhcIiwgXCJvcmlnaW5YXCJdO1xuY29uc3QgeUtleXMgPSBbXCJ5XCIsIFwic2NhbGVZXCIsIFwib3JpZ2luWVwiXTtcbi8qKlxuICogUmVtb3ZlIGEgdHJhbnNmb3JtcyBmcm9tIGFuIGJveC4gVGhpcyBpcyBlc3NlbnRpYWxseSB0aGUgc3RlcHMgb2YgYXBwbHlBeGlzQm94IGluIHJldmVyc2VcbiAqIGFuZCBhY3RzIGFzIGEgYnJpZGdlIGJldHdlZW4gbW90aW9uIHZhbHVlcyBhbmQgcmVtb3ZlQXhpc0RlbHRhXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUJveFRyYW5zZm9ybXMoYm94LCB0cmFuc2Zvcm1zLCBvcmlnaW5Cb3gsIHNvdXJjZUJveCkge1xuICAgIHJlbW92ZUF4aXNUcmFuc2Zvcm1zKGJveC54LCB0cmFuc2Zvcm1zLCB4S2V5cywgb3JpZ2luQm94ID8gb3JpZ2luQm94LnggOiB1bmRlZmluZWQsIHNvdXJjZUJveCA/IHNvdXJjZUJveC54IDogdW5kZWZpbmVkKTtcbiAgICByZW1vdmVBeGlzVHJhbnNmb3Jtcyhib3gueSwgdHJhbnNmb3JtcywgeUtleXMsIG9yaWdpbkJveCA/IG9yaWdpbkJveC55IDogdW5kZWZpbmVkLCBzb3VyY2VCb3ggPyBzb3VyY2VCb3gueSA6IHVuZGVmaW5lZCk7XG59XG5cbmZ1bmN0aW9uIGlzQXhpc0RlbHRhWmVybyhkZWx0YSkge1xuICAgIHJldHVybiBkZWx0YS50cmFuc2xhdGUgPT09IDAgJiYgZGVsdGEuc2NhbGUgPT09IDE7XG59XG5mdW5jdGlvbiBpc0RlbHRhWmVybyhkZWx0YSkge1xuICAgIHJldHVybiBpc0F4aXNEZWx0YVplcm8oZGVsdGEueCkgJiYgaXNBeGlzRGVsdGFaZXJvKGRlbHRhLnkpO1xufVxuZnVuY3Rpb24gYXhpc0VxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIGEubWluID09PSBiLm1pbiAmJiBhLm1heCA9PT0gYi5tYXg7XG59XG5mdW5jdGlvbiBib3hFcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBheGlzRXF1YWxzKGEueCwgYi54KSAmJiBheGlzRXF1YWxzKGEueSwgYi55KTtcbn1cbmZ1bmN0aW9uIGF4aXNFcXVhbHNSb3VuZGVkKGEsIGIpIHtcbiAgICByZXR1cm4gKE1hdGgucm91bmQoYS5taW4pID09PSBNYXRoLnJvdW5kKGIubWluKSAmJlxuICAgICAgICBNYXRoLnJvdW5kKGEubWF4KSA9PT0gTWF0aC5yb3VuZChiLm1heCkpO1xufVxuZnVuY3Rpb24gYm94RXF1YWxzUm91bmRlZChhLCBiKSB7XG4gICAgcmV0dXJuIGF4aXNFcXVhbHNSb3VuZGVkKGEueCwgYi54KSAmJiBheGlzRXF1YWxzUm91bmRlZChhLnksIGIueSk7XG59XG5mdW5jdGlvbiBhc3BlY3RSYXRpbyhib3gpIHtcbiAgICByZXR1cm4gY2FsY0xlbmd0aChib3gueCkgLyBjYWxjTGVuZ3RoKGJveC55KTtcbn1cbmZ1bmN0aW9uIGF4aXNEZWx0YUVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIChhLnRyYW5zbGF0ZSA9PT0gYi50cmFuc2xhdGUgJiZcbiAgICAgICAgYS5zY2FsZSA9PT0gYi5zY2FsZSAmJlxuICAgICAgICBhLm9yaWdpblBvaW50ID09PSBiLm9yaWdpblBvaW50KTtcbn1cblxuY2xhc3MgTm9kZVN0YWNrIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5tZW1iZXJzID0gW107XG4gICAgfVxuICAgIGFkZChub2RlKSB7XG4gICAgICAgIGFkZFVuaXF1ZUl0ZW0odGhpcy5tZW1iZXJzLCBub2RlKTtcbiAgICAgICAgbm9kZS5zY2hlZHVsZVJlbmRlcigpO1xuICAgIH1cbiAgICByZW1vdmUobm9kZSkge1xuICAgICAgICByZW1vdmVJdGVtKHRoaXMubWVtYmVycywgbm9kZSk7XG4gICAgICAgIGlmIChub2RlID09PSB0aGlzLnByZXZMZWFkKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZMZWFkID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlID09PSB0aGlzLmxlYWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHByZXZMZWFkID0gdGhpcy5tZW1iZXJzW3RoaXMubWVtYmVycy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmIChwcmV2TGVhZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvbW90ZShwcmV2TGVhZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVsZWdhdGUobm9kZSkge1xuICAgICAgICBjb25zdCBpbmRleE9mTm9kZSA9IHRoaXMubWVtYmVycy5maW5kSW5kZXgoKG1lbWJlcikgPT4gbm9kZSA9PT0gbWVtYmVyKTtcbiAgICAgICAgaWYgKGluZGV4T2ZOb2RlID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmluZCB0aGUgbmV4dCBwcm9qZWN0aW9uIG5vZGUgdGhhdCBpcyBwcmVzZW50XG4gICAgICAgICAqL1xuICAgICAgICBsZXQgcHJldkxlYWQ7XG4gICAgICAgIGZvciAobGV0IGkgPSBpbmRleE9mTm9kZTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IG1lbWJlciA9IHRoaXMubWVtYmVyc1tpXTtcbiAgICAgICAgICAgIGlmIChtZW1iZXIuaXNQcmVzZW50ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHByZXZMZWFkID0gbWVtYmVyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2TGVhZCkge1xuICAgICAgICAgICAgdGhpcy5wcm9tb3RlKHByZXZMZWFkKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByb21vdGUobm9kZSwgcHJlc2VydmVGb2xsb3dPcGFjaXR5KSB7XG4gICAgICAgIGNvbnN0IHByZXZMZWFkID0gdGhpcy5sZWFkO1xuICAgICAgICBpZiAobm9kZSA9PT0gcHJldkxlYWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMucHJldkxlYWQgPSBwcmV2TGVhZDtcbiAgICAgICAgdGhpcy5sZWFkID0gbm9kZTtcbiAgICAgICAgbm9kZS5zaG93KCk7XG4gICAgICAgIGlmIChwcmV2TGVhZCkge1xuICAgICAgICAgICAgcHJldkxlYWQuaW5zdGFuY2UgJiYgcHJldkxlYWQuc2NoZWR1bGVSZW5kZXIoKTtcbiAgICAgICAgICAgIG5vZGUuc2NoZWR1bGVSZW5kZXIoKTtcbiAgICAgICAgICAgIG5vZGUucmVzdW1lRnJvbSA9IHByZXZMZWFkO1xuICAgICAgICAgICAgaWYgKHByZXNlcnZlRm9sbG93T3BhY2l0eSkge1xuICAgICAgICAgICAgICAgIG5vZGUucmVzdW1lRnJvbS5wcmVzZXJ2ZU9wYWNpdHkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByZXZMZWFkLnNuYXBzaG90KSB7XG4gICAgICAgICAgICAgICAgbm9kZS5zbmFwc2hvdCA9IHByZXZMZWFkLnNuYXBzaG90O1xuICAgICAgICAgICAgICAgIG5vZGUuc25hcHNob3QubGF0ZXN0VmFsdWVzID1cbiAgICAgICAgICAgICAgICAgICAgcHJldkxlYWQuYW5pbWF0aW9uVmFsdWVzIHx8IHByZXZMZWFkLmxhdGVzdFZhbHVlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLnJvb3QgJiYgbm9kZS5yb290LmlzVXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICBub2RlLmlzTGF5b3V0RGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBjcm9zc2ZhZGUgfSA9IG5vZGUub3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjcm9zc2ZhZGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcHJldkxlYWQuaGlkZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUT0RPOlxuICAgICAgICAgICAgICogICAtIFRlc3QgYm9yZGVyIHJhZGl1cyB3aGVuIHByZXZpb3VzIG5vZGUgd2FzIGRlbGV0ZWRcbiAgICAgICAgICAgICAqICAgLSBib3hTaGFkb3cgbWl4aW5nXG4gICAgICAgICAgICAgKiAgIC0gU2hhcmVkIGJldHdlZW4gZWxlbWVudCBBIGluIHNjcm9sbGVkIGNvbnRhaW5lciBhbmQgZWxlbWVudCBCIChzY3JvbGwgc3RheXMgdGhlIHNhbWUgb3IgY2hhbmdlcylcbiAgICAgICAgICAgICAqICAgLSBTaGFyZWQgYmV0d2VlbiBlbGVtZW50IEEgaW4gdHJhbnNmb3JtZWQgY29udGFpbmVyIGFuZCBlbGVtZW50IEIgKHRyYW5zZm9ybSBzdGF5cyB0aGUgc2FtZSBvciBjaGFuZ2VzKVxuICAgICAgICAgICAgICogICAtIFNoYXJlZCBiZXR3ZWVuIGVsZW1lbnQgQSBpbiBzY3JvbGxlZCBwYWdlIGFuZCBlbGVtZW50IEIgKHNjcm9sbCBzdGF5cyB0aGUgc2FtZSBvciBjaGFuZ2VzKVxuICAgICAgICAgICAgICogLS0tXG4gICAgICAgICAgICAgKiAgIC0gQ3Jvc3NmYWRlIG9wYWNpdHkgb2Ygcm9vdCBub2Rlc1xuICAgICAgICAgICAgICogICAtIGxheW91dElkIGNoYW5nZXMgYWZ0ZXIgYW5pbWF0aW9uXG4gICAgICAgICAgICAgKiAgIC0gbGF5b3V0SWQgY2hhbmdlcyBtaWQgYW5pbWF0aW9uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgfVxuICAgIH1cbiAgICBleGl0QW5pbWF0aW9uQ29tcGxldGUoKSB7XG4gICAgICAgIHRoaXMubWVtYmVycy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG9wdGlvbnMsIHJlc3VtaW5nRnJvbSB9ID0gbm9kZTtcbiAgICAgICAgICAgIG9wdGlvbnMub25FeGl0Q29tcGxldGUgJiYgb3B0aW9ucy5vbkV4aXRDb21wbGV0ZSgpO1xuICAgICAgICAgICAgaWYgKHJlc3VtaW5nRnJvbSkge1xuICAgICAgICAgICAgICAgIHJlc3VtaW5nRnJvbS5vcHRpb25zLm9uRXhpdENvbXBsZXRlICYmXG4gICAgICAgICAgICAgICAgICAgIHJlc3VtaW5nRnJvbS5vcHRpb25zLm9uRXhpdENvbXBsZXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzY2hlZHVsZVJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5tZW1iZXJzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgICAgIG5vZGUuaW5zdGFuY2UgJiYgbm9kZS5zY2hlZHVsZVJlbmRlcihmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhciBhbnkgbGVhZHMgdGhhdCBoYXZlIGJlZW4gcmVtb3ZlZCB0aGlzIHJlbmRlciB0byBwcmV2ZW50IHRoZW0gZnJvbSBiZWluZ1xuICAgICAqIHVzZWQgaW4gZnV0dXJlIGFuaW1hdGlvbnMgYW5kIHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzXG4gICAgICovXG4gICAgcmVtb3ZlTGVhZFNuYXBzaG90KCkge1xuICAgICAgICBpZiAodGhpcy5sZWFkICYmIHRoaXMubGVhZC5zbmFwc2hvdCkge1xuICAgICAgICAgICAgdGhpcy5sZWFkLnNuYXBzaG90ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCBzY2FsZUNvcnJlY3RvcnMgPSB7fTtcbmZ1bmN0aW9uIGFkZFNjYWxlQ29ycmVjdG9yKGNvcnJlY3RvcnMpIHtcbiAgICBPYmplY3QuYXNzaWduKHNjYWxlQ29ycmVjdG9ycywgY29ycmVjdG9ycyk7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkUHJvamVjdGlvblRyYW5zZm9ybShkZWx0YSwgdHJlZVNjYWxlLCBsYXRlc3RUcmFuc2Zvcm0pIHtcbiAgICBsZXQgdHJhbnNmb3JtID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgdHJhbnNsYXRpb25zIHdlIHVzZSB0byBjYWxjdWxhdGUgYXJlIGFsd2F5cyByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQgY29vcmRpbmF0ZSBzcGFjZS5cbiAgICAgKiBCdXQgd2hlbiB3ZSBhcHBseSBzY2FsZXMsIHdlIGFsc28gc2NhbGUgdGhlIGNvb3JkaW5hdGUgc3BhY2Ugb2YgYW4gZWxlbWVudCBhbmQgaXRzIGNoaWxkcmVuLlxuICAgICAqIEZvciBpbnN0YW5jZSBpZiB3ZSBoYXZlIGEgdHJlZVNjYWxlICh0aGUgY3VsbWluYXRpb24gb2YgYWxsIHBhcmVudCBzY2FsZXMpIG9mIDAuNSBhbmQgd2UgbmVlZFxuICAgICAqIHRvIG1vdmUgYW4gZWxlbWVudCAxMDAgcGl4ZWxzLCB3ZSBhY3R1YWxseSBuZWVkIHRvIG1vdmUgaXQgMjAwIGluIHdpdGhpbiB0aGF0IHNjYWxlZCBzcGFjZS5cbiAgICAgKi9cbiAgICBjb25zdCB4VHJhbnNsYXRlID0gZGVsdGEueC50cmFuc2xhdGUgLyB0cmVlU2NhbGUueDtcbiAgICBjb25zdCB5VHJhbnNsYXRlID0gZGVsdGEueS50cmFuc2xhdGUgLyB0cmVlU2NhbGUueTtcbiAgICBjb25zdCB6VHJhbnNsYXRlID0gKGxhdGVzdFRyYW5zZm9ybSA9PT0gbnVsbCB8fCBsYXRlc3RUcmFuc2Zvcm0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxhdGVzdFRyYW5zZm9ybS56KSB8fCAwO1xuICAgIGlmICh4VHJhbnNsYXRlIHx8IHlUcmFuc2xhdGUgfHwgelRyYW5zbGF0ZSkge1xuICAgICAgICB0cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoJHt4VHJhbnNsYXRlfXB4LCAke3lUcmFuc2xhdGV9cHgsICR7elRyYW5zbGF0ZX1weCkgYDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbHkgc2NhbGUgY29ycmVjdGlvbiBmb3IgdGhlIHRyZWUgdHJhbnNmb3JtLlxuICAgICAqIFRoaXMgd2lsbCBhcHBseSBzY2FsZSB0byB0aGUgc2NyZWVuLW9yaWVudGF0ZWQgYXhlcy5cbiAgICAgKi9cbiAgICBpZiAodHJlZVNjYWxlLnggIT09IDEgfHwgdHJlZVNjYWxlLnkgIT09IDEpIHtcbiAgICAgICAgdHJhbnNmb3JtICs9IGBzY2FsZSgkezEgLyB0cmVlU2NhbGUueH0sICR7MSAvIHRyZWVTY2FsZS55fSkgYDtcbiAgICB9XG4gICAgaWYgKGxhdGVzdFRyYW5zZm9ybSkge1xuICAgICAgICBjb25zdCB7IHRyYW5zZm9ybVBlcnNwZWN0aXZlLCByb3RhdGUsIHJvdGF0ZVgsIHJvdGF0ZVksIHNrZXdYLCBza2V3WSB9ID0gbGF0ZXN0VHJhbnNmb3JtO1xuICAgICAgICBpZiAodHJhbnNmb3JtUGVyc3BlY3RpdmUpXG4gICAgICAgICAgICB0cmFuc2Zvcm0gPSBgcGVyc3BlY3RpdmUoJHt0cmFuc2Zvcm1QZXJzcGVjdGl2ZX1weCkgJHt0cmFuc2Zvcm19YDtcbiAgICAgICAgaWYgKHJvdGF0ZSlcbiAgICAgICAgICAgIHRyYW5zZm9ybSArPSBgcm90YXRlKCR7cm90YXRlfWRlZykgYDtcbiAgICAgICAgaWYgKHJvdGF0ZVgpXG4gICAgICAgICAgICB0cmFuc2Zvcm0gKz0gYHJvdGF0ZVgoJHtyb3RhdGVYfWRlZykgYDtcbiAgICAgICAgaWYgKHJvdGF0ZVkpXG4gICAgICAgICAgICB0cmFuc2Zvcm0gKz0gYHJvdGF0ZVkoJHtyb3RhdGVZfWRlZykgYDtcbiAgICAgICAgaWYgKHNrZXdYKVxuICAgICAgICAgICAgdHJhbnNmb3JtICs9IGBza2V3WCgke3NrZXdYfWRlZykgYDtcbiAgICAgICAgaWYgKHNrZXdZKVxuICAgICAgICAgICAgdHJhbnNmb3JtICs9IGBza2V3WSgke3NrZXdZfWRlZykgYDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbHkgc2NhbGUgdG8gbWF0Y2ggdGhlIHNpemUgb2YgdGhlIGVsZW1lbnQgdG8gdGhlIHNpemUgd2Ugd2FudCBpdC5cbiAgICAgKiBUaGlzIHdpbGwgYXBwbHkgc2NhbGUgdG8gdGhlIGVsZW1lbnQtb3JpZW50YXRlZCBheGVzLlxuICAgICAqL1xuICAgIGNvbnN0IGVsZW1lbnRTY2FsZVggPSBkZWx0YS54LnNjYWxlICogdHJlZVNjYWxlLng7XG4gICAgY29uc3QgZWxlbWVudFNjYWxlWSA9IGRlbHRhLnkuc2NhbGUgKiB0cmVlU2NhbGUueTtcbiAgICBpZiAoZWxlbWVudFNjYWxlWCAhPT0gMSB8fCBlbGVtZW50U2NhbGVZICE9PSAxKSB7XG4gICAgICAgIHRyYW5zZm9ybSArPSBgc2NhbGUoJHtlbGVtZW50U2NhbGVYfSwgJHtlbGVtZW50U2NhbGVZfSlgO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNmb3JtIHx8IFwibm9uZVwiO1xufVxuXG5jb25zdCBjb21wYXJlQnlEZXB0aCA9IChhLCBiKSA9PiBhLmRlcHRoIC0gYi5kZXB0aDtcblxuY2xhc3MgRmxhdFRyZWUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgICAgIHRoaXMuaXNEaXJ0eSA9IGZhbHNlO1xuICAgIH1cbiAgICBhZGQoY2hpbGQpIHtcbiAgICAgICAgYWRkVW5pcXVlSXRlbSh0aGlzLmNoaWxkcmVuLCBjaGlsZCk7XG4gICAgICAgIHRoaXMuaXNEaXJ0eSA9IHRydWU7XG4gICAgfVxuICAgIHJlbW92ZShjaGlsZCkge1xuICAgICAgICByZW1vdmVJdGVtKHRoaXMuY2hpbGRyZW4sIGNoaWxkKTtcbiAgICAgICAgdGhpcy5pc0RpcnR5ID0gdHJ1ZTtcbiAgICB9XG4gICAgZm9yRWFjaChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmlzRGlydHkgJiYgdGhpcy5jaGlsZHJlbi5zb3J0KGNvbXBhcmVCeURlcHRoKTtcbiAgICAgICAgdGhpcy5pc0RpcnR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChjYWxsYmFjayk7XG4gICAgfVxufVxuXG4vKipcbiAqIElmIHRoZSBwcm92aWRlZCB2YWx1ZSBpcyBhIE1vdGlvblZhbHVlLCB0aGlzIHJldHVybnMgdGhlIGFjdHVhbCB2YWx1ZSwgb3RoZXJ3aXNlIGp1c3QgdGhlIHZhbHVlIGl0c2VsZlxuICpcbiAqIFRPRE86IFJlbW92ZSBhbmQgbW92ZSB0byBsaWJyYXJ5XG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVNb3Rpb25WYWx1ZSh2YWx1ZSkge1xuICAgIGNvbnN0IHVud3JhcHBlZFZhbHVlID0gaXNNb3Rpb25WYWx1ZSh2YWx1ZSkgPyB2YWx1ZS5nZXQoKSA6IHZhbHVlO1xuICAgIHJldHVybiBpc0N1c3RvbVZhbHVlKHVud3JhcHBlZFZhbHVlKVxuICAgICAgICA/IHVud3JhcHBlZFZhbHVlLnRvVmFsdWUoKVxuICAgICAgICA6IHVud3JhcHBlZFZhbHVlO1xufVxuXG4vKipcbiAqIFRoaXMgc2hvdWxkIG9ubHkgZXZlciBiZSBtb2RpZmllZCBvbiB0aGUgY2xpZW50IG90aGVyd2lzZSBpdCdsbFxuICogcGVyc2lzdCB0aHJvdWdoIHNlcnZlciByZXF1ZXN0cy4gSWYgd2UgbmVlZCBpbnN0YW5jZWQgc3RhdGVzIHdlXG4gKiBjb3VsZCBsYXp5LWluaXQgdmlhIHJvb3QuXG4gKi9cbmNvbnN0IGdsb2JhbFByb2plY3Rpb25TdGF0ZSA9IHtcbiAgICAvKipcbiAgICAgKiBHbG9iYWwgZmxhZyBhcyB0byB3aGV0aGVyIHRoZSB0cmVlIGhhcyBhbmltYXRlZCBzaW5jZSB0aGUgbGFzdCB0aW1lXG4gICAgICogd2UgcmVzaXplZCB0aGUgd2luZG93XG4gICAgICovXG4gICAgaGFzQW5pbWF0ZWRTaW5jZVJlc2l6ZTogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBXZSBzZXQgdGhpcyB0byB0cnVlIG9uY2UsIG9uIHRoZSBmaXJzdCB1cGRhdGUuIEFueSBub2RlcyBhZGRlZCB0byB0aGUgdHJlZSBiZXlvbmQgdGhhdFxuICAgICAqIHVwZGF0ZSB3aWxsIGJlIGdpdmVuIGEgYGRhdGEtcHJvamVjdGlvbi1pZGAgYXR0cmlidXRlLlxuICAgICAqL1xuICAgIGhhc0V2ZXJVcGRhdGVkOiBmYWxzZSxcbn07XG5cbi8qKlxuICogVGltZW91dCBkZWZpbmVkIGluIG1zXG4gKi9cbmZ1bmN0aW9uIGRlbGF5KGNhbGxiYWNrLCB0aW1lb3V0KSB7XG4gICAgY29uc3Qgc3RhcnQgPSB0aW1lLm5vdygpO1xuICAgIGNvbnN0IGNoZWNrRWxhcHNlZCA9ICh7IHRpbWVzdGFtcCB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGVsYXBzZWQgPSB0aW1lc3RhbXAgLSBzdGFydDtcbiAgICAgICAgaWYgKGVsYXBzZWQgPj0gdGltZW91dCkge1xuICAgICAgICAgICAgY2FuY2VsRnJhbWUoY2hlY2tFbGFwc2VkKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVsYXBzZWQgLSB0aW1lb3V0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZnJhbWUucmVhZChjaGVja0VsYXBzZWQsIHRydWUpO1xuICAgIHJldHVybiAoKSA9PiBjYW5jZWxGcmFtZShjaGVja0VsYXBzZWQpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIHByb2dyZXNzID0+IHByb2dyZXNzIGVhc2luZyBmdW5jdGlvbiBmcm9tIGEgZ2VuZXJhdG9yLlxuICovXG5mdW5jdGlvbiBjcmVhdGVHZW5lcmF0b3JFYXNpbmcob3B0aW9ucywgc2NhbGUgPSAxMDAsIGNyZWF0ZUdlbmVyYXRvcikge1xuICAgIGNvbnN0IGdlbmVyYXRvciA9IGNyZWF0ZUdlbmVyYXRvcih7IC4uLm9wdGlvbnMsIGtleWZyYW1lczogWzAsIHNjYWxlXSB9KTtcbiAgICBjb25zdCBkdXJhdGlvbiA9IE1hdGgubWluKGNhbGNHZW5lcmF0b3JEdXJhdGlvbihnZW5lcmF0b3IpLCBtYXhHZW5lcmF0b3JEdXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJrZXlmcmFtZXNcIixcbiAgICAgICAgZWFzZTogKHByb2dyZXNzKSA9PiBnZW5lcmF0b3IubmV4dChkdXJhdGlvbiAqIHByb2dyZXNzKS52YWx1ZSAvIHNjYWxlLFxuICAgICAgICBkdXJhdGlvbjogbWlsbGlzZWNvbmRzVG9TZWNvbmRzKGR1cmF0aW9uKSxcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBpc0RPTUtleWZyYW1lcyhrZXlmcmFtZXMpIHtcbiAgICByZXR1cm4gdHlwZW9mIGtleWZyYW1lcyA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShrZXlmcmFtZXMpO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlU3ViamVjdHMoc3ViamVjdCwga2V5ZnJhbWVzLCBzY29wZSwgc2VsZWN0b3JDYWNoZSkge1xuICAgIGlmICh0eXBlb2Ygc3ViamVjdCA9PT0gXCJzdHJpbmdcIiAmJiBpc0RPTUtleWZyYW1lcyhrZXlmcmFtZXMpKSB7XG4gICAgICAgIHJldHVybiBtb3Rpb25Eb20ucmVzb2x2ZUVsZW1lbnRzKHN1YmplY3QsIHNjb3BlLCBzZWxlY3RvckNhY2hlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc3ViamVjdCBpbnN0YW5jZW9mIE5vZGVMaXN0KSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHN1YmplY3QpO1xuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHN1YmplY3QpKSB7XG4gICAgICAgIHJldHVybiBzdWJqZWN0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtzdWJqZWN0XTtcbiAgICB9XG59XG5cbi8qKlxuICogR2l2ZW4gYSBhYnNvbHV0ZSBvciByZWxhdGl2ZSB0aW1lIGRlZmluaXRpb24gYW5kIGN1cnJlbnQvcHJldiB0aW1lIHN0YXRlIG9mIHRoZSBzZXF1ZW5jZSxcbiAqIGNhbGN1bGF0ZSBhbiBhYnNvbHV0ZSB0aW1lIGZvciB0aGUgbmV4dCBrZXlmcmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGNhbGNOZXh0VGltZShjdXJyZW50LCBuZXh0LCBwcmV2LCBsYWJlbHMpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKHR5cGVvZiBuZXh0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiBuZXh0O1xuICAgIH1cbiAgICBlbHNlIGlmIChuZXh0LnN0YXJ0c1dpdGgoXCItXCIpIHx8IG5leHQuc3RhcnRzV2l0aChcIitcIikpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIGN1cnJlbnQgKyBwYXJzZUZsb2F0KG5leHQpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobmV4dCA9PT0gXCI8XCIpIHtcbiAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gKF9hID0gbGFiZWxzLmdldChuZXh0KSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY3VycmVudDtcbiAgICB9XG59XG5cbmNvbnN0IHdyYXAgPSAobWluLCBtYXgsIHYpID0+IHtcbiAgICBjb25zdCByYW5nZVNpemUgPSBtYXggLSBtaW47XG4gICAgcmV0dXJuICgoKCh2IC0gbWluKSAlIHJhbmdlU2l6ZSkgKyByYW5nZVNpemUpICUgcmFuZ2VTaXplKSArIG1pbjtcbn07XG5cbmZ1bmN0aW9uIGdldEVhc2luZ0ZvclNlZ21lbnQoZWFzaW5nLCBpKSB7XG4gICAgcmV0dXJuIGlzRWFzaW5nQXJyYXkoZWFzaW5nKSA/IGVhc2luZ1t3cmFwKDAsIGVhc2luZy5sZW5ndGgsIGkpXSA6IGVhc2luZztcbn1cblxuZnVuY3Rpb24gZXJhc2VLZXlmcmFtZXMoc2VxdWVuY2UsIHN0YXJ0VGltZSwgZW5kVGltZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VxdWVuY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ZnJhbWUgPSBzZXF1ZW5jZVtpXTtcbiAgICAgICAgaWYgKGtleWZyYW1lLmF0ID4gc3RhcnRUaW1lICYmIGtleWZyYW1lLmF0IDwgZW5kVGltZSkge1xuICAgICAgICAgICAgcmVtb3ZlSXRlbShzZXF1ZW5jZSwga2V5ZnJhbWUpO1xuICAgICAgICAgICAgLy8gSWYgd2UgcmVtb3ZlIHRoaXMgaXRlbSB3ZSBoYXZlIHRvIHB1c2ggdGhlIHBvaW50ZXIgYmFjayBvbmVcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZEtleWZyYW1lcyhzZXF1ZW5jZSwga2V5ZnJhbWVzLCBlYXNpbmcsIG9mZnNldCwgc3RhcnRUaW1lLCBlbmRUaW1lKSB7XG4gICAgLyoqXG4gICAgICogRXJhc2UgZXZlcnkgZXhpc3RpbmcgdmFsdWUgYmV0d2VlbiBjdXJyZW50VGltZSBhbmQgdGFyZ2V0VGltZSxcbiAgICAgKiB0aGlzIHdpbGwgZXNzZW50aWFsbHkgc3BsaWNlIHRoaXMgdGltZWxpbmUgaW50byBhbnkgY3VycmVudGx5XG4gICAgICogZGVmaW5lZCBvbmVzLlxuICAgICAqL1xuICAgIGVyYXNlS2V5ZnJhbWVzKHNlcXVlbmNlLCBzdGFydFRpbWUsIGVuZFRpbWUpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5ZnJhbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNlcXVlbmNlLnB1c2goe1xuICAgICAgICAgICAgdmFsdWU6IGtleWZyYW1lc1tpXSxcbiAgICAgICAgICAgIGF0OiBtaXhOdW1iZXIkMShzdGFydFRpbWUsIGVuZFRpbWUsIG9mZnNldFtpXSksXG4gICAgICAgICAgICBlYXNpbmc6IGdldEVhc2luZ0ZvclNlZ21lbnQoZWFzaW5nLCBpKSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjb21wYXJlQnlUaW1lKGEsIGIpIHtcbiAgICBpZiAoYS5hdCA9PT0gYi5hdCkge1xuICAgICAgICBpZiAoYS52YWx1ZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICBpZiAoYi52YWx1ZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gYS5hdCAtIGIuYXQ7XG4gICAgfVxufVxuXG4vKipcbiAqIFRha2UgYW4gYXJyYXkgb2YgdGltZXMgdGhhdCByZXByZXNlbnQgcmVwZWF0ZWQga2V5ZnJhbWVzLiBGb3IgaW5zdGFuY2VcbiAqIGlmIHdlIGhhdmUgb3JpZ2luYWwgdGltZXMgb2YgWzAsIDAuNSwgMV0gdGhlbiBvdXIgcmVwZWF0ZWQgdGltZXMgd2lsbFxuICogYmUgWzAsIDAuNSwgMSwgMSwgMS41LCAyXS4gTG9vcCBvdmVyIHRoZSB0aW1lcyBhbmQgc2NhbGUgdGhlbSBiYWNrXG4gKiBkb3duIHRvIGEgMC0xIHNjYWxlLlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVUaW1lcyh0aW1lcywgcmVwZWF0KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aW1lc1tpXSA9IHRpbWVzW2ldIC8gKHJlcGVhdCArIDEpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlUmVwZWF0RHVyYXRpb24oZHVyYXRpb24sIHJlcGVhdCwgX3JlcGVhdERlbGF5KSB7XG4gICAgcmV0dXJuIGR1cmF0aW9uICogKHJlcGVhdCArIDEpO1xufVxuXG5jb25zdCBkZWZhdWx0U2VnbWVudEVhc2luZyA9IFwiZWFzZUluT3V0XCI7XG5jb25zdCBNQVhfUkVQRUFUID0gMjA7XG5mdW5jdGlvbiBjcmVhdGVBbmltYXRpb25zRnJvbVNlcXVlbmNlKHNlcXVlbmNlLCB7IGRlZmF1bHRUcmFuc2l0aW9uID0ge30sIC4uLnNlcXVlbmNlVHJhbnNpdGlvbiB9ID0ge30sIHNjb3BlLCBnZW5lcmF0b3JzKSB7XG4gICAgY29uc3QgZGVmYXVsdER1cmF0aW9uID0gZGVmYXVsdFRyYW5zaXRpb24uZHVyYXRpb24gfHwgMC4zO1xuICAgIGNvbnN0IGFuaW1hdGlvbkRlZmluaXRpb25zID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IHNlcXVlbmNlcyA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBlbGVtZW50Q2FjaGUgPSB7fTtcbiAgICBjb25zdCB0aW1lTGFiZWxzID0gbmV3IE1hcCgpO1xuICAgIGxldCBwcmV2VGltZSA9IDA7XG4gICAgbGV0IGN1cnJlbnRUaW1lID0gMDtcbiAgICBsZXQgdG90YWxEdXJhdGlvbiA9IDA7XG4gICAgLyoqXG4gICAgICogQnVpbGQgdGhlIHRpbWVsaW5lIGJ5IG1hcHBpbmcgb3ZlciB0aGUgc2VxdWVuY2UgYXJyYXkgYW5kIGNvbnZlcnRpbmdcbiAgICAgKiB0aGUgZGVmaW5pdGlvbnMgaW50byBrZXlmcmFtZXMgYW5kIG9mZnNldHMgd2l0aCBhYnNvbHV0ZSB0aW1lIHZhbHVlcy5cbiAgICAgKiBUaGVzZSB3aWxsIGxhdGVyIGdldCBjb252ZXJ0ZWQgaW50byByZWxhdGl2ZSBvZmZzZXRzIGluIGEgc2Vjb25kIHBhc3MuXG4gICAgICovXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXF1ZW5jZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBzZWdtZW50ID0gc2VxdWVuY2VbaV07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGlzIGlzIGEgdGltZWxpbmUgbGFiZWwsIG1hcmsgaXQgYW5kIHNraXAgdGhlIHJlc3Qgb2YgdGhpcyBpdGVyYXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodHlwZW9mIHNlZ21lbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRpbWVMYWJlbHMuc2V0KHNlZ21lbnQsIGN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KHNlZ21lbnQpKSB7XG4gICAgICAgICAgICB0aW1lTGFiZWxzLnNldChzZWdtZW50Lm5hbWUsIGNhbGNOZXh0VGltZShjdXJyZW50VGltZSwgc2VnbWVudC5hdCwgcHJldlRpbWUsIHRpbWVMYWJlbHMpKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBbc3ViamVjdCwga2V5ZnJhbWVzLCB0cmFuc2l0aW9uID0ge31dID0gc2VnbWVudDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGEgcmVsYXRpdmUgb3IgYWJzb2x1dGUgdGltZSB2YWx1ZSBoYXMgYmVlbiBzcGVjaWZpZWQgd2UgbmVlZCB0byByZXNvbHZlXG4gICAgICAgICAqIGl0IGluIHJlbGF0aW9uIHRvIHRoZSBjdXJyZW50VGltZS5cbiAgICAgICAgICovXG4gICAgICAgIGlmICh0cmFuc2l0aW9uLmF0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGN1cnJlbnRUaW1lID0gY2FsY05leHRUaW1lKGN1cnJlbnRUaW1lLCB0cmFuc2l0aW9uLmF0LCBwcmV2VGltZSwgdGltZUxhYmVscyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEtlZXAgdHJhY2sgb2YgdGhlIG1heGltdW0gZHVyYXRpb24gaW4gdGhpcyBkZWZpbml0aW9uLiBUaGlzIHdpbGwgYmVcbiAgICAgICAgICogYXBwbGllZCB0byBjdXJyZW50VGltZSBvbmNlIHRoZSBkZWZpbml0aW9uIGhhcyBiZWVuIHBhcnNlZC5cbiAgICAgICAgICovXG4gICAgICAgIGxldCBtYXhEdXJhdGlvbiA9IDA7XG4gICAgICAgIGNvbnN0IHJlc29sdmVWYWx1ZVNlcXVlbmNlID0gKHZhbHVlS2V5ZnJhbWVzLCB2YWx1ZVRyYW5zaXRpb24sIHZhbHVlU2VxdWVuY2UsIGVsZW1lbnRJbmRleCA9IDAsIG51bVN1YmplY3RzID0gMCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWVLZXlmcmFtZXNBc0xpc3QgPSBrZXlmcmFtZXNBc0xpc3QodmFsdWVLZXlmcmFtZXMpO1xuICAgICAgICAgICAgY29uc3QgeyBkZWxheSA9IDAsIHRpbWVzID0gZGVmYXVsdE9mZnNldCQxKHZhbHVlS2V5ZnJhbWVzQXNMaXN0KSwgdHlwZSA9IFwia2V5ZnJhbWVzXCIsIHJlcGVhdCwgcmVwZWF0VHlwZSwgcmVwZWF0RGVsYXkgPSAwLCAuLi5yZW1haW5pbmdUcmFuc2l0aW9uIH0gPSB2YWx1ZVRyYW5zaXRpb247XG4gICAgICAgICAgICBsZXQgeyBlYXNlID0gZGVmYXVsdFRyYW5zaXRpb24uZWFzZSB8fCBcImVhc2VPdXRcIiwgZHVyYXRpb24gfSA9IHZhbHVlVHJhbnNpdGlvbjtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmVzb2x2ZSBzdGFnZ2VyKCkgaWYgZGVmaW5lZC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgY2FsY3VsYXRlZERlbGF5ID0gdHlwZW9mIGRlbGF5ID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgICAgICA/IGRlbGF5KGVsZW1lbnRJbmRleCwgbnVtU3ViamVjdHMpXG4gICAgICAgICAgICAgICAgOiBkZWxheTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgdGhpcyBhbmltYXRpb24gc2hvdWxkIGFuZCBjYW4gdXNlIGEgc3ByaW5nLCBnZW5lcmF0ZSBhIHNwcmluZyBlYXNpbmcgZnVuY3Rpb24uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IG51bUtleWZyYW1lcyA9IHZhbHVlS2V5ZnJhbWVzQXNMaXN0Lmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZUdlbmVyYXRvciA9IGlzR2VuZXJhdG9yKHR5cGUpXG4gICAgICAgICAgICAgICAgPyB0eXBlXG4gICAgICAgICAgICAgICAgOiBnZW5lcmF0b3JzID09PSBudWxsIHx8IGdlbmVyYXRvcnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdlbmVyYXRvcnNbdHlwZV07XG4gICAgICAgICAgICBpZiAobnVtS2V5ZnJhbWVzIDw9IDIgJiYgY3JlYXRlR2VuZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQXMgd2UncmUgY3JlYXRpbmcgYW4gZWFzaW5nIGZ1bmN0aW9uIGZyb20gYSBzcHJpbmcsXG4gICAgICAgICAgICAgICAgICogaWRlYWxseSB3ZSB3YW50IHRvIGdlbmVyYXRlIGl0IHVzaW5nIHRoZSByZWFsIGRpc3RhbmNlXG4gICAgICAgICAgICAgICAgICogYmV0d2VlbiB0aGUgdHdvIGtleWZyYW1lcy4gSG93ZXZlciB0aGlzIGlzbid0IGFsd2F5c1xuICAgICAgICAgICAgICAgICAqIHBvc3NpYmxlIC0gaW4gdGhlc2Ugc2l0dWF0aW9ucyB3ZSB1c2UgMC0xMDAuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgbGV0IGFic29sdXRlRGVsdGEgPSAxMDA7XG4gICAgICAgICAgICAgICAgaWYgKG51bUtleWZyYW1lcyA9PT0gMiAmJlxuICAgICAgICAgICAgICAgICAgICBpc051bWJlcktleWZyYW1lc0FycmF5KHZhbHVlS2V5ZnJhbWVzQXNMaXN0KSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWx0YSA9IHZhbHVlS2V5ZnJhbWVzQXNMaXN0WzFdIC0gdmFsdWVLZXlmcmFtZXNBc0xpc3RbMF07XG4gICAgICAgICAgICAgICAgICAgIGFic29sdXRlRGVsdGEgPSBNYXRoLmFicyhkZWx0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHNwcmluZ1RyYW5zaXRpb24gPSB7IC4uLnJlbWFpbmluZ1RyYW5zaXRpb24gfTtcbiAgICAgICAgICAgICAgICBpZiAoZHVyYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBzcHJpbmdUcmFuc2l0aW9uLmR1cmF0aW9uID0gc2Vjb25kc1RvTWlsbGlzZWNvbmRzKGR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc3ByaW5nRWFzaW5nID0gY3JlYXRlR2VuZXJhdG9yRWFzaW5nKHNwcmluZ1RyYW5zaXRpb24sIGFic29sdXRlRGVsdGEsIGNyZWF0ZUdlbmVyYXRvcik7XG4gICAgICAgICAgICAgICAgZWFzZSA9IHNwcmluZ0Vhc2luZy5lYXNlO1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gc3ByaW5nRWFzaW5nLmR1cmF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZHVyYXRpb24gIT09IG51bGwgJiYgZHVyYXRpb24gIT09IHZvaWQgMCA/IGR1cmF0aW9uIDogKGR1cmF0aW9uID0gZGVmYXVsdER1cmF0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lICsgY2FsY3VsYXRlZERlbGF5O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB0aGVyZSdzIG9ubHkgb25lIHRpbWUgb2Zmc2V0IG9mIDAsIGZpbGwgaW4gYSBzZWNvbmQgd2l0aCBsZW5ndGggMVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAodGltZXMubGVuZ3RoID09PSAxICYmIHRpbWVzWzBdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGltZXNbMV0gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBGaWxsIG91dCBpZiBvZmZzZXQgaWYgZmV3ZXIgb2Zmc2V0cyB0aGFuIGtleWZyYW1lc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCByZW1haW5kZXIgPSB0aW1lcy5sZW5ndGggLSB2YWx1ZUtleWZyYW1lc0FzTGlzdC5sZW5ndGg7XG4gICAgICAgICAgICByZW1haW5kZXIgPiAwICYmIGZpbGxPZmZzZXQodGltZXMsIHJlbWFpbmRlcik7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIG9ubHkgb25lIHZhbHVlIGhhcyBiZWVuIHNldCwgaWUgWzFdLCBwdXNoIGEgbnVsbCB0byB0aGUgc3RhcnQgb2ZcbiAgICAgICAgICAgICAqIHRoZSBrZXlmcmFtZSBhcnJheS4gVGhpcyB3aWxsIGxldCB1cyBtYXJrIGEga2V5ZnJhbWUgYXQgdGhpcyBwb2ludFxuICAgICAgICAgICAgICogdGhhdCB3aWxsIGxhdGVyIGJlIGh5ZHJhdGVkIHdpdGggdGhlIHByZXZpb3VzIHZhbHVlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YWx1ZUtleWZyYW1lc0FzTGlzdC5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZUtleWZyYW1lc0FzTGlzdC51bnNoaWZ0KG51bGwpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBIYW5kbGUgcmVwZWF0IG9wdGlvbnNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHJlcGVhdCkge1xuICAgICAgICAgICAgICAgIG1vdGlvblV0aWxzLmludmFyaWFudChyZXBlYXQgPCBNQVhfUkVQRUFULCBcIlJlcGVhdCBjb3VudCB0b28gaGlnaCwgbXVzdCBiZSBsZXNzIHRoYW4gMjBcIik7XG4gICAgICAgICAgICAgICAgZHVyYXRpb24gPSBjYWxjdWxhdGVSZXBlYXREdXJhdGlvbihkdXJhdGlvbiwgcmVwZWF0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbEtleWZyYW1lcyA9IFsuLi52YWx1ZUtleWZyYW1lc0FzTGlzdF07XG4gICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxUaW1lcyA9IFsuLi50aW1lc107XG4gICAgICAgICAgICAgICAgZWFzZSA9IEFycmF5LmlzQXJyYXkoZWFzZSkgPyBbLi4uZWFzZV0gOiBbZWFzZV07XG4gICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxFYXNlID0gWy4uLmVhc2VdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHJlcGVhdEluZGV4ID0gMDsgcmVwZWF0SW5kZXggPCByZXBlYXQ7IHJlcGVhdEluZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVLZXlmcmFtZXNBc0xpc3QucHVzaCguLi5vcmlnaW5hbEtleWZyYW1lcyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGtleWZyYW1lSW5kZXggPSAwOyBrZXlmcmFtZUluZGV4IDwgb3JpZ2luYWxLZXlmcmFtZXMubGVuZ3RoOyBrZXlmcmFtZUluZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzLnB1c2gob3JpZ2luYWxUaW1lc1trZXlmcmFtZUluZGV4XSArIChyZXBlYXRJbmRleCArIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVhc2UucHVzaChrZXlmcmFtZUluZGV4ID09PSAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBcImxpbmVhclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBnZXRFYXNpbmdGb3JTZWdtZW50KG9yaWdpbmFsRWFzZSwga2V5ZnJhbWVJbmRleCAtIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub3JtYWxpemVUaW1lcyh0aW1lcywgcmVwZWF0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRhcmdldFRpbWUgPSBzdGFydFRpbWUgKyBkdXJhdGlvbjtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQWRkIGtleWZyYW1lcywgbWFwcGluZyBvZmZzZXRzIHRvIGFic29sdXRlIHRpbWUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGFkZEtleWZyYW1lcyh2YWx1ZVNlcXVlbmNlLCB2YWx1ZUtleWZyYW1lc0FzTGlzdCwgZWFzZSwgdGltZXMsIHN0YXJ0VGltZSwgdGFyZ2V0VGltZSk7XG4gICAgICAgICAgICBtYXhEdXJhdGlvbiA9IE1hdGgubWF4KGNhbGN1bGF0ZWREZWxheSArIGR1cmF0aW9uLCBtYXhEdXJhdGlvbik7XG4gICAgICAgICAgICB0b3RhbER1cmF0aW9uID0gTWF0aC5tYXgodGFyZ2V0VGltZSwgdG90YWxEdXJhdGlvbik7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChpc01vdGlvblZhbHVlKHN1YmplY3QpKSB7XG4gICAgICAgICAgICBjb25zdCBzdWJqZWN0U2VxdWVuY2UgPSBnZXRTdWJqZWN0U2VxdWVuY2Uoc3ViamVjdCwgc2VxdWVuY2VzKTtcbiAgICAgICAgICAgIHJlc29sdmVWYWx1ZVNlcXVlbmNlKGtleWZyYW1lcywgdHJhbnNpdGlvbiwgZ2V0VmFsdWVTZXF1ZW5jZShcImRlZmF1bHRcIiwgc3ViamVjdFNlcXVlbmNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzdWJqZWN0cyA9IHJlc29sdmVTdWJqZWN0cyhzdWJqZWN0LCBrZXlmcmFtZXMsIHNjb3BlLCBlbGVtZW50Q2FjaGUpO1xuICAgICAgICAgICAgY29uc3QgbnVtU3ViamVjdHMgPSBzdWJqZWN0cy5sZW5ndGg7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEZvciBldmVyeSBlbGVtZW50IGluIHRoaXMgc2VnbWVudCwgcHJvY2VzcyB0aGUgZGVmaW5lZCB2YWx1ZXMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZvciAobGV0IHN1YmplY3RJbmRleCA9IDA7IHN1YmplY3RJbmRleCA8IG51bVN1YmplY3RzOyBzdWJqZWN0SW5kZXgrKykge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIENhc3QgbmVjZXNzYXJ5LCBidXQgd2Uga25vdyB0aGVzZSBhcmUgb2YgdGhpcyB0eXBlXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAga2V5ZnJhbWVzID0ga2V5ZnJhbWVzO1xuICAgICAgICAgICAgICAgIHRyYW5zaXRpb24gPSB0cmFuc2l0aW9uO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRoaXNTdWJqZWN0ID0gc3ViamVjdHNbc3ViamVjdEluZGV4XTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWJqZWN0U2VxdWVuY2UgPSBnZXRTdWJqZWN0U2VxdWVuY2UodGhpc1N1YmplY3QsIHNlcXVlbmNlcyk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4ga2V5ZnJhbWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVWYWx1ZVNlcXVlbmNlKGtleWZyYW1lc1trZXldLCBnZXRWYWx1ZVRyYW5zaXRpb24odHJhbnNpdGlvbiwga2V5KSwgZ2V0VmFsdWVTZXF1ZW5jZShrZXksIHN1YmplY3RTZXF1ZW5jZSksIHN1YmplY3RJbmRleCwgbnVtU3ViamVjdHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwcmV2VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgICBjdXJyZW50VGltZSArPSBtYXhEdXJhdGlvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9yIGV2ZXJ5IGVsZW1lbnQgYW5kIHZhbHVlIGNvbWJpbmF0aW9uIGNyZWF0ZSBhIG5ldyBhbmltYXRpb24uXG4gICAgICovXG4gICAgc2VxdWVuY2VzLmZvckVhY2goKHZhbHVlU2VxdWVuY2VzLCBlbGVtZW50KSA9PiB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlU2VxdWVuY2VzKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZVNlcXVlbmNlID0gdmFsdWVTZXF1ZW5jZXNba2V5XTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQXJyYW5nZSBhbGwgdGhlIGtleWZyYW1lcyBpbiBhc2NlbmRpbmcgdGltZSBvcmRlci5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFsdWVTZXF1ZW5jZS5zb3J0KGNvbXBhcmVCeVRpbWUpO1xuICAgICAgICAgICAgY29uc3Qga2V5ZnJhbWVzID0gW107XG4gICAgICAgICAgICBjb25zdCB2YWx1ZU9mZnNldCA9IFtdO1xuICAgICAgICAgICAgY29uc3QgdmFsdWVFYXNpbmcgPSBbXTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRm9yIGVhY2gga2V5ZnJhbWUsIHRyYW5zbGF0ZSBhYnNvbHV0ZSB0aW1lcyBpbnRvXG4gICAgICAgICAgICAgKiByZWxhdGl2ZSBvZmZzZXRzIGJhc2VkIG9uIHRoZSB0b3RhbCBkdXJhdGlvbiBvZiB0aGUgdGltZWxpbmUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVTZXF1ZW5jZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgYXQsIHZhbHVlLCBlYXNpbmcgfSA9IHZhbHVlU2VxdWVuY2VbaV07XG4gICAgICAgICAgICAgICAga2V5ZnJhbWVzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgIHZhbHVlT2Zmc2V0LnB1c2gocHJvZ3Jlc3MoMCwgdG90YWxEdXJhdGlvbiwgYXQpKTtcbiAgICAgICAgICAgICAgICB2YWx1ZUVhc2luZy5wdXNoKGVhc2luZyB8fCBcImVhc2VPdXRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHRoZSBmaXJzdCBrZXlmcmFtZSBkb2Vzbid0IGxhbmQgb24gb2Zmc2V0OiAwXG4gICAgICAgICAgICAgKiBwcm92aWRlIG9uZSBieSBkdXBsaWNhdGluZyB0aGUgaW5pdGlhbCBrZXlmcmFtZS4gVGhpcyBlbnN1cmVzXG4gICAgICAgICAgICAgKiBpdCBzbmFwcyB0byB0aGUgZmlyc3Qga2V5ZnJhbWUgd2hlbiB0aGUgYW5pbWF0aW9uIHN0YXJ0cy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHZhbHVlT2Zmc2V0WzBdICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVPZmZzZXQudW5zaGlmdCgwKTtcbiAgICAgICAgICAgICAgICBrZXlmcmFtZXMudW5zaGlmdChrZXlmcmFtZXNbMF0pO1xuICAgICAgICAgICAgICAgIHZhbHVlRWFzaW5nLnVuc2hpZnQoZGVmYXVsdFNlZ21lbnRFYXNpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB0aGUgbGFzdCBrZXlmcmFtZSBkb2Vzbid0IGxhbmQgb24gb2Zmc2V0OiAxXG4gICAgICAgICAgICAgKiBwcm92aWRlIG9uZSB3aXRoIGEgbnVsbCB3aWxkY2FyZCB2YWx1ZS4gVGhpcyB3aWxsIGVuc3VyZSBpdFxuICAgICAgICAgICAgICogc3RheXMgc3RhdGljIHVudGlsIHRoZSBlbmQgb2YgdGhlIGFuaW1hdGlvbi5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHZhbHVlT2Zmc2V0W3ZhbHVlT2Zmc2V0Lmxlbmd0aCAtIDFdICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVPZmZzZXQucHVzaCgxKTtcbiAgICAgICAgICAgICAgICBrZXlmcmFtZXMucHVzaChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYW5pbWF0aW9uRGVmaW5pdGlvbnMuaGFzKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uRGVmaW5pdGlvbnMuc2V0KGVsZW1lbnQsIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ZnJhbWVzOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbjoge30sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkZWZpbml0aW9uID0gYW5pbWF0aW9uRGVmaW5pdGlvbnMuZ2V0KGVsZW1lbnQpO1xuICAgICAgICAgICAgZGVmaW5pdGlvbi5rZXlmcmFtZXNba2V5XSA9IGtleWZyYW1lcztcbiAgICAgICAgICAgIGRlZmluaXRpb24udHJhbnNpdGlvbltrZXldID0ge1xuICAgICAgICAgICAgICAgIC4uLmRlZmF1bHRUcmFuc2l0aW9uLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiB0b3RhbER1cmF0aW9uLFxuICAgICAgICAgICAgICAgIGVhc2U6IHZhbHVlRWFzaW5nLFxuICAgICAgICAgICAgICAgIHRpbWVzOiB2YWx1ZU9mZnNldCxcbiAgICAgICAgICAgICAgICAuLi5zZXF1ZW5jZVRyYW5zaXRpb24sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGFuaW1hdGlvbkRlZmluaXRpb25zO1xufVxuZnVuY3Rpb24gZ2V0U3ViamVjdFNlcXVlbmNlKHN1YmplY3QsIHNlcXVlbmNlcykge1xuICAgICFzZXF1ZW5jZXMuaGFzKHN1YmplY3QpICYmIHNlcXVlbmNlcy5zZXQoc3ViamVjdCwge30pO1xuICAgIHJldHVybiBzZXF1ZW5jZXMuZ2V0KHN1YmplY3QpO1xufVxuZnVuY3Rpb24gZ2V0VmFsdWVTZXF1ZW5jZShuYW1lLCBzZXF1ZW5jZXMpIHtcbiAgICBpZiAoIXNlcXVlbmNlc1tuYW1lXSlcbiAgICAgICAgc2VxdWVuY2VzW25hbWVdID0gW107XG4gICAgcmV0dXJuIHNlcXVlbmNlc1tuYW1lXTtcbn1cbmZ1bmN0aW9uIGtleWZyYW1lc0FzTGlzdChrZXlmcmFtZXMpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShrZXlmcmFtZXMpID8ga2V5ZnJhbWVzIDogW2tleWZyYW1lc107XG59XG5mdW5jdGlvbiBnZXRWYWx1ZVRyYW5zaXRpb24odHJhbnNpdGlvbiwga2V5KSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb24gJiYgdHJhbnNpdGlvbltrZXldXG4gICAgICAgID8ge1xuICAgICAgICAgICAgLi4udHJhbnNpdGlvbixcbiAgICAgICAgICAgIC4uLnRyYW5zaXRpb25ba2V5XSxcbiAgICAgICAgfVxuICAgICAgICA6IHsgLi4udHJhbnNpdGlvbiB9O1xufVxuY29uc3QgaXNOdW1iZXIgPSAoa2V5ZnJhbWUpID0+IHR5cGVvZiBrZXlmcmFtZSA9PT0gXCJudW1iZXJcIjtcbmNvbnN0IGlzTnVtYmVyS2V5ZnJhbWVzQXJyYXkgPSAoa2V5ZnJhbWVzKSA9PiBrZXlmcmFtZXMuZXZlcnkoaXNOdW1iZXIpO1xuXG5jb25zdCB2aXN1YWxFbGVtZW50U3RvcmUgPSBuZXcgV2Vha01hcCgpO1xuXG5mdW5jdGlvbiBpc1NWR0VsZW1lbnQoZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50IGluc3RhbmNlb2YgU1ZHRWxlbWVudCAmJiBlbGVtZW50LnRhZ05hbWUgIT09IFwic3ZnXCI7XG59XG5cbmZ1bmN0aW9uIGlzRm9yY2VkTW90aW9uVmFsdWUoa2V5LCB7IGxheW91dCwgbGF5b3V0SWQgfSkge1xuICAgIHJldHVybiAodHJhbnNmb3JtUHJvcHMuaGFzKGtleSkgfHxcbiAgICAgICAga2V5LnN0YXJ0c1dpdGgoXCJvcmlnaW5cIikgfHxcbiAgICAgICAgKChsYXlvdXQgfHwgbGF5b3V0SWQgIT09IHVuZGVmaW5lZCkgJiZcbiAgICAgICAgICAgICghIXNjYWxlQ29ycmVjdG9yc1trZXldIHx8IGtleSA9PT0gXCJvcGFjaXR5XCIpKSk7XG59XG5cbmZ1bmN0aW9uIHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyQxKHByb3BzLCBwcmV2UHJvcHMsIHZpc3VhbEVsZW1lbnQpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBzdHlsZSB9ID0gcHJvcHM7XG4gICAgY29uc3QgbmV3VmFsdWVzID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc3R5bGUpIHtcbiAgICAgICAgaWYgKGlzTW90aW9uVmFsdWUoc3R5bGVba2V5XSkgfHxcbiAgICAgICAgICAgIChwcmV2UHJvcHMuc3R5bGUgJiZcbiAgICAgICAgICAgICAgICBpc01vdGlvblZhbHVlKHByZXZQcm9wcy5zdHlsZVtrZXldKSkgfHxcbiAgICAgICAgICAgIGlzRm9yY2VkTW90aW9uVmFsdWUoa2V5LCBwcm9wcykgfHxcbiAgICAgICAgICAgICgoX2EgPSB2aXN1YWxFbGVtZW50ID09PSBudWxsIHx8IHZpc3VhbEVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZpc3VhbEVsZW1lbnQuZ2V0VmFsdWUoa2V5KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxpdmVTdHlsZSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbmV3VmFsdWVzW2tleV0gPSBzdHlsZVtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXdWYWx1ZXM7XG59XG5cbmZ1bmN0aW9uIHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyhwcm9wcywgcHJldlByb3BzLCB2aXN1YWxFbGVtZW50KSB7XG4gICAgY29uc3QgbmV3VmFsdWVzID0gc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzJDEocHJvcHMsIHByZXZQcm9wcywgdmlzdWFsRWxlbWVudCk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgaWYgKGlzTW90aW9uVmFsdWUocHJvcHNba2V5XSkgfHxcbiAgICAgICAgICAgIGlzTW90aW9uVmFsdWUocHJldlByb3BzW2tleV0pKSB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRLZXkgPSB0cmFuc2Zvcm1Qcm9wT3JkZXIuaW5kZXhPZihrZXkpICE9PSAtMVxuICAgICAgICAgICAgICAgID8gXCJhdHRyXCIgKyBrZXkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBrZXkuc3Vic3RyaW5nKDEpXG4gICAgICAgICAgICAgICAgOiBrZXk7XG4gICAgICAgICAgICBuZXdWYWx1ZXNbdGFyZ2V0S2V5XSA9IHByb3BzW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ld1ZhbHVlcztcbn1cblxuY29uc3QgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIjtcblxuLy8gRG9lcyB0aGlzIGRldmljZSBwcmVmZXIgcmVkdWNlZCBtb3Rpb24/IFJldHVybnMgYG51bGxgIHNlcnZlci1zaWRlLlxuY29uc3QgcHJlZmVyc1JlZHVjZWRNb3Rpb24gPSB7IGN1cnJlbnQ6IG51bGwgfTtcbmNvbnN0IGhhc1JlZHVjZWRNb3Rpb25MaXN0ZW5lciA9IHsgY3VycmVudDogZmFsc2UgfTtcblxuZnVuY3Rpb24gaW5pdFByZWZlcnNSZWR1Y2VkTW90aW9uKCkge1xuICAgIGhhc1JlZHVjZWRNb3Rpb25MaXN0ZW5lci5jdXJyZW50ID0gdHJ1ZTtcbiAgICBpZiAoIWlzQnJvd3NlcilcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICh3aW5kb3cubWF0Y2hNZWRpYSkge1xuICAgICAgICBjb25zdCBtb3Rpb25NZWRpYVF1ZXJ5ID0gd2luZG93Lm1hdGNoTWVkaWEoXCIocHJlZmVycy1yZWR1Y2VkLW1vdGlvbilcIik7XG4gICAgICAgIGNvbnN0IHNldFJlZHVjZWRNb3Rpb25QcmVmZXJlbmNlcyA9ICgpID0+IChwcmVmZXJzUmVkdWNlZE1vdGlvbi5jdXJyZW50ID0gbW90aW9uTWVkaWFRdWVyeS5tYXRjaGVzKTtcbiAgICAgICAgbW90aW9uTWVkaWFRdWVyeS5hZGRMaXN0ZW5lcihzZXRSZWR1Y2VkTW90aW9uUHJlZmVyZW5jZXMpO1xuICAgICAgICBzZXRSZWR1Y2VkTW90aW9uUHJlZmVyZW5jZXMoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHByZWZlcnNSZWR1Y2VkTW90aW9uLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzQ29udHJvbGxpbmdWYXJpYW50cyhwcm9wcykge1xuICAgIHJldHVybiAoaXNBbmltYXRpb25Db250cm9scyhwcm9wcy5hbmltYXRlKSB8fFxuICAgICAgICB2YXJpYW50UHJvcHMuc29tZSgobmFtZSkgPT4gaXNWYXJpYW50TGFiZWwocHJvcHNbbmFtZV0pKSk7XG59XG5mdW5jdGlvbiBpc1ZhcmlhbnROb2RlKHByb3BzKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4oaXNDb250cm9sbGluZ1ZhcmlhbnRzKHByb3BzKSB8fCBwcm9wcy52YXJpYW50cyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyhlbGVtZW50LCBuZXh0LCBwcmV2KSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gbmV4dCkge1xuICAgICAgICBjb25zdCBuZXh0VmFsdWUgPSBuZXh0W2tleV07XG4gICAgICAgIGNvbnN0IHByZXZWYWx1ZSA9IHByZXZba2V5XTtcbiAgICAgICAgaWYgKGlzTW90aW9uVmFsdWUobmV4dFZhbHVlKSkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB0aGlzIGlzIGEgbW90aW9uIHZhbHVlIGZvdW5kIGluIHByb3BzIG9yIHN0eWxlLCB3ZSB3YW50IHRvIGFkZCBpdFxuICAgICAgICAgICAgICogdG8gb3VyIHZpc3VhbCBlbGVtZW50J3MgbW90aW9uIHZhbHVlIG1hcC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZWxlbWVudC5hZGRWYWx1ZShrZXksIG5leHRWYWx1ZSk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENoZWNrIHRoZSB2ZXJzaW9uIG9mIHRoZSBpbmNvbWluZyBtb3Rpb24gdmFsdWUgd2l0aCB0aGlzIHZlcnNpb25cbiAgICAgICAgICAgICAqIGFuZCB3YXJuIGFnYWluc3QgbWlzbWF0Y2hlcy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpIHtcbiAgICAgICAgICAgICAgICB3YXJuT25jZShuZXh0VmFsdWUudmVyc2lvbiA9PT0gXCIxMS4xNS4wXCIsIGBBdHRlbXB0aW5nIHRvIG1peCBNb3Rpb24gdmVyc2lvbnMgJHtuZXh0VmFsdWUudmVyc2lvbn0gd2l0aCAxMS4xNS4wIG1heSBub3Qgd29yayBhcyBleHBlY3RlZC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc01vdGlvblZhbHVlKHByZXZWYWx1ZSkpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgd2UncmUgc3dhcHBpbmcgZnJvbSBhIG1vdGlvbiB2YWx1ZSB0byBhIHN0YXRpYyB2YWx1ZSxcbiAgICAgICAgICAgICAqIGNyZWF0ZSBhIG5ldyBtb3Rpb24gdmFsdWUgZnJvbSB0aGF0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGVsZW1lbnQuYWRkVmFsdWUoa2V5LCBtb3Rpb25WYWx1ZShuZXh0VmFsdWUsIHsgb3duZXI6IGVsZW1lbnQgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByZXZWYWx1ZSAhPT0gbmV4dFZhbHVlKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHRoaXMgaXMgYSBmbGF0IHZhbHVlIHRoYXQgaGFzIGNoYW5nZWQsIHVwZGF0ZSB0aGUgbW90aW9uIHZhbHVlXG4gICAgICAgICAgICAgKiBvciBjcmVhdGUgb25lIGlmIGl0IGRvZXNuJ3QgZXhpc3QuIFdlIG9ubHkgd2FudCB0byBkbyB0aGlzIGlmIHdlJ3JlXG4gICAgICAgICAgICAgKiBub3QgaGFuZGxpbmcgdGhlIHZhbHVlIHdpdGggb3VyIGFuaW1hdGlvbiBzdGF0ZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQuaGFzVmFsdWUoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nVmFsdWUgPSBlbGVtZW50LmdldFZhbHVlKGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nVmFsdWUubGl2ZVN0eWxlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nVmFsdWUuanVtcChuZXh0VmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghZXhpc3RpbmdWYWx1ZS5oYXNBbmltYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBleGlzdGluZ1ZhbHVlLnNldChuZXh0VmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhdGVzdFZhbHVlID0gZWxlbWVudC5nZXRTdGF0aWNWYWx1ZShrZXkpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuYWRkVmFsdWUoa2V5LCBtb3Rpb25WYWx1ZShsYXRlc3RWYWx1ZSAhPT0gdW5kZWZpbmVkID8gbGF0ZXN0VmFsdWUgOiBuZXh0VmFsdWUsIHsgb3duZXI6IGVsZW1lbnQgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEhhbmRsZSByZW1vdmVkIHZhbHVlc1xuICAgIGZvciAoY29uc3Qga2V5IGluIHByZXYpIHtcbiAgICAgICAgaWYgKG5leHRba2V5XSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVWYWx1ZShrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV4dDtcbn1cblxuY29uc3QgZmVhdHVyZVByb3BzID0ge1xuICAgIGFuaW1hdGlvbjogW1xuICAgICAgICBcImFuaW1hdGVcIixcbiAgICAgICAgXCJ2YXJpYW50c1wiLFxuICAgICAgICBcIndoaWxlSG92ZXJcIixcbiAgICAgICAgXCJ3aGlsZVRhcFwiLFxuICAgICAgICBcImV4aXRcIixcbiAgICAgICAgXCJ3aGlsZUluVmlld1wiLFxuICAgICAgICBcIndoaWxlRm9jdXNcIixcbiAgICAgICAgXCJ3aGlsZURyYWdcIixcbiAgICBdLFxuICAgIGV4aXQ6IFtcImV4aXRcIl0sXG4gICAgZHJhZzogW1wiZHJhZ1wiLCBcImRyYWdDb250cm9sc1wiXSxcbiAgICBmb2N1czogW1wid2hpbGVGb2N1c1wiXSxcbiAgICBob3ZlcjogW1wid2hpbGVIb3ZlclwiLCBcIm9uSG92ZXJTdGFydFwiLCBcIm9uSG92ZXJFbmRcIl0sXG4gICAgdGFwOiBbXCJ3aGlsZVRhcFwiLCBcIm9uVGFwXCIsIFwib25UYXBTdGFydFwiLCBcIm9uVGFwQ2FuY2VsXCJdLFxuICAgIHBhbjogW1wib25QYW5cIiwgXCJvblBhblN0YXJ0XCIsIFwib25QYW5TZXNzaW9uU3RhcnRcIiwgXCJvblBhbkVuZFwiXSxcbiAgICBpblZpZXc6IFtcIndoaWxlSW5WaWV3XCIsIFwib25WaWV3cG9ydEVudGVyXCIsIFwib25WaWV3cG9ydExlYXZlXCJdLFxuICAgIGxheW91dDogW1wibGF5b3V0XCIsIFwibGF5b3V0SWRcIl0sXG59O1xuY29uc3QgZmVhdHVyZURlZmluaXRpb25zID0ge307XG5mb3IgKGNvbnN0IGtleSBpbiBmZWF0dXJlUHJvcHMpIHtcbiAgICBmZWF0dXJlRGVmaW5pdGlvbnNba2V5XSA9IHtcbiAgICAgICAgaXNFbmFibGVkOiAocHJvcHMpID0+IGZlYXR1cmVQcm9wc1trZXldLnNvbWUoKG5hbWUpID0+ICEhcHJvcHNbbmFtZV0pLFxuICAgIH07XG59XG5cbi8qKlxuICogQSBsaXN0IG9mIGFsbCBWYWx1ZVR5cGVzXG4gKi9cbmNvbnN0IHZhbHVlVHlwZXMgPSBbLi4uZGltZW5zaW9uVmFsdWVUeXBlcywgY29sb3IsIGNvbXBsZXhdO1xuLyoqXG4gKiBUZXN0cyBhIHZhbHVlIGFnYWluc3QgdGhlIGxpc3Qgb2YgVmFsdWVUeXBlc1xuICovXG5jb25zdCBmaW5kVmFsdWVUeXBlID0gKHYpID0+IHZhbHVlVHlwZXMuZmluZCh0ZXN0VmFsdWVUeXBlKHYpKTtcblxuY29uc3QgcHJvcEV2ZW50SGFuZGxlcnMgPSBbXG4gICAgXCJBbmltYXRpb25TdGFydFwiLFxuICAgIFwiQW5pbWF0aW9uQ29tcGxldGVcIixcbiAgICBcIlVwZGF0ZVwiLFxuICAgIFwiQmVmb3JlTGF5b3V0TWVhc3VyZVwiLFxuICAgIFwiTGF5b3V0TWVhc3VyZVwiLFxuICAgIFwiTGF5b3V0QW5pbWF0aW9uU3RhcnRcIixcbiAgICBcIkxheW91dEFuaW1hdGlvbkNvbXBsZXRlXCIsXG5dO1xuLyoqXG4gKiBBIFZpc3VhbEVsZW1lbnQgaXMgYW4gaW1wZXJhdGl2ZSBhYnN0cmFjdGlvbiBhcm91bmQgVUkgZWxlbWVudHMgc3VjaCBhc1xuICogSFRNTEVsZW1lbnQsIFNWR0VsZW1lbnQsIFRocmVlLk9iamVjdDNEIGV0Yy5cbiAqL1xuY2xhc3MgVmlzdWFsRWxlbWVudCB7XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgdGFrZXMgUmVhY3QgcHJvcHMgYW5kIHJldHVybnMgZm91bmQgTW90aW9uVmFsdWVzLiBGb3IgZXhhbXBsZSwgSFRNTFxuICAgICAqIE1vdGlvblZhbHVlcyB3aWxsIGJlIGZvdW5kIHdpdGhpbiB0aGUgc3R5bGUgcHJvcCwgd2hlcmVhcyBmb3IgVGhyZWUuanMgd2l0aGluIGF0dHJpYnV0ZSBhcnJheXMuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzbid0IGFuIGFic3RyYWN0IG1ldGhvZCBhcyBpdCBuZWVkcyBjYWxsaW5nIGluIHRoZSBjb25zdHJ1Y3RvciwgYnV0IGl0IGlzXG4gICAgICogaW50ZW5kZWQgdG8gYmUgb25lLlxuICAgICAqL1xuICAgIHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyhfcHJvcHMsIF9wcmV2UHJvcHMsIF92aXN1YWxFbGVtZW50KSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoeyBwYXJlbnQsIHByb3BzLCBwcmVzZW5jZUNvbnRleHQsIHJlZHVjZWRNb3Rpb25Db25maWcsIGJsb2NrSW5pdGlhbEFuaW1hdGlvbiwgdmlzdWFsU3RhdGUsIH0sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgdW5kZXJseWluZyBJbnN0YW5jZSwgZS5nLiBhIEhUTUxFbGVtZW50XG4gICAgICAgICAqIG9yIFRocmVlLk1lc2ggZXRjLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc2V0IGNvbnRhaW5pbmcgcmVmZXJlbmNlcyB0byB0aGlzIFZpc3VhbEVsZW1lbnQncyBjaGlsZHJlbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBuZXcgU2V0KCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmUgd2hhdCByb2xlIHRoaXMgdmlzdWFsIGVsZW1lbnQgc2hvdWxkIHRha2UgaW4gdGhlIHZhcmlhbnQgdHJlZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXNWYXJpYW50Tm9kZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzQ29udHJvbGxpbmdWYXJpYW50cyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVjaWRlcyB3aGV0aGVyIHRoaXMgVmlzdWFsRWxlbWVudCBzaG91bGQgYW5pbWF0ZSBpbiByZWR1Y2VkIG1vdGlvblxuICAgICAgICAgKiBtb2RlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUT0RPOiBUaGlzIGlzIGN1cnJlbnRseSBzZXQgb24gZXZlcnkgaW5kaXZpZHVhbCBWaXN1YWxFbGVtZW50IGJ1dCBmZWVsc1xuICAgICAgICAgKiBsaWtlIGl0IGNvdWxkIGJlIHNldCBnbG9iYWxseS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2hvdWxkUmVkdWNlTW90aW9uID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbWFwIG9mIGFsbCBtb3Rpb24gdmFsdWVzIGF0dGFjaGVkIHRvIHRoaXMgdmlzdWFsIGVsZW1lbnQuIE1vdGlvblxuICAgICAgICAgKiB2YWx1ZXMgYXJlIHNvdXJjZSBvZiB0cnV0aCBmb3IgYW55IGdpdmVuIGFuaW1hdGVkIHZhbHVlLiBBIG1vdGlvblxuICAgICAgICAgKiB2YWx1ZSBtaWdodCBiZSBwcm92aWRlZCBleHRlcm5hbGx5IGJ5IHRoZSBjb21wb25lbnQgdmlhIHByb3BzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52YWx1ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuS2V5ZnJhbWVSZXNvbHZlciA9IEtleWZyYW1lUmVzb2x2ZXI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbGVhbnVwIGZ1bmN0aW9ucyBmb3IgYWN0aXZlIGZlYXR1cmVzIChob3Zlci90YXAvZXhpdCBldGMpXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZlYXR1cmVzID0ge307XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIG1hcCBvZiBldmVyeSBzdWJzY3JpcHRpb24gdGhhdCBiaW5kcyB0aGUgcHJvdmlkZWQgb3IgZ2VuZXJhdGVkXG4gICAgICAgICAqIG1vdGlvbiB2YWx1ZXMgb25DaGFuZ2UgbGlzdGVuZXJzIHRvIHRoaXMgdmlzdWFsIGVsZW1lbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlU3Vic2NyaXB0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBwcmV2aW91c2x5LXByb3ZpZGVkIG1vdGlvbiB2YWx1ZXMgYXMgcmV0dXJuZWRcbiAgICAgICAgICogZnJvbSBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMuIFdlIHVzZSB0aGUga2V5cyBpbiBoZXJlIHRvIGRldGVybWluZVxuICAgICAgICAgKiBpZiBhbnkgbW90aW9uIHZhbHVlcyBuZWVkIHRvIGJlIHJlbW92ZWQgYWZ0ZXIgcHJvcHMgYXJlIHVwZGF0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByZXZNb3Rpb25WYWx1ZXMgPSB7fTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIG9iamVjdCBjb250YWluaW5nIGEgU3Vic2NyaXB0aW9uTWFuYWdlciBmb3IgZWFjaCBhY3RpdmUgZXZlbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmV2ZW50cyA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQW4gb2JqZWN0IGNvbnRhaW5pbmcgYW4gdW5zdWJzY3JpYmUgZnVuY3Rpb24gZm9yIGVhY2ggcHJvcCBldmVudCBzdWJzY3JpcHRpb24uXG4gICAgICAgICAqIEZvciBleGFtcGxlLCBldmVyeSBcIlVwZGF0ZVwiIGV2ZW50IGNhbiBoYXZlIG11bHRpcGxlIHN1YnNjcmliZXJzIHZpYVxuICAgICAgICAgKiBWaXN1YWxFbGVtZW50Lm9uKCksIGJ1dCBvbmx5IG9uZSBvZiB0aG9zZSBjYW4gYmUgZGVmaW5lZCB2aWEgdGhlIG9uVXBkYXRlIHByb3AuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByb3BFdmVudFN1YnNjcmlwdGlvbnMgPSB7fTtcbiAgICAgICAgdGhpcy5ub3RpZnlVcGRhdGUgPSAoKSA9PiB0aGlzLm5vdGlmeShcIlVwZGF0ZVwiLCB0aGlzLmxhdGVzdFZhbHVlcyk7XG4gICAgICAgIHRoaXMucmVuZGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmN1cnJlbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyQnVpbGQoKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVySW5zdGFuY2UodGhpcy5jdXJyZW50LCB0aGlzLnJlbmRlclN0YXRlLCB0aGlzLnByb3BzLnN0eWxlLCB0aGlzLnByb2plY3Rpb24pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJlbmRlclNjaGVkdWxlZEF0ID0gMC4wO1xuICAgICAgICB0aGlzLnNjaGVkdWxlUmVuZGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgbm93ID0gdGltZS5ub3coKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlbmRlclNjaGVkdWxlZEF0IDwgbm93KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJTY2hlZHVsZWRBdCA9IG5vdztcbiAgICAgICAgICAgICAgICBmcmFtZS5yZW5kZXIodGhpcy5yZW5kZXIsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgeyBsYXRlc3RWYWx1ZXMsIHJlbmRlclN0YXRlIH0gPSB2aXN1YWxTdGF0ZTtcbiAgICAgICAgdGhpcy5sYXRlc3RWYWx1ZXMgPSBsYXRlc3RWYWx1ZXM7XG4gICAgICAgIHRoaXMuYmFzZVRhcmdldCA9IHsgLi4ubGF0ZXN0VmFsdWVzIH07XG4gICAgICAgIHRoaXMuaW5pdGlhbFZhbHVlcyA9IHByb3BzLmluaXRpYWwgPyB7IC4uLmxhdGVzdFZhbHVlcyB9IDoge307XG4gICAgICAgIHRoaXMucmVuZGVyU3RhdGUgPSByZW5kZXJTdGF0ZTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgICAgdGhpcy5wcmVzZW5jZUNvbnRleHQgPSBwcmVzZW5jZUNvbnRleHQ7XG4gICAgICAgIHRoaXMuZGVwdGggPSBwYXJlbnQgPyBwYXJlbnQuZGVwdGggKyAxIDogMDtcbiAgICAgICAgdGhpcy5yZWR1Y2VkTW90aW9uQ29uZmlnID0gcmVkdWNlZE1vdGlvbkNvbmZpZztcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5ibG9ja0luaXRpYWxBbmltYXRpb24gPSBCb29sZWFuKGJsb2NrSW5pdGlhbEFuaW1hdGlvbik7XG4gICAgICAgIHRoaXMuaXNDb250cm9sbGluZ1ZhcmlhbnRzID0gaXNDb250cm9sbGluZ1ZhcmlhbnRzKHByb3BzKTtcbiAgICAgICAgdGhpcy5pc1ZhcmlhbnROb2RlID0gaXNWYXJpYW50Tm9kZShwcm9wcyk7XG4gICAgICAgIGlmICh0aGlzLmlzVmFyaWFudE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMudmFyaWFudENoaWxkcmVuID0gbmV3IFNldCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFudWFsbHlBbmltYXRlT25Nb3VudCA9IEJvb2xlYW4ocGFyZW50ICYmIHBhcmVudC5jdXJyZW50KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFueSBtb3Rpb24gdmFsdWVzIHRoYXQgYXJlIHByb3ZpZGVkIHRvIHRoZSBlbGVtZW50IHdoZW4gY3JlYXRlZFxuICAgICAgICAgKiBhcmVuJ3QgeWV0IGJvdW5kIHRvIHRoZSBlbGVtZW50LCBhcyB0aGlzIHdvdWxkIHRlY2huaWNhbGx5IGJlIGltcHVyZS5cbiAgICAgICAgICogSG93ZXZlciwgd2UgaXRlcmF0ZSB0aHJvdWdoIHRoZSBtb3Rpb24gdmFsdWVzIGFuZCBzZXQgdGhlbSB0byB0aGVcbiAgICAgICAgICogaW5pdGlhbCB2YWx1ZXMgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBUT0RPOiBUaGlzIGlzIGltcHVyZSBhbmQgd2Ugc2hvdWxkIGxvb2sgYXQgY2hhbmdpbmcgdGhpcyB0byBydW4gb24gbW91bnQuXG4gICAgICAgICAqIERvaW5nIHNvIHdpbGwgYnJlYWsgc29tZSB0ZXN0cyBidXQgdGhpcyBpc24ndCBuZWNlc3NhcmlseSBhIGJyZWFraW5nIGNoYW5nZSxcbiAgICAgICAgICogbW9yZSBhIHJlZmxlY3Rpb24gb2YgdGhlIHRlc3QuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCB7IHdpbGxDaGFuZ2UsIC4uLmluaXRpYWxNb3Rpb25WYWx1ZXMgfSA9IHRoaXMuc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzKHByb3BzLCB7fSwgdGhpcyk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGluaXRpYWxNb3Rpb25WYWx1ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gaW5pdGlhbE1vdGlvblZhbHVlc1trZXldO1xuICAgICAgICAgICAgaWYgKGxhdGVzdFZhbHVlc1trZXldICE9PSB1bmRlZmluZWQgJiYgaXNNb3Rpb25WYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZS5zZXQobGF0ZXN0VmFsdWVzW2tleV0sIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBtb3VudChpbnN0YW5jZSkge1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSBpbnN0YW5jZTtcbiAgICAgICAgdmlzdWFsRWxlbWVudFN0b3JlLnNldChpbnN0YW5jZSwgdGhpcyk7XG4gICAgICAgIGlmICh0aGlzLnByb2plY3Rpb24gJiYgIXRoaXMucHJvamVjdGlvbi5pbnN0YW5jZSkge1xuICAgICAgICAgICAgdGhpcy5wcm9qZWN0aW9uLm1vdW50KGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wYXJlbnQgJiYgdGhpcy5pc1ZhcmlhbnROb2RlICYmICF0aGlzLmlzQ29udHJvbGxpbmdWYXJpYW50cykge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVGcm9tVmFyaWFudFRyZWUgPSB0aGlzLnBhcmVudC5hZGRWYXJpYW50Q2hpbGQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWx1ZXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4gdGhpcy5iaW5kVG9Nb3Rpb25WYWx1ZShrZXksIHZhbHVlKSk7XG4gICAgICAgIGlmICghaGFzUmVkdWNlZE1vdGlvbkxpc3RlbmVyLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGluaXRQcmVmZXJzUmVkdWNlZE1vdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2hvdWxkUmVkdWNlTW90aW9uID1cbiAgICAgICAgICAgIHRoaXMucmVkdWNlZE1vdGlvbkNvbmZpZyA9PT0gXCJuZXZlclwiXG4gICAgICAgICAgICAgICAgPyBmYWxzZVxuICAgICAgICAgICAgICAgIDogdGhpcy5yZWR1Y2VkTW90aW9uQ29uZmlnID09PSBcImFsd2F5c1wiXG4gICAgICAgICAgICAgICAgICAgID8gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICA6IHByZWZlcnNSZWR1Y2VkTW90aW9uLmN1cnJlbnQ7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKHRoaXMuc2hvdWxkUmVkdWNlTW90aW9uICE9PSB0cnVlLCBcIllvdSBoYXZlIFJlZHVjZWQgTW90aW9uIGVuYWJsZWQgb24geW91ciBkZXZpY2UuIEFuaW1hdGlvbnMgbWF5IG5vdCBhcHBlYXIgYXMgZXhwZWN0ZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBhcmVudClcbiAgICAgICAgICAgIHRoaXMucGFyZW50LmNoaWxkcmVuLmFkZCh0aGlzKTtcbiAgICAgICAgdGhpcy51cGRhdGUodGhpcy5wcm9wcywgdGhpcy5wcmVzZW5jZUNvbnRleHQpO1xuICAgIH1cbiAgICB1bm1vdW50KCkge1xuICAgICAgICB2aXN1YWxFbGVtZW50U3RvcmUuZGVsZXRlKHRoaXMuY3VycmVudCk7XG4gICAgICAgIHRoaXMucHJvamVjdGlvbiAmJiB0aGlzLnByb2plY3Rpb24udW5tb3VudCgpO1xuICAgICAgICBjYW5jZWxGcmFtZSh0aGlzLm5vdGlmeVVwZGF0ZSk7XG4gICAgICAgIGNhbmNlbEZyYW1lKHRoaXMucmVuZGVyKTtcbiAgICAgICAgdGhpcy52YWx1ZVN1YnNjcmlwdGlvbnMuZm9yRWFjaCgocmVtb3ZlKSA9PiByZW1vdmUoKSk7XG4gICAgICAgIHRoaXMudmFsdWVTdWJzY3JpcHRpb25zLmNsZWFyKCk7XG4gICAgICAgIHRoaXMucmVtb3ZlRnJvbVZhcmlhbnRUcmVlICYmIHRoaXMucmVtb3ZlRnJvbVZhcmlhbnRUcmVlKCk7XG4gICAgICAgIHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LmNoaWxkcmVuLmRlbGV0ZSh0aGlzKTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5ldmVudHMpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzW2tleV0uY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLmZlYXR1cmVzKSB7XG4gICAgICAgICAgICBjb25zdCBmZWF0dXJlID0gdGhpcy5mZWF0dXJlc1trZXldO1xuICAgICAgICAgICAgaWYgKGZlYXR1cmUpIHtcbiAgICAgICAgICAgICAgICBmZWF0dXJlLnVubW91bnQoKTtcbiAgICAgICAgICAgICAgICBmZWF0dXJlLmlzTW91bnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICAgIGJpbmRUb01vdGlvblZhbHVlKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWVTdWJzY3JpcHRpb25zLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlU3Vic2NyaXB0aW9ucy5nZXQoa2V5KSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlSXNUcmFuc2Zvcm0gPSB0cmFuc2Zvcm1Qcm9wcy5oYXMoa2V5KTtcbiAgICAgICAgY29uc3QgcmVtb3ZlT25DaGFuZ2UgPSB2YWx1ZS5vbihcImNoYW5nZVwiLCAobGF0ZXN0VmFsdWUpID0+IHtcbiAgICAgICAgICAgIHRoaXMubGF0ZXN0VmFsdWVzW2tleV0gPSBsYXRlc3RWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25VcGRhdGUgJiYgZnJhbWUucHJlUmVuZGVyKHRoaXMubm90aWZ5VXBkYXRlKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZUlzVHJhbnNmb3JtICYmIHRoaXMucHJvamVjdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvamVjdGlvbi5pc1RyYW5zZm9ybURpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlbW92ZU9uUmVuZGVyUmVxdWVzdCA9IHZhbHVlLm9uKFwicmVuZGVyUmVxdWVzdFwiLCB0aGlzLnNjaGVkdWxlUmVuZGVyKTtcbiAgICAgICAgbGV0IHJlbW92ZVN5bmNDaGVjaztcbiAgICAgICAgaWYgKHdpbmRvdy5Nb3Rpb25DaGVja0FwcGVhclN5bmMpIHtcbiAgICAgICAgICAgIHJlbW92ZVN5bmNDaGVjayA9IHdpbmRvdy5Nb3Rpb25DaGVja0FwcGVhclN5bmModGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWx1ZVN1YnNjcmlwdGlvbnMuc2V0KGtleSwgKCkgPT4ge1xuICAgICAgICAgICAgcmVtb3ZlT25DaGFuZ2UoKTtcbiAgICAgICAgICAgIHJlbW92ZU9uUmVuZGVyUmVxdWVzdCgpO1xuICAgICAgICAgICAgaWYgKHJlbW92ZVN5bmNDaGVjaylcbiAgICAgICAgICAgICAgICByZW1vdmVTeW5jQ2hlY2soKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5vd25lcilcbiAgICAgICAgICAgICAgICB2YWx1ZS5zdG9wKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzb3J0Tm9kZVBvc2l0aW9uKG90aGVyKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGVzZSBub2RlcyBhcmVuJ3QgZXZlbiBvZiB0aGUgc2FtZSB0eXBlIHdlIGNhbid0IGNvbXBhcmUgdGhlaXIgZGVwdGguXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoIXRoaXMuY3VycmVudCB8fFxuICAgICAgICAgICAgIXRoaXMuc29ydEluc3RhbmNlTm9kZVBvc2l0aW9uIHx8XG4gICAgICAgICAgICB0aGlzLnR5cGUgIT09IG90aGVyLnR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNvcnRJbnN0YW5jZU5vZGVQb3NpdGlvbih0aGlzLmN1cnJlbnQsIG90aGVyLmN1cnJlbnQpO1xuICAgIH1cbiAgICB1cGRhdGVGZWF0dXJlcygpIHtcbiAgICAgICAgbGV0IGtleSA9IFwiYW5pbWF0aW9uXCI7XG4gICAgICAgIGZvciAoa2V5IGluIGZlYXR1cmVEZWZpbml0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgZmVhdHVyZURlZmluaXRpb24gPSBmZWF0dXJlRGVmaW5pdGlvbnNba2V5XTtcbiAgICAgICAgICAgIGlmICghZmVhdHVyZURlZmluaXRpb24pXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCB7IGlzRW5hYmxlZCwgRmVhdHVyZTogRmVhdHVyZUNvbnN0cnVjdG9yIH0gPSBmZWF0dXJlRGVmaW5pdGlvbjtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgdGhpcyBmZWF0dXJlIGlzIGVuYWJsZWQgYnV0IG5vdCBhY3RpdmUsIG1ha2UgYSBuZXcgaW5zdGFuY2UuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICghdGhpcy5mZWF0dXJlc1trZXldICYmXG4gICAgICAgICAgICAgICAgRmVhdHVyZUNvbnN0cnVjdG9yICYmXG4gICAgICAgICAgICAgICAgaXNFbmFibGVkKHRoaXMucHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mZWF0dXJlc1trZXldID0gbmV3IEZlYXR1cmVDb25zdHJ1Y3Rvcih0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgd2UgaGF2ZSBhIGZlYXR1cmUsIG1vdW50IG9yIHVwZGF0ZSBpdC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHRoaXMuZmVhdHVyZXNba2V5XSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZlYXR1cmUgPSB0aGlzLmZlYXR1cmVzW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKGZlYXR1cmUuaXNNb3VudGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmUudXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlLm1vdW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmUuaXNNb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdHJpZ2dlckJ1aWxkKCkge1xuICAgICAgICB0aGlzLmJ1aWxkKHRoaXMucmVuZGVyU3RhdGUsIHRoaXMubGF0ZXN0VmFsdWVzLCB0aGlzLnByb3BzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWVhc3VyZSB0aGUgY3VycmVudCB2aWV3cG9ydCBib3ggd2l0aCBvciB3aXRob3V0IHRyYW5zZm9ybXMuXG4gICAgICogT25seSBtZWFzdXJlcyBheGlzLWFsaWduZWQgYm94ZXMsIHJvdGF0ZSBhbmQgc2tldyBtdXN0IGJlIG1hbnVhbGx5XG4gICAgICogcmVtb3ZlZCB3aXRoIGEgcmUtcmVuZGVyIHRvIHdvcmsuXG4gICAgICovXG4gICAgbWVhc3VyZVZpZXdwb3J0Qm94KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50XG4gICAgICAgICAgICA/IHRoaXMubWVhc3VyZUluc3RhbmNlVmlld3BvcnRCb3godGhpcy5jdXJyZW50LCB0aGlzLnByb3BzKVxuICAgICAgICAgICAgOiBjcmVhdGVCb3goKTtcbiAgICB9XG4gICAgZ2V0U3RhdGljVmFsdWUoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhdGVzdFZhbHVlc1trZXldO1xuICAgIH1cbiAgICBzZXRTdGF0aWNWYWx1ZShrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMubGF0ZXN0VmFsdWVzW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBwcm92aWRlZCBwcm9wcy4gRW5zdXJlIGFueSBuZXdseS1hZGRlZCBtb3Rpb24gdmFsdWVzIGFyZVxuICAgICAqIGFkZGVkIHRvIG91ciBtYXAsIG9sZCBvbmVzIHJlbW92ZWQsIGFuZCBsaXN0ZW5lcnMgdXBkYXRlZC5cbiAgICAgKi9cbiAgICB1cGRhdGUocHJvcHMsIHByZXNlbmNlQ29udGV4dCkge1xuICAgICAgICBpZiAocHJvcHMudHJhbnNmb3JtVGVtcGxhdGUgfHwgdGhpcy5wcm9wcy50cmFuc2Zvcm1UZW1wbGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZVJlbmRlcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJldlByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgICB0aGlzLnByZXZQcmVzZW5jZUNvbnRleHQgPSB0aGlzLnByZXNlbmNlQ29udGV4dDtcbiAgICAgICAgdGhpcy5wcmVzZW5jZUNvbnRleHQgPSBwcmVzZW5jZUNvbnRleHQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgcHJvcCBldmVudCBoYW5kbGVycyBpZSBvbkFuaW1hdGlvblN0YXJ0LCBvbkFuaW1hdGlvbkNvbXBsZXRlXG4gICAgICAgICAqL1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BFdmVudEhhbmRsZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBwcm9wRXZlbnRIYW5kbGVyc1tpXTtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BFdmVudFN1YnNjcmlwdGlvbnNba2V5XSkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcEV2ZW50U3Vic2NyaXB0aW9uc1trZXldKCk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMucHJvcEV2ZW50U3Vic2NyaXB0aW9uc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJOYW1lID0gKFwib25cIiArIGtleSk7XG4gICAgICAgICAgICBjb25zdCBsaXN0ZW5lciA9IHByb3BzW2xpc3RlbmVyTmFtZV07XG4gICAgICAgICAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BFdmVudFN1YnNjcmlwdGlvbnNba2V5XSA9IHRoaXMub24oa2V5LCBsaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmV2TW90aW9uVmFsdWVzID0gdXBkYXRlTW90aW9uVmFsdWVzRnJvbVByb3BzKHRoaXMsIHRoaXMuc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzKHByb3BzLCB0aGlzLnByZXZQcm9wcywgdGhpcyksIHRoaXMucHJldk1vdGlvblZhbHVlcyk7XG4gICAgICAgIGlmICh0aGlzLmhhbmRsZUNoaWxkTW90aW9uVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2hpbGRNb3Rpb25WYWx1ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFByb3BzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmFyaWFudCBkZWZpbml0aW9uIHdpdGggYSBnaXZlbiBuYW1lLlxuICAgICAqL1xuICAgIGdldFZhcmlhbnQobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy52YXJpYW50cyA/IHRoaXMucHJvcHMudmFyaWFudHNbbmFtZV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRlZmluZWQgZGVmYXVsdCB0cmFuc2l0aW9uIG9uIHRoaXMgY29tcG9uZW50LlxuICAgICAqL1xuICAgIGdldERlZmF1bHRUcmFuc2l0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy50cmFuc2l0aW9uO1xuICAgIH1cbiAgICBnZXRUcmFuc2Zvcm1QYWdlUG9pbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLnRyYW5zZm9ybVBhZ2VQb2ludDtcbiAgICB9XG4gICAgZ2V0Q2xvc2VzdFZhcmlhbnROb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhcmlhbnROb2RlXG4gICAgICAgICAgICA/IHRoaXNcbiAgICAgICAgICAgIDogdGhpcy5wYXJlbnRcbiAgICAgICAgICAgICAgICA/IHRoaXMucGFyZW50LmdldENsb3Nlc3RWYXJpYW50Tm9kZSgpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIGNoaWxkIHZpc3VhbCBlbGVtZW50IHRvIG91ciBzZXQgb2YgY2hpbGRyZW4uXG4gICAgICovXG4gICAgYWRkVmFyaWFudENoaWxkKGNoaWxkKSB7XG4gICAgICAgIGNvbnN0IGNsb3Nlc3RWYXJpYW50Tm9kZSA9IHRoaXMuZ2V0Q2xvc2VzdFZhcmlhbnROb2RlKCk7XG4gICAgICAgIGlmIChjbG9zZXN0VmFyaWFudE5vZGUpIHtcbiAgICAgICAgICAgIGNsb3Nlc3RWYXJpYW50Tm9kZS52YXJpYW50Q2hpbGRyZW4gJiZcbiAgICAgICAgICAgICAgICBjbG9zZXN0VmFyaWFudE5vZGUudmFyaWFudENoaWxkcmVuLmFkZChjaGlsZCk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gY2xvc2VzdFZhcmlhbnROb2RlLnZhcmlhbnRDaGlsZHJlbi5kZWxldGUoY2hpbGQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIG1vdGlvbiB2YWx1ZSBhbmQgYmluZCBpdCB0byB0aGlzIHZpc3VhbCBlbGVtZW50LlxuICAgICAqL1xuICAgIGFkZFZhbHVlKGtleSwgdmFsdWUpIHtcbiAgICAgICAgLy8gUmVtb3ZlIGV4aXN0aW5nIHZhbHVlIGlmIGl0IGV4aXN0c1xuICAgICAgICBjb25zdCBleGlzdGluZ1ZhbHVlID0gdGhpcy52YWx1ZXMuZ2V0KGtleSk7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gZXhpc3RpbmdWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKGV4aXN0aW5nVmFsdWUpXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVWYWx1ZShrZXkpO1xuICAgICAgICAgICAgdGhpcy5iaW5kVG9Nb3Rpb25WYWx1ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMudmFsdWVzLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMubGF0ZXN0VmFsdWVzW2tleV0gPSB2YWx1ZS5nZXQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBtb3Rpb24gdmFsdWUgYW5kIHVuYmluZCBhbnkgYWN0aXZlIHN1YnNjcmlwdGlvbnMuXG4gICAgICovXG4gICAgcmVtb3ZlVmFsdWUoa2V5KSB7XG4gICAgICAgIHRoaXMudmFsdWVzLmRlbGV0ZShrZXkpO1xuICAgICAgICBjb25zdCB1bnN1YnNjcmliZSA9IHRoaXMudmFsdWVTdWJzY3JpcHRpb25zLmdldChrZXkpO1xuICAgICAgICBpZiAodW5zdWJzY3JpYmUpIHtcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aGlzLnZhbHVlU3Vic2NyaXB0aW9ucy5kZWxldGUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdGhpcy5sYXRlc3RWYWx1ZXNba2V5XTtcbiAgICAgICAgdGhpcy5yZW1vdmVWYWx1ZUZyb21SZW5kZXJTdGF0ZShrZXksIHRoaXMucmVuZGVyU3RhdGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGV0aGVyIHdlIGhhdmUgYSBtb3Rpb24gdmFsdWUgZm9yIHRoaXMga2V5XG4gICAgICovXG4gICAgaGFzVmFsdWUoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlcy5oYXMoa2V5KTtcbiAgICB9XG4gICAgZ2V0VmFsdWUoa2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMudmFsdWVzICYmIHRoaXMucHJvcHMudmFsdWVzW2tleV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BzLnZhbHVlc1trZXldO1xuICAgICAgICB9XG4gICAgICAgIGxldCB2YWx1ZSA9IHRoaXMudmFsdWVzLmdldChrZXkpO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiBkZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFsdWUgPSBtb3Rpb25WYWx1ZShkZWZhdWx0VmFsdWUgPT09IG51bGwgPyB1bmRlZmluZWQgOiBkZWZhdWx0VmFsdWUsIHsgb3duZXI6IHRoaXMgfSk7XG4gICAgICAgICAgICB0aGlzLmFkZFZhbHVlKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgd2UncmUgdHJ5aW5nIHRvIGFuaW1hdGUgdG8gYSBwcmV2aW91c2x5IHVuZW5jb3VudGVyZWQgdmFsdWUsXG4gICAgICogd2UgbmVlZCB0byBjaGVjayBmb3IgaXQgaW4gb3VyIHN0YXRlIGFuZCBhcyBhIGxhc3QgcmVzb3J0IHJlYWQgaXRcbiAgICAgKiBkaXJlY3RseSBmcm9tIHRoZSBpbnN0YW5jZSAod2hpY2ggbWlnaHQgaGF2ZSBwZXJmb3JtYW5jZSBpbXBsaWNhdGlvbnMpLlxuICAgICAqL1xuICAgIHJlYWRWYWx1ZShrZXksIHRhcmdldCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCB2YWx1ZSA9IHRoaXMubGF0ZXN0VmFsdWVzW2tleV0gIT09IHVuZGVmaW5lZCB8fCAhdGhpcy5jdXJyZW50XG4gICAgICAgICAgICA/IHRoaXMubGF0ZXN0VmFsdWVzW2tleV1cbiAgICAgICAgICAgIDogKF9hID0gdGhpcy5nZXRCYXNlVGFyZ2V0RnJvbVByb3BzKHRoaXMucHJvcHMsIGtleSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMucmVhZFZhbHVlRnJvbUluc3RhbmNlKHRoaXMuY3VycmVudCwga2V5LCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgIChpc051bWVyaWNhbFN0cmluZyh2YWx1ZSkgfHwgaXNaZXJvVmFsdWVTdHJpbmcodmFsdWUpKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYSBudW1iZXIgcmVhZCBhcyBhIHN0cmluZywgaWUgXCIwXCIgb3IgXCIyMDBcIiwgY29udmVydCBpdCB0byBhIG51bWJlclxuICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghZmluZFZhbHVlVHlwZSh2YWx1ZSkgJiYgY29tcGxleC50ZXN0KHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGdldEFuaW1hdGFibGVOb25lKGtleSwgdGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0QmFzZVRhcmdldChrZXksIGlzTW90aW9uVmFsdWUodmFsdWUpID8gdmFsdWUuZ2V0KCkgOiB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzTW90aW9uVmFsdWUodmFsdWUpID8gdmFsdWUuZ2V0KCkgOiB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBiYXNlIHRhcmdldCB0byBsYXRlciBhbmltYXRlIGJhY2sgdG8uIFRoaXMgaXMgY3VycmVudGx5XG4gICAgICogb25seSBoeWRyYXRlZCBvbiBjcmVhdGlvbiBhbmQgd2hlbiB3ZSBmaXJzdCByZWFkIGEgdmFsdWUuXG4gICAgICovXG4gICAgc2V0QmFzZVRhcmdldChrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYmFzZVRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIGJhc2UgdGFyZ2V0IGZvciBhIHZhbHVlIHRoYXRzIGJlZW4gcmVtb3ZlZCBmcm9tIGFsbCBhbmltYXRpb25cbiAgICAgKiBwcm9wcy5cbiAgICAgKi9cbiAgICBnZXRCYXNlVGFyZ2V0KGtleSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHsgaW5pdGlhbCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgbGV0IHZhbHVlRnJvbUluaXRpYWw7XG4gICAgICAgIGlmICh0eXBlb2YgaW5pdGlhbCA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgaW5pdGlhbCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgY29uc3QgdmFyaWFudCA9IHJlc29sdmVWYXJpYW50RnJvbVByb3BzKHRoaXMucHJvcHMsIGluaXRpYWwsIChfYSA9IHRoaXMucHJlc2VuY2VDb250ZXh0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY3VzdG9tKTtcbiAgICAgICAgICAgIGlmICh2YXJpYW50KSB7XG4gICAgICAgICAgICAgICAgdmFsdWVGcm9tSW5pdGlhbCA9IHZhcmlhbnRba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhpcyB2YWx1ZSBzdGlsbCBleGlzdHMgaW4gdGhlIGN1cnJlbnQgaW5pdGlhbCB2YXJpYW50LCByZWFkIHRoYXQuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoaW5pdGlhbCAmJiB2YWx1ZUZyb21Jbml0aWFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZUZyb21Jbml0aWFsO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbHRlcm5hdGl2ZWx5LCBpZiB0aGlzIFZpc3VhbEVsZW1lbnQgY29uZmlnIGhhcyBkZWZpbmVkIGEgZ2V0QmFzZVRhcmdldFxuICAgICAgICAgKiBzbyB3ZSBjYW4gcmVhZCB0aGUgdmFsdWUgZnJvbSBhbiBhbHRlcm5hdGl2ZSBzb3VyY2UsIHRyeSB0aGF0LlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5nZXRCYXNlVGFyZ2V0RnJvbVByb3BzKHRoaXMucHJvcHMsIGtleSk7XG4gICAgICAgIGlmICh0YXJnZXQgIT09IHVuZGVmaW5lZCAmJiAhaXNNb3Rpb25WYWx1ZSh0YXJnZXQpKVxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZSB2YWx1ZSB3YXMgaW5pdGlhbGx5IGRlZmluZWQgb24gaW5pdGlhbCwgYnV0IGl0IGRvZXNuJ3QgYW55IG1vcmUsXG4gICAgICAgICAqIHJldHVybiB1bmRlZmluZWQuIE90aGVyd2lzZSByZXR1cm4gdGhlIHZhbHVlIGFzIGluaXRpYWxseSByZWFkIGZyb20gdGhlIERPTS5cbiAgICAgICAgICovXG4gICAgICAgIHJldHVybiB0aGlzLmluaXRpYWxWYWx1ZXNba2V5XSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICB2YWx1ZUZyb21Jbml0aWFsID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICA6IHRoaXMuYmFzZVRhcmdldFtrZXldO1xuICAgIH1cbiAgICBvbihldmVudE5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghdGhpcy5ldmVudHNbZXZlbnROYW1lXSkge1xuICAgICAgICAgICAgdGhpcy5ldmVudHNbZXZlbnROYW1lXSA9IG5ldyBTdWJzY3JpcHRpb25NYW5hZ2VyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0uYWRkKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgbm90aWZ5KGV2ZW50TmFtZSwgLi4uYXJncykge1xuICAgICAgICBpZiAodGhpcy5ldmVudHNbZXZlbnROYW1lXSkge1xuICAgICAgICAgICAgdGhpcy5ldmVudHNbZXZlbnROYW1lXS5ub3RpZnkoLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIERPTVZpc3VhbEVsZW1lbnQgZXh0ZW5kcyBWaXN1YWxFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5LZXlmcmFtZVJlc29sdmVyID0gRE9NS2V5ZnJhbWVzUmVzb2x2ZXI7XG4gICAgfVxuICAgIHNvcnRJbnN0YW5jZU5vZGVQb3NpdGlvbihhLCBiKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjb21wYXJlRG9jdW1lbnRQb3NpdGlvbiByZXR1cm5zIGEgYml0bWFzaywgYnkgdXNpbmcgdGhlIGJpdHdpc2UgJlxuICAgICAgICAgKiB3ZSdyZSByZXR1cm5pbmcgdHJ1ZSBpZiAyIGluIHRoYXQgYml0bWFzayBpcyBzZXQgdG8gdHJ1ZS4gMiBpcyBzZXRcbiAgICAgICAgICogdG8gdHJ1ZSBpZiBiIHByZWNlZWRzIGEuXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihiKSAmIDIgPyAxIDogLTE7XG4gICAgfVxuICAgIGdldEJhc2VUYXJnZXRGcm9tUHJvcHMocHJvcHMsIGtleSkge1xuICAgICAgICByZXR1cm4gcHJvcHMuc3R5bGVcbiAgICAgICAgICAgID8gcHJvcHMuc3R5bGVba2V5XVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJlbW92ZVZhbHVlRnJvbVJlbmRlclN0YXRlKGtleSwgeyB2YXJzLCBzdHlsZSB9KSB7XG4gICAgICAgIGRlbGV0ZSB2YXJzW2tleV07XG4gICAgICAgIGRlbGV0ZSBzdHlsZVtrZXldO1xuICAgIH1cbiAgICBoYW5kbGVDaGlsZE1vdGlvblZhbHVlKCkge1xuICAgICAgICBpZiAodGhpcy5jaGlsZFN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5jaGlsZFN1YnNjcmlwdGlvbigpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuY2hpbGRTdWJzY3JpcHRpb247XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbiB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgaWYgKGlzTW90aW9uVmFsdWUoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkU3Vic2NyaXB0aW9uID0gY2hpbGRyZW4ub24oXCJjaGFuZ2VcIiwgKGxhdGVzdCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50LnRleHRDb250ZW50ID0gYCR7bGF0ZXN0fWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogUHJvdmlkZWQgYSB2YWx1ZSBhbmQgYSBWYWx1ZVR5cGUsIHJldHVybnMgdGhlIHZhbHVlIGFzIHRoYXQgdmFsdWUgdHlwZS5cbiAqL1xuY29uc3QgZ2V0VmFsdWVBc1R5cGUgPSAodmFsdWUsIHR5cGUpID0+IHtcbiAgICByZXR1cm4gdHlwZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCJcbiAgICAgICAgPyB0eXBlLnRyYW5zZm9ybSh2YWx1ZSlcbiAgICAgICAgOiB2YWx1ZTtcbn07XG5cbmNvbnN0IHRyYW5zbGF0ZUFsaWFzID0ge1xuICAgIHg6IFwidHJhbnNsYXRlWFwiLFxuICAgIHk6IFwidHJhbnNsYXRlWVwiLFxuICAgIHo6IFwidHJhbnNsYXRlWlwiLFxuICAgIHRyYW5zZm9ybVBlcnNwZWN0aXZlOiBcInBlcnNwZWN0aXZlXCIsXG59O1xuY29uc3QgbnVtVHJhbnNmb3JtcyA9IHRyYW5zZm9ybVByb3BPcmRlci5sZW5ndGg7XG4vKipcbiAqIEJ1aWxkIGEgQ1NTIHRyYW5zZm9ybSBzdHlsZSBmcm9tIGluZGl2aWR1YWwgeC95L3NjYWxlIGV0YyBwcm9wZXJ0aWVzLlxuICpcbiAqIFRoaXMgb3V0cHV0cyB3aXRoIGEgZGVmYXVsdCBvcmRlciBvZiB0cmFuc2Zvcm1zL3NjYWxlcy9yb3RhdGlvbnMsIHRoaXMgY2FuIGJlIGN1c3RvbWlzZWQgYnlcbiAqIHByb3ZpZGluZyBhIHRyYW5zZm9ybVRlbXBsYXRlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBidWlsZFRyYW5zZm9ybShsYXRlc3RWYWx1ZXMsIHRyYW5zZm9ybSwgdHJhbnNmb3JtVGVtcGxhdGUpIHtcbiAgICAvLyBUaGUgdHJhbnNmb3JtIHN0cmluZyB3ZSdyZSBnb2luZyB0byBidWlsZCBpbnRvLlxuICAgIGxldCB0cmFuc2Zvcm1TdHJpbmcgPSBcIlwiO1xuICAgIGxldCB0cmFuc2Zvcm1Jc0RlZmF1bHQgPSB0cnVlO1xuICAgIC8qKlxuICAgICAqIExvb3Agb3ZlciBhbGwgcG9zc2libGUgdHJhbnNmb3JtcyBpbiBvcmRlciwgYWRkaW5nIHRoZSBvbmVzIHRoYXRcbiAgICAgKiBhcmUgcHJlc2VudCB0byB0aGUgdHJhbnNmb3JtIHN0cmluZy5cbiAgICAgKi9cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVRyYW5zZm9ybXM7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSB0cmFuc2Zvcm1Qcm9wT3JkZXJbaV07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbGF0ZXN0VmFsdWVzW2tleV07XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGxldCB2YWx1ZUlzRGVmYXVsdCA9IHRydWU7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHZhbHVlSXNEZWZhdWx0ID0gdmFsdWUgPT09IChrZXkuc3RhcnRzV2l0aChcInNjYWxlXCIpID8gMSA6IDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsdWVJc0RlZmF1bHQgPSBwYXJzZUZsb2F0KHZhbHVlKSA9PT0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXZhbHVlSXNEZWZhdWx0IHx8IHRyYW5zZm9ybVRlbXBsYXRlKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZUFzVHlwZSA9IGdldFZhbHVlQXNUeXBlKHZhbHVlLCBudW1iZXJWYWx1ZVR5cGVzW2tleV0pO1xuICAgICAgICAgICAgaWYgKCF2YWx1ZUlzRGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybUlzRGVmYXVsdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybU5hbWUgPSB0cmFuc2xhdGVBbGlhc1trZXldIHx8IGtleTtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1TdHJpbmcgKz0gYCR7dHJhbnNmb3JtTmFtZX0oJHt2YWx1ZUFzVHlwZX0pIGA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJhbnNmb3JtVGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1ba2V5XSA9IHZhbHVlQXNUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHRyYW5zZm9ybVN0cmluZyA9IHRyYW5zZm9ybVN0cmluZy50cmltKCk7XG4gICAgLy8gSWYgd2UgaGF2ZSBhIGN1c3RvbSBgdHJhbnNmb3JtYCB0ZW1wbGF0ZSwgcGFzcyBvdXIgdHJhbnNmb3JtIHZhbHVlcyBhbmRcbiAgICAvLyBnZW5lcmF0ZWQgdHJhbnNmb3JtU3RyaW5nIHRvIHRoYXQgYmVmb3JlIHJldHVybmluZ1xuICAgIGlmICh0cmFuc2Zvcm1UZW1wbGF0ZSkge1xuICAgICAgICB0cmFuc2Zvcm1TdHJpbmcgPSB0cmFuc2Zvcm1UZW1wbGF0ZSh0cmFuc2Zvcm0sIHRyYW5zZm9ybUlzRGVmYXVsdCA/IFwiXCIgOiB0cmFuc2Zvcm1TdHJpbmcpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0cmFuc2Zvcm1Jc0RlZmF1bHQpIHtcbiAgICAgICAgdHJhbnNmb3JtU3RyaW5nID0gXCJub25lXCI7XG4gICAgfVxuICAgIHJldHVybiB0cmFuc2Zvcm1TdHJpbmc7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkSFRNTFN0eWxlcyhzdGF0ZSwgbGF0ZXN0VmFsdWVzLCB0cmFuc2Zvcm1UZW1wbGF0ZSkge1xuICAgIGNvbnN0IHsgc3R5bGUsIHZhcnMsIHRyYW5zZm9ybU9yaWdpbiB9ID0gc3RhdGU7XG4gICAgLy8gVHJhY2sgd2hldGhlciB3ZSBlbmNvdW50ZXIgYW55IHRyYW5zZm9ybSBvciB0cmFuc2Zvcm1PcmlnaW4gdmFsdWVzLlxuICAgIGxldCBoYXNUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgICBsZXQgaGFzVHJhbnNmb3JtT3JpZ2luID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogTG9vcCBvdmVyIGFsbCBvdXIgbGF0ZXN0IGFuaW1hdGVkIHZhbHVlcyBhbmQgZGVjaWRlIHdoZXRoZXIgdG8gaGFuZGxlIHRoZW1cbiAgICAgKiBhcyBhIHN0eWxlIG9yIENTUyB2YXJpYWJsZS5cbiAgICAgKlxuICAgICAqIFRyYW5zZm9ybXMgYW5kIHRyYW5zZm9ybSBvcmlnaW5zIGFyZSBrZXB0IHNlcGFyYXRlbHkgZm9yIGZ1cnRoZXIgcHJvY2Vzc2luZy5cbiAgICAgKi9cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBsYXRlc3RWYWx1ZXMpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBsYXRlc3RWYWx1ZXNba2V5XTtcbiAgICAgICAgaWYgKHRyYW5zZm9ybVByb3BzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGEgdHJhbnNmb3JtLCBmbGFnIHRvIGVuYWJsZSBmdXJ0aGVyIHRyYW5zZm9ybSBwcm9jZXNzaW5nXG4gICAgICAgICAgICBoYXNUcmFuc2Zvcm0gPSB0cnVlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNDU1NWYXJpYWJsZU5hbWUoa2V5KSkge1xuICAgICAgICAgICAgdmFyc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIHZhbHVlIHRvIGl0cyBkZWZhdWx0IHZhbHVlIHR5cGUsIGllIDAgLT4gXCIwcHhcIlxuICAgICAgICAgICAgY29uc3QgdmFsdWVBc1R5cGUgPSBnZXRWYWx1ZUFzVHlwZSh2YWx1ZSwgbnVtYmVyVmFsdWVUeXBlc1trZXldKTtcbiAgICAgICAgICAgIGlmIChrZXkuc3RhcnRzV2l0aChcIm9yaWdpblwiKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYSB0cmFuc2Zvcm0gb3JpZ2luLCBmbGFnIGFuZCBlbmFibGUgZnVydGhlciB0cmFuc2Zvcm0tb3JpZ2luIHByb2Nlc3NpbmdcbiAgICAgICAgICAgICAgICBoYXNUcmFuc2Zvcm1PcmlnaW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybU9yaWdpbltrZXldID1cbiAgICAgICAgICAgICAgICAgICAgdmFsdWVBc1R5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHlsZVtrZXldID0gdmFsdWVBc1R5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFsYXRlc3RWYWx1ZXMudHJhbnNmb3JtKSB7XG4gICAgICAgIGlmIChoYXNUcmFuc2Zvcm0gfHwgdHJhbnNmb3JtVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHN0eWxlLnRyYW5zZm9ybSA9IGJ1aWxkVHJhbnNmb3JtKGxhdGVzdFZhbHVlcywgc3RhdGUudHJhbnNmb3JtLCB0cmFuc2Zvcm1UZW1wbGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3R5bGUudHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHdlIGhhdmUgcHJldmlvdXNseSBjcmVhdGVkIGEgdHJhbnNmb3JtIGJ1dCBjdXJyZW50bHkgZG9uJ3QgaGF2ZSBhbnksXG4gICAgICAgICAgICAgKiByZXNldCB0cmFuc2Zvcm0gc3R5bGUgdG8gbm9uZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc3R5bGUudHJhbnNmb3JtID0gXCJub25lXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQnVpbGQgYSB0cmFuc2Zvcm1PcmlnaW4gc3R5bGUuIFVzZXMgdGhlIHNhbWUgZGVmYXVsdHMgYXMgdGhlIGJyb3dzZXIgZm9yXG4gICAgICogdW5kZWZpbmVkIG9yaWdpbnMuXG4gICAgICovXG4gICAgaWYgKGhhc1RyYW5zZm9ybU9yaWdpbikge1xuICAgICAgICBjb25zdCB7IG9yaWdpblggPSBcIjUwJVwiLCBvcmlnaW5ZID0gXCI1MCVcIiwgb3JpZ2luWiA9IDAsIH0gPSB0cmFuc2Zvcm1PcmlnaW47XG4gICAgICAgIHN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9IGAke29yaWdpblh9ICR7b3JpZ2luWX0gJHtvcmlnaW5afWA7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjYWxjT3JpZ2luKG9yaWdpbiwgb2Zmc2V0LCBzaXplKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvcmlnaW4gPT09IFwic3RyaW5nXCJcbiAgICAgICAgPyBvcmlnaW5cbiAgICAgICAgOiBweC50cmFuc2Zvcm0ob2Zmc2V0ICsgc2l6ZSAqIG9yaWdpbik7XG59XG4vKipcbiAqIFRoZSBTVkcgdHJhbnNmb3JtIG9yaWdpbiBkZWZhdWx0cyBhcmUgZGlmZmVyZW50IHRvIENTUyBhbmQgaXMgbGVzcyBpbnR1aXRpdmUsXG4gKiBzbyB3ZSB1c2UgdGhlIG1lYXN1cmVkIGRpbWVuc2lvbnMgb2YgdGhlIFNWRyB0byByZWNvbmNpbGUgdGhlc2UuXG4gKi9cbmZ1bmN0aW9uIGNhbGNTVkdUcmFuc2Zvcm1PcmlnaW4oZGltZW5zaW9ucywgb3JpZ2luWCwgb3JpZ2luWSkge1xuICAgIGNvbnN0IHB4T3JpZ2luWCA9IGNhbGNPcmlnaW4ob3JpZ2luWCwgZGltZW5zaW9ucy54LCBkaW1lbnNpb25zLndpZHRoKTtcbiAgICBjb25zdCBweE9yaWdpblkgPSBjYWxjT3JpZ2luKG9yaWdpblksIGRpbWVuc2lvbnMueSwgZGltZW5zaW9ucy5oZWlnaHQpO1xuICAgIHJldHVybiBgJHtweE9yaWdpblh9ICR7cHhPcmlnaW5ZfWA7XG59XG5cbmNvbnN0IGRhc2hLZXlzID0ge1xuICAgIG9mZnNldDogXCJzdHJva2UtZGFzaG9mZnNldFwiLFxuICAgIGFycmF5OiBcInN0cm9rZS1kYXNoYXJyYXlcIixcbn07XG5jb25zdCBjYW1lbEtleXMgPSB7XG4gICAgb2Zmc2V0OiBcInN0cm9rZURhc2hvZmZzZXRcIixcbiAgICBhcnJheTogXCJzdHJva2VEYXNoYXJyYXlcIixcbn07XG4vKipcbiAqIEJ1aWxkIFNWRyBwYXRoIHByb3BlcnRpZXMuIFVzZXMgdGhlIHBhdGgncyBtZWFzdXJlZCBsZW5ndGggdG8gY29udmVydFxuICogb3VyIGN1c3RvbSBwYXRoTGVuZ3RoLCBwYXRoU3BhY2luZyBhbmQgcGF0aE9mZnNldCBpbnRvIHN0cm9rZS1kYXNob2Zmc2V0XG4gKiBhbmQgc3Ryb2tlLWRhc2hhcnJheSBhdHRyaWJ1dGVzLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbXV0YXRpdmUgdG8gcmVkdWNlIHBlci1mcmFtZSBHQy5cbiAqL1xuZnVuY3Rpb24gYnVpbGRTVkdQYXRoKGF0dHJzLCBsZW5ndGgsIHNwYWNpbmcgPSAxLCBvZmZzZXQgPSAwLCB1c2VEYXNoQ2FzZSA9IHRydWUpIHtcbiAgICAvLyBOb3JtYWxpc2UgcGF0aCBsZW5ndGggYnkgc2V0dGluZyBTVkcgYXR0cmlidXRlIHBhdGhMZW5ndGggdG8gMVxuICAgIGF0dHJzLnBhdGhMZW5ndGggPSAxO1xuICAgIC8vIFdlIHVzZSBkYXNoIGNhc2Ugd2hlbiBzZXR0aW5nIGF0dHJpYnV0ZXMgZGlyZWN0bHkgdG8gdGhlIERPTSBub2RlIGFuZCBjYW1lbCBjYXNlXG4gICAgLy8gd2hlbiBkZWZpbmluZyBwcm9wcyBvbiBhIFJlYWN0IGNvbXBvbmVudC5cbiAgICBjb25zdCBrZXlzID0gdXNlRGFzaENhc2UgPyBkYXNoS2V5cyA6IGNhbWVsS2V5cztcbiAgICAvLyBCdWlsZCB0aGUgZGFzaCBvZmZzZXRcbiAgICBhdHRyc1trZXlzLm9mZnNldF0gPSBweC50cmFuc2Zvcm0oLW9mZnNldCk7XG4gICAgLy8gQnVpbGQgdGhlIGRhc2ggYXJyYXlcbiAgICBjb25zdCBwYXRoTGVuZ3RoID0gcHgudHJhbnNmb3JtKGxlbmd0aCk7XG4gICAgY29uc3QgcGF0aFNwYWNpbmcgPSBweC50cmFuc2Zvcm0oc3BhY2luZyk7XG4gICAgYXR0cnNba2V5cy5hcnJheV0gPSBgJHtwYXRoTGVuZ3RofSAke3BhdGhTcGFjaW5nfWA7XG59XG5cbi8qKlxuICogQnVpbGQgU1ZHIHZpc3VhbCBhdHRyYnV0ZXMsIGxpa2UgY3ggYW5kIHN0eWxlLnRyYW5zZm9ybVxuICovXG5mdW5jdGlvbiBidWlsZFNWR0F0dHJzKHN0YXRlLCB7IGF0dHJYLCBhdHRyWSwgYXR0clNjYWxlLCBvcmlnaW5YLCBvcmlnaW5ZLCBwYXRoTGVuZ3RoLCBwYXRoU3BhY2luZyA9IDEsIHBhdGhPZmZzZXQgPSAwLCBcbi8vIFRoaXMgaXMgb2JqZWN0IGNyZWF0aW9uLCB3aGljaCB3ZSB0cnkgdG8gYXZvaWQgcGVyLWZyYW1lLlxuLi4ubGF0ZXN0IH0sIGlzU1ZHVGFnLCB0cmFuc2Zvcm1UZW1wbGF0ZSkge1xuICAgIGJ1aWxkSFRNTFN0eWxlcyhzdGF0ZSwgbGF0ZXN0LCB0cmFuc2Zvcm1UZW1wbGF0ZSk7XG4gICAgLyoqXG4gICAgICogRm9yIHN2ZyB0YWdzIHdlIGp1c3Qgd2FudCB0byBtYWtlIHN1cmUgdmlld0JveCBpcyBhbmltYXRhYmxlIGFuZCB0cmVhdCBhbGwgdGhlIHN0eWxlc1xuICAgICAqIGFzIG5vcm1hbCBIVE1MIHRhZ3MuXG4gICAgICovXG4gICAgaWYgKGlzU1ZHVGFnKSB7XG4gICAgICAgIGlmIChzdGF0ZS5zdHlsZS52aWV3Qm94KSB7XG4gICAgICAgICAgICBzdGF0ZS5hdHRycy52aWV3Qm94ID0gc3RhdGUuc3R5bGUudmlld0JveDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHN0YXRlLmF0dHJzID0gc3RhdGUuc3R5bGU7XG4gICAgc3RhdGUuc3R5bGUgPSB7fTtcbiAgICBjb25zdCB7IGF0dHJzLCBzdHlsZSwgZGltZW5zaW9ucyB9ID0gc3RhdGU7XG4gICAgLyoqXG4gICAgICogSG93ZXZlciwgd2UgYXBwbHkgdHJhbnNmb3JtcyBhcyBDU1MgdHJhbnNmb3Jtcy4gU28gaWYgd2UgZGV0ZWN0IGEgdHJhbnNmb3JtIHdlIHRha2UgaXQgZnJvbSBhdHRyc1xuICAgICAqIGFuZCBjb3B5IGl0IGludG8gc3R5bGUuXG4gICAgICovXG4gICAgaWYgKGF0dHJzLnRyYW5zZm9ybSkge1xuICAgICAgICBpZiAoZGltZW5zaW9ucylcbiAgICAgICAgICAgIHN0eWxlLnRyYW5zZm9ybSA9IGF0dHJzLnRyYW5zZm9ybTtcbiAgICAgICAgZGVsZXRlIGF0dHJzLnRyYW5zZm9ybTtcbiAgICB9XG4gICAgLy8gUGFyc2UgdHJhbnNmb3JtT3JpZ2luXG4gICAgaWYgKGRpbWVuc2lvbnMgJiZcbiAgICAgICAgKG9yaWdpblggIT09IHVuZGVmaW5lZCB8fCBvcmlnaW5ZICE9PSB1bmRlZmluZWQgfHwgc3R5bGUudHJhbnNmb3JtKSkge1xuICAgICAgICBzdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSBjYWxjU1ZHVHJhbnNmb3JtT3JpZ2luKGRpbWVuc2lvbnMsIG9yaWdpblggIT09IHVuZGVmaW5lZCA/IG9yaWdpblggOiAwLjUsIG9yaWdpblkgIT09IHVuZGVmaW5lZCA/IG9yaWdpblkgOiAwLjUpO1xuICAgIH1cbiAgICAvLyBSZW5kZXIgYXR0clgvYXR0clkvYXR0clNjYWxlIGFzIGF0dHJpYnV0ZXNcbiAgICBpZiAoYXR0clggIT09IHVuZGVmaW5lZClcbiAgICAgICAgYXR0cnMueCA9IGF0dHJYO1xuICAgIGlmIChhdHRyWSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBhdHRycy55ID0gYXR0clk7XG4gICAgaWYgKGF0dHJTY2FsZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBhdHRycy5zY2FsZSA9IGF0dHJTY2FsZTtcbiAgICAvLyBCdWlsZCBTVkcgcGF0aCBpZiBvbmUgaGFzIGJlZW4gZGVmaW5lZFxuICAgIGlmIChwYXRoTGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYnVpbGRTVkdQYXRoKGF0dHJzLCBwYXRoTGVuZ3RoLCBwYXRoU3BhY2luZywgcGF0aE9mZnNldCwgZmFsc2UpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBIHNldCBvZiBhdHRyaWJ1dGUgbmFtZXMgdGhhdCBhcmUgYWx3YXlzIHJlYWQvd3JpdHRlbiBhcyBjYW1lbCBjYXNlLlxuICovXG5jb25zdCBjYW1lbENhc2VBdHRyaWJ1dGVzID0gbmV3IFNldChbXG4gICAgXCJiYXNlRnJlcXVlbmN5XCIsXG4gICAgXCJkaWZmdXNlQ29uc3RhbnRcIixcbiAgICBcImtlcm5lbE1hdHJpeFwiLFxuICAgIFwia2VybmVsVW5pdExlbmd0aFwiLFxuICAgIFwia2V5U3BsaW5lc1wiLFxuICAgIFwia2V5VGltZXNcIixcbiAgICBcImxpbWl0aW5nQ29uZUFuZ2xlXCIsXG4gICAgXCJtYXJrZXJIZWlnaHRcIixcbiAgICBcIm1hcmtlcldpZHRoXCIsXG4gICAgXCJudW1PY3RhdmVzXCIsXG4gICAgXCJ0YXJnZXRYXCIsXG4gICAgXCJ0YXJnZXRZXCIsXG4gICAgXCJzdXJmYWNlU2NhbGVcIixcbiAgICBcInNwZWN1bGFyQ29uc3RhbnRcIixcbiAgICBcInNwZWN1bGFyRXhwb25lbnRcIixcbiAgICBcInN0ZERldmlhdGlvblwiLFxuICAgIFwidGFibGVWYWx1ZXNcIixcbiAgICBcInZpZXdCb3hcIixcbiAgICBcImdyYWRpZW50VHJhbnNmb3JtXCIsXG4gICAgXCJwYXRoTGVuZ3RoXCIsXG4gICAgXCJzdGFydE9mZnNldFwiLFxuICAgIFwidGV4dExlbmd0aFwiLFxuICAgIFwibGVuZ3RoQWRqdXN0XCIsXG5dKTtcblxuZnVuY3Rpb24gcmVuZGVySFRNTChlbGVtZW50LCB7IHN0eWxlLCB2YXJzIH0sIHN0eWxlUHJvcCwgcHJvamVjdGlvbikge1xuICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwgc3R5bGUsIHByb2plY3Rpb24gJiYgcHJvamVjdGlvbi5nZXRQcm9qZWN0aW9uU3R5bGVzKHN0eWxlUHJvcCkpO1xuICAgIC8vIExvb3Agb3ZlciBhbnkgQ1NTIHZhcmlhYmxlcyBhbmQgYXNzaWduIHRob3NlLlxuICAgIGZvciAoY29uc3Qga2V5IGluIHZhcnMpIHtcbiAgICAgICAgZWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShrZXksIHZhcnNba2V5XSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJTVkcoZWxlbWVudCwgcmVuZGVyU3RhdGUsIF9zdHlsZVByb3AsIHByb2plY3Rpb24pIHtcbiAgICByZW5kZXJIVE1MKGVsZW1lbnQsIHJlbmRlclN0YXRlLCB1bmRlZmluZWQsIHByb2plY3Rpb24pO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHJlbmRlclN0YXRlLmF0dHJzKSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCFjYW1lbENhc2VBdHRyaWJ1dGVzLmhhcyhrZXkpID8gY2FtZWxUb0Rhc2goa2V5KSA6IGtleSwgcmVuZGVyU3RhdGUuYXR0cnNba2V5XSk7XG4gICAgfVxufVxuXG5jb25zdCBpc1NWR1RhZyA9ICh0YWcpID0+IHR5cGVvZiB0YWcgPT09IFwic3RyaW5nXCIgJiYgdGFnLnRvTG93ZXJDYXNlKCkgPT09IFwic3ZnXCI7XG5cbmNsYXNzIFNWR1Zpc3VhbEVsZW1lbnQgZXh0ZW5kcyBET01WaXN1YWxFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy50eXBlID0gXCJzdmdcIjtcbiAgICAgICAgdGhpcy5pc1NWR1RhZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1lYXN1cmVJbnN0YW5jZVZpZXdwb3J0Qm94ID0gY3JlYXRlQm94O1xuICAgIH1cbiAgICBnZXRCYXNlVGFyZ2V0RnJvbVByb3BzKHByb3BzLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIHByb3BzW2tleV07XG4gICAgfVxuICAgIHJlYWRWYWx1ZUZyb21JbnN0YW5jZShpbnN0YW5jZSwga2V5KSB7XG4gICAgICAgIGlmICh0cmFuc2Zvcm1Qcm9wcy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgY29uc3QgZGVmYXVsdFR5cGUgPSBnZXREZWZhdWx0VmFsdWVUeXBlKGtleSk7XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdFR5cGUgPyBkZWZhdWx0VHlwZS5kZWZhdWx0IHx8IDAgOiAwO1xuICAgICAgICB9XG4gICAgICAgIGtleSA9ICFjYW1lbENhc2VBdHRyaWJ1dGVzLmhhcyhrZXkpID8gY2FtZWxUb0Rhc2goa2V5KSA6IGtleTtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLmdldEF0dHJpYnV0ZShrZXkpO1xuICAgIH1cbiAgICBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMocHJvcHMsIHByZXZQcm9wcywgdmlzdWFsRWxlbWVudCkge1xuICAgICAgICByZXR1cm4gc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzKHByb3BzLCBwcmV2UHJvcHMsIHZpc3VhbEVsZW1lbnQpO1xuICAgIH1cbiAgICBidWlsZChyZW5kZXJTdGF0ZSwgbGF0ZXN0VmFsdWVzLCBwcm9wcykge1xuICAgICAgICBidWlsZFNWR0F0dHJzKHJlbmRlclN0YXRlLCBsYXRlc3RWYWx1ZXMsIHRoaXMuaXNTVkdUYWcsIHByb3BzLnRyYW5zZm9ybVRlbXBsYXRlKTtcbiAgICB9XG4gICAgcmVuZGVySW5zdGFuY2UoaW5zdGFuY2UsIHJlbmRlclN0YXRlLCBzdHlsZVByb3AsIHByb2plY3Rpb24pIHtcbiAgICAgICAgcmVuZGVyU1ZHKGluc3RhbmNlLCByZW5kZXJTdGF0ZSwgc3R5bGVQcm9wLCBwcm9qZWN0aW9uKTtcbiAgICB9XG4gICAgbW91bnQoaW5zdGFuY2UpIHtcbiAgICAgICAgdGhpcy5pc1NWR1RhZyA9IGlzU1ZHVGFnKGluc3RhbmNlLnRhZ05hbWUpO1xuICAgICAgICBzdXBlci5tb3VudChpbnN0YW5jZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRDb21wdXRlZFN0eWxlJDEoZWxlbWVudCkge1xuICAgIHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbn1cbmNsYXNzIEhUTUxWaXN1YWxFbGVtZW50IGV4dGVuZHMgRE9NVmlzdWFsRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudHlwZSA9IFwiaHRtbFwiO1xuICAgICAgICB0aGlzLnJlbmRlckluc3RhbmNlID0gcmVuZGVySFRNTDtcbiAgICB9XG4gICAgcmVhZFZhbHVlRnJvbUluc3RhbmNlKGluc3RhbmNlLCBrZXkpIHtcbiAgICAgICAgaWYgKHRyYW5zZm9ybVByb3BzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0VHlwZSA9IGdldERlZmF1bHRWYWx1ZVR5cGUoa2V5KTtcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0VHlwZSA/IGRlZmF1bHRUeXBlLmRlZmF1bHQgfHwgMCA6IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSQxKGluc3RhbmNlKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gKGlzQ1NTVmFyaWFibGVOYW1lKGtleSlcbiAgICAgICAgICAgICAgICA/IGNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShrZXkpXG4gICAgICAgICAgICAgICAgOiBjb21wdXRlZFN0eWxlW2tleV0pIHx8IDA7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gdmFsdWUudHJpbSgpIDogdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWVhc3VyZUluc3RhbmNlVmlld3BvcnRCb3goaW5zdGFuY2UsIHsgdHJhbnNmb3JtUGFnZVBvaW50IH0pIHtcbiAgICAgICAgcmV0dXJuIG1lYXN1cmVWaWV3cG9ydEJveChpbnN0YW5jZSwgdHJhbnNmb3JtUGFnZVBvaW50KTtcbiAgICB9XG4gICAgYnVpbGQocmVuZGVyU3RhdGUsIGxhdGVzdFZhbHVlcywgcHJvcHMpIHtcbiAgICAgICAgYnVpbGRIVE1MU3R5bGVzKHJlbmRlclN0YXRlLCBsYXRlc3RWYWx1ZXMsIHByb3BzLnRyYW5zZm9ybVRlbXBsYXRlKTtcbiAgICB9XG4gICAgc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzKHByb3BzLCBwcmV2UHJvcHMsIHZpc3VhbEVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyQxKHByb3BzLCBwcmV2UHJvcHMsIHZpc3VhbEVsZW1lbnQpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNPYmplY3RLZXkoa2V5LCBvYmplY3QpIHtcbiAgICByZXR1cm4ga2V5IGluIG9iamVjdDtcbn1cbmNsYXNzIE9iamVjdFZpc3VhbEVsZW1lbnQgZXh0ZW5kcyBWaXN1YWxFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy50eXBlID0gXCJvYmplY3RcIjtcbiAgICB9XG4gICAgcmVhZFZhbHVlRnJvbUluc3RhbmNlKGluc3RhbmNlLCBrZXkpIHtcbiAgICAgICAgaWYgKGlzT2JqZWN0S2V5KGtleSwgaW5zdGFuY2UpKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGluc3RhbmNlW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXRCYXNlVGFyZ2V0RnJvbVByb3BzKCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZW1vdmVWYWx1ZUZyb21SZW5kZXJTdGF0ZShrZXksIHJlbmRlclN0YXRlKSB7XG4gICAgICAgIGRlbGV0ZSByZW5kZXJTdGF0ZS5vdXRwdXRba2V5XTtcbiAgICB9XG4gICAgbWVhc3VyZUluc3RhbmNlVmlld3BvcnRCb3goKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCb3goKTtcbiAgICB9XG4gICAgYnVpbGQocmVuZGVyU3RhdGUsIGxhdGVzdFZhbHVlcykge1xuICAgICAgICBPYmplY3QuYXNzaWduKHJlbmRlclN0YXRlLm91dHB1dCwgbGF0ZXN0VmFsdWVzKTtcbiAgICB9XG4gICAgcmVuZGVySW5zdGFuY2UoaW5zdGFuY2UsIHsgb3V0cHV0IH0pIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihpbnN0YW5jZSwgb3V0cHV0KTtcbiAgICB9XG4gICAgc29ydEluc3RhbmNlTm9kZVBvc2l0aW9uKCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURPTVZpc3VhbEVsZW1lbnQoZWxlbWVudCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIHByZXNlbmNlQ29udGV4dDogbnVsbCxcbiAgICAgICAgcHJvcHM6IHt9LFxuICAgICAgICB2aXN1YWxTdGF0ZToge1xuICAgICAgICAgICAgcmVuZGVyU3RhdGU6IHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHt9LFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybU9yaWdpbjoge30sXG4gICAgICAgICAgICAgICAgc3R5bGU6IHt9LFxuICAgICAgICAgICAgICAgIHZhcnM6IHt9LFxuICAgICAgICAgICAgICAgIGF0dHJzOiB7fSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsYXRlc3RWYWx1ZXM6IHt9LFxuICAgICAgICB9LFxuICAgIH07XG4gICAgY29uc3Qgbm9kZSA9IGlzU1ZHRWxlbWVudChlbGVtZW50KVxuICAgICAgICA/IG5ldyBTVkdWaXN1YWxFbGVtZW50KG9wdGlvbnMpXG4gICAgICAgIDogbmV3IEhUTUxWaXN1YWxFbGVtZW50KG9wdGlvbnMpO1xuICAgIG5vZGUubW91bnQoZWxlbWVudCk7XG4gICAgdmlzdWFsRWxlbWVudFN0b3JlLnNldChlbGVtZW50LCBub2RlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU9iamVjdFZpc3VhbEVsZW1lbnQoc3ViamVjdCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIHByZXNlbmNlQ29udGV4dDogbnVsbCxcbiAgICAgICAgcHJvcHM6IHt9LFxuICAgICAgICB2aXN1YWxTdGF0ZToge1xuICAgICAgICAgICAgcmVuZGVyU3RhdGU6IHtcbiAgICAgICAgICAgICAgICBvdXRwdXQ6IHt9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxhdGVzdFZhbHVlczoge30sXG4gICAgICAgIH0sXG4gICAgfTtcbiAgICBjb25zdCBub2RlID0gbmV3IE9iamVjdFZpc3VhbEVsZW1lbnQob3B0aW9ucyk7XG4gICAgbm9kZS5tb3VudChzdWJqZWN0KTtcbiAgICB2aXN1YWxFbGVtZW50U3RvcmUuc2V0KHN1YmplY3QsIG5vZGUpO1xufVxuXG5mdW5jdGlvbiBhbmltYXRlU2luZ2xlVmFsdWUodmFsdWUsIGtleWZyYW1lcywgb3B0aW9ucykge1xuICAgIGNvbnN0IG1vdGlvblZhbHVlJDEgPSBpc01vdGlvblZhbHVlKHZhbHVlKSA/IHZhbHVlIDogbW90aW9uVmFsdWUodmFsdWUpO1xuICAgIG1vdGlvblZhbHVlJDEuc3RhcnQoYW5pbWF0ZU1vdGlvblZhbHVlKFwiXCIsIG1vdGlvblZhbHVlJDEsIGtleWZyYW1lcywgb3B0aW9ucykpO1xuICAgIHJldHVybiBtb3Rpb25WYWx1ZSQxLmFuaW1hdGlvbjtcbn1cblxuZnVuY3Rpb24gaXNTaW5nbGVWYWx1ZShzdWJqZWN0LCBrZXlmcmFtZXMpIHtcbiAgICByZXR1cm4gKGlzTW90aW9uVmFsdWUoc3ViamVjdCkgfHxcbiAgICAgICAgdHlwZW9mIHN1YmplY3QgPT09IFwibnVtYmVyXCIgfHxcbiAgICAgICAgKHR5cGVvZiBzdWJqZWN0ID09PSBcInN0cmluZ1wiICYmICFpc0RPTUtleWZyYW1lcyhrZXlmcmFtZXMpKSk7XG59XG4vKipcbiAqIEltcGxlbWVudGF0aW9uXG4gKi9cbmZ1bmN0aW9uIGFuaW1hdGVTdWJqZWN0KHN1YmplY3QsIGtleWZyYW1lcywgb3B0aW9ucywgc2NvcGUpIHtcbiAgICBjb25zdCBhbmltYXRpb25zID0gW107XG4gICAgaWYgKGlzU2luZ2xlVmFsdWUoc3ViamVjdCwga2V5ZnJhbWVzKSkge1xuICAgICAgICBhbmltYXRpb25zLnB1c2goYW5pbWF0ZVNpbmdsZVZhbHVlKHN1YmplY3QsIGlzRE9NS2V5ZnJhbWVzKGtleWZyYW1lcylcbiAgICAgICAgICAgID8ga2V5ZnJhbWVzLmRlZmF1bHQgfHwga2V5ZnJhbWVzXG4gICAgICAgICAgICA6IGtleWZyYW1lcywgb3B0aW9ucyA/IG9wdGlvbnMuZGVmYXVsdCB8fCBvcHRpb25zIDogb3B0aW9ucykpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3Qgc3ViamVjdHMgPSByZXNvbHZlU3ViamVjdHMoc3ViamVjdCwga2V5ZnJhbWVzLCBzY29wZSk7XG4gICAgICAgIGNvbnN0IG51bVN1YmplY3RzID0gc3ViamVjdHMubGVuZ3RoO1xuICAgICAgICBtb3Rpb25VdGlscy5pbnZhcmlhbnQoQm9vbGVhbihudW1TdWJqZWN0cyksIFwiTm8gdmFsaWQgZWxlbWVudHMgcHJvdmlkZWQuXCIpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVN1YmplY3RzOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHRoaXNTdWJqZWN0ID0gc3ViamVjdHNbaV07XG4gICAgICAgICAgICBjb25zdCBjcmVhdGVWaXN1YWxFbGVtZW50ID0gdGhpc1N1YmplY3QgaW5zdGFuY2VvZiBFbGVtZW50XG4gICAgICAgICAgICAgICAgPyBjcmVhdGVET01WaXN1YWxFbGVtZW50XG4gICAgICAgICAgICAgICAgOiBjcmVhdGVPYmplY3RWaXN1YWxFbGVtZW50O1xuICAgICAgICAgICAgaWYgKCF2aXN1YWxFbGVtZW50U3RvcmUuaGFzKHRoaXNTdWJqZWN0KSkge1xuICAgICAgICAgICAgICAgIGNyZWF0ZVZpc3VhbEVsZW1lbnQodGhpc1N1YmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdmlzdWFsRWxlbWVudCA9IHZpc3VhbEVsZW1lbnRTdG9yZS5nZXQodGhpc1N1YmplY3QpO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNpdGlvbiA9IHsgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXNvbHZlIHN0YWdnZXIgZnVuY3Rpb24gaWYgcHJvdmlkZWQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChcImRlbGF5XCIgaW4gdHJhbnNpdGlvbiAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiB0cmFuc2l0aW9uLmRlbGF5ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uLmRlbGF5ID0gdHJhbnNpdGlvbi5kZWxheShpLCBudW1TdWJqZWN0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhbmltYXRpb25zLnB1c2goLi4uYW5pbWF0ZVRhcmdldCh2aXN1YWxFbGVtZW50LCB7IC4uLmtleWZyYW1lcywgdHJhbnNpdGlvbiB9LCB7fSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhbmltYXRpb25zO1xufVxuXG5mdW5jdGlvbiBhbmltYXRlU2VxdWVuY2Uoc2VxdWVuY2UsIG9wdGlvbnMsIHNjb3BlKSB7XG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IFtdO1xuICAgIGNvbnN0IGFuaW1hdGlvbkRlZmluaXRpb25zID0gY3JlYXRlQW5pbWF0aW9uc0Zyb21TZXF1ZW5jZShzZXF1ZW5jZSwgb3B0aW9ucywgc2NvcGUsIHsgc3ByaW5nIH0pO1xuICAgIGFuaW1hdGlvbkRlZmluaXRpb25zLmZvckVhY2goKHsga2V5ZnJhbWVzLCB0cmFuc2l0aW9uIH0sIHN1YmplY3QpID0+IHtcbiAgICAgICAgYW5pbWF0aW9ucy5wdXNoKC4uLmFuaW1hdGVTdWJqZWN0KHN1YmplY3QsIGtleWZyYW1lcywgdHJhbnNpdGlvbikpO1xuICAgIH0pO1xuICAgIHJldHVybiBhbmltYXRpb25zO1xufVxuXG5mdW5jdGlvbiBpc1NlcXVlbmNlKHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIEFycmF5LmlzQXJyYXkodmFsdWVbMF0pO1xufVxuLyoqXG4gKiBDcmVhdGVzIGFuIGFuaW1hdGlvbiBmdW5jdGlvbiB0aGF0IGlzIG9wdGlvbmFsbHkgc2NvcGVkXG4gKiB0byBhIHNwZWNpZmljIGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVNjb3BlZEFuaW1hdGUoc2NvcGUpIHtcbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRhdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNjb3BlZEFuaW1hdGUoc3ViamVjdE9yU2VxdWVuY2UsIG9wdGlvbnNPcktleWZyYW1lcywgb3B0aW9ucykge1xuICAgICAgICBsZXQgYW5pbWF0aW9ucyA9IFtdO1xuICAgICAgICBpZiAoaXNTZXF1ZW5jZShzdWJqZWN0T3JTZXF1ZW5jZSkpIHtcbiAgICAgICAgICAgIGFuaW1hdGlvbnMgPSBhbmltYXRlU2VxdWVuY2Uoc3ViamVjdE9yU2VxdWVuY2UsIG9wdGlvbnNPcktleWZyYW1lcywgc2NvcGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYW5pbWF0aW9ucyA9IGFuaW1hdGVTdWJqZWN0KHN1YmplY3RPclNlcXVlbmNlLCBvcHRpb25zT3JLZXlmcmFtZXMsIG9wdGlvbnMsIHNjb3BlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhbmltYXRpb24gPSBuZXcgR3JvdXBQbGF5YmFja0NvbnRyb2xzKGFuaW1hdGlvbnMpO1xuICAgICAgICBpZiAoc2NvcGUpIHtcbiAgICAgICAgICAgIHNjb3BlLmFuaW1hdGlvbnMucHVzaChhbmltYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbmltYXRpb247XG4gICAgfVxuICAgIHJldHVybiBzY29wZWRBbmltYXRlO1xufVxuY29uc3QgYW5pbWF0ZSA9IGNyZWF0ZVNjb3BlZEFuaW1hdGUoKTtcblxuZnVuY3Rpb24gc2V0Q1NTVmFyKGVsZW1lbnQsIG5hbWUsIHZhbHVlKSB7XG4gICAgZWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShgLS0ke25hbWV9YCwgdmFsdWUpO1xufVxuZnVuY3Rpb24gc2V0U3R5bGUoZWxlbWVudCwgbmFtZSwgdmFsdWUpIHtcbiAgICBlbGVtZW50LnN0eWxlW25hbWVdID0gdmFsdWU7XG59XG5cbmNvbnN0IHN1cHBvcnRzUGFydGlhbEtleWZyYW1lcyA9IC8qQF9fUFVSRV9fKi8gbWVtbygoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKS5hbmltYXRlKHsgb3BhY2l0eTogWzFdIH0pO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufSk7XG5cbmNvbnN0IHN0YXRlID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIGh5ZHJhdGVLZXlmcmFtZXModmFsdWVOYW1lLCBrZXlmcmFtZXMsIHJlYWQpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleWZyYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoa2V5ZnJhbWVzW2ldID09PSBudWxsKSB7XG4gICAgICAgICAgICBrZXlmcmFtZXNbaV0gPSBpID09PSAwID8gcmVhZCgpIDoga2V5ZnJhbWVzW2kgLSAxXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGtleWZyYW1lc1tpXSA9PT0gXCJudW1iZXJcIiAmJlxuICAgICAgICAgICAgYnJvd3Nlck51bWJlclZhbHVlVHlwZXNbdmFsdWVOYW1lXSkge1xuICAgICAgICAgICAga2V5ZnJhbWVzW2ldID0gYnJvd3Nlck51bWJlclZhbHVlVHlwZXNbdmFsdWVOYW1lXS50cmFuc2Zvcm0oa2V5ZnJhbWVzW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXN1cHBvcnRzUGFydGlhbEtleWZyYW1lcygpICYmIGtleWZyYW1lcy5sZW5ndGggPCAyKSB7XG4gICAgICAgIGtleWZyYW1lcy51bnNoaWZ0KHJlYWQoKSk7XG4gICAgfVxufVxuY29uc3QgZGVmYXVsdEVhc2luZyA9IFwiZWFzZU91dFwiO1xuZnVuY3Rpb24gZ2V0RWxlbWVudEFuaW1hdGlvblN0YXRlKGVsZW1lbnQpIHtcbiAgICBjb25zdCBhbmltYXRpb25TdGF0ZSA9IHN0YXRlLmdldChlbGVtZW50KSB8fCBuZXcgTWFwKCk7XG4gICAgc3RhdGUuc2V0KGVsZW1lbnQsIGFuaW1hdGlvblN0YXRlKTtcbiAgICByZXR1cm4gc3RhdGUuZ2V0KGVsZW1lbnQpO1xufVxuY2xhc3MgTmF0aXZlQW5pbWF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCB2YWx1ZU5hbWUsIHZhbHVlS2V5ZnJhbWVzLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGlzQ1NTVmFyID0gdmFsdWVOYW1lLnN0YXJ0c1dpdGgoXCItLVwiKTtcbiAgICAgICAgdGhpcy5zZXRWYWx1ZSA9IGlzQ1NTVmFyID8gc2V0Q1NTVmFyIDogc2V0U3R5bGU7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMudXBkYXRlRmluaXNoZWRQcm9taXNlKCk7XG4gICAgICAgIG1vdGlvblV0aWxzLmludmFyaWFudCh0eXBlb2Ygb3B0aW9ucy50eXBlICE9PSBcInN0cmluZ1wiLCBgYW5pbWF0ZU1pbmkgZG9lc24ndCBzdXBwb3J0IFwidHlwZVwiIGFzIGEgc3RyaW5nLiBEaWQgeW91IG1lYW4gdG8gaW1wb3J0IHsgc3ByaW5nIH0gZnJvbSBcImZyYW1lci1tb3Rpb25cIj9gKTtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdBbmltYXRpb24gPSBnZXRFbGVtZW50QW5pbWF0aW9uU3RhdGUoZWxlbWVudCkuZ2V0KHZhbHVlTmFtZSk7XG4gICAgICAgIGV4aXN0aW5nQW5pbWF0aW9uICYmIGV4aXN0aW5nQW5pbWF0aW9uLnN0b3AoKTtcbiAgICAgICAgY29uc3QgcmVhZEluaXRpYWxLZXlmcmFtZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZU5hbWUuc3RhcnRzV2l0aChcIi0tXCIpXG4gICAgICAgICAgICAgICAgPyBlbGVtZW50LnN0eWxlLmdldFByb3BlcnR5VmFsdWUodmFsdWVOYW1lKVxuICAgICAgICAgICAgICAgIDogd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudClbdmFsdWVOYW1lXTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlS2V5ZnJhbWVzKSkge1xuICAgICAgICAgICAgdmFsdWVLZXlmcmFtZXMgPSBbdmFsdWVLZXlmcmFtZXNdO1xuICAgICAgICB9XG4gICAgICAgIGh5ZHJhdGVLZXlmcmFtZXModmFsdWVOYW1lLCB2YWx1ZUtleWZyYW1lcywgcmVhZEluaXRpYWxLZXlmcmFtZSk7XG4gICAgICAgIC8vIFRPRE86IFJlcGxhY2UgdGhpcyB3aXRoIHRvU3RyaW5nKCk/XG4gICAgICAgIGlmIChpc0dlbmVyYXRvcihvcHRpb25zLnR5cGUpKSB7XG4gICAgICAgICAgICBjb25zdCBnZW5lcmF0b3JPcHRpb25zID0gY3JlYXRlR2VuZXJhdG9yRWFzaW5nKG9wdGlvbnMsIDEwMCwgb3B0aW9ucy50eXBlKTtcbiAgICAgICAgICAgIG9wdGlvbnMuZWFzZSA9IHN1cHBvcnRzTGluZWFyRWFzaW5nKClcbiAgICAgICAgICAgICAgICA/IGdlbmVyYXRvck9wdGlvbnMuZWFzZVxuICAgICAgICAgICAgICAgIDogZGVmYXVsdEVhc2luZztcbiAgICAgICAgICAgIG9wdGlvbnMuZHVyYXRpb24gPSBzZWNvbmRzVG9NaWxsaXNlY29uZHMoZ2VuZXJhdG9yT3B0aW9ucy5kdXJhdGlvbik7XG4gICAgICAgICAgICBvcHRpb25zLnR5cGUgPSBcImtleWZyYW1lc1wiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucy5lYXNlID0gb3B0aW9ucy5lYXNlIHx8IGRlZmF1bHRFYXNpbmc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbmltYXRpb24gPSAoKSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IHN0YXRlLmdldChlbGVtZW50KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlbGV0ZSh2YWx1ZU5hbWUpOyB9O1xuICAgICAgICBjb25zdCBvbkZpbmlzaCA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUoZWxlbWVudCwgdmFsdWVOYW1lLCBnZXRGaW5hbEtleWZyYW1lKHZhbHVlS2V5ZnJhbWVzLCB0aGlzLm9wdGlvbnMpKTtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsKCk7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmVGaW5pc2hlZFByb21pc2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFzdXBwb3J0c1dhYXBpKCkpIHtcbiAgICAgICAgICAgIG9uRmluaXNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbiA9IHN0YXJ0V2FhcGlBbmltYXRpb24oZWxlbWVudCwgdmFsdWVOYW1lLCB2YWx1ZUtleWZyYW1lcywgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hdXRvcGxheSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGlvbi5wYXVzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hbmltYXRpb24ub25maW5pc2ggPSBvbkZpbmlzaDtcbiAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdUaW1lbGluZSkge1xuICAgICAgICAgICAgICAgIGF0dGFjaFRpbWVsaW5lKHRoaXMuYW5pbWF0aW9uLCB0aGlzLnBlbmRpbmdUaW1lbGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZXRFbGVtZW50QW5pbWF0aW9uU3RhdGUoZWxlbWVudCkuc2V0KHZhbHVlTmFtZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGR1cmF0aW9uKCkge1xuICAgICAgICByZXR1cm4gbWlsbGlzZWNvbmRzVG9TZWNvbmRzKHRoaXMub3B0aW9ucy5kdXJhdGlvbiB8fCAzMDApO1xuICAgIH1cbiAgICBnZXQgdGltZSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodGhpcy5hbmltYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBtaWxsaXNlY29uZHNUb1NlY29uZHMoKChfYSA9IHRoaXMuYW5pbWF0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY3VycmVudFRpbWUpIHx8IDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBzZXQgdGltZShuZXdUaW1lKSB7XG4gICAgICAgIGlmICh0aGlzLmFuaW1hdGlvbikge1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb24uY3VycmVudFRpbWUgPSBzZWNvbmRzVG9NaWxsaXNlY29uZHMobmV3VGltZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHNwZWVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbmltYXRpb24gPyB0aGlzLmFuaW1hdGlvbi5wbGF5YmFja1JhdGUgOiAxO1xuICAgIH1cbiAgICBzZXQgc3BlZWQobmV3U3BlZWQpIHtcbiAgICAgICAgaWYgKHRoaXMuYW5pbWF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbi5wbGF5YmFja1JhdGUgPSBuZXdTcGVlZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgc3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFuaW1hdGlvbiA/IHRoaXMuYW5pbWF0aW9uLnBsYXlTdGF0ZSA6IFwiZmluaXNoZWRcIjtcbiAgICB9XG4gICAgZ2V0IHN0YXJ0VGltZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0aW9uID8gdGhpcy5hbmltYXRpb24uc3RhcnRUaW1lIDogbnVsbDtcbiAgICB9XG4gICAgZmxhdHRlbigpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIXRoaXMuYW5pbWF0aW9uKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAoX2EgPSB0aGlzLmFuaW1hdGlvbi5lZmZlY3QpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51cGRhdGVUaW1pbmcoeyBlYXNpbmc6IFwibGluZWFyXCIgfSk7XG4gICAgfVxuICAgIHBsYXkoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBcImZpbmlzaGVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRmluaXNoZWRQcm9taXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hbmltYXRpb24gJiYgdGhpcy5hbmltYXRpb24ucGxheSgpO1xuICAgIH1cbiAgICBwYXVzZSgpIHtcbiAgICAgICAgdGhpcy5hbmltYXRpb24gJiYgdGhpcy5hbmltYXRpb24ucGF1c2UoKTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFuaW1hdGlvbiB8fFxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9PT0gXCJpZGxlXCIgfHxcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPT09IFwiZmluaXNoZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFuaW1hdGlvbi5jb21taXRTdHlsZXMpIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uLmNvbW1pdFN0eWxlcygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FuY2VsKCk7XG4gICAgfVxuICAgIGNvbXBsZXRlKCkge1xuICAgICAgICB0aGlzLmFuaW1hdGlvbiAmJiB0aGlzLmFuaW1hdGlvbi5maW5pc2goKTtcbiAgICB9XG4gICAgY2FuY2VsKCkge1xuICAgICAgICB0aGlzLnJlbW92ZUFuaW1hdGlvbigpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb24gJiYgdGhpcy5hbmltYXRpb24uY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGxvd3MgdGhlIHJldHVybmVkIGFuaW1hdGlvbiB0byBiZSBhd2FpdGVkIG9yIHByb21pc2UtY2hhaW5lZC4gQ3VycmVudGx5XG4gICAgICogcmVzb2x2ZXMgd2hlbiB0aGUgYW5pbWF0aW9uIGZpbmlzaGVzIGF0IGFsbCBidXQgaW4gYSBmdXR1cmUgdXBkYXRlIGNvdWxkL3Nob3VsZFxuICAgICAqIHJlamVjdCBpZiBpdHMgY2FuY2Vscy5cbiAgICAgKi9cbiAgICB0aGVuKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50RmluaXNoZWRQcm9taXNlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICB9XG4gICAgdXBkYXRlRmluaXNoZWRQcm9taXNlKCkge1xuICAgICAgICB0aGlzLmN1cnJlbnRGaW5pc2hlZFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlRmluaXNoZWRQcm9taXNlID0gcmVzb2x2ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGF0dGFjaFRpbWVsaW5lKHRpbWVsaW5lKSB7XG4gICAgICAgIGlmICghdGhpcy5hbmltYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ1RpbWVsaW5lID0gdGltZWxpbmU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhdHRhY2hUaW1lbGluZSh0aGlzLmFuaW1hdGlvbiwgdGltZWxpbmUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb3Rpb25VdGlscy5ub29wO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYW5pbWF0ZUVsZW1lbnRzKGVsZW1lbnRPclNlbGVjdG9yLCBrZXlmcmFtZXMsIG9wdGlvbnMsIHNjb3BlKSB7XG4gICAgY29uc3QgZWxlbWVudHMgPSBtb3Rpb25Eb20ucmVzb2x2ZUVsZW1lbnRzKGVsZW1lbnRPclNlbGVjdG9yLCBzY29wZSk7XG4gICAgY29uc3QgbnVtRWxlbWVudHMgPSBlbGVtZW50cy5sZW5ndGg7XG4gICAgbW90aW9uVXRpbHMuaW52YXJpYW50KEJvb2xlYW4obnVtRWxlbWVudHMpLCBcIk5vIHZhbGlkIGVsZW1lbnQgcHJvdmlkZWQuXCIpO1xuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUVsZW1lbnRzOyBpKyspIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuICAgICAgICBjb25zdCBlbGVtZW50VHJhbnNpdGlvbiA9IHsgLi4ub3B0aW9ucyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVzb2x2ZSBzdGFnZ2VyIGZ1bmN0aW9uIGlmIHByb3ZpZGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHR5cGVvZiBlbGVtZW50VHJhbnNpdGlvbi5kZWxheSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBlbGVtZW50VHJhbnNpdGlvbi5kZWxheSA9IGVsZW1lbnRUcmFuc2l0aW9uLmRlbGF5KGksIG51bUVsZW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlTmFtZSBpbiBrZXlmcmFtZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlS2V5ZnJhbWVzID0ga2V5ZnJhbWVzW3ZhbHVlTmFtZV07XG4gICAgICAgICAgICBjb25zdCB2YWx1ZU9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgLi4uZ2V0VmFsdWVUcmFuc2l0aW9uJDEoZWxlbWVudFRyYW5zaXRpb24sIHZhbHVlTmFtZSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFsdWVPcHRpb25zLmR1cmF0aW9uID0gdmFsdWVPcHRpb25zLmR1cmF0aW9uXG4gICAgICAgICAgICAgICAgPyBzZWNvbmRzVG9NaWxsaXNlY29uZHModmFsdWVPcHRpb25zLmR1cmF0aW9uKVxuICAgICAgICAgICAgICAgIDogdmFsdWVPcHRpb25zLmR1cmF0aW9uO1xuICAgICAgICAgICAgdmFsdWVPcHRpb25zLmRlbGF5ID0gc2Vjb25kc1RvTWlsbGlzZWNvbmRzKHZhbHVlT3B0aW9ucy5kZWxheSB8fCAwKTtcbiAgICAgICAgICAgIGFuaW1hdGlvbnMucHVzaChuZXcgTmF0aXZlQW5pbWF0aW9uKGVsZW1lbnQsIHZhbHVlTmFtZSwgdmFsdWVLZXlmcmFtZXMsIHZhbHVlT3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhbmltYXRpb25zO1xufVxuXG5jb25zdCBjcmVhdGVTY29wZWRXYWFwaUFuaW1hdGUgPSAoc2NvcGUpID0+IHtcbiAgICBmdW5jdGlvbiBzY29wZWRBbmltYXRlKGVsZW1lbnRPclNlbGVjdG9yLCBrZXlmcmFtZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBHcm91cFBsYXliYWNrQ29udHJvbHMoYW5pbWF0ZUVsZW1lbnRzKGVsZW1lbnRPclNlbGVjdG9yLCBrZXlmcmFtZXMsIG9wdGlvbnMsIHNjb3BlKSk7XG4gICAgfVxuICAgIHJldHVybiBzY29wZWRBbmltYXRlO1xufTtcbmNvbnN0IGFuaW1hdGVNaW5pID0gLypAX19QVVJFX18qLyBjcmVhdGVTY29wZWRXYWFwaUFuaW1hdGUoKTtcblxuY29uc3QgcmVzaXplSGFuZGxlcnMgPSBuZXcgV2Vha01hcCgpO1xubGV0IG9ic2VydmVyO1xuZnVuY3Rpb24gZ2V0RWxlbWVudFNpemUodGFyZ2V0LCBib3JkZXJCb3hTaXplKSB7XG4gICAgaWYgKGJvcmRlckJveFNpemUpIHtcbiAgICAgICAgY29uc3QgeyBpbmxpbmVTaXplLCBibG9ja1NpemUgfSA9IGJvcmRlckJveFNpemVbMF07XG4gICAgICAgIHJldHVybiB7IHdpZHRoOiBpbmxpbmVTaXplLCBoZWlnaHQ6IGJsb2NrU2l6ZSB9O1xuICAgIH1cbiAgICBlbHNlIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBTVkdFbGVtZW50ICYmIFwiZ2V0QkJveFwiIGluIHRhcmdldCkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0LmdldEJCb3goKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aDogdGFyZ2V0Lm9mZnNldFdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiB0YXJnZXQub2Zmc2V0SGVpZ2h0LFxuICAgICAgICB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5vdGlmeVRhcmdldCh7IHRhcmdldCwgY29udGVudFJlY3QsIGJvcmRlckJveFNpemUsIH0pIHtcbiAgICB2YXIgX2E7XG4gICAgKF9hID0gcmVzaXplSGFuZGxlcnMuZ2V0KHRhcmdldCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JFYWNoKChoYW5kbGVyKSA9PiB7XG4gICAgICAgIGhhbmRsZXIoe1xuICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgY29udGVudFNpemU6IGNvbnRlbnRSZWN0LFxuICAgICAgICAgICAgZ2V0IHNpemUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldEVsZW1lbnRTaXplKHRhcmdldCwgYm9yZGVyQm94U2l6ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIG5vdGlmeUFsbChlbnRyaWVzKSB7XG4gICAgZW50cmllcy5mb3JFYWNoKG5vdGlmeVRhcmdldCk7XG59XG5mdW5jdGlvbiBjcmVhdGVSZXNpemVPYnNlcnZlcigpIHtcbiAgICBpZiAodHlwZW9mIFJlc2l6ZU9ic2VydmVyID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm47XG4gICAgb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIobm90aWZ5QWxsKTtcbn1cbmZ1bmN0aW9uIHJlc2l6ZUVsZW1lbnQodGFyZ2V0LCBoYW5kbGVyKSB7XG4gICAgaWYgKCFvYnNlcnZlcilcbiAgICAgICAgY3JlYXRlUmVzaXplT2JzZXJ2ZXIoKTtcbiAgICBjb25zdCBlbGVtZW50cyA9IG1vdGlvbkRvbS5yZXNvbHZlRWxlbWVudHModGFyZ2V0KTtcbiAgICBlbGVtZW50cy5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgICAgIGxldCBlbGVtZW50SGFuZGxlcnMgPSByZXNpemVIYW5kbGVycy5nZXQoZWxlbWVudCk7XG4gICAgICAgIGlmICghZWxlbWVudEhhbmRsZXJzKSB7XG4gICAgICAgICAgICBlbGVtZW50SGFuZGxlcnMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICByZXNpemVIYW5kbGVycy5zZXQoZWxlbWVudCwgZWxlbWVudEhhbmRsZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBlbGVtZW50SGFuZGxlcnMuYWRkKGhhbmRsZXIpO1xuICAgICAgICBvYnNlcnZlciA9PT0gbnVsbCB8fCBvYnNlcnZlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50KTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBlbGVtZW50cy5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50SGFuZGxlcnMgPSByZXNpemVIYW5kbGVycy5nZXQoZWxlbWVudCk7XG4gICAgICAgICAgICBlbGVtZW50SGFuZGxlcnMgPT09IG51bGwgfHwgZWxlbWVudEhhbmRsZXJzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbGVtZW50SGFuZGxlcnMuZGVsZXRlKGhhbmRsZXIpO1xuICAgICAgICAgICAgaWYgKCEoZWxlbWVudEhhbmRsZXJzID09PSBudWxsIHx8IGVsZW1lbnRIYW5kbGVycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZWxlbWVudEhhbmRsZXJzLnNpemUpKSB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIgPT09IG51bGwgfHwgb2JzZXJ2ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9ic2VydmVyLnVub2JzZXJ2ZShlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbn1cblxuY29uc3Qgd2luZG93Q2FsbGJhY2tzID0gbmV3IFNldCgpO1xubGV0IHdpbmRvd1Jlc2l6ZUhhbmRsZXI7XG5mdW5jdGlvbiBjcmVhdGVXaW5kb3dSZXNpemVIYW5kbGVyKCkge1xuICAgIHdpbmRvd1Jlc2l6ZUhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHNpemUgPSB7XG4gICAgICAgICAgICB3aWR0aDogd2luZG93LmlubmVyV2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgaW5mbyA9IHtcbiAgICAgICAgICAgIHRhcmdldDogd2luZG93LFxuICAgICAgICAgICAgc2l6ZSxcbiAgICAgICAgICAgIGNvbnRlbnRTaXplOiBzaXplLFxuICAgICAgICB9O1xuICAgICAgICB3aW5kb3dDYWxsYmFja3MuZm9yRWFjaCgoY2FsbGJhY2spID0+IGNhbGxiYWNrKGluZm8pKTtcbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHdpbmRvd1Jlc2l6ZUhhbmRsZXIpO1xufVxuZnVuY3Rpb24gcmVzaXplV2luZG93KGNhbGxiYWNrKSB7XG4gICAgd2luZG93Q2FsbGJhY2tzLmFkZChjYWxsYmFjayk7XG4gICAgaWYgKCF3aW5kb3dSZXNpemVIYW5kbGVyKVxuICAgICAgICBjcmVhdGVXaW5kb3dSZXNpemVIYW5kbGVyKCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgd2luZG93Q2FsbGJhY2tzLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgICAgIGlmICghd2luZG93Q2FsbGJhY2tzLnNpemUgJiYgd2luZG93UmVzaXplSGFuZGxlcikge1xuICAgICAgICAgICAgd2luZG93UmVzaXplSGFuZGxlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIHJlc2l6ZShhLCBiKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBhID09PSBcImZ1bmN0aW9uXCIgPyByZXNpemVXaW5kb3coYSkgOiByZXNpemVFbGVtZW50KGEsIGIpO1xufVxuXG4vKipcbiAqIEEgdGltZSBpbiBtaWxsaXNlY29uZHMsIGJleW9uZCB3aGljaCB3ZSBjb25zaWRlciB0aGUgc2Nyb2xsIHZlbG9jaXR5IHRvIGJlIDAuXG4gKi9cbmNvbnN0IG1heEVsYXBzZWQgPSA1MDtcbmNvbnN0IGNyZWF0ZUF4aXNJbmZvID0gKCkgPT4gKHtcbiAgICBjdXJyZW50OiAwLFxuICAgIG9mZnNldDogW10sXG4gICAgcHJvZ3Jlc3M6IDAsXG4gICAgc2Nyb2xsTGVuZ3RoOiAwLFxuICAgIHRhcmdldE9mZnNldDogMCxcbiAgICB0YXJnZXRMZW5ndGg6IDAsXG4gICAgY29udGFpbmVyTGVuZ3RoOiAwLFxuICAgIHZlbG9jaXR5OiAwLFxufSk7XG5jb25zdCBjcmVhdGVTY3JvbGxJbmZvID0gKCkgPT4gKHtcbiAgICB0aW1lOiAwLFxuICAgIHg6IGNyZWF0ZUF4aXNJbmZvKCksXG4gICAgeTogY3JlYXRlQXhpc0luZm8oKSxcbn0pO1xuY29uc3Qga2V5cyA9IHtcbiAgICB4OiB7XG4gICAgICAgIGxlbmd0aDogXCJXaWR0aFwiLFxuICAgICAgICBwb3NpdGlvbjogXCJMZWZ0XCIsXG4gICAgfSxcbiAgICB5OiB7XG4gICAgICAgIGxlbmd0aDogXCJIZWlnaHRcIixcbiAgICAgICAgcG9zaXRpb246IFwiVG9wXCIsXG4gICAgfSxcbn07XG5mdW5jdGlvbiB1cGRhdGVBeGlzSW5mbyhlbGVtZW50LCBheGlzTmFtZSwgaW5mbywgdGltZSkge1xuICAgIGNvbnN0IGF4aXMgPSBpbmZvW2F4aXNOYW1lXTtcbiAgICBjb25zdCB7IGxlbmd0aCwgcG9zaXRpb24gfSA9IGtleXNbYXhpc05hbWVdO1xuICAgIGNvbnN0IHByZXYgPSBheGlzLmN1cnJlbnQ7XG4gICAgY29uc3QgcHJldlRpbWUgPSBpbmZvLnRpbWU7XG4gICAgYXhpcy5jdXJyZW50ID0gZWxlbWVudFtgc2Nyb2xsJHtwb3NpdGlvbn1gXTtcbiAgICBheGlzLnNjcm9sbExlbmd0aCA9IGVsZW1lbnRbYHNjcm9sbCR7bGVuZ3RofWBdIC0gZWxlbWVudFtgY2xpZW50JHtsZW5ndGh9YF07XG4gICAgYXhpcy5vZmZzZXQubGVuZ3RoID0gMDtcbiAgICBheGlzLm9mZnNldFswXSA9IDA7XG4gICAgYXhpcy5vZmZzZXRbMV0gPSBheGlzLnNjcm9sbExlbmd0aDtcbiAgICBheGlzLnByb2dyZXNzID0gcHJvZ3Jlc3MoMCwgYXhpcy5zY3JvbGxMZW5ndGgsIGF4aXMuY3VycmVudCk7XG4gICAgY29uc3QgZWxhcHNlZCA9IHRpbWUgLSBwcmV2VGltZTtcbiAgICBheGlzLnZlbG9jaXR5ID1cbiAgICAgICAgZWxhcHNlZCA+IG1heEVsYXBzZWRcbiAgICAgICAgICAgID8gMFxuICAgICAgICAgICAgOiB2ZWxvY2l0eVBlclNlY29uZChheGlzLmN1cnJlbnQgLSBwcmV2LCBlbGFwc2VkKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVNjcm9sbEluZm8oZWxlbWVudCwgaW5mbywgdGltZSkge1xuICAgIHVwZGF0ZUF4aXNJbmZvKGVsZW1lbnQsIFwieFwiLCBpbmZvLCB0aW1lKTtcbiAgICB1cGRhdGVBeGlzSW5mbyhlbGVtZW50LCBcInlcIiwgaW5mbywgdGltZSk7XG4gICAgaW5mby50aW1lID0gdGltZTtcbn1cblxuZnVuY3Rpb24gY2FsY0luc2V0KGVsZW1lbnQsIGNvbnRhaW5lcikge1xuICAgIGNvbnN0IGluc2V0ID0geyB4OiAwLCB5OiAwIH07XG4gICAgbGV0IGN1cnJlbnQgPSBlbGVtZW50O1xuICAgIHdoaWxlIChjdXJyZW50ICYmIGN1cnJlbnQgIT09IGNvbnRhaW5lcikge1xuICAgICAgICBpZiAoY3VycmVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICBpbnNldC54ICs9IGN1cnJlbnQub2Zmc2V0TGVmdDtcbiAgICAgICAgICAgIGluc2V0LnkgKz0gY3VycmVudC5vZmZzZXRUb3A7XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5vZmZzZXRQYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VycmVudC50YWdOYW1lID09PSBcInN2Z1wiKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoaXMgaXNuJ3QgYW4gaWRlYWwgYXBwcm9hY2ggdG8gbWVhc3VyaW5nIHRoZSBvZmZzZXQgb2YgPHN2ZyAvPiB0YWdzLlxuICAgICAgICAgICAgICogSXQgd291bGQgYmUgcHJlZmVyYWJsZSwgZ2l2ZW4gdGhleSBiZWhhdmUgbGlrZSBIVE1MRWxlbWVudHMgaW4gbW9zdCB3YXlzXG4gICAgICAgICAgICAgKiB0byB1c2Ugb2Zmc2V0TGVmdC9Ub3AuIEJ1dCB0aGVzZSBkb24ndCBleGlzdCBvbiA8c3ZnIC8+LiBMaWtld2lzZSB3ZVxuICAgICAgICAgICAgICogY2FuJ3QgdXNlIC5nZXRCQm94KCkgbGlrZSBtb3N0IFNWRyBlbGVtZW50cyBhcyB0aGVzZSBwcm92aWRlIHRoZSBvZmZzZXRcbiAgICAgICAgICAgICAqIHJlbGF0aXZlIHRvIHRoZSBTVkcgaXRzZWxmLCB3aGljaCBmb3IgPHN2ZyAvPiBpcyB1c3VhbGx5IDB4MC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3Qgc3ZnQm91bmRpbmdCb3ggPSBjdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudEJvdW5kaW5nQm94ID0gY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIGluc2V0LnggKz0gc3ZnQm91bmRpbmdCb3gubGVmdCAtIHBhcmVudEJvdW5kaW5nQm94LmxlZnQ7XG4gICAgICAgICAgICBpbnNldC55ICs9IHN2Z0JvdW5kaW5nQm94LnRvcCAtIHBhcmVudEJvdW5kaW5nQm94LnRvcDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXJyZW50IGluc3RhbmNlb2YgU1ZHR3JhcGhpY3NFbGVtZW50KSB7XG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IGN1cnJlbnQuZ2V0QkJveCgpO1xuICAgICAgICAgICAgaW5zZXQueCArPSB4O1xuICAgICAgICAgICAgaW5zZXQueSArPSB5O1xuICAgICAgICAgICAgbGV0IHN2ZyA9IG51bGw7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gY3VycmVudC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgd2hpbGUgKCFzdmcpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50LnRhZ05hbWUgPT09IFwic3ZnXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3ZnID0gcGFyZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBjdXJyZW50LnBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50ID0gc3ZnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGluc2V0O1xufVxuXG5jb25zdCBTY3JvbGxPZmZzZXQgPSB7XG4gICAgRW50ZXI6IFtcbiAgICAgICAgWzAsIDFdLFxuICAgICAgICBbMSwgMV0sXG4gICAgXSxcbiAgICBFeGl0OiBbXG4gICAgICAgIFswLCAwXSxcbiAgICAgICAgWzEsIDBdLFxuICAgIF0sXG4gICAgQW55OiBbXG4gICAgICAgIFsxLCAwXSxcbiAgICAgICAgWzAsIDFdLFxuICAgIF0sXG4gICAgQWxsOiBbXG4gICAgICAgIFswLCAwXSxcbiAgICAgICAgWzEsIDFdLFxuICAgIF0sXG59O1xuXG5jb25zdCBuYW1lZEVkZ2VzID0ge1xuICAgIHN0YXJ0OiAwLFxuICAgIGNlbnRlcjogMC41LFxuICAgIGVuZDogMSxcbn07XG5mdW5jdGlvbiByZXNvbHZlRWRnZShlZGdlLCBsZW5ndGgsIGluc2V0ID0gMCkge1xuICAgIGxldCBkZWx0YSA9IDA7XG4gICAgLyoqXG4gICAgICogSWYgd2UgaGF2ZSB0aGlzIGVkZ2UgZGVmaW5lZCBhcyBhIHByZXNldCwgcmVwbGFjZSB0aGUgZGVmaW5pdGlvblxuICAgICAqIHdpdGggdGhlIG51bWVyaWNhbCB2YWx1ZS5cbiAgICAgKi9cbiAgICBpZiAoZWRnZSBpbiBuYW1lZEVkZ2VzKSB7XG4gICAgICAgIGVkZ2UgPSBuYW1lZEVkZ2VzW2VkZ2VdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgdW5pdCB2YWx1ZXNcbiAgICAgKi9cbiAgICBpZiAodHlwZW9mIGVkZ2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc3QgYXNOdW1iZXIgPSBwYXJzZUZsb2F0KGVkZ2UpO1xuICAgICAgICBpZiAoZWRnZS5lbmRzV2l0aChcInB4XCIpKSB7XG4gICAgICAgICAgICBkZWx0YSA9IGFzTnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVkZ2UuZW5kc1dpdGgoXCIlXCIpKSB7XG4gICAgICAgICAgICBlZGdlID0gYXNOdW1iZXIgLyAxMDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWRnZS5lbmRzV2l0aChcInZ3XCIpKSB7XG4gICAgICAgICAgICBkZWx0YSA9IChhc051bWJlciAvIDEwMCkgKiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWRnZS5lbmRzV2l0aChcInZoXCIpKSB7XG4gICAgICAgICAgICBkZWx0YSA9IChhc051bWJlciAvIDEwMCkgKiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWRnZSA9IGFzTnVtYmVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHRoZSBlZGdlIGlzIGRlZmluZWQgYXMgYSBudW1iZXIsIGhhbmRsZSBhcyBhIHByb2dyZXNzIHZhbHVlLlxuICAgICAqL1xuICAgIGlmICh0eXBlb2YgZWRnZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBkZWx0YSA9IGxlbmd0aCAqIGVkZ2U7XG4gICAgfVxuICAgIHJldHVybiBpbnNldCArIGRlbHRhO1xufVxuXG5jb25zdCBkZWZhdWx0T2Zmc2V0ID0gWzAsIDBdO1xuZnVuY3Rpb24gcmVzb2x2ZU9mZnNldChvZmZzZXQsIGNvbnRhaW5lckxlbmd0aCwgdGFyZ2V0TGVuZ3RoLCB0YXJnZXRJbnNldCkge1xuICAgIGxldCBvZmZzZXREZWZpbml0aW9uID0gQXJyYXkuaXNBcnJheShvZmZzZXQpID8gb2Zmc2V0IDogZGVmYXVsdE9mZnNldDtcbiAgICBsZXQgdGFyZ2V0UG9pbnQgPSAwO1xuICAgIGxldCBjb250YWluZXJQb2ludCA9IDA7XG4gICAgaWYgKHR5cGVvZiBvZmZzZXQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHdlJ3JlIHByb3ZpZGVkIG9mZnNldDogWzAsIDAuNSwgMV0gdGhlbiBlYWNoIG51bWJlciB4IHNob3VsZCBiZWNvbWVcbiAgICAgICAgICogW3gsIHhdLCBzbyB3ZSBkZWZhdWx0IHRvIHRoZSBiZWhhdmlvdXIgb2YgbWFwcGluZyAwID0+IDAgb2YgYm90aCB0YXJnZXRcbiAgICAgICAgICogYW5kIGNvbnRhaW5lciBldGMuXG4gICAgICAgICAqL1xuICAgICAgICBvZmZzZXREZWZpbml0aW9uID0gW29mZnNldCwgb2Zmc2V0XTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIG9mZnNldCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBvZmZzZXQgPSBvZmZzZXQudHJpbSgpO1xuICAgICAgICBpZiAob2Zmc2V0LmluY2x1ZGVzKFwiIFwiKSkge1xuICAgICAgICAgICAgb2Zmc2V0RGVmaW5pdGlvbiA9IG9mZnNldC5zcGxpdChcIiBcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHdlJ3JlIHByb3ZpZGVkIGEgZGVmaW5pdGlvbiBsaWtlIFwiMTAwcHhcIiB0aGVuIHdlIHdhbnQgdG8gYXBwbHlcbiAgICAgICAgICAgICAqIHRoYXQgb25seSB0byB0aGUgdG9wIG9mIHRoZSB0YXJnZXQgcG9pbnQsIGxlYXZpbmcgdGhlIGNvbnRhaW5lciBhdCAwLlxuICAgICAgICAgICAgICogV2hlcmVhcyBhIG5hbWVkIG9mZnNldCBsaWtlIFwiZW5kXCIgc2hvdWxkIGJlIGFwcGxpZWQgdG8gYm90aC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgb2Zmc2V0RGVmaW5pdGlvbiA9IFtvZmZzZXQsIG5hbWVkRWRnZXNbb2Zmc2V0XSA/IG9mZnNldCA6IGAwYF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGFyZ2V0UG9pbnQgPSByZXNvbHZlRWRnZShvZmZzZXREZWZpbml0aW9uWzBdLCB0YXJnZXRMZW5ndGgsIHRhcmdldEluc2V0KTtcbiAgICBjb250YWluZXJQb2ludCA9IHJlc29sdmVFZGdlKG9mZnNldERlZmluaXRpb25bMV0sIGNvbnRhaW5lckxlbmd0aCk7XG4gICAgcmV0dXJuIHRhcmdldFBvaW50IC0gY29udGFpbmVyUG9pbnQ7XG59XG5cbmNvbnN0IHBvaW50ID0geyB4OiAwLCB5OiAwIH07XG5mdW5jdGlvbiBnZXRUYXJnZXRTaXplKHRhcmdldCkge1xuICAgIHJldHVybiBcImdldEJCb3hcIiBpbiB0YXJnZXQgJiYgdGFyZ2V0LnRhZ05hbWUgIT09IFwic3ZnXCJcbiAgICAgICAgPyB0YXJnZXQuZ2V0QkJveCgpXG4gICAgICAgIDogeyB3aWR0aDogdGFyZ2V0LmNsaWVudFdpZHRoLCBoZWlnaHQ6IHRhcmdldC5jbGllbnRIZWlnaHQgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVPZmZzZXRzKGNvbnRhaW5lciwgaW5mbywgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgb2Zmc2V0OiBvZmZzZXREZWZpbml0aW9uID0gU2Nyb2xsT2Zmc2V0LkFsbCB9ID0gb3B0aW9ucztcbiAgICBjb25zdCB7IHRhcmdldCA9IGNvbnRhaW5lciwgYXhpcyA9IFwieVwiIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGxlbmd0aExhYmVsID0gYXhpcyA9PT0gXCJ5XCIgPyBcImhlaWdodFwiIDogXCJ3aWR0aFwiO1xuICAgIGNvbnN0IGluc2V0ID0gdGFyZ2V0ICE9PSBjb250YWluZXIgPyBjYWxjSW5zZXQodGFyZ2V0LCBjb250YWluZXIpIDogcG9pbnQ7XG4gICAgLyoqXG4gICAgICogTWVhc3VyZSB0aGUgdGFyZ2V0IGFuZCBjb250YWluZXIuIElmIHRoZXkncmUgdGhlIHNhbWUgdGhpbmcgdGhlbiB3ZVxuICAgICAqIHVzZSB0aGUgY29udGFpbmVyJ3Mgc2Nyb2xsV2lkdGgvSGVpZ2h0IGFzIHRoZSB0YXJnZXQsIGZyb20gdGhlcmVcbiAgICAgKiBhbGwgb3RoZXIgY2FsY3VsYXRpb25zIGNhbiByZW1haW4gdGhlIHNhbWUuXG4gICAgICovXG4gICAgY29uc3QgdGFyZ2V0U2l6ZSA9IHRhcmdldCA9PT0gY29udGFpbmVyXG4gICAgICAgID8geyB3aWR0aDogY29udGFpbmVyLnNjcm9sbFdpZHRoLCBoZWlnaHQ6IGNvbnRhaW5lci5zY3JvbGxIZWlnaHQgfVxuICAgICAgICA6IGdldFRhcmdldFNpemUodGFyZ2V0KTtcbiAgICBjb25zdCBjb250YWluZXJTaXplID0ge1xuICAgICAgICB3aWR0aDogY29udGFpbmVyLmNsaWVudFdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGNvbnRhaW5lci5jbGllbnRIZWlnaHQsXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGUgbGVuZ3RoIG9mIHRoZSByZXNvbHZlZCBvZmZzZXQgYXJyYXkgcmF0aGVyIHRoYW4gY3JlYXRpbmcgYSBuZXcgb25lLlxuICAgICAqIFRPRE86IE1vcmUgcmV1c2FibGUgZGF0YSBzdHJ1Y3R1cmVzIGZvciB0YXJnZXRTaXplL2NvbnRhaW5lclNpemUgd291bGQgYWxzbyBiZSBnb29kLlxuICAgICAqL1xuICAgIGluZm9bYXhpc10ub2Zmc2V0Lmxlbmd0aCA9IDA7XG4gICAgLyoqXG4gICAgICogUG9wdWxhdGUgdGhlIG9mZnNldCBhcnJheSBieSByZXNvbHZpbmcgdGhlIHVzZXIncyBvZmZzZXQgZGVmaW5pdGlvbiBpbnRvXG4gICAgICogYSBsaXN0IG9mIHBpeGVsIHNjcm9sbCBvZmZldHMuXG4gICAgICovXG4gICAgbGV0IGhhc0NoYW5nZWQgPSAhaW5mb1theGlzXS5pbnRlcnBvbGF0ZTtcbiAgICBjb25zdCBudW1PZmZzZXRzID0gb2Zmc2V0RGVmaW5pdGlvbi5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1PZmZzZXRzOyBpKyspIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gcmVzb2x2ZU9mZnNldChvZmZzZXREZWZpbml0aW9uW2ldLCBjb250YWluZXJTaXplW2xlbmd0aExhYmVsXSwgdGFyZ2V0U2l6ZVtsZW5ndGhMYWJlbF0sIGluc2V0W2F4aXNdKTtcbiAgICAgICAgaWYgKCFoYXNDaGFuZ2VkICYmIG9mZnNldCAhPT0gaW5mb1theGlzXS5pbnRlcnBvbGF0b3JPZmZzZXRzW2ldKSB7XG4gICAgICAgICAgICBoYXNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpbmZvW2F4aXNdLm9mZnNldFtpXSA9IG9mZnNldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgdGhlIHBpeGVsIHNjcm9sbCBvZmZzZXRzIGhhdmUgY2hhbmdlZCwgY3JlYXRlIGEgbmV3IGludGVycG9sYXRvciBmdW5jdGlvblxuICAgICAqIHRvIG1hcCBzY3JvbGwgdmFsdWUgaW50byBhIHByb2dyZXNzLlxuICAgICAqL1xuICAgIGlmIChoYXNDaGFuZ2VkKSB7XG4gICAgICAgIGluZm9bYXhpc10uaW50ZXJwb2xhdGUgPSBpbnRlcnBvbGF0ZShpbmZvW2F4aXNdLm9mZnNldCwgZGVmYXVsdE9mZnNldCQxKG9mZnNldERlZmluaXRpb24pKTtcbiAgICAgICAgaW5mb1theGlzXS5pbnRlcnBvbGF0b3JPZmZzZXRzID0gWy4uLmluZm9bYXhpc10ub2Zmc2V0XTtcbiAgICB9XG4gICAgaW5mb1theGlzXS5wcm9ncmVzcyA9IGluZm9bYXhpc10uaW50ZXJwb2xhdGUoaW5mb1theGlzXS5jdXJyZW50KTtcbn1cblxuZnVuY3Rpb24gbWVhc3VyZShjb250YWluZXIsIHRhcmdldCA9IGNvbnRhaW5lciwgaW5mbykge1xuICAgIC8qKlxuICAgICAqIEZpbmQgaW5zZXQgb2YgdGFyZ2V0IHdpdGhpbiBzY3JvbGxhYmxlIGNvbnRhaW5lclxuICAgICAqL1xuICAgIGluZm8ueC50YXJnZXRPZmZzZXQgPSAwO1xuICAgIGluZm8ueS50YXJnZXRPZmZzZXQgPSAwO1xuICAgIGlmICh0YXJnZXQgIT09IGNvbnRhaW5lcikge1xuICAgICAgICBsZXQgbm9kZSA9IHRhcmdldDtcbiAgICAgICAgd2hpbGUgKG5vZGUgJiYgbm9kZSAhPT0gY29udGFpbmVyKSB7XG4gICAgICAgICAgICBpbmZvLngudGFyZ2V0T2Zmc2V0ICs9IG5vZGUub2Zmc2V0TGVmdDtcbiAgICAgICAgICAgIGluZm8ueS50YXJnZXRPZmZzZXQgKz0gbm9kZS5vZmZzZXRUb3A7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5vZmZzZXRQYXJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5mby54LnRhcmdldExlbmd0aCA9XG4gICAgICAgIHRhcmdldCA9PT0gY29udGFpbmVyID8gdGFyZ2V0LnNjcm9sbFdpZHRoIDogdGFyZ2V0LmNsaWVudFdpZHRoO1xuICAgIGluZm8ueS50YXJnZXRMZW5ndGggPVxuICAgICAgICB0YXJnZXQgPT09IGNvbnRhaW5lciA/IHRhcmdldC5zY3JvbGxIZWlnaHQgOiB0YXJnZXQuY2xpZW50SGVpZ2h0O1xuICAgIGluZm8ueC5jb250YWluZXJMZW5ndGggPSBjb250YWluZXIuY2xpZW50V2lkdGg7XG4gICAgaW5mby55LmNvbnRhaW5lckxlbmd0aCA9IGNvbnRhaW5lci5jbGllbnRIZWlnaHQ7XG4gICAgLyoqXG4gICAgICogSW4gZGV2ZWxvcG1lbnQgbW9kZSBlbnN1cmUgc2Nyb2xsIGNvbnRhaW5lcnMgYXJlbid0IHBvc2l0aW9uOiBzdGF0aWMgYXMgdGhpcyBtYWtlc1xuICAgICAqIGl0IGRpZmZpY3VsdCB0byBtZWFzdXJlIHRoZWlyIHJlbGF0aXZlIHBvc2l0aW9ucy5cbiAgICAgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGlmIChjb250YWluZXIgJiYgdGFyZ2V0ICYmIHRhcmdldCAhPT0gY29udGFpbmVyKSB7XG4gICAgICAgICAgICB3YXJuT25jZShnZXRDb21wdXRlZFN0eWxlKGNvbnRhaW5lcikucG9zaXRpb24gIT09IFwic3RhdGljXCIsIFwiUGxlYXNlIGVuc3VyZSB0aGF0IHRoZSBjb250YWluZXIgaGFzIGEgbm9uLXN0YXRpYyBwb3NpdGlvbiwgbGlrZSAncmVsYXRpdmUnLCAnZml4ZWQnLCBvciAnYWJzb2x1dGUnIHRvIGVuc3VyZSBzY3JvbGwgb2Zmc2V0IGlzIGNhbGN1bGF0ZWQgY29ycmVjdGx5LlwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZU9uU2Nyb2xsSGFuZGxlcihlbGVtZW50LCBvblNjcm9sbCwgaW5mbywgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWVhc3VyZTogKCkgPT4gbWVhc3VyZShlbGVtZW50LCBvcHRpb25zLnRhcmdldCwgaW5mbyksXG4gICAgICAgIHVwZGF0ZTogKHRpbWUpID0+IHtcbiAgICAgICAgICAgIHVwZGF0ZVNjcm9sbEluZm8oZWxlbWVudCwgaW5mbywgdGltZSk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vZmZzZXQgfHwgb3B0aW9ucy50YXJnZXQpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlT2Zmc2V0cyhlbGVtZW50LCBpbmZvLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbm90aWZ5OiAoKSA9PiBvblNjcm9sbChpbmZvKSxcbiAgICB9O1xufVxuXG5jb25zdCBzY3JvbGxMaXN0ZW5lcnMgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgcmVzaXplTGlzdGVuZXJzID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IG9uU2Nyb2xsSGFuZGxlcnMgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgZ2V0RXZlbnRUYXJnZXQgPSAoZWxlbWVudCkgPT4gZWxlbWVudCA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ID8gd2luZG93IDogZWxlbWVudDtcbmZ1bmN0aW9uIHNjcm9sbEluZm8ob25TY3JvbGwsIHsgY29udGFpbmVyID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCAuLi5vcHRpb25zIH0gPSB7fSkge1xuICAgIGxldCBjb250YWluZXJIYW5kbGVycyA9IG9uU2Nyb2xsSGFuZGxlcnMuZ2V0KGNvbnRhaW5lcik7XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBvblNjcm9sbCBoYW5kbGVycyBmb3IgdGhpcyBjb250YWluZXIuXG4gICAgICogSWYgb25lIGlzbid0IGZvdW5kLCBjcmVhdGUgYSBuZXcgb25lLlxuICAgICAqL1xuICAgIGlmICghY29udGFpbmVySGFuZGxlcnMpIHtcbiAgICAgICAgY29udGFpbmVySGFuZGxlcnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIG9uU2Nyb2xsSGFuZGxlcnMuc2V0KGNvbnRhaW5lciwgY29udGFpbmVySGFuZGxlcnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgb25TY3JvbGwgaGFuZGxlciBmb3IgdGhlIHByb3ZpZGVkIGNhbGxiYWNrLlxuICAgICAqL1xuICAgIGNvbnN0IGluZm8gPSBjcmVhdGVTY3JvbGxJbmZvKCk7XG4gICAgY29uc3QgY29udGFpbmVySGFuZGxlciA9IGNyZWF0ZU9uU2Nyb2xsSGFuZGxlcihjb250YWluZXIsIG9uU2Nyb2xsLCBpbmZvLCBvcHRpb25zKTtcbiAgICBjb250YWluZXJIYW5kbGVycy5hZGQoY29udGFpbmVySGFuZGxlcik7XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlcmUncyBhIHNjcm9sbCBldmVudCBsaXN0ZW5lciBmb3IgdGhpcyBjb250YWluZXIuXG4gICAgICogSWYgbm90LCBjcmVhdGUgb25lLlxuICAgICAqL1xuICAgIGlmICghc2Nyb2xsTGlzdGVuZXJzLmhhcyhjb250YWluZXIpKSB7XG4gICAgICAgIGNvbnN0IG1lYXN1cmVBbGwgPSAoKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGhhbmRsZXIgb2YgY29udGFpbmVySGFuZGxlcnMpXG4gICAgICAgICAgICAgICAgaGFuZGxlci5tZWFzdXJlKCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHVwZGF0ZUFsbCA9ICgpID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaGFuZGxlciBvZiBjb250YWluZXJIYW5kbGVycykge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIudXBkYXRlKGZyYW1lRGF0YS50aW1lc3RhbXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBub3RpZnlBbGwgPSAoKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGhhbmRsZXIgb2YgY29udGFpbmVySGFuZGxlcnMpXG4gICAgICAgICAgICAgICAgaGFuZGxlci5ub3RpZnkoKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICBmcmFtZS5yZWFkKG1lYXN1cmVBbGwsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIGZyYW1lLnJlYWQodXBkYXRlQWxsLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICBmcmFtZS51cGRhdGUobm90aWZ5QWxsLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIHNjcm9sbExpc3RlbmVycy5zZXQoY29udGFpbmVyLCBsaXN0ZW5lcik7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGNvbnRhaW5lcik7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGxpc3RlbmVyLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgIGlmIChjb250YWluZXIgIT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgICAgICAgcmVzaXplTGlzdGVuZXJzLnNldChjb250YWluZXIsIHJlc2l6ZShjb250YWluZXIsIGxpc3RlbmVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgbGlzdGVuZXIsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICB9XG4gICAgY29uc3QgbGlzdGVuZXIgPSBzY3JvbGxMaXN0ZW5lcnMuZ2V0KGNvbnRhaW5lcik7XG4gICAgZnJhbWUucmVhZChsaXN0ZW5lciwgZmFsc2UsIHRydWUpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY2FuY2VsRnJhbWUobGlzdGVuZXIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2sgaWYgd2UgZXZlbiBoYXZlIGFueSBoYW5kbGVycyBmb3IgdGhpcyBjb250YWluZXIuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBjdXJyZW50SGFuZGxlcnMgPSBvblNjcm9sbEhhbmRsZXJzLmdldChjb250YWluZXIpO1xuICAgICAgICBpZiAoIWN1cnJlbnRIYW5kbGVycylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY3VycmVudEhhbmRsZXJzLmRlbGV0ZShjb250YWluZXJIYW5kbGVyKTtcbiAgICAgICAgaWYgKGN1cnJlbnRIYW5kbGVycy5zaXplKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgbm8gbW9yZSBoYW5kbGVycywgcmVtb3ZlIHRoZSBzY3JvbGwgbGlzdGVuZXIgdG9vLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3Qgc2Nyb2xsTGlzdGVuZXIgPSBzY3JvbGxMaXN0ZW5lcnMuZ2V0KGNvbnRhaW5lcik7XG4gICAgICAgIHNjcm9sbExpc3RlbmVycy5kZWxldGUoY29udGFpbmVyKTtcbiAgICAgICAgaWYgKHNjcm9sbExpc3RlbmVyKSB7XG4gICAgICAgICAgICBnZXRFdmVudFRhcmdldChjb250YWluZXIpLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgc2Nyb2xsTGlzdGVuZXIpO1xuICAgICAgICAgICAgKF9hID0gcmVzaXplTGlzdGVuZXJzLmdldChjb250YWluZXIpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EoKTtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHNjcm9sbExpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIG9ic2VydmVUaW1lbGluZSh1cGRhdGUsIHRpbWVsaW5lKSB7XG4gICAgbGV0IHByZXZQcm9ncmVzcztcbiAgICBjb25zdCBvbkZyYW1lID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB7IGN1cnJlbnRUaW1lIH0gPSB0aW1lbGluZTtcbiAgICAgICAgY29uc3QgcGVyY2VudGFnZSA9IGN1cnJlbnRUaW1lID09PSBudWxsID8gMCA6IGN1cnJlbnRUaW1lLnZhbHVlO1xuICAgICAgICBjb25zdCBwcm9ncmVzcyA9IHBlcmNlbnRhZ2UgLyAxMDA7XG4gICAgICAgIGlmIChwcmV2UHJvZ3Jlc3MgIT09IHByb2dyZXNzKSB7XG4gICAgICAgICAgICB1cGRhdGUocHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICAgIHByZXZQcm9ncmVzcyA9IHByb2dyZXNzO1xuICAgIH07XG4gICAgZnJhbWUudXBkYXRlKG9uRnJhbWUsIHRydWUpO1xuICAgIHJldHVybiAoKSA9PiBjYW5jZWxGcmFtZShvbkZyYW1lKTtcbn1cblxuZnVuY3Rpb24gc2Nyb2xsVGltZWxpbmVGYWxsYmFjayh7IHNvdXJjZSwgY29udGFpbmVyLCBheGlzID0gXCJ5XCIsIH0pIHtcbiAgICAvLyBTdXBwb3J0IGxlZ2FjeSBzb3VyY2UgYXJndW1lbnQuIERlcHJlY2F0ZSBsYXRlci5cbiAgICBpZiAoc291cmNlKVxuICAgICAgICBjb250YWluZXIgPSBzb3VyY2U7XG4gICAgLy8gU2Nyb2xsVGltZWxpbmUgcmVjb3JkcyBwcm9ncmVzcyBhcyBhIHBlcmNlbnRhZ2UgQ1NTVW5pdFZhbHVlXG4gICAgY29uc3QgY3VycmVudFRpbWUgPSB7IHZhbHVlOiAwIH07XG4gICAgY29uc3QgY2FuY2VsID0gc2Nyb2xsSW5mbygoaW5mbykgPT4ge1xuICAgICAgICBjdXJyZW50VGltZS52YWx1ZSA9IGluZm9bYXhpc10ucHJvZ3Jlc3MgKiAxMDA7XG4gICAgfSwgeyBjb250YWluZXIsIGF4aXMgfSk7XG4gICAgcmV0dXJuIHsgY3VycmVudFRpbWUsIGNhbmNlbCB9O1xufVxuY29uc3QgdGltZWxpbmVDYWNoZSA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIGdldFRpbWVsaW5lKHsgc291cmNlLCBjb250YWluZXIgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIGF4aXMgPSBcInlcIiwgfSA9IHt9KSB7XG4gICAgLy8gU3VwcG9ydCBsZWdhY3kgc291cmNlIGFyZ3VtZW50LiBEZXByZWNhdGUgbGF0ZXIuXG4gICAgaWYgKHNvdXJjZSlcbiAgICAgICAgY29udGFpbmVyID0gc291cmNlO1xuICAgIGlmICghdGltZWxpbmVDYWNoZS5oYXMoY29udGFpbmVyKSkge1xuICAgICAgICB0aW1lbGluZUNhY2hlLnNldChjb250YWluZXIsIHt9KTtcbiAgICB9XG4gICAgY29uc3QgZWxlbWVudENhY2hlID0gdGltZWxpbmVDYWNoZS5nZXQoY29udGFpbmVyKTtcbiAgICBpZiAoIWVsZW1lbnRDYWNoZVtheGlzXSkge1xuICAgICAgICBlbGVtZW50Q2FjaGVbYXhpc10gPSBzdXBwb3J0c1Njcm9sbFRpbWVsaW5lKClcbiAgICAgICAgICAgID8gbmV3IFNjcm9sbFRpbWVsaW5lKHsgc291cmNlOiBjb250YWluZXIsIGF4aXMgfSlcbiAgICAgICAgICAgIDogc2Nyb2xsVGltZWxpbmVGYWxsYmFjayh7IHNvdXJjZTogY29udGFpbmVyLCBheGlzIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudENhY2hlW2F4aXNdO1xufVxuLyoqXG4gKiBJZiB0aGUgb25TY3JvbGwgZnVuY3Rpb24gaGFzIHR3byBhcmd1bWVudHMsIGl0J3MgZXhwZWN0aW5nXG4gKiBtb3JlIHNwZWNpZmljIGluZm9ybWF0aW9uIGFib3V0IHRoZSBzY3JvbGwgZnJvbSBzY3JvbGxJbmZvLlxuICovXG5mdW5jdGlvbiBpc09uU2Nyb2xsV2l0aEluZm8ob25TY3JvbGwpIHtcbiAgICByZXR1cm4gb25TY3JvbGwubGVuZ3RoID09PSAyO1xufVxuLyoqXG4gKiBDdXJyZW50bHksIHdlIG9ubHkgc3VwcG9ydCBlbGVtZW50IHRyYWNraW5nIHdpdGggYHNjcm9sbEluZm9gLCB0aG91Z2ggaW5cbiAqIHRoZSBmdXR1cmUgd2UgY2FuIGFsc28gb2ZmZXIgVmlld1RpbWVsaW5lIHN1cHBvcnQuXG4gKi9cbmZ1bmN0aW9uIG5lZWRzRWxlbWVudFRyYWNraW5nKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucyAmJiAob3B0aW9ucy50YXJnZXQgfHwgb3B0aW9ucy5vZmZzZXQpO1xufVxuZnVuY3Rpb24gc2Nyb2xsRnVuY3Rpb24ob25TY3JvbGwsIG9wdGlvbnMpIHtcbiAgICBpZiAoaXNPblNjcm9sbFdpdGhJbmZvKG9uU2Nyb2xsKSB8fCBuZWVkc0VsZW1lbnRUcmFja2luZyhvcHRpb25zKSkge1xuICAgICAgICByZXR1cm4gc2Nyb2xsSW5mbygoaW5mbykgPT4ge1xuICAgICAgICAgICAgb25TY3JvbGwoaW5mb1tvcHRpb25zLmF4aXNdLnByb2dyZXNzLCBpbmZvKTtcbiAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gb2JzZXJ2ZVRpbWVsaW5lKG9uU2Nyb2xsLCBnZXRUaW1lbGluZShvcHRpb25zKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2Nyb2xsQW5pbWF0aW9uKGFuaW1hdGlvbiwgb3B0aW9ucykge1xuICAgIGFuaW1hdGlvbi5mbGF0dGVuKCk7XG4gICAgaWYgKG5lZWRzRWxlbWVudFRyYWNraW5nKG9wdGlvbnMpKSB7XG4gICAgICAgIGFuaW1hdGlvbi5wYXVzZSgpO1xuICAgICAgICByZXR1cm4gc2Nyb2xsSW5mbygoaW5mbykgPT4ge1xuICAgICAgICAgICAgYW5pbWF0aW9uLnRpbWUgPSBhbmltYXRpb24uZHVyYXRpb24gKiBpbmZvW29wdGlvbnMuYXhpc10ucHJvZ3Jlc3M7XG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgdGltZWxpbmUgPSBnZXRUaW1lbGluZShvcHRpb25zKTtcbiAgICAgICAgaWYgKGFuaW1hdGlvbi5hdHRhY2hUaW1lbGluZSkge1xuICAgICAgICAgICAgcmV0dXJuIGFuaW1hdGlvbi5hdHRhY2hUaW1lbGluZSh0aW1lbGluZSwgKHZhbHVlQW5pbWF0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFsdWVBbmltYXRpb24ucGF1c2UoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JzZXJ2ZVRpbWVsaW5lKChwcm9ncmVzcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZUFuaW1hdGlvbi50aW1lID0gdmFsdWVBbmltYXRpb24uZHVyYXRpb24gKiBwcm9ncmVzcztcbiAgICAgICAgICAgICAgICB9LCB0aW1lbGluZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBtb3Rpb25VdGlscy5ub29wO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gc2Nyb2xsKG9uU2Nyb2xsLCB7IGF4aXMgPSBcInlcIiwgLi4ub3B0aW9ucyB9ID0ge30pIHtcbiAgICBjb25zdCBvcHRpb25zV2l0aERlZmF1bHRzID0geyBheGlzLCAuLi5vcHRpb25zIH07XG4gICAgcmV0dXJuIHR5cGVvZiBvblNjcm9sbCA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgID8gc2Nyb2xsRnVuY3Rpb24ob25TY3JvbGwsIG9wdGlvbnNXaXRoRGVmYXVsdHMpXG4gICAgICAgIDogc2Nyb2xsQW5pbWF0aW9uKG9uU2Nyb2xsLCBvcHRpb25zV2l0aERlZmF1bHRzKTtcbn1cblxuY29uc3QgdGhyZXNob2xkcyA9IHtcbiAgICBzb21lOiAwLFxuICAgIGFsbDogMSxcbn07XG5mdW5jdGlvbiBpblZpZXcoZWxlbWVudE9yU2VsZWN0b3IsIG9uU3RhcnQsIHsgcm9vdCwgbWFyZ2luOiByb290TWFyZ2luLCBhbW91bnQgPSBcInNvbWVcIiB9ID0ge30pIHtcbiAgICBjb25zdCBlbGVtZW50cyA9IG1vdGlvbkRvbS5yZXNvbHZlRWxlbWVudHMoZWxlbWVudE9yU2VsZWN0b3IpO1xuICAgIGNvbnN0IGFjdGl2ZUludGVyc2VjdGlvbnMgPSBuZXcgV2Vha01hcCgpO1xuICAgIGNvbnN0IG9uSW50ZXJzZWN0aW9uQ2hhbmdlID0gKGVudHJpZXMpID0+IHtcbiAgICAgICAgZW50cmllcy5mb3JFYWNoKChlbnRyeSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb25FbmQgPSBhY3RpdmVJbnRlcnNlY3Rpb25zLmdldChlbnRyeS50YXJnZXQpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB0aGVyZSdzIG5vIGNoYW5nZSB0byB0aGUgaW50ZXJzZWN0aW9uLCB3ZSBkb24ndCBuZWVkIHRvXG4gICAgICAgICAgICAgKiBkbyBhbnl0aGluZyBoZXJlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoZW50cnkuaXNJbnRlcnNlY3RpbmcgPT09IEJvb2xlYW4ob25FbmQpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChlbnRyeS5pc0ludGVyc2VjdGluZykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld09uRW5kID0gb25TdGFydChlbnRyeSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBuZXdPbkVuZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZUludGVyc2VjdGlvbnMuc2V0KGVudHJ5LnRhcmdldCwgbmV3T25FbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIudW5vYnNlcnZlKGVudHJ5LnRhcmdldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob25FbmQpIHtcbiAgICAgICAgICAgICAgICBvbkVuZChlbnRyeSk7XG4gICAgICAgICAgICAgICAgYWN0aXZlSW50ZXJzZWN0aW9ucy5kZWxldGUoZW50cnkudGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihvbkludGVyc2VjdGlvbkNoYW5nZSwge1xuICAgICAgICByb290LFxuICAgICAgICByb290TWFyZ2luLFxuICAgICAgICB0aHJlc2hvbGQ6IHR5cGVvZiBhbW91bnQgPT09IFwibnVtYmVyXCIgPyBhbW91bnQgOiB0aHJlc2hvbGRzW2Ftb3VudF0sXG4gICAgfSk7XG4gICAgZWxlbWVudHMuZm9yRWFjaCgoZWxlbWVudCkgPT4gb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50KSk7XG4gICAgcmV0dXJuICgpID0+IG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbn1cblxuZnVuY3Rpb24gc3RlcHMobnVtU3RlcHMsIGRpcmVjdGlvbiA9IFwiZW5kXCIpIHtcbiAgICByZXR1cm4gKHByb2dyZXNzKSA9PiB7XG4gICAgICAgIHByb2dyZXNzID1cbiAgICAgICAgICAgIGRpcmVjdGlvbiA9PT0gXCJlbmRcIlxuICAgICAgICAgICAgICAgID8gTWF0aC5taW4ocHJvZ3Jlc3MsIDAuOTk5KVxuICAgICAgICAgICAgICAgIDogTWF0aC5tYXgocHJvZ3Jlc3MsIDAuMDAxKTtcbiAgICAgICAgY29uc3QgZXhwYW5kZWQgPSBwcm9ncmVzcyAqIG51bVN0ZXBzO1xuICAgICAgICBjb25zdCByb3VuZGVkID0gZGlyZWN0aW9uID09PSBcImVuZFwiID8gTWF0aC5mbG9vcihleHBhbmRlZCkgOiBNYXRoLmNlaWwoZXhwYW5kZWQpO1xuICAgICAgICByZXR1cm4gY2xhbXAoMCwgMSwgcm91bmRlZCAvIG51bVN0ZXBzKTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBnZXRPcmlnaW5JbmRleChmcm9tLCB0b3RhbCkge1xuICAgIGlmIChmcm9tID09PSBcImZpcnN0XCIpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBsYXN0SW5kZXggPSB0b3RhbCAtIDE7XG4gICAgICAgIHJldHVybiBmcm9tID09PSBcImxhc3RcIiA/IGxhc3RJbmRleCA6IGxhc3RJbmRleCAvIDI7XG4gICAgfVxufVxuZnVuY3Rpb24gc3RhZ2dlcihkdXJhdGlvbiA9IDAuMSwgeyBzdGFydERlbGF5ID0gMCwgZnJvbSA9IDAsIGVhc2UgfSA9IHt9KSB7XG4gICAgcmV0dXJuIChpLCB0b3RhbCkgPT4ge1xuICAgICAgICBjb25zdCBmcm9tSW5kZXggPSB0eXBlb2YgZnJvbSA9PT0gXCJudW1iZXJcIiA/IGZyb20gOiBnZXRPcmlnaW5JbmRleChmcm9tLCB0b3RhbCk7XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5hYnMoZnJvbUluZGV4IC0gaSk7XG4gICAgICAgIGxldCBkZWxheSA9IGR1cmF0aW9uICogZGlzdGFuY2U7XG4gICAgICAgIGlmIChlYXNlKSB7XG4gICAgICAgICAgICBjb25zdCBtYXhEZWxheSA9IHRvdGFsICogZHVyYXRpb247XG4gICAgICAgICAgICBjb25zdCBlYXNpbmdGdW5jdGlvbiA9IGVhc2luZ0RlZmluaXRpb25Ub0Z1bmN0aW9uKGVhc2UpO1xuICAgICAgICAgICAgZGVsYXkgPSBlYXNpbmdGdW5jdGlvbihkZWxheSAvIG1heERlbGF5KSAqIG1heERlbGF5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGFydERlbGF5ICsgZGVsYXk7XG4gICAgfTtcbn1cblxuY29uc3QgaXNDdXN0b21WYWx1ZVR5cGUgPSAodikgPT4ge1xuICAgIHJldHVybiB2ICYmIHR5cGVvZiB2ID09PSBcIm9iamVjdFwiICYmIHYubWl4O1xufTtcbmNvbnN0IGdldE1peGVyID0gKHYpID0+IChpc0N1c3RvbVZhbHVlVHlwZSh2KSA/IHYubWl4IDogdW5kZWZpbmVkKTtcbmZ1bmN0aW9uIHRyYW5zZm9ybSguLi5hcmdzKSB7XG4gICAgY29uc3QgdXNlSW1tZWRpYXRlID0gIUFycmF5LmlzQXJyYXkoYXJnc1swXSk7XG4gICAgY29uc3QgYXJnT2Zmc2V0ID0gdXNlSW1tZWRpYXRlID8gMCA6IC0xO1xuICAgIGNvbnN0IGlucHV0VmFsdWUgPSBhcmdzWzAgKyBhcmdPZmZzZXRdO1xuICAgIGNvbnN0IGlucHV0UmFuZ2UgPSBhcmdzWzEgKyBhcmdPZmZzZXRdO1xuICAgIGNvbnN0IG91dHB1dFJhbmdlID0gYXJnc1syICsgYXJnT2Zmc2V0XTtcbiAgICBjb25zdCBvcHRpb25zID0gYXJnc1szICsgYXJnT2Zmc2V0XTtcbiAgICBjb25zdCBpbnRlcnBvbGF0b3IgPSBpbnRlcnBvbGF0ZShpbnB1dFJhbmdlLCBvdXRwdXRSYW5nZSwge1xuICAgICAgICBtaXhlcjogZ2V0TWl4ZXIob3V0cHV0UmFuZ2VbMF0pLFxuICAgICAgICAuLi5vcHRpb25zLFxuICAgIH0pO1xuICAgIHJldHVybiB1c2VJbW1lZGlhdGUgPyBpbnRlcnBvbGF0b3IoaW5wdXRWYWx1ZSkgOiBpbnRlcnBvbGF0b3I7XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWRcbiAqXG4gKiBJbXBvcnQgYXMgYGZyYW1lYCBpbnN0ZWFkLlxuICovXG5jb25zdCBzeW5jID0gZnJhbWU7XG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKlxuICogVXNlIGNhbmNlbEZyYW1lKGNhbGxiYWNrKSBpbnN0ZWFkLlxuICovXG5jb25zdCBjYW5jZWxTeW5jID0gc3RlcHNPcmRlci5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgYWNjW2tleV0gPSAocHJvY2VzcykgPT4gY2FuY2VsRnJhbWUocHJvY2Vzcyk7XG4gICAgcmV0dXJuIGFjYztcbn0sIHt9KTtcblxuY29uc3QgeyBzY2hlZHVsZTogbWljcm90YXNrLCBjYW5jZWw6IGNhbmNlbE1pY3JvdGFzayB9ID0gY3JlYXRlUmVuZGVyQmF0Y2hlcihxdWV1ZU1pY3JvdGFzaywgZmFsc2UpO1xuXG5jb25zdCBtZXRyaWNzID0ge1xuICAgIHR5cGU6IFwicHJvamVjdGlvbkZyYW1lXCIsXG4gICAgdG90YWxOb2RlczogMCxcbiAgICByZXNvbHZlZFRhcmdldERlbHRhczogMCxcbiAgICByZWNhbGN1bGF0ZWRQcm9qZWN0aW9uOiAwLFxufTtcbmNvbnN0IGlzRGVidWcgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5Nb3Rpb25EZWJ1ZyAhPT0gdW5kZWZpbmVkO1xuY29uc3QgdHJhbnNmb3JtQXhlcyA9IFtcIlwiLCBcIlhcIiwgXCJZXCIsIFwiWlwiXTtcbmNvbnN0IGhpZGRlblZpc2liaWxpdHkgPSB7IHZpc2liaWxpdHk6IFwiaGlkZGVuXCIgfTtcbi8qKlxuICogV2UgdXNlIDEwMDAgYXMgdGhlIGFuaW1hdGlvbiB0YXJnZXQgYXMgMC0xMDAwIG1hcHMgYmV0dGVyIHRvIHBpeGVscyB0aGFuIDAtMVxuICogd2hpY2ggaGFzIGEgbm90aWNlYWJsZSBkaWZmZXJlbmNlIGluIHNwcmluZyBhbmltYXRpb25zXG4gKi9cbmNvbnN0IGFuaW1hdGlvblRhcmdldCA9IDEwMDA7XG5sZXQgaWQkMSA9IDA7XG5mdW5jdGlvbiByZXNldERpc3RvcnRpbmdUcmFuc2Zvcm0oa2V5LCB2aXN1YWxFbGVtZW50LCB2YWx1ZXMsIHNoYXJlZEFuaW1hdGlvblZhbHVlcykge1xuICAgIGNvbnN0IHsgbGF0ZXN0VmFsdWVzIH0gPSB2aXN1YWxFbGVtZW50O1xuICAgIC8vIFJlY29yZCB0aGUgZGlzdG9ydGluZyB0cmFuc2Zvcm0gYW5kIHRoZW4gdGVtcG9yYXJpbHkgc2V0IGl0IHRvIDBcbiAgICBpZiAobGF0ZXN0VmFsdWVzW2tleV0pIHtcbiAgICAgICAgdmFsdWVzW2tleV0gPSBsYXRlc3RWYWx1ZXNba2V5XTtcbiAgICAgICAgdmlzdWFsRWxlbWVudC5zZXRTdGF0aWNWYWx1ZShrZXksIDApO1xuICAgICAgICBpZiAoc2hhcmVkQW5pbWF0aW9uVmFsdWVzKSB7XG4gICAgICAgICAgICBzaGFyZWRBbmltYXRpb25WYWx1ZXNba2V5XSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjYW5jZWxUcmVlT3B0aW1pc2VkVHJhbnNmb3JtQW5pbWF0aW9ucyhwcm9qZWN0aW9uTm9kZSkge1xuICAgIHByb2plY3Rpb25Ob2RlLmhhc0NoZWNrZWRPcHRpbWlzZWRBcHBlYXIgPSB0cnVlO1xuICAgIGlmIChwcm9qZWN0aW9uTm9kZS5yb290ID09PSBwcm9qZWN0aW9uTm9kZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgdmlzdWFsRWxlbWVudCB9ID0gcHJvamVjdGlvbk5vZGUub3B0aW9ucztcbiAgICBpZiAoIXZpc3VhbEVsZW1lbnQpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBhcHBlYXJJZCA9IGdldE9wdGltaXNlZEFwcGVhcklkKHZpc3VhbEVsZW1lbnQpO1xuICAgIGlmICh3aW5kb3cuTW90aW9uSGFzT3B0aW1pc2VkQW5pbWF0aW9uKGFwcGVhcklkLCBcInRyYW5zZm9ybVwiKSkge1xuICAgICAgICBjb25zdCB7IGxheW91dCwgbGF5b3V0SWQgfSA9IHByb2plY3Rpb25Ob2RlLm9wdGlvbnM7XG4gICAgICAgIHdpbmRvdy5Nb3Rpb25DYW5jZWxPcHRpbWlzZWRBbmltYXRpb24oYXBwZWFySWQsIFwidHJhbnNmb3JtXCIsIGZyYW1lLCAhKGxheW91dCB8fCBsYXlvdXRJZCkpO1xuICAgIH1cbiAgICBjb25zdCB7IHBhcmVudCB9ID0gcHJvamVjdGlvbk5vZGU7XG4gICAgaWYgKHBhcmVudCAmJiAhcGFyZW50Lmhhc0NoZWNrZWRPcHRpbWlzZWRBcHBlYXIpIHtcbiAgICAgICAgY2FuY2VsVHJlZU9wdGltaXNlZFRyYW5zZm9ybUFuaW1hdGlvbnMocGFyZW50KTtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVQcm9qZWN0aW9uTm9kZSQxKHsgYXR0YWNoUmVzaXplTGlzdGVuZXIsIGRlZmF1bHRQYXJlbnQsIG1lYXN1cmVTY3JvbGwsIGNoZWNrSXNTY3JvbGxSb290LCByZXNldFRyYW5zZm9ybSwgfSkge1xuICAgIHJldHVybiBjbGFzcyBQcm9qZWN0aW9uTm9kZSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGxhdGVzdFZhbHVlcyA9IHt9LCBwYXJlbnQgPSBkZWZhdWx0UGFyZW50ID09PSBudWxsIHx8IGRlZmF1bHRQYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRlZmF1bHRQYXJlbnQoKSkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBIHVuaXF1ZSBJRCBnZW5lcmF0ZWQgZm9yIGV2ZXJ5IHByb2plY3Rpb24gbm9kZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5pZCA9IGlkJDErKztcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQW4gaWQgdGhhdCByZXByZXNlbnRzIGEgdW5pcXVlIHNlc3Npb24gaW5zdGlnYXRlZCBieSBzdGFydFVwZGF0ZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25JZCA9IDA7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEEgU2V0IGNvbnRhaW5pbmcgYWxsIHRoaXMgY29tcG9uZW50J3MgY2hpbGRyZW4uIFRoaXMgaXMgdXNlZCB0byBpdGVyYXRlXG4gICAgICAgICAgICAgKiB0aHJvdWdoIHRoZSBjaGlsZHJlbi5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBUT0RPOiBUaGlzIGNvdWxkIGJlIGZhc3RlciB0byBpdGVyYXRlIGFzIGEgZmxhdCBhcnJheSBzdG9yZWQgb24gdGhlIHJvb3Qgbm9kZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbiA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogT3B0aW9ucyBmb3IgdGhlIG5vZGUuIFdlIHVzZSB0aGlzIHRvIGNvbmZpZ3VyZSB3aGF0IGtpbmQgb2YgbGF5b3V0IGFuaW1hdGlvbnNcbiAgICAgICAgICAgICAqIHdlIHNob3VsZCBwZXJmb3JtIChpZiBhbnkpLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2UgdXNlIHRoaXMgdG8gZGV0ZWN0IHdoZW4gaXRzIHNhZmUgdG8gc2h1dCBkb3duIHBhcnQgb2YgYSBwcm9qZWN0aW9uIHRyZWUuXG4gICAgICAgICAgICAgKiBXZSBoYXZlIHRvIGtlZXAgcHJvamVjdGluZyBjaGlsZHJlbiBmb3Igc2NhbGUgY29ycmVjdGlvbiBhbmQgcmVsYXRpdmUgcHJvamVjdGlvblxuICAgICAgICAgICAgICogdW50aWwgYWxsIHRoZWlyIHBhcmVudHMgc3RvcCBwZXJmb3JtaW5nIGxheW91dCBhbmltYXRpb25zLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmlzVHJlZUFuaW1hdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5pc0FuaW1hdGlvbkJsb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRmxhZyB0byB0cnVlIGlmIHdlIHRoaW5rIHRoaXMgbGF5b3V0IGhhcyBiZWVuIGNoYW5nZWQuIFdlIGNhbid0IGFsd2F5cyBrbm93IHRoaXMsXG4gICAgICAgICAgICAgKiBjdXJyZW50bHkgd2Ugc2V0IGl0IHRvIHRydWUgZXZlcnkgdGltZSBhIGNvbXBvbmVudCByZW5kZXJzLCBvciBpZiBpdCBoYXMgYSBsYXlvdXREZXBlbmRlbmN5XG4gICAgICAgICAgICAgKiBpZiB0aGF0IGhhcyBjaGFuZ2VkIGJldHdlZW4gcmVuZGVycy4gQWRkaXRpb25hbGx5LCBjb21wb25lbnRzIGNhbiBiZSBncm91cGVkIGJ5IExheW91dEdyb3VwXG4gICAgICAgICAgICAgKiBhbmQgaWYgb25lIG5vZGUgaXMgZGlydGllZCwgdGhleSBhbGwgYXJlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmlzTGF5b3V0RGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRmxhZyB0byB0cnVlIGlmIHdlIHRoaW5rIHRoZSBwcm9qZWN0aW9uIGNhbGN1bGF0aW9ucyBmb3IgdGhpcyBub2RlIG5lZWRzXG4gICAgICAgICAgICAgKiByZWNhbGN1bGF0aW5nIGFzIGEgcmVzdWx0IG9mIGFuIHVwZGF0ZWQgdHJhbnNmb3JtIG9yIGxheW91dCBhbmltYXRpb24uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuaXNQcm9qZWN0aW9uRGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRmxhZyB0byB0cnVlIGlmIHRoZSBsYXlvdXQgKm9yKiB0cmFuc2Zvcm0gaGFzIGNoYW5nZWQuIFRoaXMgdGhlbiBnZXRzIHByb3BhZ2F0ZWRcbiAgICAgICAgICAgICAqIHRocm91Z2hvdXQgdGhlIHByb2plY3Rpb24gdHJlZSwgZm9yY2luZyBhbnkgZWxlbWVudCBiZWxvdyB0byByZWNhbGN1bGF0ZSBvbiB0aGUgbmV4dCBmcmFtZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5pc1NoYXJlZFByb2plY3Rpb25EaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBGbGFnIHRyYW5zZm9ybSBkaXJ0eS4gVGhpcyBnZXRzIHByb3BhZ2F0ZWQgdGhyb3VnaG91dCB0aGUgd2hvbGUgdHJlZSBidXQgaXMgb25seVxuICAgICAgICAgICAgICogcmVzcGVjdGVkIGJ5IHNoYXJlZCBub2Rlcy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5pc1RyYW5zZm9ybURpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEJsb2NrIGxheW91dCB1cGRhdGVzIGZvciBpbnN0YW50IGxheW91dCB0cmFuc2l0aW9ucyB0aHJvdWdob3V0IHRoZSB0cmVlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU1hbnVhbGx5QmxvY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVCbG9ja2VkQnlSZXNpemUgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2V0IHRvIHRydWUgYmV0d2VlbiB0aGUgc3RhcnQgb2YgdGhlIGZpcnN0IGB3aWxsVXBkYXRlYCBjYWxsIGFuZCB0aGUgZW5kIG9mIHRoZSBgZGlkVXBkYXRlYFxuICAgICAgICAgICAgICogY2FsbC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5pc1VwZGF0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHRoaXMgaXMgYW4gU1ZHIGVsZW1lbnQgd2UgY3VycmVudGx5IGRpc2FibGUgcHJvamVjdGlvbiB0cmFuc2Zvcm1zXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuaXNTVkcgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRmxhZyB0byB0cnVlIChkdXJpbmcgcHJvbW90aW9uKSBpZiBhIG5vZGUgZG9pbmcgYW4gaW5zdGFudCBsYXlvdXQgdHJhbnNpdGlvbiBuZWVkcyB0byByZXNldFxuICAgICAgICAgICAgICogaXRzIHByb2plY3Rpb24gc3R5bGVzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLm5lZWRzUmVzZXQgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRmxhZ3Mgd2hldGhlciB0aGlzIG5vZGUgc2hvdWxkIGhhdmUgaXRzIHRyYW5zZm9ybSByZXNldCBwcmlvciB0byBtZWFzdXJpbmcuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuc2hvdWxkUmVzZXRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU3RvcmUgd2hldGhlciB0aGlzIG5vZGUgaGFzIGJlZW4gY2hlY2tlZCBmb3Igb3B0aW1pc2VkIGFwcGVhciBhbmltYXRpb25zLiBBc1xuICAgICAgICAgICAgICogZWZmZWN0cyBmaXJlIGJvdHRvbS11cCwgYW5kIHdlIHdhbnQgdG8gbG9vayB1cCB0aGUgdHJlZSBmb3IgYXBwZWFyIGFuaW1hdGlvbnMsXG4gICAgICAgICAgICAgKiB0aGlzIG1ha2VzIHN1cmUgd2Ugb25seSBjaGVjayBlYWNoIHBhdGggb25jZSwgc3RvcHBpbmcgYXQgbm9kZXMgdGhhdFxuICAgICAgICAgICAgICogaGF2ZSBhbHJlYWR5IGJlZW4gY2hlY2tlZC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5oYXNDaGVja2VkT3B0aW1pc2VkQXBwZWFyID0gZmFsc2U7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGNhbGN1bGF0ZWQgY29udGV4dHVhbC9hY2N1bXVsYXRlZC90cmVlIHNjYWxlLlxuICAgICAgICAgICAgICogVGhpcyB3aWxsIGJlIHVzZWQgdG8gc2NhbGUgY2FsY3VsY2F0ZWQgcHJvamVjdGlvbiB0cmFuc2Zvcm1zLCBhcyB0aGVzZSBhcmVcbiAgICAgICAgICAgICAqIGNhbGN1bGF0ZWQgaW4gc2NyZWVuLXNwYWNlIGJ1dCBuZWVkIHRvIGJlIHNjYWxlZCBmb3IgZWxlbWVudHMgdG8gbGF5b3V0bHlcbiAgICAgICAgICAgICAqIG1ha2UgaXQgdG8gdGhlaXIgY2FsY3VsYXRlZCBkZXN0aW5hdGlvbnMuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogVE9ETzogTGF6eS1pbml0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMudHJlZVNjYWxlID0geyB4OiAxLCB5OiAxIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuZXZlbnRIYW5kbGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHRoaXMuaGFzVHJlZUFuaW1hdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBOb3RlOiBDdXJyZW50bHkgb25seSBydW5uaW5nIG9uIHJvb3Qgbm9kZVxuICAgICAgICAgICAgdGhpcy51cGRhdGVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVVcGRhdGUgPSAoKSA9PiB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5wcm9qZWN0aW9uVXBkYXRlU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmNoZWNrVXBkYXRlRmFpbGVkID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzVXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc1VwZGF0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJBbGxTbmFwc2hvdHMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGlzIGlzIGEgbXVsdGktc3RlcCBwcm9jZXNzIGFzIHNoYXJlZCBub2RlcyBtaWdodCBiZSBvZiBkaWZmZXJlbnQgZGVwdGhzLiBOb2Rlc1xuICAgICAgICAgICAgICogYXJlIHNvcnRlZCBieSBkZXB0aCBvcmRlciwgc28gd2UgbmVlZCB0byByZXNvbHZlIHRoZSBlbnRpcmUgdHJlZSBiZWZvcmUgbW92aW5nIHRvXG4gICAgICAgICAgICAgKiB0aGUgbmV4dCBzdGVwLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVByb2plY3Rpb24gPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9qZWN0aW9uVXBkYXRlU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogUmVzZXQgZGVidWcgY291bnRzLiBNYW51YWxseSByZXNldHRpbmcgcmF0aGVyIHRoYW4gY3JlYXRpbmcgYSBuZXdcbiAgICAgICAgICAgICAgICAgKiBvYmplY3QgZWFjaCBmcmFtZS5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAoaXNEZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICBtZXRyaWNzLnRvdGFsTm9kZXMgPVxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0cmljcy5yZXNvbHZlZFRhcmdldERlbHRhcyA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0cmljcy5yZWNhbGN1bGF0ZWRQcm9qZWN0aW9uID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5mb3JFYWNoKHByb3BhZ2F0ZURpcnR5Tm9kZXMpO1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZXMuZm9yRWFjaChyZXNvbHZlVGFyZ2V0RGVsdGEpO1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZXMuZm9yRWFjaChjYWxjUHJvamVjdGlvbik7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5mb3JFYWNoKGNsZWFuRGlydHlOb2Rlcyk7XG4gICAgICAgICAgICAgICAgaWYgKGlzRGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93Lk1vdGlvbkRlYnVnLnJlY29yZChtZXRyaWNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBGcmFtZSBjYWxjdWxhdGlvbnNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlZFJlbGF0aXZlVGFyZ2V0QXQgPSAwLjA7XG4gICAgICAgICAgICB0aGlzLmhhc1Byb2plY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5pc1Zpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25Qcm9ncmVzcyA9IDA7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNoYXJlZCBsYXlvdXRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLy8gVE9ETyBPbmx5IHJ1bm5pbmcgb24gcm9vdCBub2RlXG4gICAgICAgICAgICB0aGlzLnNoYXJlZE5vZGVzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgdGhpcy5sYXRlc3RWYWx1ZXMgPSBsYXRlc3RWYWx1ZXM7XG4gICAgICAgICAgICB0aGlzLnJvb3QgPSBwYXJlbnQgPyBwYXJlbnQucm9vdCB8fCBwYXJlbnQgOiB0aGlzO1xuICAgICAgICAgICAgdGhpcy5wYXRoID0gcGFyZW50ID8gWy4uLnBhcmVudC5wYXRoLCBwYXJlbnRdIDogW107XG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICAgIHRoaXMuZGVwdGggPSBwYXJlbnQgPyBwYXJlbnQuZGVwdGggKyAxIDogMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXRoW2ldLnNob3VsZFJlc2V0VHJhbnNmb3JtID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnJvb3QgPT09IHRoaXMpXG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlcyA9IG5ldyBGbGF0VHJlZSgpO1xuICAgICAgICB9XG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlcikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmV2ZW50SGFuZGxlcnMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzLnNldChuYW1lLCBuZXcgU3Vic2NyaXB0aW9uTWFuYWdlcigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV2ZW50SGFuZGxlcnMuZ2V0KG5hbWUpLmFkZChoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBub3RpZnlMaXN0ZW5lcnMobmFtZSwgLi4uYXJncykge1xuICAgICAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uTWFuYWdlciA9IHRoaXMuZXZlbnRIYW5kbGVycy5nZXQobmFtZSk7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb25NYW5hZ2VyICYmIHN1YnNjcmlwdGlvbk1hbmFnZXIubm90aWZ5KC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGhhc0xpc3RlbmVycyhuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ldmVudEhhbmRsZXJzLmhhcyhuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogTGlmZWN5Y2xlc1xuICAgICAgICAgKi9cbiAgICAgICAgbW91bnQoaW5zdGFuY2UsIGlzTGF5b3V0RGlydHkgPSB0aGlzLnJvb3QuaGFzVHJlZUFuaW1hdGVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbnN0YW5jZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLmlzU1ZHID0gaXNTVkdFbGVtZW50KGluc3RhbmNlKTtcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICAgICAgICAgIGNvbnN0IHsgbGF5b3V0SWQsIGxheW91dCwgdmlzdWFsRWxlbWVudCB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAgICAgaWYgKHZpc3VhbEVsZW1lbnQgJiYgIXZpc3VhbEVsZW1lbnQuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIHZpc3VhbEVsZW1lbnQubW91bnQoaW5zdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yb290Lm5vZGVzLmFkZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LmNoaWxkcmVuLmFkZCh0aGlzKTtcbiAgICAgICAgICAgIGlmIChpc0xheW91dERpcnR5ICYmIChsYXlvdXQgfHwgbGF5b3V0SWQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0xheW91dERpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhdHRhY2hSZXNpemVMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIGxldCBjYW5jZWxEZWxheTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNpemVVbmJsb2NrVXBkYXRlID0gKCkgPT4gKHRoaXMucm9vdC51cGRhdGVCbG9ja2VkQnlSZXNpemUgPSBmYWxzZSk7XG4gICAgICAgICAgICAgICAgYXR0YWNoUmVzaXplTGlzdGVuZXIoaW5zdGFuY2UsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb290LnVwZGF0ZUJsb2NrZWRCeVJlc2l6ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbERlbGF5ICYmIGNhbmNlbERlbGF5KCk7XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbERlbGF5ID0gZGVsYXkocmVzaXplVW5ibG9ja1VwZGF0ZSwgMjUwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdsb2JhbFByb2plY3Rpb25TdGF0ZS5oYXNBbmltYXRlZFNpbmNlUmVzaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnbG9iYWxQcm9qZWN0aW9uU3RhdGUuaGFzQW5pbWF0ZWRTaW5jZVJlc2l6ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5mb3JFYWNoKGZpbmlzaEFuaW1hdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXlvdXRJZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucm9vdC5yZWdpc3RlclNoYXJlZE5vZGUobGF5b3V0SWQsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT25seSByZWdpc3RlciB0aGUgaGFuZGxlciBpZiBpdCByZXF1aXJlcyBsYXlvdXQgYW5pbWF0aW9uXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFuaW1hdGUgIT09IGZhbHNlICYmXG4gICAgICAgICAgICAgICAgdmlzdWFsRWxlbWVudCAmJlxuICAgICAgICAgICAgICAgIChsYXlvdXRJZCB8fCBsYXlvdXQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKFwiZGlkVXBkYXRlXCIsICh7IGRlbHRhLCBoYXNMYXlvdXRDaGFuZ2VkLCBoYXNSZWxhdGl2ZVRhcmdldENoYW5nZWQsIGxheW91dDogbmV3TGF5b3V0LCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzVHJlZUFuaW1hdGlvbkJsb2NrZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50YXJnZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aXZlVGFyZ2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IENoZWNrIGhlcmUgaWYgYW4gYW5pbWF0aW9uIGV4aXN0c1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXlvdXRUcmFuc2l0aW9uID0gdGhpcy5vcHRpb25zLnRyYW5zaXRpb24gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc3VhbEVsZW1lbnQuZ2V0RGVmYXVsdFRyYW5zaXRpb24oKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdExheW91dFRyYW5zaXRpb247XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgb25MYXlvdXRBbmltYXRpb25TdGFydCwgb25MYXlvdXRBbmltYXRpb25Db21wbGV0ZSwgfSA9IHZpc3VhbEVsZW1lbnQuZ2V0UHJvcHMoKTtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIFRoZSB0YXJnZXQgbGF5b3V0IG9mIHRoZSBlbGVtZW50IG1pZ2h0IHN0YXkgdGhlIHNhbWUsXG4gICAgICAgICAgICAgICAgICAgICAqIGJ1dCBpdHMgcG9zaXRpb24gcmVsYXRpdmUgdG8gaXRzIHBhcmVudCBoYXMgY2hhbmdlZC5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldENoYW5nZWQgPSAhdGhpcy50YXJnZXRMYXlvdXQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICFib3hFcXVhbHNSb3VuZGVkKHRoaXMudGFyZ2V0TGF5b3V0LCBuZXdMYXlvdXQpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNSZWxhdGl2ZVRhcmdldENoYW5nZWQ7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBJZiB0aGUgbGF5b3V0IGhhc24ndCBzZWVtZWQgdG8gaGF2ZSBjaGFuZ2VkLCBpdCBtaWdodCBiZSB0aGF0IHRoZVxuICAgICAgICAgICAgICAgICAgICAgKiBlbGVtZW50IGlzIHZpc3VhbGx5IGluIHRoZSBzYW1lIHBsYWNlIGluIHRoZSBkb2N1bWVudCBidXQgaXRzIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAqIHJlbGF0aXZlIHRvIGl0cyBwYXJlbnQgaGFzIGluZGVlZCBjaGFuZ2VkLiBTbyBoZXJlIHdlIGNoZWNrIGZvciB0aGF0LlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFzT25seVJlbGF0aXZlVGFyZ2V0Q2hhbmdlZCA9ICFoYXNMYXlvdXRDaGFuZ2VkICYmIGhhc1JlbGF0aXZlVGFyZ2V0Q2hhbmdlZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5sYXlvdXRSb290IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5yZXN1bWVGcm9tICYmIHRoaXMucmVzdW1lRnJvbS5pbnN0YW5jZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc09ubHlSZWxhdGl2ZVRhcmdldENoYW5nZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChoYXNMYXlvdXRDaGFuZ2VkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRhcmdldENoYW5nZWQgfHwgIXRoaXMuY3VycmVudEFuaW1hdGlvbikpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXN1bWVGcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN1bWluZ0Zyb20gPSB0aGlzLnJlc3VtZUZyb207XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN1bWluZ0Zyb20ucmVzdW1pbmdGcm9tID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRBbmltYXRpb25PcmlnaW4oZGVsdGEsIGhhc09ubHlSZWxhdGl2ZVRhcmdldENoYW5nZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYW5pbWF0aW9uT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5nZXRWYWx1ZVRyYW5zaXRpb24kMShsYXlvdXRUcmFuc2l0aW9uLCBcImxheW91dFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblBsYXk6IG9uTGF5b3V0QW5pbWF0aW9uU3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25Db21wbGV0ZTogb25MYXlvdXRBbmltYXRpb25Db21wbGV0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmlzdWFsRWxlbWVudC5zaG91bGRSZWR1Y2VNb3Rpb24gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMubGF5b3V0Um9vdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbk9wdGlvbnMuZGVsYXkgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbk9wdGlvbnMudHlwZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydEFuaW1hdGlvbihhbmltYXRpb25PcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogSWYgdGhlIGxheW91dCBoYXNuJ3QgY2hhbmdlZCBhbmQgd2UgaGF2ZSBhbiBhbmltYXRpb24gdGhhdCBoYXNuJ3Qgc3RhcnRlZCB5ZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBmaW5pc2ggaXQgaW1tZWRpYXRlbHkuIE90aGVyd2lzZSBpdCB3aWxsIGJlIGFuaW1hdGluZyBmcm9tIGEgbG9jYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAqIHRoYXQgd2FzIHByb2JhYmx5IG5ldmVyIGNvbW1pdGVkIHRvIHNjcmVlbiBhbmQgbG9vayBsaWtlIGEganVtcHkgYm94LlxuICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWhhc0xheW91dENoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hBbmltYXRpb24odGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0xlYWQoKSAmJiB0aGlzLm9wdGlvbnMub25FeGl0Q29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMub25FeGl0Q29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhcmdldExheW91dCA9IG5ld0xheW91dDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB1bm1vdW50KCkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmxheW91dElkICYmIHRoaXMud2lsbFVwZGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5yb290Lm5vZGVzLnJlbW92ZSh0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YWNrID0gdGhpcy5nZXRTdGFjaygpO1xuICAgICAgICAgICAgc3RhY2sgJiYgc3RhY2sucmVtb3ZlKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuY2hpbGRyZW4uZGVsZXRlKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNhbmNlbEZyYW1lKHRoaXMudXBkYXRlUHJvamVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb25seSBvbiB0aGUgcm9vdFxuICAgICAgICBibG9ja1VwZGF0ZSgpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTWFudWFsbHlCbG9ja2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB1bmJsb2NrVXBkYXRlKCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVNYW51YWxseUJsb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpc1VwZGF0ZUJsb2NrZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVNYW51YWxseUJsb2NrZWQgfHwgdGhpcy51cGRhdGVCbG9ja2VkQnlSZXNpemU7XG4gICAgICAgIH1cbiAgICAgICAgaXNUcmVlQW5pbWF0aW9uQmxvY2tlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5pc0FuaW1hdGlvbkJsb2NrZWQgfHxcbiAgICAgICAgICAgICAgICAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuaXNUcmVlQW5pbWF0aW9uQmxvY2tlZCgpKSB8fFxuICAgICAgICAgICAgICAgIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3RlOiBjdXJyZW50bHkgb25seSBydW5uaW5nIG9uIHJvb3Qgbm9kZVxuICAgICAgICBzdGFydFVwZGF0ZSgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVXBkYXRlQmxvY2tlZCgpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuaXNVcGRhdGluZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm5vZGVzICYmIHRoaXMubm9kZXMuZm9yRWFjaChyZXNldFNrZXdBbmRSb3RhdGlvbik7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbklkKys7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0VHJhbnNmb3JtVGVtcGxhdGUoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHZpc3VhbEVsZW1lbnQgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgICAgIHJldHVybiB2aXN1YWxFbGVtZW50ICYmIHZpc3VhbEVsZW1lbnQuZ2V0UHJvcHMoKS50cmFuc2Zvcm1UZW1wbGF0ZTtcbiAgICAgICAgfVxuICAgICAgICB3aWxsVXBkYXRlKHNob3VsZE5vdGlmeUxpc3RlbmVycyA9IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMucm9vdC5oYXNUcmVlQW5pbWF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMucm9vdC5pc1VwZGF0ZUJsb2NrZWQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5vbkV4aXRDb21wbGV0ZSAmJiB0aGlzLm9wdGlvbnMub25FeGl0Q29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHdlJ3JlIHJ1bm5pbmcgb3B0aW1pc2VkIGFwcGVhciBhbmltYXRpb25zIHRoZW4gdGhlc2UgbXVzdCBiZVxuICAgICAgICAgICAgICogY2FuY2VsbGVkIGJlZm9yZSBtZWFzdXJpbmcgdGhlIERPTS4gVGhpcyBpcyBzbyB3ZSBjYW4gbWVhc3VyZVxuICAgICAgICAgICAgICogdGhlIHRydWUgbGF5b3V0IG9mIHRoZSBlbGVtZW50IHJhdGhlciB0aGFuIHRoZSBXQUFQSSBhbmltYXRpb25cbiAgICAgICAgICAgICAqIHdoaWNoIHdpbGwgYmUgdW5hZmZlY3RlZCBieSB0aGUgcmVzZXRTa2V3QW5kUm90YXRlIHN0ZXAuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogTm90ZTogVGhpcyBpcyBhIERPTSB3cml0ZS4gV29yc3QgY2FzZSBzY2VuYXJpbyBpcyB0aGlzIGlzIHNhbmR3aWNoZWRcbiAgICAgICAgICAgICAqIGJldHdlZW4gb3RoZXIgc25hcHNob3QgcmVhZHMgd2hpY2ggd2lsbCBjYXVzZSB1bm5lY2Vzc2FyeSBzdHlsZSByZWNhbGN1bGF0aW9ucy5cbiAgICAgICAgICAgICAqIFRoaXMgaGFzIHRvIGhhcHBlbiBoZXJlIHRob3VnaCwgYXMgd2UgZG9uJ3QgeWV0IGtub3cgd2hpY2ggbm9kZXMgd2lsbCBuZWVkXG4gICAgICAgICAgICAgKiBzbmFwc2hvdHMgaW4gc3RhcnRVcGRhdGUoKSwgYnV0IHdlIG9ubHkgd2FudCB0byBjYW5jZWwgb3B0aW1pc2VkIGFuaW1hdGlvbnNcbiAgICAgICAgICAgICAqIGlmIGEgbGF5b3V0IGFuaW1hdGlvbiBtZWFzdXJlbWVudCBpcyBhY3R1YWxseSBnb2luZyB0byBiZSBhZmZlY3RlZCBieSB0aGVtLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAod2luZG93Lk1vdGlvbkNhbmNlbE9wdGltaXNlZEFuaW1hdGlvbiAmJlxuICAgICAgICAgICAgICAgICF0aGlzLmhhc0NoZWNrZWRPcHRpbWlzZWRBcHBlYXIpIHtcbiAgICAgICAgICAgICAgICBjYW5jZWxUcmVlT3B0aW1pc2VkVHJhbnNmb3JtQW5pbWF0aW9ucyh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICF0aGlzLnJvb3QuaXNVcGRhdGluZyAmJiB0aGlzLnJvb3Quc3RhcnRVcGRhdGUoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTGF5b3V0RGlydHkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5pc0xheW91dERpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMucGF0aFtpXTtcbiAgICAgICAgICAgICAgICBub2RlLnNob3VsZFJlc2V0VHJhbnNmb3JtID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBub2RlLnVwZGF0ZVNjcm9sbChcInNuYXBzaG90XCIpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlLm9wdGlvbnMubGF5b3V0Um9vdCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLndpbGxVcGRhdGUoZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgbGF5b3V0SWQsIGxheW91dCB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAgICAgaWYgKGxheW91dElkID09PSB1bmRlZmluZWQgJiYgIWxheW91dClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1UZW1wbGF0ZSA9IHRoaXMuZ2V0VHJhbnNmb3JtVGVtcGxhdGUoKTtcbiAgICAgICAgICAgIHRoaXMucHJldlRyYW5zZm9ybVRlbXBsYXRlVmFsdWUgPSB0cmFuc2Zvcm1UZW1wbGF0ZVxuICAgICAgICAgICAgICAgID8gdHJhbnNmb3JtVGVtcGxhdGUodGhpcy5sYXRlc3RWYWx1ZXMsIFwiXCIpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNuYXBzaG90KCk7XG4gICAgICAgICAgICBzaG91bGROb3RpZnlMaXN0ZW5lcnMgJiYgdGhpcy5ub3RpZnlMaXN0ZW5lcnMoXCJ3aWxsVXBkYXRlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVXYXNCbG9ja2VkID0gdGhpcy5pc1VwZGF0ZUJsb2NrZWQoKTtcbiAgICAgICAgICAgIC8vIFdoZW4gZG9pbmcgYW4gaW5zdGFudCB0cmFuc2l0aW9uLCB3ZSBza2lwIHRoZSBsYXlvdXQgdXBkYXRlLFxuICAgICAgICAgICAgLy8gYnV0IHNob3VsZCBzdGlsbCBjbGVhbiB1cCB0aGUgbWVhc3VyZW1lbnRzIHNvIHRoYXQgdGhlIG5leHRcbiAgICAgICAgICAgIC8vIHNuYXBzaG90IGNvdWxkIGJlIHRha2VuIGNvcnJlY3RseS5cbiAgICAgICAgICAgIGlmICh1cGRhdGVXYXNCbG9ja2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51bmJsb2NrVXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhckFsbFNuYXBzaG90cygpO1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZXMuZm9yRWFjaChjbGVhck1lYXN1cmVtZW50cyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzVXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLmZvckVhY2goY2xlYXJJc0xheW91dERpcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaXNVcGRhdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXcml0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLm5vZGVzLmZvckVhY2gocmVzZXRUcmFuc2Zvcm1TdHlsZSk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJlYWQgPT09PT09PT09PT09PT09PT09XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBsYXlvdXQgbWVhc3VyZW1lbnRzIG9mIHVwZGF0ZWQgY2hpbGRyZW5cbiAgICAgICAgICAgIHRoaXMubm9kZXMuZm9yRWFjaCh1cGRhdGVMYXlvdXQpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXcml0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvLyBOb3RpZnkgbGlzdGVuZXJzIHRoYXQgdGhlIGxheW91dCBpcyB1cGRhdGVkXG4gICAgICAgICAgICB0aGlzLm5vZGVzLmZvckVhY2gobm90aWZ5TGF5b3V0VXBkYXRlKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJBbGxTbmFwc2hvdHMoKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTWFudWFsbHkgZmx1c2ggYW55IHBlbmRpbmcgdXBkYXRlcy4gSWRlYWxseVxuICAgICAgICAgICAgICogd2UgY291bGQgbGVhdmUgdGhpcyB0byB0aGUgZm9sbG93aW5nIHJlcXVlc3RBbmltYXRpb25GcmFtZSBidXQgdGhpcyBzZWVtc1xuICAgICAgICAgICAgICogdG8gbGVhdmUgYSBmbGFzaCBvZiBpbmNvcnJlY3RseSBzdHlsZWQgY29udGVudC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3Qgbm93ID0gdGltZS5ub3coKTtcbiAgICAgICAgICAgIGZyYW1lRGF0YS5kZWx0YSA9IGNsYW1wKDAsIDEwMDAgLyA2MCwgbm93IC0gZnJhbWVEYXRhLnRpbWVzdGFtcCk7XG4gICAgICAgICAgICBmcmFtZURhdGEudGltZXN0YW1wID0gbm93O1xuICAgICAgICAgICAgZnJhbWVEYXRhLmlzUHJvY2Vzc2luZyA9IHRydWU7XG4gICAgICAgICAgICBmcmFtZVN0ZXBzLnVwZGF0ZS5wcm9jZXNzKGZyYW1lRGF0YSk7XG4gICAgICAgICAgICBmcmFtZVN0ZXBzLnByZVJlbmRlci5wcm9jZXNzKGZyYW1lRGF0YSk7XG4gICAgICAgICAgICBmcmFtZVN0ZXBzLnJlbmRlci5wcm9jZXNzKGZyYW1lRGF0YSk7XG4gICAgICAgICAgICBmcmFtZURhdGEuaXNQcm9jZXNzaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZGlkVXBkYXRlKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnVwZGF0ZVNjaGVkdWxlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBtaWNyb3Rhc2sucmVhZCh0aGlzLnNjaGVkdWxlVXBkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjbGVhckFsbFNuYXBzaG90cygpIHtcbiAgICAgICAgICAgIHRoaXMubm9kZXMuZm9yRWFjaChjbGVhclNuYXBzaG90KTtcbiAgICAgICAgICAgIHRoaXMuc2hhcmVkTm9kZXMuZm9yRWFjaChyZW1vdmVMZWFkU25hcHNob3RzKTtcbiAgICAgICAgfVxuICAgICAgICBzY2hlZHVsZVVwZGF0ZVByb2plY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucHJvamVjdGlvblVwZGF0ZVNjaGVkdWxlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvamVjdGlvblVwZGF0ZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZnJhbWUucHJlUmVuZGVyKHRoaXMudXBkYXRlUHJvamVjdGlvbiwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNjaGVkdWxlQ2hlY2tBZnRlclVubW91bnQoKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHRoZSB1bm1vdW50aW5nIG5vZGUgaXMgaW4gYSBsYXlvdXRHcm91cCBhbmQgZGlkIHRyaWdnZXIgYSB3aWxsVXBkYXRlLFxuICAgICAgICAgICAgICogd2UgbWFudWFsbHkgY2FsbCBkaWRVcGRhdGUgdG8gZ2l2ZSBhIGNoYW5jZSB0byB0aGUgc2libGluZ3MgdG8gYW5pbWF0ZS5cbiAgICAgICAgICAgICAqIE90aGVyd2lzZSwgY2xlYW51cCBhbGwgc25hcHNob3RzIHRvIHByZXZlbnRzIGZ1dHVyZSBub2RlcyBmcm9tIHJldXNpbmcgdGhlbS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnJhbWUucG9zdFJlbmRlcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNMYXlvdXREaXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvb3QuZGlkVXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvb3QuY2hlY2tVcGRhdGVGYWlsZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlIG1lYXN1cmVtZW50c1xuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlU25hcHNob3QoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zbmFwc2hvdCB8fCAhdGhpcy5pbnN0YW5jZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLnNuYXBzaG90ID0gdGhpcy5tZWFzdXJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlTGF5b3V0KCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmluc3RhbmNlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIFRPRE86IEluY29ycG9yYXRlIGludG8gYSBmb3J3YXJkZWQgc2Nyb2xsIG9mZnNldFxuICAgICAgICAgICAgdGhpcy51cGRhdGVTY3JvbGwoKTtcbiAgICAgICAgICAgIGlmICghKHRoaXMub3B0aW9ucy5hbHdheXNNZWFzdXJlTGF5b3V0ICYmIHRoaXMuaXNMZWFkKCkpICYmXG4gICAgICAgICAgICAgICAgIXRoaXMuaXNMYXlvdXREaXJ0eSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2hlbiBhIG5vZGUgaXMgbW91bnRlZCwgaXQgc2ltcGx5IHJlc3VtZXMgZnJvbSB0aGUgcHJldkxlYWQnc1xuICAgICAgICAgICAgICogc25hcHNob3QgaW5zdGVhZCBvZiB0YWtpbmcgYSBuZXcgb25lLCBidXQgdGhlIGFuY2VzdG9ycyBzY3JvbGxcbiAgICAgICAgICAgICAqIG1pZ2h0IGhhdmUgdXBkYXRlZCB3aGlsZSB0aGUgcHJldkxlYWQgaXMgdW5tb3VudGVkLiBXZSBuZWVkIHRvXG4gICAgICAgICAgICAgKiB1cGRhdGUgdGhlIHNjcm9sbCBhZ2FpbiB0byBtYWtlIHN1cmUgdGhlIGxheW91dCB3ZSBtZWFzdXJlIGlzXG4gICAgICAgICAgICAgKiB1cCB0byBkYXRlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAodGhpcy5yZXN1bWVGcm9tICYmICF0aGlzLnJlc3VtZUZyb20uaW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5wYXRoW2ldO1xuICAgICAgICAgICAgICAgICAgICBub2RlLnVwZGF0ZVNjcm9sbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHByZXZMYXlvdXQgPSB0aGlzLmxheW91dDtcbiAgICAgICAgICAgIHRoaXMubGF5b3V0ID0gdGhpcy5tZWFzdXJlKGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMubGF5b3V0Q29ycmVjdGVkID0gY3JlYXRlQm94KCk7XG4gICAgICAgICAgICB0aGlzLmlzTGF5b3V0RGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMucHJvamVjdGlvbkRlbHRhID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5ub3RpZnlMaXN0ZW5lcnMoXCJtZWFzdXJlXCIsIHRoaXMubGF5b3V0LmxheW91dEJveCk7XG4gICAgICAgICAgICBjb25zdCB7IHZpc3VhbEVsZW1lbnQgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgICAgIHZpc3VhbEVsZW1lbnQgJiZcbiAgICAgICAgICAgICAgICB2aXN1YWxFbGVtZW50Lm5vdGlmeShcIkxheW91dE1lYXN1cmVcIiwgdGhpcy5sYXlvdXQubGF5b3V0Qm94LCBwcmV2TGF5b3V0ID8gcHJldkxheW91dC5sYXlvdXRCb3ggOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZVNjcm9sbChwaGFzZSA9IFwibWVhc3VyZVwiKSB7XG4gICAgICAgICAgICBsZXQgbmVlZHNNZWFzdXJlbWVudCA9IEJvb2xlYW4odGhpcy5vcHRpb25zLmxheW91dFNjcm9sbCAmJiB0aGlzLmluc3RhbmNlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnNjcm9sbCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsLmFuaW1hdGlvbklkID09PSB0aGlzLnJvb3QuYW5pbWF0aW9uSWQgJiZcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbC5waGFzZSA9PT0gcGhhc2UpIHtcbiAgICAgICAgICAgICAgICBuZWVkc01lYXN1cmVtZW50ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmVlZHNNZWFzdXJlbWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzUm9vdCA9IGNoZWNrSXNTY3JvbGxSb290KHRoaXMuaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsID0ge1xuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25JZDogdGhpcy5yb290LmFuaW1hdGlvbklkLFxuICAgICAgICAgICAgICAgICAgICBwaGFzZSxcbiAgICAgICAgICAgICAgICAgICAgaXNSb290LFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IG1lYXN1cmVTY3JvbGwodGhpcy5pbnN0YW5jZSksXG4gICAgICAgICAgICAgICAgICAgIHdhc1Jvb3Q6IHRoaXMuc2Nyb2xsID8gdGhpcy5zY3JvbGwuaXNSb290IDogaXNSb290LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzZXRUcmFuc2Zvcm0oKSB7XG4gICAgICAgICAgICBpZiAoIXJlc2V0VHJhbnNmb3JtKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IGlzUmVzZXRSZXF1ZXN0ZWQgPSB0aGlzLmlzTGF5b3V0RGlydHkgfHxcbiAgICAgICAgICAgICAgICB0aGlzLnNob3VsZFJlc2V0VHJhbnNmb3JtIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmFsd2F5c01lYXN1cmVMYXlvdXQ7XG4gICAgICAgICAgICBjb25zdCBoYXNQcm9qZWN0aW9uID0gdGhpcy5wcm9qZWN0aW9uRGVsdGEgJiYgIWlzRGVsdGFaZXJvKHRoaXMucHJvamVjdGlvbkRlbHRhKTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybVRlbXBsYXRlID0gdGhpcy5nZXRUcmFuc2Zvcm1UZW1wbGF0ZSgpO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtVGVtcGxhdGVWYWx1ZSA9IHRyYW5zZm9ybVRlbXBsYXRlXG4gICAgICAgICAgICAgICAgPyB0cmFuc2Zvcm1UZW1wbGF0ZSh0aGlzLmxhdGVzdFZhbHVlcywgXCJcIilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybVRlbXBsYXRlSGFzQ2hhbmdlZCA9IHRyYW5zZm9ybVRlbXBsYXRlVmFsdWUgIT09IHRoaXMucHJldlRyYW5zZm9ybVRlbXBsYXRlVmFsdWU7XG4gICAgICAgICAgICBpZiAoaXNSZXNldFJlcXVlc3RlZCAmJlxuICAgICAgICAgICAgICAgIChoYXNQcm9qZWN0aW9uIHx8XG4gICAgICAgICAgICAgICAgICAgIGhhc1RyYW5zZm9ybSh0aGlzLmxhdGVzdFZhbHVlcykgfHxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtVGVtcGxhdGVIYXNDaGFuZ2VkKSkge1xuICAgICAgICAgICAgICAgIHJlc2V0VHJhbnNmb3JtKHRoaXMuaW5zdGFuY2UsIHRyYW5zZm9ybVRlbXBsYXRlVmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2hvdWxkUmVzZXRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnNjaGVkdWxlUmVuZGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWVhc3VyZShyZW1vdmVUcmFuc2Zvcm0gPSB0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCBwYWdlQm94ID0gdGhpcy5tZWFzdXJlUGFnZUJveCgpO1xuICAgICAgICAgICAgbGV0IGxheW91dEJveCA9IHRoaXMucmVtb3ZlRWxlbWVudFNjcm9sbChwYWdlQm94KTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTWVhc3VyZW1lbnRzIHRha2VuIGR1cmluZyB0aGUgcHJlLXJlbmRlciBzdGFnZVxuICAgICAgICAgICAgICogc3RpbGwgaGF2ZSB0cmFuc2Zvcm1zIGFwcGxpZWQgc28gd2UgcmVtb3ZlIHRoZW1cbiAgICAgICAgICAgICAqIHZpYSBjYWxjdWxhdGlvbi5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHJlbW92ZVRyYW5zZm9ybSkge1xuICAgICAgICAgICAgICAgIGxheW91dEJveCA9IHRoaXMucmVtb3ZlVHJhbnNmb3JtKGxheW91dEJveCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb3VuZEJveChsYXlvdXRCb3gpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhbmltYXRpb25JZDogdGhpcy5yb290LmFuaW1hdGlvbklkLFxuICAgICAgICAgICAgICAgIG1lYXN1cmVkQm94OiBwYWdlQm94LFxuICAgICAgICAgICAgICAgIGxheW91dEJveCxcbiAgICAgICAgICAgICAgICBsYXRlc3RWYWx1ZXM6IHt9LFxuICAgICAgICAgICAgICAgIHNvdXJjZTogdGhpcy5pZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbWVhc3VyZVBhZ2VCb3goKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCB7IHZpc3VhbEVsZW1lbnQgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgICAgIGlmICghdmlzdWFsRWxlbWVudClcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQm94KCk7XG4gICAgICAgICAgICBjb25zdCBib3ggPSB2aXN1YWxFbGVtZW50Lm1lYXN1cmVWaWV3cG9ydEJveCgpO1xuICAgICAgICAgICAgY29uc3Qgd2FzSW5TY3JvbGxSb290ID0gKChfYSA9IHRoaXMuc2Nyb2xsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eud2FzUm9vdCkgfHwgdGhpcy5wYXRoLnNvbWUoY2hlY2tOb2RlV2FzU2Nyb2xsUm9vdCk7XG4gICAgICAgICAgICBpZiAoIXdhc0luU2Nyb2xsUm9vdCkge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB2aWV3cG9ydCBzY3JvbGwgdG8gZ2l2ZSBwYWdlLXJlbGF0aXZlIGNvb3JkaW5hdGVzXG4gICAgICAgICAgICAgICAgY29uc3QgeyBzY3JvbGwgfSA9IHRoaXMucm9vdDtcbiAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZUF4aXMoYm94LngsIHNjcm9sbC5vZmZzZXQueCk7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZUF4aXMoYm94LnksIHNjcm9sbC5vZmZzZXQueSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJveDtcbiAgICAgICAgfVxuICAgICAgICByZW1vdmVFbGVtZW50U2Nyb2xsKGJveCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgY29uc3QgYm94V2l0aG91dFNjcm9sbCA9IGNyZWF0ZUJveCgpO1xuICAgICAgICAgICAgY29weUJveEludG8oYm94V2l0aG91dFNjcm9sbCwgYm94KTtcbiAgICAgICAgICAgIGlmICgoX2EgPSB0aGlzLnNjcm9sbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLndhc1Jvb3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYm94V2l0aG91dFNjcm9sbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUGVyZm9ybWFuY2UgVE9ETzogS2VlcCBhIGN1bXVsYXRpdmUgc2Nyb2xsIG9mZnNldCBkb3duIHRoZSB0cmVlXG4gICAgICAgICAgICAgKiByYXRoZXIgdGhhbiBsb29wIGJhY2sgdXAgdGhlIHBhdGguXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMucGF0aFtpXTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHNjcm9sbCwgb3B0aW9ucyB9ID0gbm9kZTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSAhPT0gdGhpcy5yb290ICYmIHNjcm9sbCAmJiBvcHRpb25zLmxheW91dFNjcm9sbCkge1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogSWYgdGhpcyBpcyBhIG5ldyBzY3JvbGwgcm9vdCwgd2Ugd2FudCB0byByZW1vdmUgYWxsIHByZXZpb3VzIHNjcm9sbHNcbiAgICAgICAgICAgICAgICAgICAgICogZnJvbSB0aGUgdmlld3BvcnQgYm94LlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjcm9sbC53YXNSb290KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3B5Qm94SW50byhib3hXaXRob3V0U2Nyb2xsLCBib3gpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZUF4aXMoYm94V2l0aG91dFNjcm9sbC54LCBzY3JvbGwub2Zmc2V0LngpO1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVBeGlzKGJveFdpdGhvdXRTY3JvbGwueSwgc2Nyb2xsLm9mZnNldC55KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYm94V2l0aG91dFNjcm9sbDtcbiAgICAgICAgfVxuICAgICAgICBhcHBseVRyYW5zZm9ybShib3gsIHRyYW5zZm9ybU9ubHkgPSBmYWxzZSkge1xuICAgICAgICAgICAgY29uc3Qgd2l0aFRyYW5zZm9ybXMgPSBjcmVhdGVCb3goKTtcbiAgICAgICAgICAgIGNvcHlCb3hJbnRvKHdpdGhUcmFuc2Zvcm1zLCBib3gpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5wYXRoW2ldO1xuICAgICAgICAgICAgICAgIGlmICghdHJhbnNmb3JtT25seSAmJlxuICAgICAgICAgICAgICAgICAgICBub2RlLm9wdGlvbnMubGF5b3V0U2Nyb2xsICYmXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuc2Nyb2xsICYmXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgIT09IG5vZGUucm9vdCkge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1Cb3god2l0aFRyYW5zZm9ybXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IC1ub2RlLnNjcm9sbC5vZmZzZXQueCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IC1ub2RlLnNjcm9sbC5vZmZzZXQueSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghaGFzVHJhbnNmb3JtKG5vZGUubGF0ZXN0VmFsdWVzKSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtQm94KHdpdGhUcmFuc2Zvcm1zLCBub2RlLmxhdGVzdFZhbHVlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzVHJhbnNmb3JtKHRoaXMubGF0ZXN0VmFsdWVzKSkge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybUJveCh3aXRoVHJhbnNmb3JtcywgdGhpcy5sYXRlc3RWYWx1ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHdpdGhUcmFuc2Zvcm1zO1xuICAgICAgICB9XG4gICAgICAgIHJlbW92ZVRyYW5zZm9ybShib3gpIHtcbiAgICAgICAgICAgIGNvbnN0IGJveFdpdGhvdXRUcmFuc2Zvcm0gPSBjcmVhdGVCb3goKTtcbiAgICAgICAgICAgIGNvcHlCb3hJbnRvKGJveFdpdGhvdXRUcmFuc2Zvcm0sIGJveCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnBhdGhbaV07XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlLmluc3RhbmNlKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc1RyYW5zZm9ybShub2RlLmxhdGVzdFZhbHVlcykpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGhhc1NjYWxlKG5vZGUubGF0ZXN0VmFsdWVzKSAmJiBub2RlLnVwZGF0ZVNuYXBzaG90KCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc291cmNlQm94ID0gY3JlYXRlQm94KCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZUJveCA9IG5vZGUubWVhc3VyZVBhZ2VCb3goKTtcbiAgICAgICAgICAgICAgICBjb3B5Qm94SW50byhzb3VyY2VCb3gsIG5vZGVCb3gpO1xuICAgICAgICAgICAgICAgIHJlbW92ZUJveFRyYW5zZm9ybXMoYm94V2l0aG91dFRyYW5zZm9ybSwgbm9kZS5sYXRlc3RWYWx1ZXMsIG5vZGUuc25hcHNob3QgPyBub2RlLnNuYXBzaG90LmxheW91dEJveCA6IHVuZGVmaW5lZCwgc291cmNlQm94KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNUcmFuc2Zvcm0odGhpcy5sYXRlc3RWYWx1ZXMpKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlQm94VHJhbnNmb3Jtcyhib3hXaXRob3V0VHJhbnNmb3JtLCB0aGlzLmxhdGVzdFZhbHVlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYm94V2l0aG91dFRyYW5zZm9ybTtcbiAgICAgICAgfVxuICAgICAgICBzZXRUYXJnZXREZWx0YShkZWx0YSkge1xuICAgICAgICAgICAgdGhpcy50YXJnZXREZWx0YSA9IGRlbHRhO1xuICAgICAgICAgICAgdGhpcy5yb290LnNjaGVkdWxlVXBkYXRlUHJvamVjdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5pc1Byb2plY3Rpb25EaXJ0eSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgY3Jvc3NmYWRlOiBvcHRpb25zLmNyb3NzZmFkZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jcm9zc2ZhZGUgOiB0cnVlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjbGVhck1lYXN1cmVtZW50cygpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5sYXlvdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLnNuYXBzaG90ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5wcmV2VHJhbnNmb3JtVGVtcGxhdGVWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0RGVsdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLnRhcmdldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuaXNMYXlvdXREaXJ0eSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvcmNlUmVsYXRpdmVQYXJlbnRUb1Jlc29sdmVUYXJnZXQoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucmVsYXRpdmVQYXJlbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB0aGUgcGFyZW50IHRhcmdldCBpc24ndCB1cC10by1kYXRlLCBmb3JjZSBpdCB0byB1cGRhdGUuXG4gICAgICAgICAgICAgKiBUaGlzIGlzIGFuIHVuZm9ydHVuYXRlIGRlLW9wdGltaXNhdGlvbiBhcyBpdCBtZWFucyBhbnkgdXBkYXRpbmcgcmVsYXRpdmVcbiAgICAgICAgICAgICAqIHByb2plY3Rpb24gd2lsbCBjYXVzZSBhbGwgdGhlIHJlbGF0aXZlIHBhcmVudHMgdG8gcmVjYWxjdWxhdGUgYmFja1xuICAgICAgICAgICAgICogdXAgdGhlIHRyZWUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLnJlbGF0aXZlUGFyZW50LnJlc29sdmVkUmVsYXRpdmVUYXJnZXRBdCAhPT1cbiAgICAgICAgICAgICAgICBmcmFtZURhdGEudGltZXN0YW1wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWxhdGl2ZVBhcmVudC5yZXNvbHZlVGFyZ2V0RGVsdGEodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZVRhcmdldERlbHRhKGZvcmNlUmVjYWxjdWxhdGlvbiA9IGZhbHNlKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE9uY2UgdGhlIGRpcnR5IHN0YXR1cyBvZiBub2RlcyBoYXMgYmVlbiBzcHJlYWQgdGhyb3VnaCB0aGUgdHJlZSwgd2UgYWxzb1xuICAgICAgICAgICAgICogbmVlZCB0byBjaGVjayBpZiB3ZSBoYXZlIGEgc2hhcmVkIG5vZGUgb2YgYSBkaWZmZXJlbnQgZGVwdGggdGhhdCBoYXMgaXRzZWxmXG4gICAgICAgICAgICAgKiBiZWVuIGRpcnRpZWQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IGxlYWQgPSB0aGlzLmdldExlYWQoKTtcbiAgICAgICAgICAgIHRoaXMuaXNQcm9qZWN0aW9uRGlydHkgfHwgKHRoaXMuaXNQcm9qZWN0aW9uRGlydHkgPSBsZWFkLmlzUHJvamVjdGlvbkRpcnR5KTtcbiAgICAgICAgICAgIHRoaXMuaXNUcmFuc2Zvcm1EaXJ0eSB8fCAodGhpcy5pc1RyYW5zZm9ybURpcnR5ID0gbGVhZC5pc1RyYW5zZm9ybURpcnR5KTtcbiAgICAgICAgICAgIHRoaXMuaXNTaGFyZWRQcm9qZWN0aW9uRGlydHkgfHwgKHRoaXMuaXNTaGFyZWRQcm9qZWN0aW9uRGlydHkgPSBsZWFkLmlzU2hhcmVkUHJvamVjdGlvbkRpcnR5KTtcbiAgICAgICAgICAgIGNvbnN0IGlzU2hhcmVkID0gQm9vbGVhbih0aGlzLnJlc3VtaW5nRnJvbSkgfHwgdGhpcyAhPT0gbGVhZDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2UgZG9uJ3QgdXNlIHRyYW5zZm9ybSBmb3IgdGhpcyBzdGVwIG9mIHByb2Nlc3Npbmcgc28gd2UgZG9uJ3RcbiAgICAgICAgICAgICAqIG5lZWQgdG8gY2hlY2sgd2hldGhlciBhbnkgbm9kZXMgaGF2ZSBjaGFuZ2VkIHRyYW5zZm9ybS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgY2FuU2tpcCA9ICEoZm9yY2VSZWNhbGN1bGF0aW9uIHx8XG4gICAgICAgICAgICAgICAgKGlzU2hhcmVkICYmIHRoaXMuaXNTaGFyZWRQcm9qZWN0aW9uRGlydHkpIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5pc1Byb2plY3Rpb25EaXJ0eSB8fFxuICAgICAgICAgICAgICAgICgoX2EgPSB0aGlzLnBhcmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzUHJvamVjdGlvbkRpcnR5KSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuYXR0ZW1wdFRvUmVzb2x2ZVJlbGF0aXZlVGFyZ2V0IHx8XG4gICAgICAgICAgICAgICAgdGhpcy5yb290LnVwZGF0ZUJsb2NrZWRCeVJlc2l6ZSk7XG4gICAgICAgICAgICBpZiAoY2FuU2tpcClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCB7IGxheW91dCwgbGF5b3V0SWQgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgd2UgaGF2ZSBubyBsYXlvdXQsIHdlIGNhbid0IHBlcmZvcm0gcHJvamVjdGlvbiwgc28gZWFybHkgcmV0dXJuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICghdGhpcy5sYXlvdXQgfHwgIShsYXlvdXQgfHwgbGF5b3V0SWQpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZWRSZWxhdGl2ZVRhcmdldEF0ID0gZnJhbWVEYXRhLnRpbWVzdGFtcDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgd2UgZG9uJ3QgaGF2ZSBhIHRhcmdldERlbHRhIGJ1dCBkbyBoYXZlIGEgbGF5b3V0LCB3ZSBjYW4gYXR0ZW1wdCB0byByZXNvbHZlXG4gICAgICAgICAgICAgKiBhIHJlbGF0aXZlUGFyZW50LiBUaGlzIHdpbGwgYWxsb3cgYSBjb21wb25lbnQgdG8gcGVyZm9ybSBzY2FsZSBjb3JyZWN0aW9uXG4gICAgICAgICAgICAgKiBldmVuIGlmIG5vIGFuaW1hdGlvbiBoYXMgc3RhcnRlZC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKCF0aGlzLnRhcmdldERlbHRhICYmICF0aGlzLnJlbGF0aXZlVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVsYXRpdmVQYXJlbnQgPSB0aGlzLmdldENsb3Nlc3RQcm9qZWN0aW5nUGFyZW50KCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlbGF0aXZlUGFyZW50ICYmXG4gICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlUGFyZW50LmxheW91dCAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGlvblByb2dyZXNzICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVsYXRpdmVQYXJlbnQgPSByZWxhdGl2ZVBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mb3JjZVJlbGF0aXZlUGFyZW50VG9SZXNvbHZlVGFyZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVsYXRpdmVUYXJnZXQgPSBjcmVhdGVCb3goKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWxhdGl2ZVRhcmdldE9yaWdpbiA9IGNyZWF0ZUJveCgpO1xuICAgICAgICAgICAgICAgICAgICBjYWxjUmVsYXRpdmVQb3NpdGlvbih0aGlzLnJlbGF0aXZlVGFyZ2V0T3JpZ2luLCB0aGlzLmxheW91dC5sYXlvdXRCb3gsIHJlbGF0aXZlUGFyZW50LmxheW91dC5sYXlvdXRCb3gpO1xuICAgICAgICAgICAgICAgICAgICBjb3B5Qm94SW50byh0aGlzLnJlbGF0aXZlVGFyZ2V0LCB0aGlzLnJlbGF0aXZlVGFyZ2V0T3JpZ2luKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVsYXRpdmVQYXJlbnQgPSB0aGlzLnJlbGF0aXZlVGFyZ2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgd2UgaGF2ZSBubyByZWxhdGl2ZSB0YXJnZXQgb3Igbm8gdGFyZ2V0IGRlbHRhIG91ciB0YXJnZXQgaXNuJ3QgdmFsaWRcbiAgICAgICAgICAgICAqIGZvciB0aGlzIGZyYW1lLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoIXRoaXMucmVsYXRpdmVUYXJnZXQgJiYgIXRoaXMudGFyZ2V0RGVsdGEpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBMYXp5LWluaXQgdGFyZ2V0IGRhdGEgc3RydWN0dXJlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICghdGhpcy50YXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRhcmdldCA9IGNyZWF0ZUJveCgpO1xuICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0V2l0aFRyYW5zZm9ybXMgPSBjcmVhdGVCb3goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgd2UndmUgZ290IGEgcmVsYXRpdmUgYm94IGZvciB0aGlzIGNvbXBvbmVudCwgcmVzb2x2ZSBpdCBpbnRvIGEgdGFyZ2V0IHJlbGF0aXZlIHRvIHRoZSBwYXJlbnQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLnJlbGF0aXZlVGFyZ2V0ICYmXG4gICAgICAgICAgICAgICAgdGhpcy5yZWxhdGl2ZVRhcmdldE9yaWdpbiAmJlxuICAgICAgICAgICAgICAgIHRoaXMucmVsYXRpdmVQYXJlbnQgJiZcbiAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aXZlUGFyZW50LnRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9yY2VSZWxhdGl2ZVBhcmVudFRvUmVzb2x2ZVRhcmdldCgpO1xuICAgICAgICAgICAgICAgIGNhbGNSZWxhdGl2ZUJveCh0aGlzLnRhcmdldCwgdGhpcy5yZWxhdGl2ZVRhcmdldCwgdGhpcy5yZWxhdGl2ZVBhcmVudC50YXJnZXQpO1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIElmIHdlJ3ZlIG9ubHkgZ290IGEgdGFyZ2V0RGVsdGEsIHJlc29sdmUgaXQgaW50byBhIHRhcmdldFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy50YXJnZXREZWx0YSkge1xuICAgICAgICAgICAgICAgIGlmIChCb29sZWFuKHRoaXMucmVzdW1pbmdGcm9tKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBUaGlzIGlzIGNyZWF0aW5nIGEgbmV3IG9iamVjdCBldmVyeSBmcmFtZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhcmdldCA9IHRoaXMuYXBwbHlUcmFuc2Zvcm0odGhpcy5sYXlvdXQubGF5b3V0Qm94KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvcHlCb3hJbnRvKHRoaXMudGFyZ2V0LCB0aGlzLmxheW91dC5sYXlvdXRCb3gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhcHBseUJveERlbHRhKHRoaXMudGFyZ2V0LCB0aGlzLnRhcmdldERlbHRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIElmIG5vIHRhcmdldCwgdXNlIG93biBsYXlvdXQgYXMgdGFyZ2V0XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgY29weUJveEludG8odGhpcy50YXJnZXQsIHRoaXMubGF5b3V0LmxheW91dEJveCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHdlJ3ZlIGJlZW4gdG9sZCB0byBhdHRlbXB0IHRvIHJlc29sdmUgYSByZWxhdGl2ZSB0YXJnZXQsIGRvIHNvLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAodGhpcy5hdHRlbXB0VG9SZXNvbHZlUmVsYXRpdmVUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmF0dGVtcHRUb1Jlc29sdmVSZWxhdGl2ZVRhcmdldCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlbGF0aXZlUGFyZW50ID0gdGhpcy5nZXRDbG9zZXN0UHJvamVjdGluZ1BhcmVudCgpO1xuICAgICAgICAgICAgICAgIGlmIChyZWxhdGl2ZVBhcmVudCAmJlxuICAgICAgICAgICAgICAgICAgICBCb29sZWFuKHJlbGF0aXZlUGFyZW50LnJlc3VtaW5nRnJvbSkgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICBCb29sZWFuKHRoaXMucmVzdW1pbmdGcm9tKSAmJlxuICAgICAgICAgICAgICAgICAgICAhcmVsYXRpdmVQYXJlbnQub3B0aW9ucy5sYXlvdXRTY3JvbGwgJiZcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmVQYXJlbnQudGFyZ2V0ICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uUHJvZ3Jlc3MgIT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWxhdGl2ZVBhcmVudCA9IHJlbGF0aXZlUGFyZW50O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZvcmNlUmVsYXRpdmVQYXJlbnRUb1Jlc29sdmVUYXJnZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWxhdGl2ZVRhcmdldCA9IGNyZWF0ZUJveCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aXZlVGFyZ2V0T3JpZ2luID0gY3JlYXRlQm94KCk7XG4gICAgICAgICAgICAgICAgICAgIGNhbGNSZWxhdGl2ZVBvc2l0aW9uKHRoaXMucmVsYXRpdmVUYXJnZXRPcmlnaW4sIHRoaXMudGFyZ2V0LCByZWxhdGl2ZVBhcmVudC50YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICBjb3B5Qm94SW50byh0aGlzLnJlbGF0aXZlVGFyZ2V0LCB0aGlzLnJlbGF0aXZlVGFyZ2V0T3JpZ2luKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVsYXRpdmVQYXJlbnQgPSB0aGlzLnJlbGF0aXZlVGFyZ2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSW5jcmVhc2UgZGVidWcgY291bnRlciBmb3IgcmVzb2x2ZWQgdGFyZ2V0IGRlbHRhc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoaXNEZWJ1Zykge1xuICAgICAgICAgICAgICAgIG1ldHJpY3MucmVzb2x2ZWRUYXJnZXREZWx0YXMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBnZXRDbG9zZXN0UHJvamVjdGluZ1BhcmVudCgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJlbnQgfHxcbiAgICAgICAgICAgICAgICBoYXNTY2FsZSh0aGlzLnBhcmVudC5sYXRlc3RWYWx1ZXMpIHx8XG4gICAgICAgICAgICAgICAgaGFzMkRUcmFuc2xhdGUodGhpcy5wYXJlbnQubGF0ZXN0VmFsdWVzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQuaXNQcm9qZWN0aW5nKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQuZ2V0Q2xvc2VzdFByb2plY3RpbmdQYXJlbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpc1Byb2plY3RpbmcoKSB7XG4gICAgICAgICAgICByZXR1cm4gQm9vbGVhbigodGhpcy5yZWxhdGl2ZVRhcmdldCB8fFxuICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0RGVsdGEgfHxcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMubGF5b3V0Um9vdCkgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmxheW91dCk7XG4gICAgICAgIH1cbiAgICAgICAgY2FsY1Byb2plY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCBsZWFkID0gdGhpcy5nZXRMZWFkKCk7XG4gICAgICAgICAgICBjb25zdCBpc1NoYXJlZCA9IEJvb2xlYW4odGhpcy5yZXN1bWluZ0Zyb20pIHx8IHRoaXMgIT09IGxlYWQ7XG4gICAgICAgICAgICBsZXQgY2FuU2tpcCA9IHRydWU7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHRoaXMgaXMgYSBub3JtYWwgbGF5b3V0IGFuaW1hdGlvbiBhbmQgbmVpdGhlciB0aGlzIG5vZGUgbm9yIGl0cyBuZWFyZXN0IHByb2plY3RpbmdcbiAgICAgICAgICAgICAqIGlzIGRpcnR5IHRoZW4gd2UgY2FuJ3Qgc2tpcC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNQcm9qZWN0aW9uRGlydHkgfHwgKChfYSA9IHRoaXMucGFyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNQcm9qZWN0aW9uRGlydHkpKSB7XG4gICAgICAgICAgICAgICAgY2FuU2tpcCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB0aGlzIGlzIGEgc2hhcmVkIGxheW91dCBhbmltYXRpb24gYW5kIHRoaXMgbm9kZSdzIHNoYXJlZCBwcm9qZWN0aW9uIGlzIGRpcnR5IHRoZW5cbiAgICAgICAgICAgICAqIHdlIGNhbid0IHNraXAuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChpc1NoYXJlZCAmJlxuICAgICAgICAgICAgICAgICh0aGlzLmlzU2hhcmVkUHJvamVjdGlvbkRpcnR5IHx8IHRoaXMuaXNUcmFuc2Zvcm1EaXJ0eSkpIHtcbiAgICAgICAgICAgICAgICBjYW5Ta2lwID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHdlIGhhdmUgcmVzb2x2ZWQgdGhlIHRhcmdldCB0aGlzIGZyYW1lIHdlIG11c3QgcmVjYWxjdWxhdGUgdGhlXG4gICAgICAgICAgICAgKiBwcm9qZWN0aW9uIHRvIGVuc3VyZSBpdCB2aXN1YWxseSByZXByZXNlbnRzIHRoZSBpbnRlcm5hbCBjYWxjdWxhdGlvbnMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLnJlc29sdmVkUmVsYXRpdmVUYXJnZXRBdCA9PT0gZnJhbWVEYXRhLnRpbWVzdGFtcCkge1xuICAgICAgICAgICAgICAgIGNhblNraXAgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYW5Ta2lwKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IHsgbGF5b3V0LCBsYXlvdXRJZCB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB0aGlzIHNlY3Rpb24gb2YgdGhlIHRyZWUgaXNuJ3QgYW5pbWF0aW5nIHdlIGNhblxuICAgICAgICAgICAgICogZGVsZXRlIG91ciB0YXJnZXQgc291cmNlcyBmb3IgdGhlIGZvbGxvd2luZyBmcmFtZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5pc1RyZWVBbmltYXRpbmcgPSBCb29sZWFuKCh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5pc1RyZWVBbmltYXRpbmcpIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQW5pbWF0aW9uKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1RyZWVBbmltYXRpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRhcmdldERlbHRhID0gdGhpcy5yZWxhdGl2ZVRhcmdldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5sYXlvdXQgfHwgIShsYXlvdXQgfHwgbGF5b3V0SWQpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmVzZXQgdGhlIGNvcnJlY3RlZCBib3ggd2l0aCB0aGUgbGF0ZXN0IHZhbHVlcyBmcm9tIGJveCwgYXMgd2UncmUgdGhlbiBnb2luZ1xuICAgICAgICAgICAgICogdG8gcGVyZm9ybSBtdXRhdGl2ZSBvcGVyYXRpb25zIG9uIGl0LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb3B5Qm94SW50byh0aGlzLmxheW91dENvcnJlY3RlZCwgdGhpcy5sYXlvdXQubGF5b3V0Qm94KTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmVjb3JkIHByZXZpb3VzIHRyZWUgc2NhbGVzIGJlZm9yZSB1cGRhdGluZy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgcHJldlRyZWVTY2FsZVggPSB0aGlzLnRyZWVTY2FsZS54O1xuICAgICAgICAgICAgY29uc3QgcHJldlRyZWVTY2FsZVkgPSB0aGlzLnRyZWVTY2FsZS55O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBcHBseSBhbGwgdGhlIHBhcmVudCBkZWx0YXMgdG8gdGhpcyBib3ggdG8gcHJvZHVjZSB0aGUgY29ycmVjdGVkIGJveC4gVGhpc1xuICAgICAgICAgICAgICogaXMgdGhlIGxheW91dCBib3gsIGFzIGl0IHdpbGwgYXBwZWFyIG9uIHNjcmVlbiBhcyBhIHJlc3VsdCBvZiB0aGUgdHJhbnNmb3JtcyBvZiBpdHMgcGFyZW50cy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgYXBwbHlUcmVlRGVsdGFzKHRoaXMubGF5b3V0Q29ycmVjdGVkLCB0aGlzLnRyZWVTY2FsZSwgdGhpcy5wYXRoLCBpc1NoYXJlZCk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHRoaXMgbGF5ZXIgbmVlZHMgdG8gcGVyZm9ybSBzY2FsZSBjb3JyZWN0aW9uIGJ1dCBkb2Vzbid0IGhhdmUgYSB0YXJnZXQsXG4gICAgICAgICAgICAgKiB1c2UgdGhlIGxheW91dCBhcyB0aGUgdGFyZ2V0LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAobGVhZC5sYXlvdXQgJiZcbiAgICAgICAgICAgICAgICAhbGVhZC50YXJnZXQgJiZcbiAgICAgICAgICAgICAgICAodGhpcy50cmVlU2NhbGUueCAhPT0gMSB8fCB0aGlzLnRyZWVTY2FsZS55ICE9PSAxKSkge1xuICAgICAgICAgICAgICAgIGxlYWQudGFyZ2V0ID0gbGVhZC5sYXlvdXQubGF5b3V0Qm94O1xuICAgICAgICAgICAgICAgIGxlYWQudGFyZ2V0V2l0aFRyYW5zZm9ybXMgPSBjcmVhdGVCb3goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgdGFyZ2V0IH0gPSBsZWFkO1xuICAgICAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBJZiB3ZSBkb24ndCBoYXZlIGEgdGFyZ2V0IHRvIHByb2plY3QgaW50bywgYnV0IHdlIHdlcmUgcHJldmlvdXNseVxuICAgICAgICAgICAgICAgICAqIHByb2plY3RpbmcsIHdlIHdhbnQgdG8gcmVtb3ZlIHRoZSBzdG9yZWQgdHJhbnNmb3JtIGFuZCBzY2hlZHVsZVxuICAgICAgICAgICAgICAgICAqIGEgcmVuZGVyIHRvIGVuc3VyZSB0aGUgZWxlbWVudHMgcmVmbGVjdCB0aGUgcmVtb3ZlZCB0cmFuc2Zvcm0uXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJldlByb2plY3Rpb25EZWx0YSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZVByb2plY3Rpb25EZWx0YXMoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2hlZHVsZVJlbmRlcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMucHJvamVjdGlvbkRlbHRhIHx8ICF0aGlzLnByZXZQcm9qZWN0aW9uRGVsdGEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZVByb2plY3Rpb25EZWx0YXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvcHlBeGlzRGVsdGFJbnRvKHRoaXMucHJldlByb2plY3Rpb25EZWx0YS54LCB0aGlzLnByb2plY3Rpb25EZWx0YS54KTtcbiAgICAgICAgICAgICAgICBjb3B5QXhpc0RlbHRhSW50byh0aGlzLnByZXZQcm9qZWN0aW9uRGVsdGEueSwgdGhpcy5wcm9qZWN0aW9uRGVsdGEueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFVwZGF0ZSB0aGUgZGVsdGEgYmV0d2VlbiB0aGUgY29ycmVjdGVkIGJveCBhbmQgdGhlIHRhcmdldCBib3ggYmVmb3JlIHVzZXItc2V0IHRyYW5zZm9ybXMgd2VyZSBhcHBsaWVkLlxuICAgICAgICAgICAgICogVGhpcyB3aWxsIGFsbG93IHVzIHRvIGNhbGN1bGF0ZSB0aGUgY29ycmVjdGVkIGJvcmRlclJhZGl1cyBhbmQgYm94U2hhZG93IHRvIGNvbXBlbnNhdGVcbiAgICAgICAgICAgICAqIGZvciBvdXIgbGF5b3V0IHJlcHJvamVjdGlvbiwgYnV0IHN0aWxsIGFsbG93IHRoZW0gdG8gYmUgc2NhbGVkIGNvcnJlY3RseSBieSB0aGUgdXNlci5cbiAgICAgICAgICAgICAqIEl0IG1pZ2h0IGJlIHRoYXQgdG8gc2ltcGxpZnkgdGhpcyB3ZSBtYXkgd2FudCB0byBhY2NlcHQgdGhhdCB1c2VyLXNldCBzY2FsZSBpcyBhbHNvIGNvcnJlY3RlZFxuICAgICAgICAgICAgICogYW5kIHdlIHdvdWxkbid0IGhhdmUgdG8ga2VlcCBhbmQgY2FsYyBib3RoIGRlbHRhcywgT1Igd2UgY291bGQgc3VwcG9ydCBhIHVzZXIgc2V0dGluZ1xuICAgICAgICAgICAgICogdG8gYWxsb3cgcGVvcGxlIHRvIGNob29zZSB3aGV0aGVyIHRoZXNlIHN0eWxlcyBhcmUgY29ycmVjdGVkIGJhc2VkIG9uIGp1c3QgdGhlXG4gICAgICAgICAgICAgKiBsYXlvdXQgcmVwcm9qZWN0aW9uIG9yIHRoZSBmaW5hbCBib3VuZGluZyBib3guXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNhbGNCb3hEZWx0YSh0aGlzLnByb2plY3Rpb25EZWx0YSwgdGhpcy5sYXlvdXRDb3JyZWN0ZWQsIHRhcmdldCwgdGhpcy5sYXRlc3RWYWx1ZXMpO1xuICAgICAgICAgICAgaWYgKHRoaXMudHJlZVNjYWxlLnggIT09IHByZXZUcmVlU2NhbGVYIHx8XG4gICAgICAgICAgICAgICAgdGhpcy50cmVlU2NhbGUueSAhPT0gcHJldlRyZWVTY2FsZVkgfHxcbiAgICAgICAgICAgICAgICAhYXhpc0RlbHRhRXF1YWxzKHRoaXMucHJvamVjdGlvbkRlbHRhLngsIHRoaXMucHJldlByb2plY3Rpb25EZWx0YS54KSB8fFxuICAgICAgICAgICAgICAgICFheGlzRGVsdGFFcXVhbHModGhpcy5wcm9qZWN0aW9uRGVsdGEueSwgdGhpcy5wcmV2UHJvamVjdGlvbkRlbHRhLnkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYXNQcm9qZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVSZW5kZXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeUxpc3RlbmVycyhcInByb2plY3Rpb25VcGRhdGVcIiwgdGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSW5jcmVhc2UgZGVidWcgY291bnRlciBmb3IgcmVjYWxjdWxhdGVkIHByb2plY3Rpb25zXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChpc0RlYnVnKSB7XG4gICAgICAgICAgICAgICAgbWV0cmljcy5yZWNhbGN1bGF0ZWRQcm9qZWN0aW9uKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaGlkZSgpIHtcbiAgICAgICAgICAgIHRoaXMuaXNWaXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBUT0RPOiBTY2hlZHVsZSByZW5kZXJcbiAgICAgICAgfVxuICAgICAgICBzaG93KCkge1xuICAgICAgICAgICAgdGhpcy5pc1Zpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgLy8gVE9ETzogU2NoZWR1bGUgcmVuZGVyXG4gICAgICAgIH1cbiAgICAgICAgc2NoZWR1bGVSZW5kZXIobm90aWZ5QWxsID0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgKF9hID0gdGhpcy5vcHRpb25zLnZpc3VhbEVsZW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zY2hlZHVsZVJlbmRlcigpO1xuICAgICAgICAgICAgaWYgKG5vdGlmeUFsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YWNrID0gdGhpcy5nZXRTdGFjaygpO1xuICAgICAgICAgICAgICAgIHN0YWNrICYmIHN0YWNrLnNjaGVkdWxlUmVuZGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5yZXN1bWluZ0Zyb20gJiYgIXRoaXMucmVzdW1pbmdGcm9tLmluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bWluZ0Zyb20gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3JlYXRlUHJvamVjdGlvbkRlbHRhcygpIHtcbiAgICAgICAgICAgIHRoaXMucHJldlByb2plY3Rpb25EZWx0YSA9IGNyZWF0ZURlbHRhKCk7XG4gICAgICAgICAgICB0aGlzLnByb2plY3Rpb25EZWx0YSA9IGNyZWF0ZURlbHRhKCk7XG4gICAgICAgICAgICB0aGlzLnByb2plY3Rpb25EZWx0YVdpdGhUcmFuc2Zvcm0gPSBjcmVhdGVEZWx0YSgpO1xuICAgICAgICB9XG4gICAgICAgIHNldEFuaW1hdGlvbk9yaWdpbihkZWx0YSwgaGFzT25seVJlbGF0aXZlVGFyZ2V0Q2hhbmdlZCA9IGZhbHNlKSB7XG4gICAgICAgICAgICBjb25zdCBzbmFwc2hvdCA9IHRoaXMuc25hcHNob3Q7XG4gICAgICAgICAgICBjb25zdCBzbmFwc2hvdExhdGVzdFZhbHVlcyA9IHNuYXBzaG90XG4gICAgICAgICAgICAgICAgPyBzbmFwc2hvdC5sYXRlc3RWYWx1ZXNcbiAgICAgICAgICAgICAgICA6IHt9O1xuICAgICAgICAgICAgY29uc3QgbWl4ZWRWYWx1ZXMgPSB7IC4uLnRoaXMubGF0ZXN0VmFsdWVzIH07XG4gICAgICAgICAgICBjb25zdCB0YXJnZXREZWx0YSA9IGNyZWF0ZURlbHRhKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMucmVsYXRpdmVQYXJlbnQgfHxcbiAgICAgICAgICAgICAgICAhdGhpcy5yZWxhdGl2ZVBhcmVudC5vcHRpb25zLmxheW91dFJvb3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aXZlVGFyZ2V0ID0gdGhpcy5yZWxhdGl2ZVRhcmdldE9yaWdpbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYXR0ZW1wdFRvUmVzb2x2ZVJlbGF0aXZlVGFyZ2V0ID0gIWhhc09ubHlSZWxhdGl2ZVRhcmdldENoYW5nZWQ7XG4gICAgICAgICAgICBjb25zdCByZWxhdGl2ZUxheW91dCA9IGNyZWF0ZUJveCgpO1xuICAgICAgICAgICAgY29uc3Qgc25hcHNob3RTb3VyY2UgPSBzbmFwc2hvdCA/IHNuYXBzaG90LnNvdXJjZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IGxheW91dFNvdXJjZSA9IHRoaXMubGF5b3V0ID8gdGhpcy5sYXlvdXQuc291cmNlIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29uc3QgaXNTaGFyZWRMYXlvdXRBbmltYXRpb24gPSBzbmFwc2hvdFNvdXJjZSAhPT0gbGF5b3V0U291cmNlO1xuICAgICAgICAgICAgY29uc3Qgc3RhY2sgPSB0aGlzLmdldFN0YWNrKCk7XG4gICAgICAgICAgICBjb25zdCBpc09ubHlNZW1iZXIgPSAhc3RhY2sgfHwgc3RhY2subWVtYmVycy5sZW5ndGggPD0gMTtcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZENyb3NzZmFkZU9wYWNpdHkgPSBCb29sZWFuKGlzU2hhcmVkTGF5b3V0QW5pbWF0aW9uICYmXG4gICAgICAgICAgICAgICAgIWlzT25seU1lbWJlciAmJlxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5jcm9zc2ZhZGUgPT09IHRydWUgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy5wYXRoLnNvbWUoaGFzT3BhY2l0eUNyb3NzZmFkZSkpO1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25Qcm9ncmVzcyA9IDA7XG4gICAgICAgICAgICBsZXQgcHJldlJlbGF0aXZlVGFyZ2V0O1xuICAgICAgICAgICAgdGhpcy5taXhUYXJnZXREZWx0YSA9IChsYXRlc3QpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9ncmVzcyA9IGxhdGVzdCAvIDEwMDA7XG4gICAgICAgICAgICAgICAgbWl4QXhpc0RlbHRhKHRhcmdldERlbHRhLngsIGRlbHRhLngsIHByb2dyZXNzKTtcbiAgICAgICAgICAgICAgICBtaXhBeGlzRGVsdGEodGFyZ2V0RGVsdGEueSwgZGVsdGEueSwgcHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0VGFyZ2V0RGVsdGEodGFyZ2V0RGVsdGEpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlbGF0aXZlVGFyZ2V0ICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVsYXRpdmVUYXJnZXRPcmlnaW4gJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXlvdXQgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWxhdGl2ZVBhcmVudCAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aXZlUGFyZW50LmxheW91dCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxjUmVsYXRpdmVQb3NpdGlvbihyZWxhdGl2ZUxheW91dCwgdGhpcy5sYXlvdXQubGF5b3V0Qm94LCB0aGlzLnJlbGF0aXZlUGFyZW50LmxheW91dC5sYXlvdXRCb3gpO1xuICAgICAgICAgICAgICAgICAgICBtaXhCb3godGhpcy5yZWxhdGl2ZVRhcmdldCwgdGhpcy5yZWxhdGl2ZVRhcmdldE9yaWdpbiwgcmVsYXRpdmVMYXlvdXQsIHByb2dyZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIElmIHRoaXMgaXMgYW4gdW5jaGFuZ2VkIHJlbGF0aXZlIHRhcmdldCB3ZSBjYW4gY29uc2lkZXIgdGhlXG4gICAgICAgICAgICAgICAgICAgICAqIHByb2plY3Rpb24gbm90IGRpcnR5LlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZSZWxhdGl2ZVRhcmdldCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgYm94RXF1YWxzKHRoaXMucmVsYXRpdmVUYXJnZXQsIHByZXZSZWxhdGl2ZVRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXNQcm9qZWN0aW9uRGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXByZXZSZWxhdGl2ZVRhcmdldClcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZSZWxhdGl2ZVRhcmdldCA9IGNyZWF0ZUJveCgpO1xuICAgICAgICAgICAgICAgICAgICBjb3B5Qm94SW50byhwcmV2UmVsYXRpdmVUYXJnZXQsIHRoaXMucmVsYXRpdmVUYXJnZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNTaGFyZWRMYXlvdXRBbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbmltYXRpb25WYWx1ZXMgPSBtaXhlZFZhbHVlcztcbiAgICAgICAgICAgICAgICAgICAgbWl4VmFsdWVzKG1peGVkVmFsdWVzLCBzbmFwc2hvdExhdGVzdFZhbHVlcywgdGhpcy5sYXRlc3RWYWx1ZXMsIHByb2dyZXNzLCBzaG91bGRDcm9zc2ZhZGVPcGFjaXR5LCBpc09ubHlNZW1iZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJvb3Quc2NoZWR1bGVVcGRhdGVQcm9qZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2hlZHVsZVJlbmRlcigpO1xuICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uUHJvZ3Jlc3MgPSBwcm9ncmVzcztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLm1peFRhcmdldERlbHRhKHRoaXMub3B0aW9ucy5sYXlvdXRSb290ID8gMTAwMCA6IDApO1xuICAgICAgICB9XG4gICAgICAgIHN0YXJ0QW5pbWF0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5TGlzdGVuZXJzKFwiYW5pbWF0aW9uU3RhcnRcIik7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRBbmltYXRpb24gJiYgdGhpcy5jdXJyZW50QW5pbWF0aW9uLnN0b3AoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc3VtaW5nRnJvbSAmJiB0aGlzLnJlc3VtaW5nRnJvbS5jdXJyZW50QW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bWluZ0Zyb20uY3VycmVudEFuaW1hdGlvbi5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgY2FuY2VsRnJhbWUodGhpcy5wZW5kaW5nQW5pbWF0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdBbmltYXRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFN0YXJ0IHRoZSBhbmltYXRpb24gaW4gdGhlIG5leHQgZnJhbWUgdG8gaGF2ZSBhIGZyYW1lIHdpdGggcHJvZ3Jlc3MgMCxcbiAgICAgICAgICAgICAqIHdoZXJlIHRoZSB0YXJnZXQgaXMgdGhlIHNhbWUgYXMgd2hlbiB0aGUgYW5pbWF0aW9uIHN0YXJ0ZWQsIHNvIHdlIGNhblxuICAgICAgICAgICAgICogY2FsY3VsYXRlIHRoZSByZWxhdGl2ZSBwb3NpdGlvbnMgY29ycmVjdGx5IGZvciBpbnN0YW50IHRyYW5zaXRpb25zLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdBbmltYXRpb24gPSBmcmFtZS51cGRhdGUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGdsb2JhbFByb2plY3Rpb25TdGF0ZS5oYXNBbmltYXRlZFNpbmNlUmVzaXplID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRBbmltYXRpb24gPSBhbmltYXRlU2luZ2xlVmFsdWUoMCwgYW5pbWF0aW9uVGFyZ2V0LCB7XG4gICAgICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIG9uVXBkYXRlOiAobGF0ZXN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1peFRhcmdldERlbHRhKGxhdGVzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uVXBkYXRlICYmIG9wdGlvbnMub25VcGRhdGUobGF0ZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25Db21wbGV0ZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5vbkNvbXBsZXRlICYmIG9wdGlvbnMub25Db21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wbGV0ZUFuaW1hdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlc3VtaW5nRnJvbSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3VtaW5nRnJvbS5jdXJyZW50QW5pbWF0aW9uID0gdGhpcy5jdXJyZW50QW5pbWF0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdBbmltYXRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb21wbGV0ZUFuaW1hdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc3VtaW5nRnJvbSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdW1pbmdGcm9tLmN1cnJlbnRBbmltYXRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bWluZ0Zyb20ucHJlc2VydmVPcGFjaXR5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3RhY2sgPSB0aGlzLmdldFN0YWNrKCk7XG4gICAgICAgICAgICBzdGFjayAmJiBzdGFjay5leGl0QW5pbWF0aW9uQ29tcGxldGUoKTtcbiAgICAgICAgICAgIHRoaXMucmVzdW1pbmdGcm9tID1cbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRBbmltYXRpb24gPVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGlvblZhbHVlcyA9XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeUxpc3RlbmVycyhcImFuaW1hdGlvbkNvbXBsZXRlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmlzaEFuaW1hdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRBbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1peFRhcmdldERlbHRhICYmIHRoaXMubWl4VGFyZ2V0RGVsdGEoYW5pbWF0aW9uVGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRBbmltYXRpb24uc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb21wbGV0ZUFuaW1hdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGFwcGx5VHJhbnNmb3Jtc1RvVGFyZ2V0KCkge1xuICAgICAgICAgICAgY29uc3QgbGVhZCA9IHRoaXMuZ2V0TGVhZCgpO1xuICAgICAgICAgICAgbGV0IHsgdGFyZ2V0V2l0aFRyYW5zZm9ybXMsIHRhcmdldCwgbGF5b3V0LCBsYXRlc3RWYWx1ZXMgfSA9IGxlYWQ7XG4gICAgICAgICAgICBpZiAoIXRhcmdldFdpdGhUcmFuc2Zvcm1zIHx8ICF0YXJnZXQgfHwgIWxheW91dClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHdlJ3JlIG9ubHkgYW5pbWF0aW5nIHBvc2l0aW9uLCBhbmQgdGhpcyBlbGVtZW50IGlzbid0IHRoZSBsZWFkIGVsZW1lbnQsXG4gICAgICAgICAgICAgKiB0aGVuIGluc3RlYWQgb2YgcHJvamVjdGluZyBpbnRvIHRoZSBsZWFkIGJveCB3ZSBpbnN0ZWFkIHdhbnQgdG8gY2FsY3VsYXRlXG4gICAgICAgICAgICAgKiBhIG5ldyB0YXJnZXQgdGhhdCBhbGlnbnMgdGhlIHR3byBib3hlcyBidXQgbWFpbnRhaW5zIHRoZSBsYXlvdXQgc2hhcGUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICh0aGlzICE9PSBsZWFkICYmXG4gICAgICAgICAgICAgICAgdGhpcy5sYXlvdXQgJiZcbiAgICAgICAgICAgICAgICBsYXlvdXQgJiZcbiAgICAgICAgICAgICAgICBzaG91bGRBbmltYXRlUG9zaXRpb25Pbmx5KHRoaXMub3B0aW9ucy5hbmltYXRpb25UeXBlLCB0aGlzLmxheW91dC5sYXlvdXRCb3gsIGxheW91dC5sYXlvdXRCb3gpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGhpcy50YXJnZXQgfHwgY3JlYXRlQm94KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgeExlbmd0aCA9IGNhbGNMZW5ndGgodGhpcy5sYXlvdXQubGF5b3V0Qm94LngpO1xuICAgICAgICAgICAgICAgIHRhcmdldC54Lm1pbiA9IGxlYWQudGFyZ2V0LngubWluO1xuICAgICAgICAgICAgICAgIHRhcmdldC54Lm1heCA9IHRhcmdldC54Lm1pbiArIHhMZW5ndGg7XG4gICAgICAgICAgICAgICAgY29uc3QgeUxlbmd0aCA9IGNhbGNMZW5ndGgodGhpcy5sYXlvdXQubGF5b3V0Qm94LnkpO1xuICAgICAgICAgICAgICAgIHRhcmdldC55Lm1pbiA9IGxlYWQudGFyZ2V0LnkubWluO1xuICAgICAgICAgICAgICAgIHRhcmdldC55Lm1heCA9IHRhcmdldC55Lm1pbiArIHlMZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb3B5Qm94SW50byh0YXJnZXRXaXRoVHJhbnNmb3JtcywgdGFyZ2V0KTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQXBwbHkgdGhlIGxhdGVzdCB1c2VyLXNldCB0cmFuc2Zvcm1zIHRvIHRoZSB0YXJnZXRCb3ggdG8gcHJvZHVjZSB0aGUgdGFyZ2V0Qm94RmluYWwuXG4gICAgICAgICAgICAgKiBUaGlzIGlzIHRoZSBmaW5hbCBib3ggdGhhdCB3ZSB3aWxsIHRoZW4gcHJvamVjdCBpbnRvIGJ5IGNhbGN1bGF0aW5nIGEgdHJhbnNmb3JtIGRlbHRhIGFuZFxuICAgICAgICAgICAgICogYXBwbHlpbmcgaXQgdG8gdGhlIGNvcnJlY3RlZCBib3guXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRyYW5zZm9ybUJveCh0YXJnZXRXaXRoVHJhbnNmb3JtcywgbGF0ZXN0VmFsdWVzKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVXBkYXRlIHRoZSBkZWx0YSBiZXR3ZWVuIHRoZSBjb3JyZWN0ZWQgYm94IGFuZCB0aGUgZmluYWwgdGFyZ2V0IGJveCwgYWZ0ZXJcbiAgICAgICAgICAgICAqIHVzZXItc2V0IHRyYW5zZm9ybXMgYXJlIGFwcGxpZWQgdG8gaXQuIFRoaXMgd2lsbCBiZSB1c2VkIGJ5IHRoZSByZW5kZXJlciB0b1xuICAgICAgICAgICAgICogY3JlYXRlIGEgdHJhbnNmb3JtIHN0eWxlIHRoYXQgd2lsbCByZXByb2plY3QgdGhlIGVsZW1lbnQgZnJvbSBpdHMgbGF5b3V0IGxheW91dFxuICAgICAgICAgICAgICogaW50byB0aGUgZGVzaXJlZCBib3VuZGluZyBib3guXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNhbGNCb3hEZWx0YSh0aGlzLnByb2plY3Rpb25EZWx0YVdpdGhUcmFuc2Zvcm0sIHRoaXMubGF5b3V0Q29ycmVjdGVkLCB0YXJnZXRXaXRoVHJhbnNmb3JtcywgbGF0ZXN0VmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICByZWdpc3RlclNoYXJlZE5vZGUobGF5b3V0SWQsIG5vZGUpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zaGFyZWROb2Rlcy5oYXMobGF5b3V0SWQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaGFyZWROb2Rlcy5zZXQobGF5b3V0SWQsIG5ldyBOb2RlU3RhY2soKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdGFjayA9IHRoaXMuc2hhcmVkTm9kZXMuZ2V0KGxheW91dElkKTtcbiAgICAgICAgICAgIHN0YWNrLmFkZChub2RlKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IG5vZGUub3B0aW9ucy5pbml0aWFsUHJvbW90aW9uQ29uZmlnO1xuICAgICAgICAgICAgbm9kZS5wcm9tb3RlKHtcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uOiBjb25maWcgPyBjb25maWcudHJhbnNpdGlvbiA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBwcmVzZXJ2ZUZvbGxvd09wYWNpdHk6IGNvbmZpZyAmJiBjb25maWcuc2hvdWxkUHJlc2VydmVGb2xsb3dPcGFjaXR5XG4gICAgICAgICAgICAgICAgICAgID8gY29uZmlnLnNob3VsZFByZXNlcnZlRm9sbG93T3BhY2l0eShub2RlKVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlzTGVhZCgpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YWNrID0gdGhpcy5nZXRTdGFjaygpO1xuICAgICAgICAgICAgcmV0dXJuIHN0YWNrID8gc3RhY2subGVhZCA9PT0gdGhpcyA6IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0TGVhZCgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IHsgbGF5b3V0SWQgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgICAgIHJldHVybiBsYXlvdXRJZCA/ICgoX2EgPSB0aGlzLmdldFN0YWNrKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZWFkKSB8fCB0aGlzIDogdGhpcztcbiAgICAgICAgfVxuICAgICAgICBnZXRQcmV2TGVhZCgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IHsgbGF5b3V0SWQgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgICAgIHJldHVybiBsYXlvdXRJZCA/IChfYSA9IHRoaXMuZ2V0U3RhY2soKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnByZXZMZWFkIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGdldFN0YWNrKCkge1xuICAgICAgICAgICAgY29uc3QgeyBsYXlvdXRJZCB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAgICAgaWYgKGxheW91dElkKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJvb3Quc2hhcmVkTm9kZXMuZ2V0KGxheW91dElkKTtcbiAgICAgICAgfVxuICAgICAgICBwcm9tb3RlKHsgbmVlZHNSZXNldCwgdHJhbnNpdGlvbiwgcHJlc2VydmVGb2xsb3dPcGFjaXR5LCB9ID0ge30pIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YWNrID0gdGhpcy5nZXRTdGFjaygpO1xuICAgICAgICAgICAgaWYgKHN0YWNrKVxuICAgICAgICAgICAgICAgIHN0YWNrLnByb21vdGUodGhpcywgcHJlc2VydmVGb2xsb3dPcGFjaXR5KTtcbiAgICAgICAgICAgIGlmIChuZWVkc1Jlc2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9qZWN0aW9uRGVsdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5uZWVkc1Jlc2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0cmFuc2l0aW9uKVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0T3B0aW9ucyh7IHRyYW5zaXRpb24gfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVsZWdhdGUoKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFjayA9IHRoaXMuZ2V0U3RhY2soKTtcbiAgICAgICAgICAgIGlmIChzdGFjaykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGFjay5yZWxlZ2F0ZSh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXNldFNrZXdBbmRSb3RhdGlvbigpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdmlzdWFsRWxlbWVudCB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAgICAgaWYgKCF2aXN1YWxFbGVtZW50KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gZGV0ZWN0ZWQgc2tldyBvciByb3RhdGlvbiB2YWx1ZXMsIHdlIGNhbiBlYXJseSByZXR1cm4gd2l0aG91dCBhIGZvcmNlZCByZW5kZXIuXG4gICAgICAgICAgICBsZXQgaGFzRGlzdG9ydGluZ1RyYW5zZm9ybSA9IGZhbHNlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBbiB1bnJvbGxlZCBjaGVjayBmb3Igcm90YXRpb24gdmFsdWVzLiBNb3N0IGVsZW1lbnRzIGRvbid0IGhhdmUgYW55IHJvdGF0aW9uIGFuZFxuICAgICAgICAgICAgICogc2tpcHBpbmcgdGhlIG5lc3RlZCBsb29wIGFuZCBuZXcgb2JqZWN0IGNyZWF0aW9uIGlzIDUwJSBmYXN0ZXIuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IHsgbGF0ZXN0VmFsdWVzIH0gPSB2aXN1YWxFbGVtZW50O1xuICAgICAgICAgICAgaWYgKGxhdGVzdFZhbHVlcy56IHx8XG4gICAgICAgICAgICAgICAgbGF0ZXN0VmFsdWVzLnJvdGF0ZSB8fFxuICAgICAgICAgICAgICAgIGxhdGVzdFZhbHVlcy5yb3RhdGVYIHx8XG4gICAgICAgICAgICAgICAgbGF0ZXN0VmFsdWVzLnJvdGF0ZVkgfHxcbiAgICAgICAgICAgICAgICBsYXRlc3RWYWx1ZXMucm90YXRlWiB8fFxuICAgICAgICAgICAgICAgIGxhdGVzdFZhbHVlcy5za2V3WCB8fFxuICAgICAgICAgICAgICAgIGxhdGVzdFZhbHVlcy5za2V3WSkge1xuICAgICAgICAgICAgICAgIGhhc0Rpc3RvcnRpbmdUcmFuc2Zvcm0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBubyBkaXN0b3J0aW5nIHZhbHVlcywgd2UgZG9uJ3QgbmVlZCB0byBkbyBhbnkgbW9yZS5cbiAgICAgICAgICAgIGlmICghaGFzRGlzdG9ydGluZ1RyYW5zZm9ybSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCByZXNldFZhbHVlcyA9IHt9O1xuICAgICAgICAgICAgaWYgKGxhdGVzdFZhbHVlcy56KSB7XG4gICAgICAgICAgICAgICAgcmVzZXREaXN0b3J0aW5nVHJhbnNmb3JtKFwielwiLCB2aXN1YWxFbGVtZW50LCByZXNldFZhbHVlcywgdGhpcy5hbmltYXRpb25WYWx1ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIHNrZXcgYW5kIHJvdGF0ZSB2YWx1ZSBvZiBhbGwgYXhlcyBhbmQgcmVzZXQgdG8gMFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFuc2Zvcm1BeGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzZXREaXN0b3J0aW5nVHJhbnNmb3JtKGByb3RhdGUke3RyYW5zZm9ybUF4ZXNbaV19YCwgdmlzdWFsRWxlbWVudCwgcmVzZXRWYWx1ZXMsIHRoaXMuYW5pbWF0aW9uVmFsdWVzKTtcbiAgICAgICAgICAgICAgICByZXNldERpc3RvcnRpbmdUcmFuc2Zvcm0oYHNrZXcke3RyYW5zZm9ybUF4ZXNbaV19YCwgdmlzdWFsRWxlbWVudCwgcmVzZXRWYWx1ZXMsIHRoaXMuYW5pbWF0aW9uVmFsdWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZvcmNlIGEgcmVuZGVyIG9mIHRoaXMgZWxlbWVudCB0byBhcHBseSB0aGUgdHJhbnNmb3JtIHdpdGggYWxsIHNrZXdzIGFuZCByb3RhdGlvbnNcbiAgICAgICAgICAgIC8vIHNldCB0byAwLlxuICAgICAgICAgICAgdmlzdWFsRWxlbWVudC5yZW5kZXIoKTtcbiAgICAgICAgICAgIC8vIFB1dCBiYWNrIGFsbCB0aGUgdmFsdWVzIHdlIHJlc2V0XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiByZXNldFZhbHVlcykge1xuICAgICAgICAgICAgICAgIHZpc3VhbEVsZW1lbnQuc2V0U3RhdGljVmFsdWUoa2V5LCByZXNldFZhbHVlc1trZXldKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hbmltYXRpb25WYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbmltYXRpb25WYWx1ZXNba2V5XSA9IHJlc2V0VmFsdWVzW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2NoZWR1bGUgYSByZW5kZXIgZm9yIHRoZSBuZXh0IGZyYW1lLiBUaGlzIGVuc3VyZXMgd2Ugd29uJ3QgdmlzdWFsbHlcbiAgICAgICAgICAgIC8vIHNlZSB0aGUgZWxlbWVudCB3aXRoIHRoZSByZXNldCByb3RhdGUgdmFsdWUgYXBwbGllZC5cbiAgICAgICAgICAgIHZpc3VhbEVsZW1lbnQuc2NoZWR1bGVSZW5kZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBnZXRQcm9qZWN0aW9uU3R5bGVzKHN0eWxlUHJvcCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGlmICghdGhpcy5pbnN0YW5jZSB8fCB0aGlzLmlzU1ZHKVxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhpZGRlblZpc2liaWxpdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdHlsZXMgPSB7XG4gICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogXCJcIixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1UZW1wbGF0ZSA9IHRoaXMuZ2V0VHJhbnNmb3JtVGVtcGxhdGUoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm5lZWRzUmVzZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5lZWRzUmVzZXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBzdHlsZXMub3BhY2l0eSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgc3R5bGVzLnBvaW50ZXJFdmVudHMgPVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlTW90aW9uVmFsdWUoc3R5bGVQcm9wID09PSBudWxsIHx8IHN0eWxlUHJvcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3R5bGVQcm9wLnBvaW50ZXJFdmVudHMpIHx8IFwiXCI7XG4gICAgICAgICAgICAgICAgc3R5bGVzLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVRlbXBsYXRlXG4gICAgICAgICAgICAgICAgICAgID8gdHJhbnNmb3JtVGVtcGxhdGUodGhpcy5sYXRlc3RWYWx1ZXMsIFwiXCIpXG4gICAgICAgICAgICAgICAgICAgIDogXCJub25lXCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0eWxlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxlYWQgPSB0aGlzLmdldExlYWQoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5wcm9qZWN0aW9uRGVsdGEgfHwgIXRoaXMubGF5b3V0IHx8ICFsZWFkLnRhcmdldCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVtcHR5U3R5bGVzID0ge307XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5sYXlvdXRJZCkge1xuICAgICAgICAgICAgICAgICAgICBlbXB0eVN0eWxlcy5vcGFjaXR5ID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0VmFsdWVzLm9wYWNpdHkgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy5sYXRlc3RWYWx1ZXMub3BhY2l0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogMTtcbiAgICAgICAgICAgICAgICAgICAgZW1wdHlTdHlsZXMucG9pbnRlckV2ZW50cyA9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlTW90aW9uVmFsdWUoc3R5bGVQcm9wID09PSBudWxsIHx8IHN0eWxlUHJvcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3R5bGVQcm9wLnBvaW50ZXJFdmVudHMpIHx8IFwiXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc1Byb2plY3RlZCAmJiAhaGFzVHJhbnNmb3JtKHRoaXMubGF0ZXN0VmFsdWVzKSkge1xuICAgICAgICAgICAgICAgICAgICBlbXB0eVN0eWxlcy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1UZW1wbGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0cmFuc2Zvcm1UZW1wbGF0ZSh7fSwgXCJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIDogXCJub25lXCI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFzUHJvamVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBlbXB0eVN0eWxlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlc1RvUmVuZGVyID0gbGVhZC5hbmltYXRpb25WYWx1ZXMgfHwgbGVhZC5sYXRlc3RWYWx1ZXM7XG4gICAgICAgICAgICB0aGlzLmFwcGx5VHJhbnNmb3Jtc1RvVGFyZ2V0KCk7XG4gICAgICAgICAgICBzdHlsZXMudHJhbnNmb3JtID0gYnVpbGRQcm9qZWN0aW9uVHJhbnNmb3JtKHRoaXMucHJvamVjdGlvbkRlbHRhV2l0aFRyYW5zZm9ybSwgdGhpcy50cmVlU2NhbGUsIHZhbHVlc1RvUmVuZGVyKTtcbiAgICAgICAgICAgIGlmICh0cmFuc2Zvcm1UZW1wbGF0ZSkge1xuICAgICAgICAgICAgICAgIHN0eWxlcy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1UZW1wbGF0ZSh2YWx1ZXNUb1JlbmRlciwgc3R5bGVzLnRyYW5zZm9ybSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMucHJvamVjdGlvbkRlbHRhO1xuICAgICAgICAgICAgc3R5bGVzLnRyYW5zZm9ybU9yaWdpbiA9IGAke3gub3JpZ2luICogMTAwfSUgJHt5Lm9yaWdpbiAqIDEwMH0lIDBgO1xuICAgICAgICAgICAgaWYgKGxlYWQuYW5pbWF0aW9uVmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogSWYgdGhlIGxlYWQgY29tcG9uZW50IGlzIGFuaW1hdGluZywgYXNzaWduIHRoaXMgZWl0aGVyIHRoZSBlbnRlcmluZy9sZWF2aW5nXG4gICAgICAgICAgICAgICAgICogb3BhY2l0eVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHN0eWxlcy5vcGFjaXR5ID1cbiAgICAgICAgICAgICAgICAgICAgbGVhZCA9PT0gdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgPyAoX2IgPSAoX2EgPSB2YWx1ZXNUb1JlbmRlci5vcGFjaXR5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLmxhdGVzdFZhbHVlcy5vcGFjaXR5KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAxXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMucHJlc2VydmVPcGFjaXR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLmxhdGVzdFZhbHVlcy5vcGFjaXR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZXNUb1JlbmRlci5vcGFjaXR5RXhpdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIE9yIHdlJ3JlIG5vdCBhbmltYXRpbmcgYXQgYWxsLCBzZXQgdGhlIGxlYWQgY29tcG9uZW50IHRvIGl0cyBsYXlvdXRcbiAgICAgICAgICAgICAgICAgKiBvcGFjaXR5IGFuZCBvdGhlciBjb21wb25lbnRzIHRvIGhpZGRlbi5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBzdHlsZXMub3BhY2l0eSA9XG4gICAgICAgICAgICAgICAgICAgIGxlYWQgPT09IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdmFsdWVzVG9SZW5kZXIub3BhY2l0eSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB2YWx1ZXNUb1JlbmRlci5vcGFjaXR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcIlwiXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHZhbHVlc1RvUmVuZGVyLm9wYWNpdHlFeGl0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHZhbHVlc1RvUmVuZGVyLm9wYWNpdHlFeGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBcHBseSBzY2FsZSBjb3JyZWN0aW9uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNjYWxlQ29ycmVjdG9ycykge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZXNUb1JlbmRlcltrZXldID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgY29ycmVjdCwgYXBwbHlUbyB9ID0gc2NhbGVDb3JyZWN0b3JzW2tleV07XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogT25seSBhcHBseSBzY2FsZSBjb3JyZWN0aW9uIHRvIHRoZSB2YWx1ZSBpZiB3ZSBoYXZlIGFuXG4gICAgICAgICAgICAgICAgICogYWN0aXZlIHByb2plY3Rpb24gdHJhbnNmb3JtLiBPdGhlcndpc2UgdGhlc2UgdmFsdWVzIGJlY29tZVxuICAgICAgICAgICAgICAgICAqIHZ1bG5lcmFibGUgdG8gZGlzdG9ydGlvbiBpZiB0aGUgZWxlbWVudCBjaGFuZ2VzIHNpemUgd2l0aG91dFxuICAgICAgICAgICAgICAgICAqIGEgY29ycmVzcG9uZGluZyBsYXlvdXQgYW5pbWF0aW9uLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvcnJlY3RlZCA9IHN0eWxlcy50cmFuc2Zvcm0gPT09IFwibm9uZVwiXG4gICAgICAgICAgICAgICAgICAgID8gdmFsdWVzVG9SZW5kZXJba2V5XVxuICAgICAgICAgICAgICAgICAgICA6IGNvcnJlY3QodmFsdWVzVG9SZW5kZXJba2V5XSwgbGVhZCk7XG4gICAgICAgICAgICAgICAgaWYgKGFwcGx5VG8pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbnVtID0gYXBwbHlUby5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlc1thcHBseVRvW2ldXSA9IGNvcnJlY3RlZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzW2tleV0gPSBjb3JyZWN0ZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEaXNhYmxlIHBvaW50ZXIgZXZlbnRzIG9uIGZvbGxvdyBjb21wb25lbnRzLiBUaGlzIGlzIHRvIGVuc3VyZVxuICAgICAgICAgICAgICogdGhhdCBpZiBhIGZvbGxvdyBjb21wb25lbnQgY292ZXJzIGEgbGVhZCBjb21wb25lbnQgaXQgZG9lc24ndCBibG9ja1xuICAgICAgICAgICAgICogcG9pbnRlciBldmVudHMgb24gdGhlIGxlYWQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMubGF5b3V0SWQpIHtcbiAgICAgICAgICAgICAgICBzdHlsZXMucG9pbnRlckV2ZW50cyA9XG4gICAgICAgICAgICAgICAgICAgIGxlYWQgPT09IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcmVzb2x2ZU1vdGlvblZhbHVlKHN0eWxlUHJvcCA9PT0gbnVsbCB8fCBzdHlsZVByb3AgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0eWxlUHJvcC5wb2ludGVyRXZlbnRzKSB8fCBcIlwiXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFwibm9uZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0eWxlcztcbiAgICAgICAgfVxuICAgICAgICBjbGVhclNuYXBzaG90KCkge1xuICAgICAgICAgICAgdGhpcy5yZXN1bWVGcm9tID0gdGhpcy5zbmFwc2hvdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBPbmx5IHJ1biBvbiByb290XG4gICAgICAgIHJlc2V0VHJlZSgpIHtcbiAgICAgICAgICAgIHRoaXMucm9vdC5ub2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IG5vZGUuY3VycmVudEFuaW1hdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0b3AoKTsgfSk7XG4gICAgICAgICAgICB0aGlzLnJvb3Qubm9kZXMuZm9yRWFjaChjbGVhck1lYXN1cmVtZW50cyk7XG4gICAgICAgICAgICB0aGlzLnJvb3Quc2hhcmVkTm9kZXMuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiB1cGRhdGVMYXlvdXQobm9kZSkge1xuICAgIG5vZGUudXBkYXRlTGF5b3V0KCk7XG59XG5mdW5jdGlvbiBub3RpZnlMYXlvdXRVcGRhdGUobm9kZSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBzbmFwc2hvdCA9ICgoX2EgPSBub2RlLnJlc3VtZUZyb20pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zbmFwc2hvdCkgfHwgbm9kZS5zbmFwc2hvdDtcbiAgICBpZiAobm9kZS5pc0xlYWQoKSAmJlxuICAgICAgICBub2RlLmxheW91dCAmJlxuICAgICAgICBzbmFwc2hvdCAmJlxuICAgICAgICBub2RlLmhhc0xpc3RlbmVycyhcImRpZFVwZGF0ZVwiKSkge1xuICAgICAgICBjb25zdCB7IGxheW91dEJveDogbGF5b3V0LCBtZWFzdXJlZEJveDogbWVhc3VyZWRMYXlvdXQgfSA9IG5vZGUubGF5b3V0O1xuICAgICAgICBjb25zdCB7IGFuaW1hdGlvblR5cGUgfSA9IG5vZGUub3B0aW9ucztcbiAgICAgICAgY29uc3QgaXNTaGFyZWQgPSBzbmFwc2hvdC5zb3VyY2UgIT09IG5vZGUubGF5b3V0LnNvdXJjZTtcbiAgICAgICAgLy8gVE9ETyBNYXliZSB3ZSB3YW50IHRvIGFsc28gcmVzaXplIHRoZSBsYXlvdXQgc25hcHNob3Qgc28gd2UgZG9uJ3QgdHJpZ2dlclxuICAgICAgICAvLyBhbmltYXRpb25zIGZvciBpbnN0YW5jZSBpZiBsYXlvdXQ9XCJzaXplXCIgYW5kIGFuIGVsZW1lbnQgaGFzIG9ubHkgY2hhbmdlZCBwb3NpdGlvblxuICAgICAgICBpZiAoYW5pbWF0aW9uVHlwZSA9PT0gXCJzaXplXCIpIHtcbiAgICAgICAgICAgIGVhY2hBeGlzKChheGlzKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXhpc1NuYXBzaG90ID0gaXNTaGFyZWRcbiAgICAgICAgICAgICAgICAgICAgPyBzbmFwc2hvdC5tZWFzdXJlZEJveFtheGlzXVxuICAgICAgICAgICAgICAgICAgICA6IHNuYXBzaG90LmxheW91dEJveFtheGlzXTtcbiAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBjYWxjTGVuZ3RoKGF4aXNTbmFwc2hvdCk7XG4gICAgICAgICAgICAgICAgYXhpc1NuYXBzaG90Lm1pbiA9IGxheW91dFtheGlzXS5taW47XG4gICAgICAgICAgICAgICAgYXhpc1NuYXBzaG90Lm1heCA9IGF4aXNTbmFwc2hvdC5taW4gKyBsZW5ndGg7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzaG91bGRBbmltYXRlUG9zaXRpb25Pbmx5KGFuaW1hdGlvblR5cGUsIHNuYXBzaG90LmxheW91dEJveCwgbGF5b3V0KSkge1xuICAgICAgICAgICAgZWFjaEF4aXMoKGF4aXMpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBheGlzU25hcHNob3QgPSBpc1NoYXJlZFxuICAgICAgICAgICAgICAgICAgICA/IHNuYXBzaG90Lm1lYXN1cmVkQm94W2F4aXNdXG4gICAgICAgICAgICAgICAgICAgIDogc25hcHNob3QubGF5b3V0Qm94W2F4aXNdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IGNhbGNMZW5ndGgobGF5b3V0W2F4aXNdKTtcbiAgICAgICAgICAgICAgICBheGlzU25hcHNob3QubWF4ID0gYXhpc1NuYXBzaG90Lm1pbiArIGxlbmd0aDtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBFbnN1cmUgcmVsYXRpdmUgdGFyZ2V0IGdldHMgcmVzaXplZCBhbmQgcmVyZW5kZXJlcmRcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAobm9kZS5yZWxhdGl2ZVRhcmdldCAmJiAhbm9kZS5jdXJyZW50QW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuaXNQcm9qZWN0aW9uRGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBub2RlLnJlbGF0aXZlVGFyZ2V0W2F4aXNdLm1heCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnJlbGF0aXZlVGFyZ2V0W2F4aXNdLm1pbiArIGxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYXlvdXREZWx0YSA9IGNyZWF0ZURlbHRhKCk7XG4gICAgICAgIGNhbGNCb3hEZWx0YShsYXlvdXREZWx0YSwgbGF5b3V0LCBzbmFwc2hvdC5sYXlvdXRCb3gpO1xuICAgICAgICBjb25zdCB2aXN1YWxEZWx0YSA9IGNyZWF0ZURlbHRhKCk7XG4gICAgICAgIGlmIChpc1NoYXJlZCkge1xuICAgICAgICAgICAgY2FsY0JveERlbHRhKHZpc3VhbERlbHRhLCBub2RlLmFwcGx5VHJhbnNmb3JtKG1lYXN1cmVkTGF5b3V0LCB0cnVlKSwgc25hcHNob3QubWVhc3VyZWRCb3gpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2FsY0JveERlbHRhKHZpc3VhbERlbHRhLCBsYXlvdXQsIHNuYXBzaG90LmxheW91dEJveCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFzTGF5b3V0Q2hhbmdlZCA9ICFpc0RlbHRhWmVybyhsYXlvdXREZWx0YSk7XG4gICAgICAgIGxldCBoYXNSZWxhdGl2ZVRhcmdldENoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKCFub2RlLnJlc3VtZUZyb20pIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbGF0aXZlUGFyZW50ID0gbm9kZS5nZXRDbG9zZXN0UHJvamVjdGluZ1BhcmVudCgpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB0aGUgcmVsYXRpdmVQYXJlbnQgaXMgaXRzZWxmIHJlc3VtaW5nIGZyb20gYSBkaWZmZXJlbnQgZWxlbWVudCB0aGVuXG4gICAgICAgICAgICAgKiB0aGUgcmVsYXRpdmUgc25hcHNob3QgaXMgbm90IHJlbGF2ZW50XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZVBhcmVudCAmJiAhcmVsYXRpdmVQYXJlbnQucmVzdW1lRnJvbSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgc25hcHNob3Q6IHBhcmVudFNuYXBzaG90LCBsYXlvdXQ6IHBhcmVudExheW91dCB9ID0gcmVsYXRpdmVQYXJlbnQ7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudFNuYXBzaG90ICYmIHBhcmVudExheW91dCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWxhdGl2ZVNuYXBzaG90ID0gY3JlYXRlQm94KCk7XG4gICAgICAgICAgICAgICAgICAgIGNhbGNSZWxhdGl2ZVBvc2l0aW9uKHJlbGF0aXZlU25hcHNob3QsIHNuYXBzaG90LmxheW91dEJveCwgcGFyZW50U25hcHNob3QubGF5b3V0Qm94KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVsYXRpdmVMYXlvdXQgPSBjcmVhdGVCb3goKTtcbiAgICAgICAgICAgICAgICAgICAgY2FsY1JlbGF0aXZlUG9zaXRpb24ocmVsYXRpdmVMYXlvdXQsIGxheW91dCwgcGFyZW50TGF5b3V0LmxheW91dEJveCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYm94RXF1YWxzUm91bmRlZChyZWxhdGl2ZVNuYXBzaG90LCByZWxhdGl2ZUxheW91dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc1JlbGF0aXZlVGFyZ2V0Q2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbGF0aXZlUGFyZW50Lm9wdGlvbnMubGF5b3V0Um9vdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5yZWxhdGl2ZVRhcmdldCA9IHJlbGF0aXZlTGF5b3V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5yZWxhdGl2ZVRhcmdldE9yaWdpbiA9IHJlbGF0aXZlU25hcHNob3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnJlbGF0aXZlUGFyZW50ID0gcmVsYXRpdmVQYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5ub3RpZnlMaXN0ZW5lcnMoXCJkaWRVcGRhdGVcIiwge1xuICAgICAgICAgICAgbGF5b3V0LFxuICAgICAgICAgICAgc25hcHNob3QsXG4gICAgICAgICAgICBkZWx0YTogdmlzdWFsRGVsdGEsXG4gICAgICAgICAgICBsYXlvdXREZWx0YSxcbiAgICAgICAgICAgIGhhc0xheW91dENoYW5nZWQsXG4gICAgICAgICAgICBoYXNSZWxhdGl2ZVRhcmdldENoYW5nZWQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlLmlzTGVhZCgpKSB7XG4gICAgICAgIGNvbnN0IHsgb25FeGl0Q29tcGxldGUgfSA9IG5vZGUub3B0aW9ucztcbiAgICAgICAgb25FeGl0Q29tcGxldGUgJiYgb25FeGl0Q29tcGxldGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXJpbmcgdHJhbnNpdGlvblxuICAgICAqIFRPRE86IEludmVzdGlnYXRlIHdoeSB0aGlzIHRyYW5zaXRpb24gaXMgYmVpbmcgcGFzc2VkIGluIGFzIHt0eXBlOiBmYWxzZSB9IGZyb20gRnJhbWVyXG4gICAgICogYW5kIHdoeSB3ZSBuZWVkIGl0IGF0IGFsbFxuICAgICAqL1xuICAgIG5vZGUub3B0aW9ucy50cmFuc2l0aW9uID0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gcHJvcGFnYXRlRGlydHlOb2Rlcyhub2RlKSB7XG4gICAgLyoqXG4gICAgICogSW5jcmVhc2UgZGVidWcgY291bnRlciBmb3Igbm9kZXMgZW5jb3VudGVyZWQgdGhpcyBmcmFtZVxuICAgICAqL1xuICAgIGlmIChpc0RlYnVnKSB7XG4gICAgICAgIG1ldHJpY3MudG90YWxOb2RlcysrO1xuICAgIH1cbiAgICBpZiAoIW5vZGUucGFyZW50KVxuICAgICAgICByZXR1cm47XG4gICAgLyoqXG4gICAgICogSWYgdGhpcyBub2RlIGlzbid0IHByb2plY3RpbmcsIHByb3BhZ2F0ZSBpc1Byb2plY3Rpb25EaXJ0eS4gSXQgd2lsbCBoYXZlXG4gICAgICogbm8gcGVyZm9ybWFuY2UgaW1wYWN0IGJ1dCBpdCB3aWxsIGFsbG93IHRoZSBuZXh0IGNoaWxkIHRoYXQgKmlzKiBwcm9qZWN0aW5nXG4gICAgICogYnV0ICppc24ndCogZGlydHkgdG8ganVzdCBjaGVjayBpdHMgcGFyZW50IHRvIHNlZSBpZiAqYW55KiBhbmNlc3RvciBuZWVkc1xuICAgICAqIGNvcnJlY3RpbmcuXG4gICAgICovXG4gICAgaWYgKCFub2RlLmlzUHJvamVjdGluZygpKSB7XG4gICAgICAgIG5vZGUuaXNQcm9qZWN0aW9uRGlydHkgPSBub2RlLnBhcmVudC5pc1Byb2plY3Rpb25EaXJ0eTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvcGFnYXRlIGlzU2hhcmVkUHJvamVjdGlvbkRpcnR5IGFuZCBpc1RyYW5zZm9ybURpcnR5XG4gICAgICogdGhyb3VnaG91dCB0aGUgd2hvbGUgdHJlZS4gQSBmdXR1cmUgcmV2aXNpb24gY2FuIHRha2UgYW5vdGhlciBsb29rIGF0XG4gICAgICogdGhpcyBidXQgZm9yIHNhZmV0eSB3ZSBzdGlsbCByZWNhbGN1YWx0ZSBzaGFyZWQgbm9kZXMuXG4gICAgICovXG4gICAgbm9kZS5pc1NoYXJlZFByb2plY3Rpb25EaXJ0eSB8fCAobm9kZS5pc1NoYXJlZFByb2plY3Rpb25EaXJ0eSA9IEJvb2xlYW4obm9kZS5pc1Byb2plY3Rpb25EaXJ0eSB8fFxuICAgICAgICBub2RlLnBhcmVudC5pc1Byb2plY3Rpb25EaXJ0eSB8fFxuICAgICAgICBub2RlLnBhcmVudC5pc1NoYXJlZFByb2plY3Rpb25EaXJ0eSkpO1xuICAgIG5vZGUuaXNUcmFuc2Zvcm1EaXJ0eSB8fCAobm9kZS5pc1RyYW5zZm9ybURpcnR5ID0gbm9kZS5wYXJlbnQuaXNUcmFuc2Zvcm1EaXJ0eSk7XG59XG5mdW5jdGlvbiBjbGVhbkRpcnR5Tm9kZXMobm9kZSkge1xuICAgIG5vZGUuaXNQcm9qZWN0aW9uRGlydHkgPVxuICAgICAgICBub2RlLmlzU2hhcmVkUHJvamVjdGlvbkRpcnR5ID1cbiAgICAgICAgICAgIG5vZGUuaXNUcmFuc2Zvcm1EaXJ0eSA9XG4gICAgICAgICAgICAgICAgZmFsc2U7XG59XG5mdW5jdGlvbiBjbGVhclNuYXBzaG90KG5vZGUpIHtcbiAgICBub2RlLmNsZWFyU25hcHNob3QoKTtcbn1cbmZ1bmN0aW9uIGNsZWFyTWVhc3VyZW1lbnRzKG5vZGUpIHtcbiAgICBub2RlLmNsZWFyTWVhc3VyZW1lbnRzKCk7XG59XG5mdW5jdGlvbiBjbGVhcklzTGF5b3V0RGlydHkobm9kZSkge1xuICAgIG5vZGUuaXNMYXlvdXREaXJ0eSA9IGZhbHNlO1xufVxuZnVuY3Rpb24gcmVzZXRUcmFuc2Zvcm1TdHlsZShub2RlKSB7XG4gICAgY29uc3QgeyB2aXN1YWxFbGVtZW50IH0gPSBub2RlLm9wdGlvbnM7XG4gICAgaWYgKHZpc3VhbEVsZW1lbnQgJiYgdmlzdWFsRWxlbWVudC5nZXRQcm9wcygpLm9uQmVmb3JlTGF5b3V0TWVhc3VyZSkge1xuICAgICAgICB2aXN1YWxFbGVtZW50Lm5vdGlmeShcIkJlZm9yZUxheW91dE1lYXN1cmVcIik7XG4gICAgfVxuICAgIG5vZGUucmVzZXRUcmFuc2Zvcm0oKTtcbn1cbmZ1bmN0aW9uIGZpbmlzaEFuaW1hdGlvbihub2RlKSB7XG4gICAgbm9kZS5maW5pc2hBbmltYXRpb24oKTtcbiAgICBub2RlLnRhcmdldERlbHRhID0gbm9kZS5yZWxhdGl2ZVRhcmdldCA9IG5vZGUudGFyZ2V0ID0gdW5kZWZpbmVkO1xuICAgIG5vZGUuaXNQcm9qZWN0aW9uRGlydHkgPSB0cnVlO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVRhcmdldERlbHRhKG5vZGUpIHtcbiAgICBub2RlLnJlc29sdmVUYXJnZXREZWx0YSgpO1xufVxuZnVuY3Rpb24gY2FsY1Byb2plY3Rpb24obm9kZSkge1xuICAgIG5vZGUuY2FsY1Byb2plY3Rpb24oKTtcbn1cbmZ1bmN0aW9uIHJlc2V0U2tld0FuZFJvdGF0aW9uKG5vZGUpIHtcbiAgICBub2RlLnJlc2V0U2tld0FuZFJvdGF0aW9uKCk7XG59XG5mdW5jdGlvbiByZW1vdmVMZWFkU25hcHNob3RzKHN0YWNrKSB7XG4gICAgc3RhY2sucmVtb3ZlTGVhZFNuYXBzaG90KCk7XG59XG5mdW5jdGlvbiBtaXhBeGlzRGVsdGEob3V0cHV0LCBkZWx0YSwgcCkge1xuICAgIG91dHB1dC50cmFuc2xhdGUgPSBtaXhOdW1iZXIkMShkZWx0YS50cmFuc2xhdGUsIDAsIHApO1xuICAgIG91dHB1dC5zY2FsZSA9IG1peE51bWJlciQxKGRlbHRhLnNjYWxlLCAxLCBwKTtcbiAgICBvdXRwdXQub3JpZ2luID0gZGVsdGEub3JpZ2luO1xuICAgIG91dHB1dC5vcmlnaW5Qb2ludCA9IGRlbHRhLm9yaWdpblBvaW50O1xufVxuZnVuY3Rpb24gbWl4QXhpcyhvdXRwdXQsIGZyb20sIHRvLCBwKSB7XG4gICAgb3V0cHV0Lm1pbiA9IG1peE51bWJlciQxKGZyb20ubWluLCB0by5taW4sIHApO1xuICAgIG91dHB1dC5tYXggPSBtaXhOdW1iZXIkMShmcm9tLm1heCwgdG8ubWF4LCBwKTtcbn1cbmZ1bmN0aW9uIG1peEJveChvdXRwdXQsIGZyb20sIHRvLCBwKSB7XG4gICAgbWl4QXhpcyhvdXRwdXQueCwgZnJvbS54LCB0by54LCBwKTtcbiAgICBtaXhBeGlzKG91dHB1dC55LCBmcm9tLnksIHRvLnksIHApO1xufVxuZnVuY3Rpb24gaGFzT3BhY2l0eUNyb3NzZmFkZShub2RlKSB7XG4gICAgcmV0dXJuIChub2RlLmFuaW1hdGlvblZhbHVlcyAmJiBub2RlLmFuaW1hdGlvblZhbHVlcy5vcGFjaXR5RXhpdCAhPT0gdW5kZWZpbmVkKTtcbn1cbmNvbnN0IGRlZmF1bHRMYXlvdXRUcmFuc2l0aW9uID0ge1xuICAgIGR1cmF0aW9uOiAwLjQ1LFxuICAgIGVhc2U6IFswLjQsIDAsIDAuMSwgMV0sXG59O1xuY29uc3QgdXNlckFnZW50Q29udGFpbnMgPSAoc3RyaW5nKSA9PiB0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJlxuICAgIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhzdHJpbmcpO1xuLyoqXG4gKiBNZWFzdXJlZCBib3VuZGluZyBib3hlcyBtdXN0IGJlIHJvdW5kZWQgaW4gU2FmYXJpIGFuZFxuICogbGVmdCB1bnRvdWNoZWQgaW4gQ2hyb21lLCBvdGhlcndpc2Ugbm9uLWludGVnZXIgbGF5b3V0cyB3aXRoaW4gc2NhbGVkLXVwIGVsZW1lbnRzXG4gKiBjYW4gYXBwZWFyIHRvIGp1bXAuXG4gKi9cbmNvbnN0IHJvdW5kUG9pbnQgPSB1c2VyQWdlbnRDb250YWlucyhcImFwcGxld2Via2l0L1wiKSAmJiAhdXNlckFnZW50Q29udGFpbnMoXCJjaHJvbWUvXCIpXG4gICAgPyBNYXRoLnJvdW5kXG4gICAgOiBtb3Rpb25VdGlscy5ub29wO1xuZnVuY3Rpb24gcm91bmRBeGlzKGF4aXMpIHtcbiAgICAvLyBSb3VuZCB0byB0aGUgbmVhcmVzdCAuNSBwaXhlbHMgdG8gc3VwcG9ydCBzdWJwaXhlbCBsYXlvdXRzXG4gICAgYXhpcy5taW4gPSByb3VuZFBvaW50KGF4aXMubWluKTtcbiAgICBheGlzLm1heCA9IHJvdW5kUG9pbnQoYXhpcy5tYXgpO1xufVxuZnVuY3Rpb24gcm91bmRCb3goYm94KSB7XG4gICAgcm91bmRBeGlzKGJveC54KTtcbiAgICByb3VuZEF4aXMoYm94LnkpO1xufVxuZnVuY3Rpb24gc2hvdWxkQW5pbWF0ZVBvc2l0aW9uT25seShhbmltYXRpb25UeXBlLCBzbmFwc2hvdCwgbGF5b3V0KSB7XG4gICAgcmV0dXJuIChhbmltYXRpb25UeXBlID09PSBcInBvc2l0aW9uXCIgfHxcbiAgICAgICAgKGFuaW1hdGlvblR5cGUgPT09IFwicHJlc2VydmUtYXNwZWN0XCIgJiZcbiAgICAgICAgICAgICFpc05lYXIoYXNwZWN0UmF0aW8oc25hcHNob3QpLCBhc3BlY3RSYXRpbyhsYXlvdXQpLCAwLjIpKSk7XG59XG5mdW5jdGlvbiBjaGVja05vZGVXYXNTY3JvbGxSb290KG5vZGUpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIG5vZGUgIT09IG5vZGUucm9vdCAmJiAoKF9hID0gbm9kZS5zY3JvbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS53YXNSb290KTtcbn1cblxuY29uc3QgRG9jdW1lbnRQcm9qZWN0aW9uTm9kZSA9IGNyZWF0ZVByb2plY3Rpb25Ob2RlJDEoe1xuICAgIGF0dGFjaFJlc2l6ZUxpc3RlbmVyOiAocmVmLCBub3RpZnkpID0+IGFkZERvbUV2ZW50KHJlZiwgXCJyZXNpemVcIiwgbm90aWZ5KSxcbiAgICBtZWFzdXJlU2Nyb2xsOiAoKSA9PiAoe1xuICAgICAgICB4OiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQsXG4gICAgICAgIHk6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AsXG4gICAgfSksXG4gICAgY2hlY2tJc1Njcm9sbFJvb3Q6ICgpID0+IHRydWUsXG59KTtcblxuY29uc3Qgcm9vdFByb2plY3Rpb25Ob2RlID0ge1xuICAgIGN1cnJlbnQ6IHVuZGVmaW5lZCxcbn07XG5jb25zdCBIVE1MUHJvamVjdGlvbk5vZGUgPSBjcmVhdGVQcm9qZWN0aW9uTm9kZSQxKHtcbiAgICBtZWFzdXJlU2Nyb2xsOiAoaW5zdGFuY2UpID0+ICh7XG4gICAgICAgIHg6IGluc3RhbmNlLnNjcm9sbExlZnQsXG4gICAgICAgIHk6IGluc3RhbmNlLnNjcm9sbFRvcCxcbiAgICB9KSxcbiAgICBkZWZhdWx0UGFyZW50OiAoKSA9PiB7XG4gICAgICAgIGlmICghcm9vdFByb2plY3Rpb25Ob2RlLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50Tm9kZSA9IG5ldyBEb2N1bWVudFByb2plY3Rpb25Ob2RlKHt9KTtcbiAgICAgICAgICAgIGRvY3VtZW50Tm9kZS5tb3VudCh3aW5kb3cpO1xuICAgICAgICAgICAgZG9jdW1lbnROb2RlLnNldE9wdGlvbnMoeyBsYXlvdXRTY3JvbGw6IHRydWUgfSk7XG4gICAgICAgICAgICByb290UHJvamVjdGlvbk5vZGUuY3VycmVudCA9IGRvY3VtZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm9vdFByb2plY3Rpb25Ob2RlLmN1cnJlbnQ7XG4gICAgfSxcbiAgICByZXNldFRyYW5zZm9ybTogKGluc3RhbmNlLCB2YWx1ZSkgPT4ge1xuICAgICAgICBpbnN0YW5jZS5zdHlsZS50cmFuc2Zvcm0gPSB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiBcIm5vbmVcIjtcbiAgICB9LFxuICAgIGNoZWNrSXNTY3JvbGxSb290OiAoaW5zdGFuY2UpID0+IEJvb2xlYW4od2luZG93LmdldENvbXB1dGVkU3R5bGUoaW5zdGFuY2UpLnBvc2l0aW9uID09PSBcImZpeGVkXCIpLFxufSk7XG5cbmNvbnN0IG5vdGlmeSA9IChub2RlKSA9PiAhbm9kZS5pc0xheW91dERpcnR5ICYmIG5vZGUud2lsbFVwZGF0ZShmYWxzZSk7XG5mdW5jdGlvbiBub2RlR3JvdXAoKSB7XG4gICAgY29uc3Qgbm9kZXMgPSBuZXcgU2V0KCk7XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9ucyA9IG5ldyBXZWFrTWFwKCk7XG4gICAgY29uc3QgZGlydHlBbGwgPSAoKSA9PiBub2Rlcy5mb3JFYWNoKG5vdGlmeSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkOiAobm9kZSkgPT4ge1xuICAgICAgICAgICAgbm9kZXMuYWRkKG5vZGUpO1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9ucy5zZXQobm9kZSwgbm9kZS5hZGRFdmVudExpc3RlbmVyKFwid2lsbFVwZGF0ZVwiLCBkaXJ0eUFsbCkpO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmU6IChub2RlKSA9PiB7XG4gICAgICAgICAgICBub2Rlcy5kZWxldGUobm9kZSk7XG4gICAgICAgICAgICBjb25zdCB1bnN1YnNjcmliZSA9IHN1YnNjcmlwdGlvbnMuZ2V0KG5vZGUpO1xuICAgICAgICAgICAgaWYgKHVuc3Vic2NyaWJlKSB7XG4gICAgICAgICAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb25zLmRlbGV0ZShub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpcnR5QWxsKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGRpcnR5OiBkaXJ0eUFsbCxcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBwaXhlbHNUb1BlcmNlbnQocGl4ZWxzLCBheGlzKSB7XG4gICAgaWYgKGF4aXMubWF4ID09PSBheGlzLm1pbilcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgcmV0dXJuIChwaXhlbHMgLyAoYXhpcy5tYXggLSBheGlzLm1pbikpICogMTAwO1xufVxuLyoqXG4gKiBXZSBhbHdheXMgY29ycmVjdCBib3JkZXJSYWRpdXMgYXMgYSBwZXJjZW50YWdlIHJhdGhlciB0aGFuIHBpeGVscyB0byByZWR1Y2UgcGFpbnRzLlxuICogRm9yIGV4YW1wbGUsIGlmIHlvdSBhcmUgcHJvamVjdGluZyBhIGJveCB0aGF0IGlzIDEwMHB4IHdpZGUgd2l0aCBhIDEwcHggYm9yZGVyUmFkaXVzXG4gKiBpbnRvIGEgYm94IHRoYXQgaXMgMjAwcHggd2lkZSB3aXRoIGEgMjBweCBib3JkZXJSYWRpdXMsIHRoYXQgaXMgYWN0dWFsbHkgYSAxMCVcbiAqIGJvcmRlclJhZGl1cyBpbiBib3RoIHN0YXRlcy4gSWYgd2UgYW5pbWF0ZSBiZXR3ZWVuIHRoZSB0d28gaW4gcGl4ZWxzIHRoYXQgd2lsbCB0cmlnZ2VyXG4gKiBhIHBhaW50IGVhY2ggdGltZS4gSWYgd2UgYW5pbWF0ZSBiZXR3ZWVuIHRoZSB0d28gaW4gcGVyY2VudGFnZSB3ZSdsbCBhdm9pZCBhIHBhaW50LlxuICovXG5jb25zdCBjb3JyZWN0Qm9yZGVyUmFkaXVzID0ge1xuICAgIGNvcnJlY3Q6IChsYXRlc3QsIG5vZGUpID0+IHtcbiAgICAgICAgaWYgKCFub2RlLnRhcmdldClcbiAgICAgICAgICAgIHJldHVybiBsYXRlc3Q7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBsYXRlc3QgaXMgYSBzdHJpbmcsIGlmIGl0J3MgYSBwZXJjZW50YWdlIHdlIGNhbiByZXR1cm4gaW1tZWRpYXRlbHkgYXMgaXQnc1xuICAgICAgICAgKiBnb2luZyB0byBiZSBzdHJldGNoZWQgYXBwcm9wcmlhdGVseS4gT3RoZXJ3aXNlLCBpZiBpdCdzIGEgcGl4ZWwsIGNvbnZlcnQgaXQgdG8gYSBudW1iZXIuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodHlwZW9mIGxhdGVzdCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKHB4LnRlc3QobGF0ZXN0KSkge1xuICAgICAgICAgICAgICAgIGxhdGVzdCA9IHBhcnNlRmxvYXQobGF0ZXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBsYXRlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGxhdGVzdCBpcyBhIG51bWJlciwgaXQncyBhIHBpeGVsIHZhbHVlLiBXZSB1c2UgdGhlIGN1cnJlbnQgdmlld3BvcnRCb3ggdG8gY2FsY3VsYXRlIHRoYXRcbiAgICAgICAgICogcGl4ZWwgdmFsdWUgYXMgYSBwZXJjZW50YWdlIG9mIGVhY2ggYXhpc1xuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgeCA9IHBpeGVsc1RvUGVyY2VudChsYXRlc3QsIG5vZGUudGFyZ2V0LngpO1xuICAgICAgICBjb25zdCB5ID0gcGl4ZWxzVG9QZXJjZW50KGxhdGVzdCwgbm9kZS50YXJnZXQueSk7XG4gICAgICAgIHJldHVybiBgJHt4fSUgJHt5fSVgO1xuICAgIH0sXG59O1xuXG5jb25zdCBjb3JyZWN0Qm94U2hhZG93ID0ge1xuICAgIGNvcnJlY3Q6IChsYXRlc3QsIHsgdHJlZVNjYWxlLCBwcm9qZWN0aW9uRGVsdGEgfSkgPT4ge1xuICAgICAgICBjb25zdCBvcmlnaW5hbCA9IGxhdGVzdDtcbiAgICAgICAgY29uc3Qgc2hhZG93ID0gY29tcGxleC5wYXJzZShsYXRlc3QpO1xuICAgICAgICAvLyBUT0RPOiBEb2Vzbid0IHN1cHBvcnQgbXVsdGlwbGUgc2hhZG93c1xuICAgICAgICBpZiAoc2hhZG93Lmxlbmd0aCA+IDUpXG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWw7XG4gICAgICAgIGNvbnN0IHRlbXBsYXRlID0gY29tcGxleC5jcmVhdGVUcmFuc2Zvcm1lcihsYXRlc3QpO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0eXBlb2Ygc2hhZG93WzBdICE9PSBcIm51bWJlclwiID8gMSA6IDA7XG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgb3ZlcmFsbCBjb250ZXh0IHNjYWxlXG4gICAgICAgIGNvbnN0IHhTY2FsZSA9IHByb2plY3Rpb25EZWx0YS54LnNjYWxlICogdHJlZVNjYWxlLng7XG4gICAgICAgIGNvbnN0IHlTY2FsZSA9IHByb2plY3Rpb25EZWx0YS55LnNjYWxlICogdHJlZVNjYWxlLnk7XG4gICAgICAgIHNoYWRvd1swICsgb2Zmc2V0XSAvPSB4U2NhbGU7XG4gICAgICAgIHNoYWRvd1sxICsgb2Zmc2V0XSAvPSB5U2NhbGU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZGVhbGx5IHdlJ2QgY29ycmVjdCB4IGFuZCB5IHNjYWxlcyBpbmRpdmlkdWFsbHksIGJ1dCBiZWNhdXNlIGJsdXIgYW5kXG4gICAgICAgICAqIHNwcmVhZCBhcHBseSB0byBib3RoIHdlIGhhdmUgdG8gdGFrZSBhIHNjYWxlIGF2ZXJhZ2UgYW5kIGFwcGx5IHRoYXQgaW5zdGVhZC5cbiAgICAgICAgICogV2UgY291bGQgcG90ZW50aWFsbHkgaW1wcm92ZSB0aGUgb3V0Y29tZSBvZiB0aGlzIGJ5IGluY29ycG9yYXRpbmcgdGhlIHJhdGlvIGJldHdlZW5cbiAgICAgICAgICogdGhlIHR3byBzY2FsZXMuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBhdmVyYWdlU2NhbGUgPSBtaXhOdW1iZXIkMSh4U2NhbGUsIHlTY2FsZSwgMC41KTtcbiAgICAgICAgLy8gQmx1clxuICAgICAgICBpZiAodHlwZW9mIHNoYWRvd1syICsgb2Zmc2V0XSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHNoYWRvd1syICsgb2Zmc2V0XSAvPSBhdmVyYWdlU2NhbGU7XG4gICAgICAgIC8vIFNwcmVhZFxuICAgICAgICBpZiAodHlwZW9mIHNoYWRvd1szICsgb2Zmc2V0XSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHNoYWRvd1szICsgb2Zmc2V0XSAvPSBhdmVyYWdlU2NhbGU7XG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZShzaGFkb3cpO1xuICAgIH0sXG59O1xuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgUHJlc2VuY2VDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcblxuLyoqXG4gKiBXaGVuIGEgY29tcG9uZW50IGlzIHRoZSBjaGlsZCBvZiBgQW5pbWF0ZVByZXNlbmNlYCwgaXQgY2FuIHVzZSBgdXNlUHJlc2VuY2VgXG4gKiB0byBhY2Nlc3MgaW5mb3JtYXRpb24gYWJvdXQgd2hldGhlciBpdCdzIHN0aWxsIHByZXNlbnQgaW4gdGhlIFJlYWN0IHRyZWUuXG4gKlxuICogYGBganN4XG4gKiBpbXBvcnQgeyB1c2VQcmVzZW5jZSB9IGZyb20gXCJmcmFtZXItbW90aW9uXCJcbiAqXG4gKiBleHBvcnQgY29uc3QgQ29tcG9uZW50ID0gKCkgPT4ge1xuICogICBjb25zdCBbaXNQcmVzZW50LCBzYWZlVG9SZW1vdmVdID0gdXNlUHJlc2VuY2UoKVxuICpcbiAqICAgdXNlRWZmZWN0KCgpID0+IHtcbiAqICAgICAhaXNQcmVzZW50ICYmIHNldFRpbWVvdXQoc2FmZVRvUmVtb3ZlLCAxMDAwKVxuICogICB9LCBbaXNQcmVzZW50XSlcbiAqXG4gKiAgIHJldHVybiA8ZGl2IC8+XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBJZiBgaXNQcmVzZW50YCBpcyBgZmFsc2VgLCBpdCBtZWFucyB0aGF0IGEgY29tcG9uZW50IGhhcyBiZWVuIHJlbW92ZWQgdGhlIHRyZWUsIGJ1dFxuICogYEFuaW1hdGVQcmVzZW5jZWAgd29uJ3QgcmVhbGx5IHJlbW92ZSBpdCB1bnRpbCBgc2FmZVRvUmVtb3ZlYCBoYXMgYmVlbiBjYWxsZWQuXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB1c2VQcmVzZW5jZSgpIHtcbiAgICBjb25zdCBjb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChQcmVzZW5jZUNvbnRleHQpO1xuICAgIGlmIChjb250ZXh0ID09PSBudWxsKVxuICAgICAgICByZXR1cm4gW3RydWUsIG51bGxdO1xuICAgIGNvbnN0IHsgaXNQcmVzZW50LCBvbkV4aXRDb21wbGV0ZSwgcmVnaXN0ZXIgfSA9IGNvbnRleHQ7XG4gICAgLy8gSXQncyBzYWZlIHRvIGNhbGwgdGhlIGZvbGxvd2luZyBob29rcyBjb25kaXRpb25hbGx5IChhZnRlciBhbiBlYXJseSByZXR1cm4pIGJlY2F1c2UgdGhlIGNvbnRleHQgd2lsbCBhbHdheXNcbiAgICAvLyBlaXRoZXIgYmUgbnVsbCBvciBub24tbnVsbCBmb3IgdGhlIGxpZmVzcGFuIG9mIHRoZSBjb21wb25lbnQuXG4gICAgY29uc3QgaWQgPSBSZWFjdC51c2VJZCgpO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiByZWdpc3RlcihpZCksIFtdKTtcbiAgICBjb25zdCBzYWZlVG9SZW1vdmUgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiBvbkV4aXRDb21wbGV0ZSAmJiBvbkV4aXRDb21wbGV0ZShpZCksIFtpZCwgb25FeGl0Q29tcGxldGVdKTtcbiAgICByZXR1cm4gIWlzUHJlc2VudCAmJiBvbkV4aXRDb21wbGV0ZSA/IFtmYWxzZSwgc2FmZVRvUmVtb3ZlXSA6IFt0cnVlXTtcbn1cbi8qKlxuICogU2ltaWxhciB0byBgdXNlUHJlc2VuY2VgLCBleGNlcHQgYHVzZUlzUHJlc2VudGAgc2ltcGx5IHJldHVybnMgd2hldGhlciBvciBub3QgdGhlIGNvbXBvbmVudCBpcyBwcmVzZW50LlxuICogVGhlcmUgaXMgbm8gYHNhZmVUb1JlbW92ZWAgZnVuY3Rpb24uXG4gKlxuICogYGBganN4XG4gKiBpbXBvcnQgeyB1c2VJc1ByZXNlbnQgfSBmcm9tIFwiZnJhbWVyLW1vdGlvblwiXG4gKlxuICogZXhwb3J0IGNvbnN0IENvbXBvbmVudCA9ICgpID0+IHtcbiAqICAgY29uc3QgaXNQcmVzZW50ID0gdXNlSXNQcmVzZW50KClcbiAqXG4gKiAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gKiAgICAgIWlzUHJlc2VudCAmJiBjb25zb2xlLmxvZyhcIkkndmUgYmVlbiByZW1vdmVkIVwiKVxuICogICB9LCBbaXNQcmVzZW50XSlcbiAqXG4gKiAgIHJldHVybiA8ZGl2IC8+XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHVzZUlzUHJlc2VudCgpIHtcbiAgICByZXR1cm4gaXNQcmVzZW50KFJlYWN0LnVzZUNvbnRleHQoUHJlc2VuY2VDb250ZXh0KSk7XG59XG5mdW5jdGlvbiBpc1ByZXNlbnQoY29udGV4dCkge1xuICAgIHJldHVybiBjb250ZXh0ID09PSBudWxsID8gdHJ1ZSA6IGNvbnRleHQuaXNQcmVzZW50O1xufVxuXG5jb25zdCBMYXlvdXRHcm91cENvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KHt9KTtcblxuLyoqXG4gKiBJbnRlcm5hbCwgZXhwb3J0ZWQgb25seSBmb3IgdXNhZ2UgaW4gRnJhbWVyXG4gKi9cbmNvbnN0IFN3aXRjaExheW91dEdyb3VwQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoe30pO1xuXG5jbGFzcyBNZWFzdXJlTGF5b3V0V2l0aENvbnRleHQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIFRoaXMgb25seSBtb3VudHMgcHJvamVjdGlvbiBub2RlcyBmb3IgY29tcG9uZW50cyB0aGF0XG4gICAgICogbmVlZCBtZWFzdXJpbmcsIHdlIG1pZ2h0IHdhbnQgdG8gZG8gaXQgZm9yIGFsbCBjb21wb25lbnRzXG4gICAgICogaW4gb3JkZXIgdG8gaW5jb3Jwb3JhdGUgdHJhbnNmb3Jtc1xuICAgICAqL1xuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBjb25zdCB7IHZpc3VhbEVsZW1lbnQsIGxheW91dEdyb3VwLCBzd2l0Y2hMYXlvdXRHcm91cCwgbGF5b3V0SWQgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHsgcHJvamVjdGlvbiB9ID0gdmlzdWFsRWxlbWVudDtcbiAgICAgICAgYWRkU2NhbGVDb3JyZWN0b3IoZGVmYXVsdFNjYWxlQ29ycmVjdG9ycyk7XG4gICAgICAgIGlmIChwcm9qZWN0aW9uKSB7XG4gICAgICAgICAgICBpZiAobGF5b3V0R3JvdXAuZ3JvdXApXG4gICAgICAgICAgICAgICAgbGF5b3V0R3JvdXAuZ3JvdXAuYWRkKHByb2plY3Rpb24pO1xuICAgICAgICAgICAgaWYgKHN3aXRjaExheW91dEdyb3VwICYmIHN3aXRjaExheW91dEdyb3VwLnJlZ2lzdGVyICYmIGxheW91dElkKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoTGF5b3V0R3JvdXAucmVnaXN0ZXIocHJvamVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9qZWN0aW9uLnJvb3QuZGlkVXBkYXRlKCk7XG4gICAgICAgICAgICBwcm9qZWN0aW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25Db21wbGV0ZVwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zYWZlVG9SZW1vdmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcHJvamVjdGlvbi5zZXRPcHRpb25zKHtcbiAgICAgICAgICAgICAgICAuLi5wcm9qZWN0aW9uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgb25FeGl0Q29tcGxldGU6ICgpID0+IHRoaXMuc2FmZVRvUmVtb3ZlKCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBnbG9iYWxQcm9qZWN0aW9uU3RhdGUuaGFzRXZlclVwZGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAgICAgY29uc3QgeyBsYXlvdXREZXBlbmRlbmN5LCB2aXN1YWxFbGVtZW50LCBkcmFnLCBpc1ByZXNlbnQgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHByb2plY3Rpb24gPSB2aXN1YWxFbGVtZW50LnByb2plY3Rpb247XG4gICAgICAgIGlmICghcHJvamVjdGlvbilcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogVE9ETzogV2UgdXNlIHRoaXMgZGF0YSBpbiByZWxlZ2F0ZSB0byBkZXRlcm1pbmUgd2hldGhlciB0b1xuICAgICAgICAgKiBwcm9tb3RlIGEgcHJldmlvdXMgZWxlbWVudC4gVGhlcmUncyBubyBndWFyYW50ZWUgaXRzIHByZXNlbmNlIGRhdGFcbiAgICAgICAgICogd2lsbCBoYXZlIHVwZGF0ZWQgYnkgdGhpcyBwb2ludCAtIGlmIGEgYnVnIGxpa2UgdGhpcyBhcmlzZXMgaXQgd2lsbFxuICAgICAgICAgKiBoYXZlIHRvIGJlIHRoYXQgd2UgbWFya0ZvclJlbGVnYXRpb24gYW5kIHRoZW4gZmluZCBhIG5ldyBsZWFkIHNvbWUgb3RoZXIgd2F5LFxuICAgICAgICAgKiBwZXJoYXBzIGluIGRpZFVwZGF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgcHJvamVjdGlvbi5pc1ByZXNlbnQgPSBpc1ByZXNlbnQ7XG4gICAgICAgIGlmIChkcmFnIHx8XG4gICAgICAgICAgICBwcmV2UHJvcHMubGF5b3V0RGVwZW5kZW5jeSAhPT0gbGF5b3V0RGVwZW5kZW5jeSB8fFxuICAgICAgICAgICAgbGF5b3V0RGVwZW5kZW5jeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwcm9qZWN0aW9uLndpbGxVcGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2FmZVRvUmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZQcm9wcy5pc1ByZXNlbnQgIT09IGlzUHJlc2VudCkge1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudCkge1xuICAgICAgICAgICAgICAgIHByb2plY3Rpb24ucHJvbW90ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXByb2plY3Rpb24ucmVsZWdhdGUoKSkge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIElmIHRoZXJlJ3MgYW5vdGhlciBzdGFjayBtZW1iZXIgdGFraW5nIG92ZXIgZnJvbSB0aGlzIG9uZSxcbiAgICAgICAgICAgICAgICAgKiBpdCdzIGluIGNoYXJnZSBvZiB0aGUgZXhpdCBhbmltYXRpb24gYW5kIHRoZXJlZm9yZSBzaG91bGRcbiAgICAgICAgICAgICAgICAgKiBiZSBpbiBjaGFyZ2Ugb2YgdGhlIHNhZmUgdG8gcmVtb3ZlLiBPdGhlcndpc2Ugd2UgY2FsbCBpdCBoZXJlLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGZyYW1lLnBvc3RSZW5kZXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGFjayA9IHByb2plY3Rpb24uZ2V0U3RhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdGFjayB8fCAhc3RhY2subWVtYmVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2FmZVRvUmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICBjb25zdCB7IHByb2plY3Rpb24gfSA9IHRoaXMucHJvcHMudmlzdWFsRWxlbWVudDtcbiAgICAgICAgaWYgKHByb2plY3Rpb24pIHtcbiAgICAgICAgICAgIHByb2plY3Rpb24ucm9vdC5kaWRVcGRhdGUoKTtcbiAgICAgICAgICAgIG1pY3JvdGFzay5wb3N0UmVuZGVyKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXByb2plY3Rpb24uY3VycmVudEFuaW1hdGlvbiAmJiBwcm9qZWN0aW9uLmlzTGVhZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2FmZVRvUmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIGNvbnN0IHsgdmlzdWFsRWxlbWVudCwgbGF5b3V0R3JvdXAsIHN3aXRjaExheW91dEdyb3VwOiBwcm9tb3RlQ29udGV4dCwgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHsgcHJvamVjdGlvbiB9ID0gdmlzdWFsRWxlbWVudDtcbiAgICAgICAgaWYgKHByb2plY3Rpb24pIHtcbiAgICAgICAgICAgIHByb2plY3Rpb24uc2NoZWR1bGVDaGVja0FmdGVyVW5tb3VudCgpO1xuICAgICAgICAgICAgaWYgKGxheW91dEdyb3VwICYmIGxheW91dEdyb3VwLmdyb3VwKVxuICAgICAgICAgICAgICAgIGxheW91dEdyb3VwLmdyb3VwLnJlbW92ZShwcm9qZWN0aW9uKTtcbiAgICAgICAgICAgIGlmIChwcm9tb3RlQ29udGV4dCAmJiBwcm9tb3RlQ29udGV4dC5kZXJlZ2lzdGVyKVxuICAgICAgICAgICAgICAgIHByb21vdGVDb250ZXh0LmRlcmVnaXN0ZXIocHJvamVjdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2FmZVRvUmVtb3ZlKCkge1xuICAgICAgICBjb25zdCB7IHNhZmVUb1JlbW92ZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgc2FmZVRvUmVtb3ZlICYmIHNhZmVUb1JlbW92ZSgpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIE1lYXN1cmVMYXlvdXQocHJvcHMpIHtcbiAgICBjb25zdCBbaXNQcmVzZW50LCBzYWZlVG9SZW1vdmVdID0gdXNlUHJlc2VuY2UoKTtcbiAgICBjb25zdCBsYXlvdXRHcm91cCA9IFJlYWN0LnVzZUNvbnRleHQoTGF5b3V0R3JvdXBDb250ZXh0KTtcbiAgICByZXR1cm4gKGpzeFJ1bnRpbWUuanN4KE1lYXN1cmVMYXlvdXRXaXRoQ29udGV4dCwgeyAuLi5wcm9wcywgbGF5b3V0R3JvdXA6IGxheW91dEdyb3VwLCBzd2l0Y2hMYXlvdXRHcm91cDogUmVhY3QudXNlQ29udGV4dChTd2l0Y2hMYXlvdXRHcm91cENvbnRleHQpLCBpc1ByZXNlbnQ6IGlzUHJlc2VudCwgc2FmZVRvUmVtb3ZlOiBzYWZlVG9SZW1vdmUgfSkpO1xufVxuY29uc3QgZGVmYXVsdFNjYWxlQ29ycmVjdG9ycyA9IHtcbiAgICBib3JkZXJSYWRpdXM6IHtcbiAgICAgICAgLi4uY29ycmVjdEJvcmRlclJhZGl1cyxcbiAgICAgICAgYXBwbHlUbzogW1xuICAgICAgICAgICAgXCJib3JkZXJUb3BMZWZ0UmFkaXVzXCIsXG4gICAgICAgICAgICBcImJvcmRlclRvcFJpZ2h0UmFkaXVzXCIsXG4gICAgICAgICAgICBcImJvcmRlckJvdHRvbUxlZnRSYWRpdXNcIixcbiAgICAgICAgICAgIFwiYm9yZGVyQm90dG9tUmlnaHRSYWRpdXNcIixcbiAgICAgICAgXSxcbiAgICB9LFxuICAgIGJvcmRlclRvcExlZnRSYWRpdXM6IGNvcnJlY3RCb3JkZXJSYWRpdXMsXG4gICAgYm9yZGVyVG9wUmlnaHRSYWRpdXM6IGNvcnJlY3RCb3JkZXJSYWRpdXMsXG4gICAgYm9yZGVyQm90dG9tTGVmdFJhZGl1czogY29ycmVjdEJvcmRlclJhZGl1cyxcbiAgICBib3JkZXJCb3R0b21SaWdodFJhZGl1czogY29ycmVjdEJvcmRlclJhZGl1cyxcbiAgICBib3hTaGFkb3c6IGNvcnJlY3RCb3hTaGFkb3csXG59O1xuXG5jb25zdCBkcmFnID0ge1xuICAgIHBhbjoge1xuICAgICAgICBGZWF0dXJlOiBQYW5HZXN0dXJlLFxuICAgIH0sXG4gICAgZHJhZzoge1xuICAgICAgICBGZWF0dXJlOiBEcmFnR2VzdHVyZSxcbiAgICAgICAgUHJvamVjdGlvbk5vZGU6IEhUTUxQcm9qZWN0aW9uTm9kZSxcbiAgICAgICAgTWVhc3VyZUxheW91dCxcbiAgICB9LFxufTtcblxuZnVuY3Rpb24gaGFuZGxlSG92ZXJFdmVudChub2RlLCBldmVudCwgbGlmZWN5Y2xlKSB7XG4gICAgY29uc3QgeyBwcm9wcyB9ID0gbm9kZTtcbiAgICBpZiAobm9kZS5hbmltYXRpb25TdGF0ZSAmJiBwcm9wcy53aGlsZUhvdmVyKSB7XG4gICAgICAgIG5vZGUuYW5pbWF0aW9uU3RhdGUuc2V0QWN0aXZlKFwid2hpbGVIb3ZlclwiLCBsaWZlY3ljbGUgPT09IFwiU3RhcnRcIik7XG4gICAgfVxuICAgIGNvbnN0IGV2ZW50TmFtZSA9IChcIm9uSG92ZXJcIiArIGxpZmVjeWNsZSk7XG4gICAgY29uc3QgY2FsbGJhY2sgPSBwcm9wc1tldmVudE5hbWVdO1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBmcmFtZS5wb3N0UmVuZGVyKCgpID0+IGNhbGxiYWNrKGV2ZW50LCBleHRyYWN0RXZlbnRJbmZvKGV2ZW50KSkpO1xuICAgIH1cbn1cbmNsYXNzIEhvdmVyR2VzdHVyZSBleHRlbmRzIEZlYXR1cmUge1xuICAgIG1vdW50KCkge1xuICAgICAgICBjb25zdCB7IGN1cnJlbnQgfSA9IHRoaXMubm9kZTtcbiAgICAgICAgaWYgKCFjdXJyZW50KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnVubW91bnQgPSBtb3Rpb25Eb20uaG92ZXIoY3VycmVudCwgKHN0YXJ0RXZlbnQpID0+IHtcbiAgICAgICAgICAgIGhhbmRsZUhvdmVyRXZlbnQodGhpcy5ub2RlLCBzdGFydEV2ZW50LCBcIlN0YXJ0XCIpO1xuICAgICAgICAgICAgcmV0dXJuIChlbmRFdmVudCkgPT4gaGFuZGxlSG92ZXJFdmVudCh0aGlzLm5vZGUsIGVuZEV2ZW50LCBcIkVuZFwiKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVubW91bnQoKSB7IH1cbn1cblxuY2xhc3MgRm9jdXNHZXN0dXJlIGV4dGVuZHMgRmVhdHVyZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcbiAgICB9XG4gICAgb25Gb2N1cygpIHtcbiAgICAgICAgbGV0IGlzRm9jdXNWaXNpYmxlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGlzIGVsZW1lbnQgZG9lc24ndCBtYXRjaCBmb2N1cy12aXNpYmxlIHRoZW4gZG9uJ3RcbiAgICAgICAgICogYXBwbHkgd2hpbGVIb3Zlci4gQnV0LCBpZiBtYXRjaGVzIHRocm93cyB0aGF0IGZvY3VzLXZpc2libGVcbiAgICAgICAgICogaXMgbm90IGEgdmFsaWQgc2VsZWN0b3IgdGhlbiBpbiB0aGF0IGJyb3dzZXIgb3V0bGluZSBzdHlsZXMgd2lsbCBiZSBhcHBsaWVkXG4gICAgICAgICAqIHRvIHRoZSBlbGVtZW50IGJ5IGRlZmF1bHQgYW5kIHdlIHdhbnQgdG8gbWF0Y2ggdGhhdCBiZWhhdmlvdXIgd2l0aCB3aGlsZUZvY3VzLlxuICAgICAgICAgKi9cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlzRm9jdXNWaXNpYmxlID0gdGhpcy5ub2RlLmN1cnJlbnQubWF0Y2hlcyhcIjpmb2N1cy12aXNpYmxlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpc0ZvY3VzVmlzaWJsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0ZvY3VzVmlzaWJsZSB8fCAhdGhpcy5ub2RlLmFuaW1hdGlvblN0YXRlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLm5vZGUuYW5pbWF0aW9uU3RhdGUuc2V0QWN0aXZlKFwid2hpbGVGb2N1c1wiLCB0cnVlKTtcbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IHRydWU7XG4gICAgfVxuICAgIG9uQmx1cigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQWN0aXZlIHx8ICF0aGlzLm5vZGUuYW5pbWF0aW9uU3RhdGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMubm9kZS5hbmltYXRpb25TdGF0ZS5zZXRBY3RpdmUoXCJ3aGlsZUZvY3VzXCIsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgIH1cbiAgICBtb3VudCgpIHtcbiAgICAgICAgdGhpcy51bm1vdW50ID0gcGlwZShhZGREb21FdmVudCh0aGlzLm5vZGUuY3VycmVudCwgXCJmb2N1c1wiLCAoKSA9PiB0aGlzLm9uRm9jdXMoKSksIGFkZERvbUV2ZW50KHRoaXMubm9kZS5jdXJyZW50LCBcImJsdXJcIiwgKCkgPT4gdGhpcy5vbkJsdXIoKSkpO1xuICAgIH1cbiAgICB1bm1vdW50KCkgeyB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVByZXNzRXZlbnQobm9kZSwgZXZlbnQsIGxpZmVjeWNsZSkge1xuICAgIGNvbnN0IHsgcHJvcHMgfSA9IG5vZGU7XG4gICAgaWYgKG5vZGUuYW5pbWF0aW9uU3RhdGUgJiYgcHJvcHMud2hpbGVUYXApIHtcbiAgICAgICAgbm9kZS5hbmltYXRpb25TdGF0ZS5zZXRBY3RpdmUoXCJ3aGlsZVRhcFwiLCBsaWZlY3ljbGUgPT09IFwiU3RhcnRcIik7XG4gICAgfVxuICAgIGNvbnN0IGV2ZW50TmFtZSA9IChcIm9uVGFwXCIgKyAobGlmZWN5Y2xlID09PSBcIkVuZFwiID8gXCJcIiA6IGxpZmVjeWNsZSkpO1xuICAgIGNvbnN0IGNhbGxiYWNrID0gcHJvcHNbZXZlbnROYW1lXTtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgZnJhbWUucG9zdFJlbmRlcigoKSA9PiBjYWxsYmFjayhldmVudCwgZXh0cmFjdEV2ZW50SW5mbyhldmVudCkpKTtcbiAgICB9XG59XG5jbGFzcyBQcmVzc0dlc3R1cmUgZXh0ZW5kcyBGZWF0dXJlIHtcbiAgICBtb3VudCgpIHtcbiAgICAgICAgY29uc3QgeyBjdXJyZW50IH0gPSB0aGlzLm5vZGU7XG4gICAgICAgIGlmICghY3VycmVudClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy51bm1vdW50ID0gbW90aW9uRG9tLnByZXNzKGN1cnJlbnQsIChzdGFydEV2ZW50KSA9PiB7XG4gICAgICAgICAgICBoYW5kbGVQcmVzc0V2ZW50KHRoaXMubm9kZSwgc3RhcnRFdmVudCwgXCJTdGFydFwiKTtcbiAgICAgICAgICAgIHJldHVybiAoZW5kRXZlbnQsIHsgc3VjY2VzcyB9KSA9PiBoYW5kbGVQcmVzc0V2ZW50KHRoaXMubm9kZSwgZW5kRXZlbnQsIHN1Y2Nlc3MgPyBcIkVuZFwiIDogXCJDYW5jZWxcIik7XG4gICAgICAgIH0sIHsgdXNlR2xvYmFsVGFyZ2V0OiB0aGlzLm5vZGUucHJvcHMuZ2xvYmFsVGFwVGFyZ2V0IH0pO1xuICAgIH1cbiAgICB1bm1vdW50KCkgeyB9XG59XG5cbi8qKlxuICogTWFwIGFuIEludGVyc2VjdGlvbkhhbmRsZXIgY2FsbGJhY2sgdG8gYW4gZWxlbWVudC4gV2Ugb25seSBldmVyIG1ha2Ugb25lIGhhbmRsZXIgZm9yIG9uZVxuICogZWxlbWVudCwgc28gZXZlbiB0aG91Z2ggdGhlc2UgaGFuZGxlcnMgbWlnaHQgYWxsIGJlIHRyaWdnZXJlZCBieSBkaWZmZXJlbnRcbiAqIG9ic2VydmVycywgd2UgY2FuIGtlZXAgdGhlbSBpbiB0aGUgc2FtZSBtYXAuXG4gKi9cbmNvbnN0IG9ic2VydmVyQ2FsbGJhY2tzID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogTXVsdGlwbGUgb2JzZXJ2ZXJzIGNhbiBiZSBjcmVhdGVkIGZvciBtdWx0aXBsZSBlbGVtZW50L2RvY3VtZW50IHJvb3RzLiBFYWNoIHdpdGhcbiAqIGRpZmZlcmVudCBzZXR0aW5ncy4gU28gaGVyZSB3ZSBzdG9yZSBkaWN0aW9uYXJpZXMgb2Ygb2JzZXJ2ZXJzIHRvIGVhY2ggcm9vdCxcbiAqIHVzaW5nIHNlcmlhbGlzZWQgc2V0dGluZ3MgKHRocmVzaG9sZC9tYXJnaW4pIGFzIGxvb2t1cCBrZXlzLlxuICovXG5jb25zdCBvYnNlcnZlcnMgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgZmlyZU9ic2VydmVyQ2FsbGJhY2sgPSAoZW50cnkpID0+IHtcbiAgICBjb25zdCBjYWxsYmFjayA9IG9ic2VydmVyQ2FsbGJhY2tzLmdldChlbnRyeS50YXJnZXQpO1xuICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGVudHJ5KTtcbn07XG5jb25zdCBmaXJlQWxsT2JzZXJ2ZXJDYWxsYmFja3MgPSAoZW50cmllcykgPT4ge1xuICAgIGVudHJpZXMuZm9yRWFjaChmaXJlT2JzZXJ2ZXJDYWxsYmFjayk7XG59O1xuZnVuY3Rpb24gaW5pdEludGVyc2VjdGlvbk9ic2VydmVyKHsgcm9vdCwgLi4ub3B0aW9ucyB9KSB7XG4gICAgY29uc3QgbG9va3VwUm9vdCA9IHJvb3QgfHwgZG9jdW1lbnQ7XG4gICAgLyoqXG4gICAgICogSWYgd2UgZG9uJ3QgaGF2ZSBhbiBvYnNlcnZlciBsb29rdXAgbWFwIGZvciB0aGlzIHJvb3QsIGNyZWF0ZSBvbmUuXG4gICAgICovXG4gICAgaWYgKCFvYnNlcnZlcnMuaGFzKGxvb2t1cFJvb3QpKSB7XG4gICAgICAgIG9ic2VydmVycy5zZXQobG9va3VwUm9vdCwge30pO1xuICAgIH1cbiAgICBjb25zdCByb290T2JzZXJ2ZXJzID0gb2JzZXJ2ZXJzLmdldChsb29rdXBSb290KTtcbiAgICBjb25zdCBrZXkgPSBKU09OLnN0cmluZ2lmeShvcHRpb25zKTtcbiAgICAvKipcbiAgICAgKiBJZiB3ZSBkb24ndCBoYXZlIGFuIG9ic2VydmVyIGZvciB0aGlzIGNvbWJpbmF0aW9uIG9mIHJvb3QgYW5kIHNldHRpbmdzLFxuICAgICAqIGNyZWF0ZSBvbmUuXG4gICAgICovXG4gICAgaWYgKCFyb290T2JzZXJ2ZXJzW2tleV0pIHtcbiAgICAgICAgcm9vdE9ic2VydmVyc1trZXldID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGZpcmVBbGxPYnNlcnZlckNhbGxiYWNrcywgeyByb290LCAuLi5vcHRpb25zIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcm9vdE9ic2VydmVyc1trZXldO1xufVxuZnVuY3Rpb24gb2JzZXJ2ZUludGVyc2VjdGlvbihlbGVtZW50LCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHJvb3RJbnRlcmVzZWN0aW9uT2JzZXJ2ZXIgPSBpbml0SW50ZXJzZWN0aW9uT2JzZXJ2ZXIob3B0aW9ucyk7XG4gICAgb2JzZXJ2ZXJDYWxsYmFja3Muc2V0KGVsZW1lbnQsIGNhbGxiYWNrKTtcbiAgICByb290SW50ZXJlc2VjdGlvbk9ic2VydmVyLm9ic2VydmUoZWxlbWVudCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgb2JzZXJ2ZXJDYWxsYmFja3MuZGVsZXRlKGVsZW1lbnQpO1xuICAgICAgICByb290SW50ZXJlc2VjdGlvbk9ic2VydmVyLnVub2JzZXJ2ZShlbGVtZW50KTtcbiAgICB9O1xufVxuXG5jb25zdCB0aHJlc2hvbGROYW1lcyA9IHtcbiAgICBzb21lOiAwLFxuICAgIGFsbDogMSxcbn07XG5jbGFzcyBJblZpZXdGZWF0dXJlIGV4dGVuZHMgRmVhdHVyZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuaGFzRW50ZXJlZFZpZXcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc0luVmlldyA9IGZhbHNlO1xuICAgIH1cbiAgICBzdGFydE9ic2VydmVyKCkge1xuICAgICAgICB0aGlzLnVubW91bnQoKTtcbiAgICAgICAgY29uc3QgeyB2aWV3cG9ydCA9IHt9IH0gPSB0aGlzLm5vZGUuZ2V0UHJvcHMoKTtcbiAgICAgICAgY29uc3QgeyByb290LCBtYXJnaW46IHJvb3RNYXJnaW4sIGFtb3VudCA9IFwic29tZVwiLCBvbmNlIH0gPSB2aWV3cG9ydDtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHJvb3Q6IHJvb3QgPyByb290LmN1cnJlbnQgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICByb290TWFyZ2luLFxuICAgICAgICAgICAgdGhyZXNob2xkOiB0eXBlb2YgYW1vdW50ID09PSBcIm51bWJlclwiID8gYW1vdW50IDogdGhyZXNob2xkTmFtZXNbYW1vdW50XSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb25JbnRlcnNlY3Rpb25VcGRhdGUgPSAoZW50cnkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgaXNJbnRlcnNlY3RpbmcgfSA9IGVudHJ5O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB0aGVyZSdzIGJlZW4gbm8gY2hhbmdlIGluIHRoZSB2aWV3cG9ydCBzdGF0ZSwgZWFybHkgcmV0dXJuLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAodGhpcy5pc0luVmlldyA9PT0gaXNJbnRlcnNlY3RpbmcpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5pc0luVmlldyA9IGlzSW50ZXJzZWN0aW5nO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBIYW5kbGUgaGFzRW50ZXJlZFZpZXcuIElmIHRoaXMgaXMgb25seSBtZWFudCB0byBydW4gb25jZSwgYW5kXG4gICAgICAgICAgICAgKiBlbGVtZW50IGlzbid0IHZpc2libGUsIGVhcmx5IHJldHVybi4gT3RoZXJ3aXNlIHNldCBoYXNFbnRlcmVkVmlldyB0byB0cnVlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAob25jZSAmJiAhaXNJbnRlcnNlY3RpbmcgJiYgdGhpcy5oYXNFbnRlcmVkVmlldykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzSW50ZXJzZWN0aW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYXNFbnRlcmVkVmlldyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5ub2RlLmFuaW1hdGlvblN0YXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlLmFuaW1hdGlvblN0YXRlLnNldEFjdGl2ZShcIndoaWxlSW5WaWV3XCIsIGlzSW50ZXJzZWN0aW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVXNlIHRoZSBsYXRlc3QgY29tbWl0dGVkIHByb3BzIHJhdGhlciB0aGFuIHRoZSBvbmVzIGluIHNjb3BlXG4gICAgICAgICAgICAgKiB3aGVuIHRoaXMgb2JzZXJ2ZXIgaXMgY3JlYXRlZFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCB7IG9uVmlld3BvcnRFbnRlciwgb25WaWV3cG9ydExlYXZlIH0gPSB0aGlzLm5vZGUuZ2V0UHJvcHMoKTtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gaXNJbnRlcnNlY3RpbmcgPyBvblZpZXdwb3J0RW50ZXIgOiBvblZpZXdwb3J0TGVhdmU7XG4gICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhlbnRyeSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBvYnNlcnZlSW50ZXJzZWN0aW9uKHRoaXMubm9kZS5jdXJyZW50LCBvcHRpb25zLCBvbkludGVyc2VjdGlvblVwZGF0ZSk7XG4gICAgfVxuICAgIG1vdW50KCkge1xuICAgICAgICB0aGlzLnN0YXJ0T2JzZXJ2ZXIoKTtcbiAgICB9XG4gICAgdXBkYXRlKCkge1xuICAgICAgICBpZiAodHlwZW9mIEludGVyc2VjdGlvbk9ic2VydmVyID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB7IHByb3BzLCBwcmV2UHJvcHMgfSA9IHRoaXMubm9kZTtcbiAgICAgICAgY29uc3QgaGFzT3B0aW9uc0NoYW5nZWQgPSBbXCJhbW91bnRcIiwgXCJtYXJnaW5cIiwgXCJyb290XCJdLnNvbWUoaGFzVmlld3BvcnRPcHRpb25DaGFuZ2VkKHByb3BzLCBwcmV2UHJvcHMpKTtcbiAgICAgICAgaWYgKGhhc09wdGlvbnNDaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0T2JzZXJ2ZXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1bm1vdW50KCkgeyB9XG59XG5mdW5jdGlvbiBoYXNWaWV3cG9ydE9wdGlvbkNoYW5nZWQoeyB2aWV3cG9ydCA9IHt9IH0sIHsgdmlld3BvcnQ6IHByZXZWaWV3cG9ydCA9IHt9IH0gPSB7fSkge1xuICAgIHJldHVybiAobmFtZSkgPT4gdmlld3BvcnRbbmFtZV0gIT09IHByZXZWaWV3cG9ydFtuYW1lXTtcbn1cblxuY29uc3QgZ2VzdHVyZUFuaW1hdGlvbnMgPSB7XG4gICAgaW5WaWV3OiB7XG4gICAgICAgIEZlYXR1cmU6IEluVmlld0ZlYXR1cmUsXG4gICAgfSxcbiAgICB0YXA6IHtcbiAgICAgICAgRmVhdHVyZTogUHJlc3NHZXN0dXJlLFxuICAgIH0sXG4gICAgZm9jdXM6IHtcbiAgICAgICAgRmVhdHVyZTogRm9jdXNHZXN0dXJlLFxuICAgIH0sXG4gICAgaG92ZXI6IHtcbiAgICAgICAgRmVhdHVyZTogSG92ZXJHZXN0dXJlLFxuICAgIH0sXG59O1xuXG5jb25zdCBsYXlvdXQgPSB7XG4gICAgbGF5b3V0OiB7XG4gICAgICAgIFByb2plY3Rpb25Ob2RlOiBIVE1MUHJvamVjdGlvbk5vZGUsXG4gICAgICAgIE1lYXN1cmVMYXlvdXQsXG4gICAgfSxcbn07XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5jb25zdCBNb3Rpb25Db25maWdDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dCh7XG4gICAgdHJhbnNmb3JtUGFnZVBvaW50OiAocCkgPT4gcCxcbiAgICBpc1N0YXRpYzogZmFsc2UsXG4gICAgcmVkdWNlZE1vdGlvbjogXCJuZXZlclwiLFxufSk7XG5cbmNvbnN0IE1vdGlvbkNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KHt9KTtcblxuY29uc3QgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IGlzQnJvd3NlciA/IFJlYWN0LnVzZUxheW91dEVmZmVjdCA6IFJlYWN0LnVzZUVmZmVjdDtcblxuY29uc3QgTGF6eUNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KHsgc3RyaWN0OiBmYWxzZSB9KTtcblxuZnVuY3Rpb24gdXNlVmlzdWFsRWxlbWVudChDb21wb25lbnQsIHZpc3VhbFN0YXRlLCBwcm9wcywgY3JlYXRlVmlzdWFsRWxlbWVudCwgUHJvamVjdGlvbk5vZGVDb25zdHJ1Y3Rvcikge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgeyB2aXN1YWxFbGVtZW50OiBwYXJlbnQgfSA9IFJlYWN0LnVzZUNvbnRleHQoTW90aW9uQ29udGV4dCk7XG4gICAgY29uc3QgbGF6eUNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KExhenlDb250ZXh0KTtcbiAgICBjb25zdCBwcmVzZW5jZUNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KFByZXNlbmNlQ29udGV4dCk7XG4gICAgY29uc3QgcmVkdWNlZE1vdGlvbkNvbmZpZyA9IFJlYWN0LnVzZUNvbnRleHQoTW90aW9uQ29uZmlnQ29udGV4dCkucmVkdWNlZE1vdGlvbjtcbiAgICBjb25zdCB2aXN1YWxFbGVtZW50UmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICAgIC8qKlxuICAgICAqIElmIHdlIGhhdmVuJ3QgcHJlbG9hZGVkIGEgcmVuZGVyZXIsIGNoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIG9uZSBsYXp5LWxvYWRlZFxuICAgICAqL1xuICAgIGNyZWF0ZVZpc3VhbEVsZW1lbnQgPSBjcmVhdGVWaXN1YWxFbGVtZW50IHx8IGxhenlDb250ZXh0LnJlbmRlcmVyO1xuICAgIGlmICghdmlzdWFsRWxlbWVudFJlZi5jdXJyZW50ICYmIGNyZWF0ZVZpc3VhbEVsZW1lbnQpIHtcbiAgICAgICAgdmlzdWFsRWxlbWVudFJlZi5jdXJyZW50ID0gY3JlYXRlVmlzdWFsRWxlbWVudChDb21wb25lbnQsIHtcbiAgICAgICAgICAgIHZpc3VhbFN0YXRlLFxuICAgICAgICAgICAgcGFyZW50LFxuICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICBwcmVzZW5jZUNvbnRleHQsXG4gICAgICAgICAgICBibG9ja0luaXRpYWxBbmltYXRpb246IHByZXNlbmNlQ29udGV4dFxuICAgICAgICAgICAgICAgID8gcHJlc2VuY2VDb250ZXh0LmluaXRpYWwgPT09IGZhbHNlXG4gICAgICAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIHJlZHVjZWRNb3Rpb25Db25maWcsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCB2aXN1YWxFbGVtZW50ID0gdmlzdWFsRWxlbWVudFJlZi5jdXJyZW50O1xuICAgIC8qKlxuICAgICAqIExvYWQgTW90aW9uIGdlc3R1cmUgYW5kIGFuaW1hdGlvbiBmZWF0dXJlcy4gVGhlc2UgYXJlIHJlbmRlcmVkIGFzIHJlbmRlcmxlc3NcbiAgICAgKiBjb21wb25lbnRzIHNvIGVhY2ggZmVhdHVyZSBjYW4gb3B0aW9uYWxseSBtYWtlIHVzZSBvZiBSZWFjdCBsaWZlY3ljbGUgbWV0aG9kcy5cbiAgICAgKi9cbiAgICBjb25zdCBpbml0aWFsTGF5b3V0R3JvdXBDb25maWcgPSBSZWFjdC51c2VDb250ZXh0KFN3aXRjaExheW91dEdyb3VwQ29udGV4dCk7XG4gICAgaWYgKHZpc3VhbEVsZW1lbnQgJiZcbiAgICAgICAgIXZpc3VhbEVsZW1lbnQucHJvamVjdGlvbiAmJlxuICAgICAgICBQcm9qZWN0aW9uTm9kZUNvbnN0cnVjdG9yICYmXG4gICAgICAgICh2aXN1YWxFbGVtZW50LnR5cGUgPT09IFwiaHRtbFwiIHx8IHZpc3VhbEVsZW1lbnQudHlwZSA9PT0gXCJzdmdcIikpIHtcbiAgICAgICAgY3JlYXRlUHJvamVjdGlvbk5vZGUodmlzdWFsRWxlbWVudFJlZi5jdXJyZW50LCBwcm9wcywgUHJvamVjdGlvbk5vZGVDb25zdHJ1Y3RvciwgaW5pdGlhbExheW91dEdyb3VwQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgaXNNb3VudGVkID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgICBSZWFjdC51c2VJbnNlcnRpb25FZmZlY3QoKCkgPT4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2sgdGhlIGNvbXBvbmVudCBoYXMgYWxyZWFkeSBtb3VudGVkIGJlZm9yZSBjYWxsaW5nXG4gICAgICAgICAqIGB1cGRhdGVgIHVubmVjZXNzYXJpbHkuIFRoaXMgZW5zdXJlcyB3ZSBza2lwIHRoZSBpbml0aWFsIHVwZGF0ZS5cbiAgICAgICAgICovXG4gICAgICAgIGlmICh2aXN1YWxFbGVtZW50ICYmIGlzTW91bnRlZC5jdXJyZW50KSB7XG4gICAgICAgICAgICB2aXN1YWxFbGVtZW50LnVwZGF0ZShwcm9wcywgcHJlc2VuY2VDb250ZXh0KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIENhY2hlIHRoaXMgdmFsdWUgYXMgd2Ugd2FudCB0byBrbm93IHdoZXRoZXIgSGFuZG9mZkFwcGVhckFuaW1hdGlvbnNcbiAgICAgKiB3YXMgcHJlc2VudCBvbiBpbml0aWFsIHJlbmRlciAtIGl0IHdpbGwgYmUgZGVsZXRlZCBhZnRlciB0aGlzLlxuICAgICAqL1xuICAgIGNvbnN0IG9wdGltaXNlZEFwcGVhcklkID0gcHJvcHNbb3B0aW1pemVkQXBwZWFyRGF0YUF0dHJpYnV0ZV07XG4gICAgY29uc3Qgd2FudHNIYW5kb2ZmID0gUmVhY3QudXNlUmVmKEJvb2xlYW4ob3B0aW1pc2VkQXBwZWFySWQpICYmXG4gICAgICAgICEoKF9hID0gd2luZG93Lk1vdGlvbkhhbmRvZmZJc0NvbXBsZXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh3aW5kb3csIG9wdGltaXNlZEFwcGVhcklkKSkgJiZcbiAgICAgICAgKChfYiA9IHdpbmRvdy5Nb3Rpb25IYXNPcHRpbWlzZWRBbmltYXRpb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKHdpbmRvdywgb3B0aW1pc2VkQXBwZWFySWQpKSk7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghdmlzdWFsRWxlbWVudClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaXNNb3VudGVkLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICB3aW5kb3cuTW90aW9uSXNNb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgdmlzdWFsRWxlbWVudC51cGRhdGVGZWF0dXJlcygpO1xuICAgICAgICBtaWNyb3Rhc2sucmVuZGVyKHZpc3VhbEVsZW1lbnQucmVuZGVyKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElkZWFsbHkgdGhpcyBmdW5jdGlvbiB3b3VsZCBhbHdheXMgcnVuIGluIGEgdXNlRWZmZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBIb3dldmVyLCBpZiB3ZSBoYXZlIG9wdGltaXNlZCBhcHBlYXIgYW5pbWF0aW9ucyB0byBoYW5kb2ZmIGZyb20sXG4gICAgICAgICAqIGl0IG5lZWRzIHRvIGhhcHBlbiBzeW5jaHJvbm91c2x5IHRvIGVuc3VyZSB0aGVyZSdzIG5vIGZsYXNoIG9mXG4gICAgICAgICAqIGluY29ycmVjdCBzdHlsZXMgaW4gdGhlIGV2ZW50IG9mIGEgaHlkcmF0aW9uIGVycm9yLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTbyBpZiB3ZSBkZXRlY3QgYSBzaXR1dGF0aW9uIHdoZXJlIG9wdGltaXNlZCBhcHBlYXIgYW5pbWF0aW9uc1xuICAgICAgICAgKiBhcmUgcnVubmluZywgd2UgdXNlIHVzZUxheW91dEVmZmVjdCB0byB0cmlnZ2VyIGFuaW1hdGlvbnMuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAod2FudHNIYW5kb2ZmLmN1cnJlbnQgJiYgdmlzdWFsRWxlbWVudC5hbmltYXRpb25TdGF0ZSkge1xuICAgICAgICAgICAgdmlzdWFsRWxlbWVudC5hbmltYXRpb25TdGF0ZS5hbmltYXRlQ2hhbmdlcygpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCF2aXN1YWxFbGVtZW50KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIXdhbnRzSGFuZG9mZi5jdXJyZW50ICYmIHZpc3VhbEVsZW1lbnQuYW5pbWF0aW9uU3RhdGUpIHtcbiAgICAgICAgICAgIHZpc3VhbEVsZW1lbnQuYW5pbWF0aW9uU3RhdGUuYW5pbWF0ZUNoYW5nZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod2FudHNIYW5kb2ZmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgZW5zdXJlcyBhbGwgZnV0dXJlIGNhbGxzIHRvIGFuaW1hdGVDaGFuZ2VzKCkgaW4gdGhpcyBjb21wb25lbnQgd2lsbCBydW4gaW4gdXNlRWZmZWN0XG4gICAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIChfYSA9IHdpbmRvdy5Nb3Rpb25IYW5kb2ZmTWFya0FzQ29tcGxldGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHdpbmRvdywgb3B0aW1pc2VkQXBwZWFySWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB3YW50c0hhbmRvZmYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHZpc3VhbEVsZW1lbnQ7XG59XG5mdW5jdGlvbiBjcmVhdGVQcm9qZWN0aW9uTm9kZSh2aXN1YWxFbGVtZW50LCBwcm9wcywgUHJvamVjdGlvbk5vZGVDb25zdHJ1Y3RvciwgaW5pdGlhbFByb21vdGlvbkNvbmZpZykge1xuICAgIGNvbnN0IHsgbGF5b3V0SWQsIGxheW91dCwgZHJhZywgZHJhZ0NvbnN0cmFpbnRzLCBsYXlvdXRTY3JvbGwsIGxheW91dFJvb3QsIH0gPSBwcm9wcztcbiAgICB2aXN1YWxFbGVtZW50LnByb2plY3Rpb24gPSBuZXcgUHJvamVjdGlvbk5vZGVDb25zdHJ1Y3Rvcih2aXN1YWxFbGVtZW50LmxhdGVzdFZhbHVlcywgcHJvcHNbXCJkYXRhLWZyYW1lci1wb3J0YWwtaWRcIl1cbiAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgOiBnZXRDbG9zZXN0UHJvamVjdGluZ05vZGUodmlzdWFsRWxlbWVudC5wYXJlbnQpKTtcbiAgICB2aXN1YWxFbGVtZW50LnByb2plY3Rpb24uc2V0T3B0aW9ucyh7XG4gICAgICAgIGxheW91dElkLFxuICAgICAgICBsYXlvdXQsXG4gICAgICAgIGFsd2F5c01lYXN1cmVMYXlvdXQ6IEJvb2xlYW4oZHJhZykgfHwgKGRyYWdDb25zdHJhaW50cyAmJiBpc1JlZk9iamVjdChkcmFnQ29uc3RyYWludHMpKSxcbiAgICAgICAgdmlzdWFsRWxlbWVudCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRPRE86IFVwZGF0ZSBvcHRpb25zIGluIGFuIGVmZmVjdC4gVGhpcyBjb3VsZCBiZSB0cmlja3kgYXMgaXQnbGwgYmUgdG9vIGxhdGVcbiAgICAgICAgICogdG8gdXBkYXRlIGJ5IHRoZSB0aW1lIGxheW91dCBhbmltYXRpb25zIHJ1bi5cbiAgICAgICAgICogV2UgYWxzbyBuZWVkIHRvIGZpeCB0aGlzIHNhZmVUb1JlbW92ZSBieSBsaW5raW5nIGl0IHVwIHRvIHRoZSBvbmUgcmV0dXJuZWQgYnkgdXNlUHJlc2VuY2UsXG4gICAgICAgICAqIGVuc3VyaW5nIGl0IGdldHMgY2FsbGVkIGlmIHRoZXJlJ3Mgbm8gcG90ZW50aWFsIGxheW91dCBhbmltYXRpb25zLlxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgYW5pbWF0aW9uVHlwZTogdHlwZW9mIGxheW91dCA9PT0gXCJzdHJpbmdcIiA/IGxheW91dCA6IFwiYm90aFwiLFxuICAgICAgICBpbml0aWFsUHJvbW90aW9uQ29uZmlnLFxuICAgICAgICBsYXlvdXRTY3JvbGwsXG4gICAgICAgIGxheW91dFJvb3QsXG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRDbG9zZXN0UHJvamVjdGluZ05vZGUodmlzdWFsRWxlbWVudCkge1xuICAgIGlmICghdmlzdWFsRWxlbWVudClcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICByZXR1cm4gdmlzdWFsRWxlbWVudC5vcHRpb25zLmFsbG93UHJvamVjdGlvbiAhPT0gZmFsc2VcbiAgICAgICAgPyB2aXN1YWxFbGVtZW50LnByb2plY3Rpb25cbiAgICAgICAgOiBnZXRDbG9zZXN0UHJvamVjdGluZ05vZGUodmlzdWFsRWxlbWVudC5wYXJlbnQpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSByZWYgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsIGh5ZHJhdGVzIHRoZSBwcm92aWRlZFxuICogZXh0ZXJuYWwgcmVmIGFuZCBWaXN1YWxFbGVtZW50LlxuICovXG5mdW5jdGlvbiB1c2VNb3Rpb25SZWYodmlzdWFsU3RhdGUsIHZpc3VhbEVsZW1lbnQsIGV4dGVybmFsUmVmKSB7XG4gICAgcmV0dXJuIFJlYWN0LnVzZUNhbGxiYWNrKChpbnN0YW5jZSkgPT4ge1xuICAgICAgICBpbnN0YW5jZSAmJiB2aXN1YWxTdGF0ZS5tb3VudCAmJiB2aXN1YWxTdGF0ZS5tb3VudChpbnN0YW5jZSk7XG4gICAgICAgIGlmICh2aXN1YWxFbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICB2aXN1YWxFbGVtZW50Lm1vdW50KGluc3RhbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZpc3VhbEVsZW1lbnQudW5tb3VudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChleHRlcm5hbFJlZikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBleHRlcm5hbFJlZiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgZXh0ZXJuYWxSZWYoaW5zdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNSZWZPYmplY3QoZXh0ZXJuYWxSZWYpKSB7XG4gICAgICAgICAgICAgICAgZXh0ZXJuYWxSZWYuY3VycmVudCA9IGluc3RhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgXG4gICAgLyoqXG4gICAgICogT25seSBwYXNzIGEgbmV3IHJlZiBjYWxsYmFjayB0byBSZWFjdCBpZiB3ZSd2ZSByZWNlaXZlZCBhIHZpc3VhbCBlbGVtZW50XG4gICAgICogZmFjdG9yeS4gT3RoZXJ3aXNlIHdlJ2xsIGJlIG1vdW50aW5nL3JlbW91bnRpbmcgZXZlcnkgdGltZSBleHRlcm5hbFJlZlxuICAgICAqIG9yIG90aGVyIGRlcGVuZGVuY2llcyBjaGFuZ2UuXG4gICAgICovXG4gICAgW3Zpc3VhbEVsZW1lbnRdKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q3VycmVudFRyZWVWYXJpYW50cyhwcm9wcywgY29udGV4dCkge1xuICAgIGlmIChpc0NvbnRyb2xsaW5nVmFyaWFudHMocHJvcHMpKSB7XG4gICAgICAgIGNvbnN0IHsgaW5pdGlhbCwgYW5pbWF0ZSB9ID0gcHJvcHM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbml0aWFsOiBpbml0aWFsID09PSBmYWxzZSB8fCBpc1ZhcmlhbnRMYWJlbChpbml0aWFsKVxuICAgICAgICAgICAgICAgID8gaW5pdGlhbFxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgYW5pbWF0ZTogaXNWYXJpYW50TGFiZWwoYW5pbWF0ZSkgPyBhbmltYXRlIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcHJvcHMuaW5oZXJpdCAhPT0gZmFsc2UgPyBjb250ZXh0IDoge307XG59XG5cbmZ1bmN0aW9uIHVzZUNyZWF0ZU1vdGlvbkNvbnRleHQocHJvcHMpIHtcbiAgICBjb25zdCB7IGluaXRpYWwsIGFuaW1hdGUgfSA9IGdldEN1cnJlbnRUcmVlVmFyaWFudHMocHJvcHMsIFJlYWN0LnVzZUNvbnRleHQoTW90aW9uQ29udGV4dCkpO1xuICAgIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+ICh7IGluaXRpYWwsIGFuaW1hdGUgfSksIFt2YXJpYW50TGFiZWxzQXNEZXBlbmRlbmN5KGluaXRpYWwpLCB2YXJpYW50TGFiZWxzQXNEZXBlbmRlbmN5KGFuaW1hdGUpXSk7XG59XG5mdW5jdGlvbiB2YXJpYW50TGFiZWxzQXNEZXBlbmRlbmN5KHByb3ApIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShwcm9wKSA/IHByb3Auam9pbihcIiBcIikgOiBwcm9wO1xufVxuXG5mdW5jdGlvbiBsb2FkRmVhdHVyZXMoZmVhdHVyZXMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBmZWF0dXJlcykge1xuICAgICAgICBmZWF0dXJlRGVmaW5pdGlvbnNba2V5XSA9IHtcbiAgICAgICAgICAgIC4uLmZlYXR1cmVEZWZpbml0aW9uc1trZXldLFxuICAgICAgICAgICAgLi4uZmVhdHVyZXNba2V5XSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmNvbnN0IG1vdGlvbkNvbXBvbmVudFN5bWJvbCA9IFN5bWJvbC5mb3IoXCJtb3Rpb25Db21wb25lbnRTeW1ib2xcIik7XG5cbi8qKlxuICogQ3JlYXRlIGEgYG1vdGlvbmAgY29tcG9uZW50LlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyBhIENvbXBvbmVudCBhcmd1bWVudCwgd2hpY2ggY2FuIGJlIGVpdGhlciBhIHN0cmluZyAoaWUgXCJkaXZcIlxuICogZm9yIGBtb3Rpb24uZGl2YCksIG9yIGFuIGFjdHVhbCBSZWFjdCBjb21wb25lbnQuXG4gKlxuICogQWxvbmdzaWRlIHRoaXMgaXMgYSBjb25maWcgb3B0aW9uIHdoaWNoIHByb3ZpZGVzIGEgd2F5IG9mIHJlbmRlcmluZyB0aGUgcHJvdmlkZWRcbiAqIGNvbXBvbmVudCBcIm9mZmxpbmVcIiwgb3Igb3V0c2lkZSB0aGUgUmVhY3QgcmVuZGVyIGN5Y2xlLlxuICovXG5mdW5jdGlvbiBjcmVhdGVSZW5kZXJlck1vdGlvbkNvbXBvbmVudCh7IHByZWxvYWRlZEZlYXR1cmVzLCBjcmVhdGVWaXN1YWxFbGVtZW50LCB1c2VSZW5kZXIsIHVzZVZpc3VhbFN0YXRlLCBDb21wb25lbnQsIH0pIHtcbiAgICBwcmVsb2FkZWRGZWF0dXJlcyAmJiBsb2FkRmVhdHVyZXMocHJlbG9hZGVkRmVhdHVyZXMpO1xuICAgIGZ1bmN0aW9uIE1vdGlvbkNvbXBvbmVudChwcm9wcywgZXh0ZXJuYWxSZWYpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHdlIG5lZWQgdG8gbWVhc3VyZSB0aGUgZWxlbWVudCB3ZSBsb2FkIHRoaXMgZnVuY3Rpb25hbGl0eSBpbiBhXG4gICAgICAgICAqIHNlcGFyYXRlIGNsYXNzIGNvbXBvbmVudCBpbiBvcmRlciB0byBnYWluIGFjY2VzcyB0byBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZS5cbiAgICAgICAgICovXG4gICAgICAgIGxldCBNZWFzdXJlTGF5b3V0O1xuICAgICAgICBjb25zdCBjb25maWdBbmRQcm9wcyA9IHtcbiAgICAgICAgICAgIC4uLlJlYWN0LnVzZUNvbnRleHQoTW90aW9uQ29uZmlnQ29udGV4dCksXG4gICAgICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgICAgIGxheW91dElkOiB1c2VMYXlvdXRJZChwcm9wcyksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHsgaXNTdGF0aWMgfSA9IGNvbmZpZ0FuZFByb3BzO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gdXNlQ3JlYXRlTW90aW9uQ29udGV4dChwcm9wcyk7XG4gICAgICAgIGNvbnN0IHZpc3VhbFN0YXRlID0gdXNlVmlzdWFsU3RhdGUocHJvcHMsIGlzU3RhdGljKTtcbiAgICAgICAgaWYgKCFpc1N0YXRpYyAmJiBpc0Jyb3dzZXIpIHtcbiAgICAgICAgICAgIHVzZVN0cmljdE1vZGUoY29uZmlnQW5kUHJvcHMsIHByZWxvYWRlZEZlYXR1cmVzKTtcbiAgICAgICAgICAgIGNvbnN0IGxheW91dFByb2plY3Rpb24gPSBnZXRQcm9qZWN0aW9uRnVuY3Rpb25hbGl0eShjb25maWdBbmRQcm9wcyk7XG4gICAgICAgICAgICBNZWFzdXJlTGF5b3V0ID0gbGF5b3V0UHJvamVjdGlvbi5NZWFzdXJlTGF5b3V0O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDcmVhdGUgYSBWaXN1YWxFbGVtZW50IGZvciB0aGlzIGNvbXBvbmVudC4gQSBWaXN1YWxFbGVtZW50IHByb3ZpZGVzIGEgY29tbW9uXG4gICAgICAgICAgICAgKiBpbnRlcmZhY2UgdG8gcmVuZGVyZXItc3BlY2lmaWMgQVBJcyAoaWUgRE9NL1RocmVlLmpzIGV0YykgYXMgd2VsbCBhc1xuICAgICAgICAgICAgICogcHJvdmlkaW5nIGEgd2F5IG9mIHJlbmRlcmluZyB0byB0aGVzZSBBUElzIG91dHNpZGUgb2YgdGhlIFJlYWN0IHJlbmRlciBsb29wXG4gICAgICAgICAgICAgKiBmb3IgbW9yZSBwZXJmb3JtYW50IGFuaW1hdGlvbnMgYW5kIGludGVyYWN0aW9uc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb250ZXh0LnZpc3VhbEVsZW1lbnQgPSB1c2VWaXN1YWxFbGVtZW50KENvbXBvbmVudCwgdmlzdWFsU3RhdGUsIGNvbmZpZ0FuZFByb3BzLCBjcmVhdGVWaXN1YWxFbGVtZW50LCBsYXlvdXRQcm9qZWN0aW9uLlByb2plY3Rpb25Ob2RlKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1vdW50IG9yZGVyIGFuZCBoaWVyYXJjaHkgaXMgc3BlY2lmaWMgdG8gZW5zdXJlIG91ciBlbGVtZW50IHJlZlxuICAgICAgICAgKiBpcyBoeWRyYXRlZCBieSB0aGUgdGltZSBmZWF0dXJlcyBmaXJlIHRoZWlyIGVmZmVjdHMuXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gKGpzeFJ1bnRpbWUuanN4cyhNb3Rpb25Db250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBjb250ZXh0LCBjaGlsZHJlbjogW01lYXN1cmVMYXlvdXQgJiYgY29udGV4dC52aXN1YWxFbGVtZW50ID8gKGpzeFJ1bnRpbWUuanN4KE1lYXN1cmVMYXlvdXQsIHsgdmlzdWFsRWxlbWVudDogY29udGV4dC52aXN1YWxFbGVtZW50LCAuLi5jb25maWdBbmRQcm9wcyB9KSkgOiBudWxsLCB1c2VSZW5kZXIoQ29tcG9uZW50LCBwcm9wcywgdXNlTW90aW9uUmVmKHZpc3VhbFN0YXRlLCBjb250ZXh0LnZpc3VhbEVsZW1lbnQsIGV4dGVybmFsUmVmKSwgdmlzdWFsU3RhdGUsIGlzU3RhdGljLCBjb250ZXh0LnZpc3VhbEVsZW1lbnQpXSB9KSk7XG4gICAgfVxuICAgIGNvbnN0IEZvcndhcmRSZWZNb3Rpb25Db21wb25lbnQgPSBSZWFjdC5mb3J3YXJkUmVmKE1vdGlvbkNvbXBvbmVudCk7XG4gICAgRm9yd2FyZFJlZk1vdGlvbkNvbXBvbmVudFttb3Rpb25Db21wb25lbnRTeW1ib2xdID0gQ29tcG9uZW50O1xuICAgIHJldHVybiBGb3J3YXJkUmVmTW90aW9uQ29tcG9uZW50O1xufVxuZnVuY3Rpb24gdXNlTGF5b3V0SWQoeyBsYXlvdXRJZCB9KSB7XG4gICAgY29uc3QgbGF5b3V0R3JvdXBJZCA9IFJlYWN0LnVzZUNvbnRleHQoTGF5b3V0R3JvdXBDb250ZXh0KS5pZDtcbiAgICByZXR1cm4gbGF5b3V0R3JvdXBJZCAmJiBsYXlvdXRJZCAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gbGF5b3V0R3JvdXBJZCArIFwiLVwiICsgbGF5b3V0SWRcbiAgICAgICAgOiBsYXlvdXRJZDtcbn1cbmZ1bmN0aW9uIHVzZVN0cmljdE1vZGUoY29uZmlnQW5kUHJvcHMsIHByZWxvYWRlZEZlYXR1cmVzKSB7XG4gICAgY29uc3QgaXNTdHJpY3QgPSBSZWFjdC51c2VDb250ZXh0KExhenlDb250ZXh0KS5zdHJpY3Q7XG4gICAgLyoqXG4gICAgICogSWYgd2UncmUgaW4gZGV2ZWxvcG1lbnQgbW9kZSwgY2hlY2sgdG8gbWFrZSBzdXJlIHdlJ3JlIG5vdCByZW5kZXJpbmcgYSBtb3Rpb24gY29tcG9uZW50XG4gICAgICogYXMgYSBjaGlsZCBvZiBMYXp5TW90aW9uLCBhcyB0aGlzIHdpbGwgYnJlYWsgdGhlIGZpbGUtc2l6ZSBiZW5lZml0cyBvZiB1c2luZyBpdC5cbiAgICAgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmXG4gICAgICAgIHByZWxvYWRlZEZlYXR1cmVzICYmXG4gICAgICAgIGlzU3RyaWN0KSB7XG4gICAgICAgIGNvbnN0IHN0cmljdE1lc3NhZ2UgPSBcIllvdSBoYXZlIHJlbmRlcmVkIGEgYG1vdGlvbmAgY29tcG9uZW50IHdpdGhpbiBhIGBMYXp5TW90aW9uYCBjb21wb25lbnQuIFRoaXMgd2lsbCBicmVhayB0cmVlIHNoYWtpbmcuIEltcG9ydCBhbmQgcmVuZGVyIGEgYG1gIGNvbXBvbmVudCBpbnN0ZWFkLlwiO1xuICAgICAgICBjb25maWdBbmRQcm9wcy5pZ25vcmVTdHJpY3RcbiAgICAgICAgICAgID8gbW90aW9uVXRpbHMud2FybmluZyhmYWxzZSwgc3RyaWN0TWVzc2FnZSlcbiAgICAgICAgICAgIDogbW90aW9uVXRpbHMuaW52YXJpYW50KGZhbHNlLCBzdHJpY3RNZXNzYWdlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRQcm9qZWN0aW9uRnVuY3Rpb25hbGl0eShwcm9wcykge1xuICAgIGNvbnN0IHsgZHJhZywgbGF5b3V0IH0gPSBmZWF0dXJlRGVmaW5pdGlvbnM7XG4gICAgaWYgKCFkcmFnICYmICFsYXlvdXQpXG4gICAgICAgIHJldHVybiB7fTtcbiAgICBjb25zdCBjb21iaW5lZCA9IHsgLi4uZHJhZywgLi4ubGF5b3V0IH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgTWVhc3VyZUxheW91dDogKGRyYWcgPT09IG51bGwgfHwgZHJhZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZHJhZy5pc0VuYWJsZWQocHJvcHMpKSB8fCAobGF5b3V0ID09PSBudWxsIHx8IGxheW91dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGF5b3V0LmlzRW5hYmxlZChwcm9wcykpXG4gICAgICAgICAgICA/IGNvbWJpbmVkLk1lYXN1cmVMYXlvdXRcbiAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICBQcm9qZWN0aW9uTm9kZTogY29tYmluZWQuUHJvamVjdGlvbk5vZGUsXG4gICAgfTtcbn1cblxuLyoqXG4gKiBXZSBrZWVwIHRoZXNlIGxpc3RlZCBzZXBhcmF0ZWx5IGFzIHdlIHVzZSB0aGUgbG93ZXJjYXNlIHRhZyBuYW1lcyBhcyBwYXJ0XG4gKiBvZiB0aGUgcnVudGltZSBidW5kbGUgdG8gZGV0ZWN0IFNWRyBjb21wb25lbnRzXG4gKi9cbmNvbnN0IGxvd2VyY2FzZVNWR0VsZW1lbnRzID0gW1xuICAgIFwiYW5pbWF0ZVwiLFxuICAgIFwiY2lyY2xlXCIsXG4gICAgXCJkZWZzXCIsXG4gICAgXCJkZXNjXCIsXG4gICAgXCJlbGxpcHNlXCIsXG4gICAgXCJnXCIsXG4gICAgXCJpbWFnZVwiLFxuICAgIFwibGluZVwiLFxuICAgIFwiZmlsdGVyXCIsXG4gICAgXCJtYXJrZXJcIixcbiAgICBcIm1hc2tcIixcbiAgICBcIm1ldGFkYXRhXCIsXG4gICAgXCJwYXRoXCIsXG4gICAgXCJwYXR0ZXJuXCIsXG4gICAgXCJwb2x5Z29uXCIsXG4gICAgXCJwb2x5bGluZVwiLFxuICAgIFwicmVjdFwiLFxuICAgIFwic3RvcFwiLFxuICAgIFwic3dpdGNoXCIsXG4gICAgXCJzeW1ib2xcIixcbiAgICBcInN2Z1wiLFxuICAgIFwidGV4dFwiLFxuICAgIFwidHNwYW5cIixcbiAgICBcInVzZVwiLFxuICAgIFwidmlld1wiLFxuXTtcblxuZnVuY3Rpb24gaXNTVkdDb21wb25lbnQoQ29tcG9uZW50KSB7XG4gICAgaWYgKFxuICAgIC8qKlxuICAgICAqIElmIGl0J3Mgbm90IGEgc3RyaW5nLCBpdCdzIGEgY3VzdG9tIFJlYWN0IGNvbXBvbmVudC4gQ3VycmVudGx5IHdlIG9ubHkgc3VwcG9ydFxuICAgICAqIEhUTUwgY3VzdG9tIFJlYWN0IGNvbXBvbmVudHMuXG4gICAgICovXG4gICAgdHlwZW9mIENvbXBvbmVudCAhPT0gXCJzdHJpbmdcIiB8fFxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgaXQgY29udGFpbnMgYSBkYXNoLCB0aGUgZWxlbWVudCBpcyBhIGN1c3RvbSBIVE1MIHdlYmNvbXBvbmVudC5cbiAgICAgICAgICovXG4gICAgICAgIENvbXBvbmVudC5pbmNsdWRlcyhcIi1cIikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIGlmIChcbiAgICAvKipcbiAgICAgKiBJZiBpdCdzIGluIG91ciBsaXN0IG9mIGxvd2VyY2FzZSBTVkcgdGFncywgaXQncyBhbiBTVkcgY29tcG9uZW50XG4gICAgICovXG4gICAgbG93ZXJjYXNlU1ZHRWxlbWVudHMuaW5kZXhPZihDb21wb25lbnQpID4gLTEgfHxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGl0IGNvbnRhaW5zIGEgY2FwaXRhbCBsZXR0ZXIsIGl0J3MgYW4gU1ZHIGNvbXBvbmVudFxuICAgICAgICAgKi9cbiAgICAgICAgL1tBLVpdL3UudGVzdChDb21wb25lbnQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNvbnN0YW50IHZhbHVlIG92ZXIgdGhlIGxpZmVjeWNsZSBvZiBhIGNvbXBvbmVudC5cbiAqXG4gKiBFdmVuIGlmIGB1c2VNZW1vYCBpcyBwcm92aWRlZCBhbiBlbXB0eSBhcnJheSBhcyBpdHMgZmluYWwgYXJndW1lbnQsIGl0IGRvZXNuJ3Qgb2ZmZXJcbiAqIGEgZ3VhcmFudGVlIHRoYXQgaXQgd29uJ3QgcmUtcnVuIGZvciBwZXJmb3JtYW5jZSByZWFzb25zIGxhdGVyIG9uLiBCeSB1c2luZyBgdXNlQ29uc3RhbnRgXG4gKiB5b3UgY2FuIGVuc3VyZSB0aGF0IGluaXRpYWxpc2VycyBkb24ndCBleGVjdXRlIHR3aWNlIG9yIG1vcmUuXG4gKi9cbmZ1bmN0aW9uIHVzZUNvbnN0YW50KGluaXQpIHtcbiAgICBjb25zdCByZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gICAgaWYgKHJlZi5jdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgIHJlZi5jdXJyZW50ID0gaW5pdCgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVmLmN1cnJlbnQ7XG59XG5cbmZ1bmN0aW9uIG1ha2VTdGF0ZSh7IHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcywgY3JlYXRlUmVuZGVyU3RhdGUsIG9uTW91bnQsIH0sIHByb3BzLCBjb250ZXh0LCBwcmVzZW5jZUNvbnRleHQpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgICAgbGF0ZXN0VmFsdWVzOiBtYWtlTGF0ZXN0VmFsdWVzKHByb3BzLCBjb250ZXh0LCBwcmVzZW5jZUNvbnRleHQsIHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyksXG4gICAgICAgIHJlbmRlclN0YXRlOiBjcmVhdGVSZW5kZXJTdGF0ZSgpLFxuICAgIH07XG4gICAgaWYgKG9uTW91bnQpIHtcbiAgICAgICAgc3RhdGUubW91bnQgPSAoaW5zdGFuY2UpID0+IG9uTW91bnQocHJvcHMsIGluc3RhbmNlLCBzdGF0ZSk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZTtcbn1cbmNvbnN0IG1ha2VVc2VWaXN1YWxTdGF0ZSA9IChjb25maWcpID0+IChwcm9wcywgaXNTdGF0aWMpID0+IHtcbiAgICBjb25zdCBjb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChNb3Rpb25Db250ZXh0KTtcbiAgICBjb25zdCBwcmVzZW5jZUNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KFByZXNlbmNlQ29udGV4dCk7XG4gICAgY29uc3QgbWFrZSA9ICgpID0+IG1ha2VTdGF0ZShjb25maWcsIHByb3BzLCBjb250ZXh0LCBwcmVzZW5jZUNvbnRleHQpO1xuICAgIHJldHVybiBpc1N0YXRpYyA/IG1ha2UoKSA6IHVzZUNvbnN0YW50KG1ha2UpO1xufTtcbmZ1bmN0aW9uIG1ha2VMYXRlc3RWYWx1ZXMocHJvcHMsIGNvbnRleHQsIHByZXNlbmNlQ29udGV4dCwgc2NyYXBlTW90aW9uVmFsdWVzKSB7XG4gICAgY29uc3QgdmFsdWVzID0ge307XG4gICAgY29uc3QgbW90aW9uVmFsdWVzID0gc2NyYXBlTW90aW9uVmFsdWVzKHByb3BzLCB7fSk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gbW90aW9uVmFsdWVzKSB7XG4gICAgICAgIHZhbHVlc1trZXldID0gcmVzb2x2ZU1vdGlvblZhbHVlKG1vdGlvblZhbHVlc1trZXldKTtcbiAgICB9XG4gICAgbGV0IHsgaW5pdGlhbCwgYW5pbWF0ZSB9ID0gcHJvcHM7XG4gICAgY29uc3QgaXNDb250cm9sbGluZ1ZhcmlhbnRzJDEgPSBpc0NvbnRyb2xsaW5nVmFyaWFudHMocHJvcHMpO1xuICAgIGNvbnN0IGlzVmFyaWFudE5vZGUkMSA9IGlzVmFyaWFudE5vZGUocHJvcHMpO1xuICAgIGlmIChjb250ZXh0ICYmXG4gICAgICAgIGlzVmFyaWFudE5vZGUkMSAmJlxuICAgICAgICAhaXNDb250cm9sbGluZ1ZhcmlhbnRzJDEgJiZcbiAgICAgICAgcHJvcHMuaW5oZXJpdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGluaXRpYWwgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGluaXRpYWwgPSBjb250ZXh0LmluaXRpYWw7XG4gICAgICAgIGlmIChhbmltYXRlID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBhbmltYXRlID0gY29udGV4dC5hbmltYXRlO1xuICAgIH1cbiAgICBsZXQgaXNJbml0aWFsQW5pbWF0aW9uQmxvY2tlZCA9IHByZXNlbmNlQ29udGV4dFxuICAgICAgICA/IHByZXNlbmNlQ29udGV4dC5pbml0aWFsID09PSBmYWxzZVxuICAgICAgICA6IGZhbHNlO1xuICAgIGlzSW5pdGlhbEFuaW1hdGlvbkJsb2NrZWQgPSBpc0luaXRpYWxBbmltYXRpb25CbG9ja2VkIHx8IGluaXRpYWwgPT09IGZhbHNlO1xuICAgIGNvbnN0IHZhcmlhbnRUb1NldCA9IGlzSW5pdGlhbEFuaW1hdGlvbkJsb2NrZWQgPyBhbmltYXRlIDogaW5pdGlhbDtcbiAgICBpZiAodmFyaWFudFRvU2V0ICYmXG4gICAgICAgIHR5cGVvZiB2YXJpYW50VG9TZXQgIT09IFwiYm9vbGVhblwiICYmXG4gICAgICAgICFpc0FuaW1hdGlvbkNvbnRyb2xzKHZhcmlhbnRUb1NldCkpIHtcbiAgICAgICAgY29uc3QgbGlzdCA9IEFycmF5LmlzQXJyYXkodmFyaWFudFRvU2V0KSA/IHZhcmlhbnRUb1NldCA6IFt2YXJpYW50VG9TZXRdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkID0gcmVzb2x2ZVZhcmlhbnRGcm9tUHJvcHMocHJvcHMsIGxpc3RbaV0pO1xuICAgICAgICAgICAgaWYgKHJlc29sdmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB0cmFuc2l0aW9uRW5kLCB0cmFuc2l0aW9uLCAuLi50YXJnZXQgfSA9IHJlc29sdmVkO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWVUYXJnZXQgPSB0YXJnZXRba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVUYXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIFRha2UgZmluYWwga2V5ZnJhbWUgaWYgdGhlIGluaXRpYWwgYW5pbWF0aW9uIGlzIGJsb2NrZWQgYmVjYXVzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICogd2Ugd2FudCB0byBpbml0aWFsaXNlIGF0IHRoZSBlbmQgb2YgdGhhdCBibG9ja2VkIGFuaW1hdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBpc0luaXRpYWxBbmltYXRpb25CbG9ja2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB2YWx1ZVRhcmdldC5sZW5ndGggLSAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVUYXJnZXQgPSB2YWx1ZVRhcmdldFtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlVGFyZ2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXNba2V5XSA9IHZhbHVlVGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRyYW5zaXRpb25FbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzW2tleV0gPSB0cmFuc2l0aW9uRW5kW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG59XG5cbmNvbnN0IGNyZWF0ZUh0bWxSZW5kZXJTdGF0ZSA9ICgpID0+ICh7XG4gICAgc3R5bGU6IHt9LFxuICAgIHRyYW5zZm9ybToge30sXG4gICAgdHJhbnNmb3JtT3JpZ2luOiB7fSxcbiAgICB2YXJzOiB7fSxcbn0pO1xuXG5jb25zdCBjcmVhdGVTdmdSZW5kZXJTdGF0ZSA9ICgpID0+ICh7XG4gICAgLi4uY3JlYXRlSHRtbFJlbmRlclN0YXRlKCksXG4gICAgYXR0cnM6IHt9LFxufSk7XG5cbmNvbnN0IHN2Z01vdGlvbkNvbmZpZyA9IHtcbiAgICB1c2VWaXN1YWxTdGF0ZTogbWFrZVVzZVZpc3VhbFN0YXRlKHtcbiAgICAgICAgc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzOiBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMsXG4gICAgICAgIGNyZWF0ZVJlbmRlclN0YXRlOiBjcmVhdGVTdmdSZW5kZXJTdGF0ZSxcbiAgICAgICAgb25Nb3VudDogKHByb3BzLCBpbnN0YW5jZSwgeyByZW5kZXJTdGF0ZSwgbGF0ZXN0VmFsdWVzIH0pID0+IHtcbiAgICAgICAgICAgIGZyYW1lLnJlYWQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLmRpbWVuc2lvbnMgPVxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGluc3RhbmNlLmdldEJCb3ggPT09XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBpbnN0YW5jZS5nZXRCQm94KClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGluc3RhbmNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBNb3N0IGxpa2VseSB0cnlpbmcgdG8gbWVhc3VyZSBhbiB1bnJlbmRlcmVkIGVsZW1lbnQgdW5kZXIgRmlyZWZveFxuICAgICAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5kaW1lbnNpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZyYW1lLnJlbmRlcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgYnVpbGRTVkdBdHRycyhyZW5kZXJTdGF0ZSwgbGF0ZXN0VmFsdWVzLCBpc1NWR1RhZyhpbnN0YW5jZS50YWdOYW1lKSwgcHJvcHMudHJhbnNmb3JtVGVtcGxhdGUpO1xuICAgICAgICAgICAgICAgIHJlbmRlclNWRyhpbnN0YW5jZSwgcmVuZGVyU3RhdGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgfSksXG59O1xuXG5jb25zdCBodG1sTW90aW9uQ29uZmlnID0ge1xuICAgIHVzZVZpc3VhbFN0YXRlOiBtYWtlVXNlVmlzdWFsU3RhdGUoe1xuICAgICAgICBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHM6IHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyQxLFxuICAgICAgICBjcmVhdGVSZW5kZXJTdGF0ZTogY3JlYXRlSHRtbFJlbmRlclN0YXRlLFxuICAgIH0pLFxufTtcblxuZnVuY3Rpb24gY29weVJhd1ZhbHVlc09ubHkodGFyZ2V0LCBzb3VyY2UsIHByb3BzKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmICghaXNNb3Rpb25WYWx1ZShzb3VyY2Vba2V5XSkgJiYgIWlzRm9yY2VkTW90aW9uVmFsdWUoa2V5LCBwcm9wcykpIHtcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiB1c2VJbml0aWFsTW90aW9uVmFsdWVzKHsgdHJhbnNmb3JtVGVtcGxhdGUgfSwgdmlzdWFsU3RhdGUpIHtcbiAgICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gY3JlYXRlSHRtbFJlbmRlclN0YXRlKCk7XG4gICAgICAgIGJ1aWxkSFRNTFN0eWxlcyhzdGF0ZSwgdmlzdWFsU3RhdGUsIHRyYW5zZm9ybVRlbXBsYXRlKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnZhcnMsIHN0YXRlLnN0eWxlKTtcbiAgICB9LCBbdmlzdWFsU3RhdGVdKTtcbn1cbmZ1bmN0aW9uIHVzZVN0eWxlKHByb3BzLCB2aXN1YWxTdGF0ZSkge1xuICAgIGNvbnN0IHN0eWxlUHJvcCA9IHByb3BzLnN0eWxlIHx8IHt9O1xuICAgIGNvbnN0IHN0eWxlID0ge307XG4gICAgLyoqXG4gICAgICogQ29weSBub24tTW90aW9uIFZhbHVlcyBzdHJhaWdodCBpbnRvIHN0eWxlXG4gICAgICovXG4gICAgY29weVJhd1ZhbHVlc09ubHkoc3R5bGUsIHN0eWxlUHJvcCwgcHJvcHMpO1xuICAgIE9iamVjdC5hc3NpZ24oc3R5bGUsIHVzZUluaXRpYWxNb3Rpb25WYWx1ZXMocHJvcHMsIHZpc3VhbFN0YXRlKSk7XG4gICAgcmV0dXJuIHN0eWxlO1xufVxuZnVuY3Rpb24gdXNlSFRNTFByb3BzKHByb3BzLCB2aXN1YWxTdGF0ZSkge1xuICAgIC8vIFRoZSBgYW55YCBpc24ndCBpZGVhbCBidXQgaXQgaXMgdGhlIHR5cGUgb2YgY3JlYXRlRWxlbWVudCBwcm9wcyBhcmd1bWVudFxuICAgIGNvbnN0IGh0bWxQcm9wcyA9IHt9O1xuICAgIGNvbnN0IHN0eWxlID0gdXNlU3R5bGUocHJvcHMsIHZpc3VhbFN0YXRlKTtcbiAgICBpZiAocHJvcHMuZHJhZyAmJiBwcm9wcy5kcmFnTGlzdGVuZXIgIT09IGZhbHNlKSB7XG4gICAgICAgIC8vIERpc2FibGUgdGhlIGdob3N0IGVsZW1lbnQgd2hlbiBhIHVzZXIgZHJhZ3NcbiAgICAgICAgaHRtbFByb3BzLmRyYWdnYWJsZSA9IGZhbHNlO1xuICAgICAgICAvLyBEaXNhYmxlIHRleHQgc2VsZWN0aW9uXG4gICAgICAgIHN0eWxlLnVzZXJTZWxlY3QgPVxuICAgICAgICAgICAgc3R5bGUuV2Via2l0VXNlclNlbGVjdCA9XG4gICAgICAgICAgICAgICAgc3R5bGUuV2Via2l0VG91Y2hDYWxsb3V0ID1cbiAgICAgICAgICAgICAgICAgICAgXCJub25lXCI7XG4gICAgICAgIC8vIERpc2FibGUgc2Nyb2xsaW5nIG9uIHRoZSBkcmFnZ2FibGUgZGlyZWN0aW9uXG4gICAgICAgIHN0eWxlLnRvdWNoQWN0aW9uID1cbiAgICAgICAgICAgIHByb3BzLmRyYWcgPT09IHRydWVcbiAgICAgICAgICAgICAgICA/IFwibm9uZVwiXG4gICAgICAgICAgICAgICAgOiBgcGFuLSR7cHJvcHMuZHJhZyA9PT0gXCJ4XCIgPyBcInlcIiA6IFwieFwifWA7XG4gICAgfVxuICAgIGlmIChwcm9wcy50YWJJbmRleCA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgIChwcm9wcy5vblRhcCB8fCBwcm9wcy5vblRhcFN0YXJ0IHx8IHByb3BzLndoaWxlVGFwKSkge1xuICAgICAgICBodG1sUHJvcHMudGFiSW5kZXggPSAwO1xuICAgIH1cbiAgICBodG1sUHJvcHMuc3R5bGUgPSBzdHlsZTtcbiAgICByZXR1cm4gaHRtbFByb3BzO1xufVxuXG4vKipcbiAqIEEgbGlzdCBvZiBhbGwgdmFsaWQgTW90aW9uUHJvcHMuXG4gKlxuICogQHByaXZhdGVSZW1hcmtzXG4gKiBUaGlzIGRvZXNuJ3QgdGhyb3cgaWYgYSBgTW90aW9uUHJvcGAgbmFtZSBpcyBtaXNzaW5nIC0gaXQgc2hvdWxkLlxuICovXG5jb25zdCB2YWxpZE1vdGlvblByb3BzID0gbmV3IFNldChbXG4gICAgXCJhbmltYXRlXCIsXG4gICAgXCJleGl0XCIsXG4gICAgXCJ2YXJpYW50c1wiLFxuICAgIFwiaW5pdGlhbFwiLFxuICAgIFwic3R5bGVcIixcbiAgICBcInZhbHVlc1wiLFxuICAgIFwidmFyaWFudHNcIixcbiAgICBcInRyYW5zaXRpb25cIixcbiAgICBcInRyYW5zZm9ybVRlbXBsYXRlXCIsXG4gICAgXCJjdXN0b21cIixcbiAgICBcImluaGVyaXRcIixcbiAgICBcIm9uQmVmb3JlTGF5b3V0TWVhc3VyZVwiLFxuICAgIFwib25BbmltYXRpb25TdGFydFwiLFxuICAgIFwib25BbmltYXRpb25Db21wbGV0ZVwiLFxuICAgIFwib25VcGRhdGVcIixcbiAgICBcIm9uRHJhZ1N0YXJ0XCIsXG4gICAgXCJvbkRyYWdcIixcbiAgICBcIm9uRHJhZ0VuZFwiLFxuICAgIFwib25NZWFzdXJlRHJhZ0NvbnN0cmFpbnRzXCIsXG4gICAgXCJvbkRpcmVjdGlvbkxvY2tcIixcbiAgICBcIm9uRHJhZ1RyYW5zaXRpb25FbmRcIixcbiAgICBcIl9kcmFnWFwiLFxuICAgIFwiX2RyYWdZXCIsXG4gICAgXCJvbkhvdmVyU3RhcnRcIixcbiAgICBcIm9uSG92ZXJFbmRcIixcbiAgICBcIm9uVmlld3BvcnRFbnRlclwiLFxuICAgIFwib25WaWV3cG9ydExlYXZlXCIsXG4gICAgXCJnbG9iYWxUYXBUYXJnZXRcIixcbiAgICBcImlnbm9yZVN0cmljdFwiLFxuICAgIFwidmlld3BvcnRcIixcbl0pO1xuLyoqXG4gKiBDaGVjayB3aGV0aGVyIGEgcHJvcCBuYW1lIGlzIGEgdmFsaWQgYE1vdGlvblByb3BgIGtleS5cbiAqXG4gKiBAcGFyYW0ga2V5IC0gTmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gY2hlY2tcbiAqIEByZXR1cm5zIGB0cnVlYCBpcyBrZXkgaXMgYSB2YWxpZCBgTW90aW9uUHJvcGAuXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBpc1ZhbGlkTW90aW9uUHJvcChrZXkpIHtcbiAgICByZXR1cm4gKGtleS5zdGFydHNXaXRoKFwid2hpbGVcIikgfHxcbiAgICAgICAgKGtleS5zdGFydHNXaXRoKFwiZHJhZ1wiKSAmJiBrZXkgIT09IFwiZHJhZ2dhYmxlXCIpIHx8XG4gICAgICAgIGtleS5zdGFydHNXaXRoKFwibGF5b3V0XCIpIHx8XG4gICAgICAgIGtleS5zdGFydHNXaXRoKFwib25UYXBcIikgfHxcbiAgICAgICAga2V5LnN0YXJ0c1dpdGgoXCJvblBhblwiKSB8fFxuICAgICAgICBrZXkuc3RhcnRzV2l0aChcIm9uTGF5b3V0XCIpIHx8XG4gICAgICAgIHZhbGlkTW90aW9uUHJvcHMuaGFzKGtleSkpO1xufVxuXG5sZXQgc2hvdWxkRm9yd2FyZCA9IChrZXkpID0+ICFpc1ZhbGlkTW90aW9uUHJvcChrZXkpO1xuZnVuY3Rpb24gbG9hZEV4dGVybmFsSXNWYWxpZFByb3AoaXNWYWxpZFByb3ApIHtcbiAgICBpZiAoIWlzVmFsaWRQcm9wKVxuICAgICAgICByZXR1cm47XG4gICAgLy8gRXhwbGljaXRseSBmaWx0ZXIgb3VyIGV2ZW50c1xuICAgIHNob3VsZEZvcndhcmQgPSAoa2V5KSA9PiBrZXkuc3RhcnRzV2l0aChcIm9uXCIpID8gIWlzVmFsaWRNb3Rpb25Qcm9wKGtleSkgOiBpc1ZhbGlkUHJvcChrZXkpO1xufVxuLyoqXG4gKiBFbW90aW9uIGFuZCBTdHlsZWQgQ29tcG9uZW50cyBib3RoIGFsbG93IHVzZXJzIHRvIHBhc3MgdGhyb3VnaCBhcmJpdHJhcnkgcHJvcHMgdG8gdGhlaXIgY29tcG9uZW50c1xuICogdG8gZHluYW1pY2FsbHkgZ2VuZXJhdGUgQ1NTLiBUaGV5IGJvdGggdXNlIHRoZSBgQGVtb3Rpb24vaXMtcHJvcC12YWxpZGAgcGFja2FnZSB0byBkZXRlcm1pbmUgd2hpY2hcbiAqIG9mIHRoZXNlIHNob3VsZCBiZSBwYXNzZWQgdG8gdGhlIHVuZGVybHlpbmcgRE9NIG5vZGUuXG4gKlxuICogSG93ZXZlciwgd2hlbiBzdHlsaW5nIGEgTW90aW9uIGNvbXBvbmVudCBgc3R5bGVkKG1vdGlvbi5kaXYpYCwgYm90aCBwYWNrYWdlcyBwYXNzIHRocm91Z2ggKmFsbCogcHJvcHNcbiAqIGFzIGl0J3Mgc2VlbiBhcyBhbiBhcmJpdHJhcnkgY29tcG9uZW50IHJhdGhlciB0aGFuIGEgRE9NIG5vZGUuIE1vdGlvbiBvbmx5IGFsbG93cyBhcmJpdHJhcnkgcHJvcHNcbiAqIHBhc3NlZCB0aHJvdWdoIHRoZSBgY3VzdG9tYCBwcm9wIHNvIGl0IGRvZXNuJ3QgKm5lZWQqIHRoZSBwYXlsb2FkIG9yIGNvbXB1dGF0aW9uYWwgb3ZlcmhlYWQgb2ZcbiAqIGBAZW1vdGlvbi9pcy1wcm9wLXZhbGlkYCwgaG93ZXZlciB0byBmaXggdGhpcyBwcm9ibGVtIHdlIG5lZWQgdG8gdXNlIGl0LlxuICpcbiAqIEJ5IG1ha2luZyBpdCBhbiBvcHRpb25hbERlcGVuZGVuY3kgd2UgY2FuIG9mZmVyIHRoaXMgZnVuY3Rpb25hbGl0eSBvbmx5IGluIHRoZSBzaXR1YXRpb25zIHdoZXJlIGl0J3NcbiAqIGFjdHVhbGx5IHJlcXVpcmVkLlxuICovXG50cnkge1xuICAgIC8qKlxuICAgICAqIFdlIGF0dGVtcHQgdG8gaW1wb3J0IHRoaXMgcGFja2FnZSBidXQgcmVxdWlyZSB3b24ndCBiZSBkZWZpbmVkIGluIGVzbSBlbnZpcm9ubWVudHMsIGluIHRoYXQgY2FzZVxuICAgICAqIGlzUHJvcFZhbGlkIHdpbGwgaGF2ZSB0byBiZSBwcm92aWRlZCB2aWEgYE1vdGlvbkNvbnRleHRgLiBJbiBhIDYuMC4wIHRoaXMgc2hvdWxkIHByb2JhYmx5IGJlIHJlbW92ZWRcbiAgICAgKiBpbiBmYXZvdXIgb2YgZXhwbGljaXQgaW5qZWN0aW9uLlxuICAgICAqL1xuICAgIGxvYWRFeHRlcm5hbElzVmFsaWRQcm9wKHJlcXVpcmUoXCJAZW1vdGlvbi9pcy1wcm9wLXZhbGlkXCIpLmRlZmF1bHQpO1xufVxuY2F0Y2ggKF9hKSB7XG4gICAgLy8gV2UgZG9uJ3QgbmVlZCB0byBhY3R1YWxseSBkbyBhbnl0aGluZyBoZXJlIC0gdGhlIGZhbGxiYWNrIGlzIHRoZSBleGlzdGluZyBgaXNQcm9wVmFsaWRgLlxufVxuZnVuY3Rpb24gZmlsdGVyUHJvcHMocHJvcHMsIGlzRG9tLCBmb3J3YXJkTW90aW9uUHJvcHMpIHtcbiAgICBjb25zdCBmaWx0ZXJlZFByb3BzID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHZhbHVlcyBpcyBjb25zaWRlcmVkIGEgdmFsaWQgcHJvcCBieSBFbW90aW9uLCBzbyBpZiBpdCdzIHByZXNlbnRcbiAgICAgICAgICogdGhpcyB3aWxsIGJlIHJlbmRlcmVkIG91dCB0byB0aGUgRE9NIHVubGVzcyBleHBsaWNpdGx5IGZpbHRlcmVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBXZSBjaGVjayB0aGUgdHlwZSBhcyBpdCBjb3VsZCBiZSB1c2VkIHdpdGggdGhlIGBmZUNvbG9yTWF0cml4YFxuICAgICAgICAgKiBlbGVtZW50LCB3aGljaCB3ZSBzdXBwb3J0LlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGtleSA9PT0gXCJ2YWx1ZXNcIiAmJiB0eXBlb2YgcHJvcHMudmFsdWVzID09PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChzaG91bGRGb3J3YXJkKGtleSkgfHxcbiAgICAgICAgICAgIChmb3J3YXJkTW90aW9uUHJvcHMgPT09IHRydWUgJiYgaXNWYWxpZE1vdGlvblByb3Aoa2V5KSkgfHxcbiAgICAgICAgICAgICghaXNEb20gJiYgIWlzVmFsaWRNb3Rpb25Qcm9wKGtleSkpIHx8XG4gICAgICAgICAgICAvLyBJZiB0cnlpbmcgdG8gdXNlIG5hdGl2ZSBIVE1MIGRyYWcgZXZlbnRzLCBmb3J3YXJkIGRyYWcgbGlzdGVuZXJzXG4gICAgICAgICAgICAocHJvcHNbXCJkcmFnZ2FibGVcIl0gJiZcbiAgICAgICAgICAgICAgICBrZXkuc3RhcnRzV2l0aChcIm9uRHJhZ1wiKSkpIHtcbiAgICAgICAgICAgIGZpbHRlcmVkUHJvcHNba2V5XSA9XG4gICAgICAgICAgICAgICAgcHJvcHNba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmlsdGVyZWRQcm9wcztcbn1cblxuZnVuY3Rpb24gdXNlU1ZHUHJvcHMocHJvcHMsIHZpc3VhbFN0YXRlLCBfaXNTdGF0aWMsIENvbXBvbmVudCkge1xuICAgIGNvbnN0IHZpc3VhbFByb3BzID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gY3JlYXRlU3ZnUmVuZGVyU3RhdGUoKTtcbiAgICAgICAgYnVpbGRTVkdBdHRycyhzdGF0ZSwgdmlzdWFsU3RhdGUsIGlzU1ZHVGFnKENvbXBvbmVudCksIHByb3BzLnRyYW5zZm9ybVRlbXBsYXRlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN0YXRlLmF0dHJzLFxuICAgICAgICAgICAgc3R5bGU6IHsgLi4uc3RhdGUuc3R5bGUgfSxcbiAgICAgICAgfTtcbiAgICB9LCBbdmlzdWFsU3RhdGVdKTtcbiAgICBpZiAocHJvcHMuc3R5bGUpIHtcbiAgICAgICAgY29uc3QgcmF3U3R5bGVzID0ge307XG4gICAgICAgIGNvcHlSYXdWYWx1ZXNPbmx5KHJhd1N0eWxlcywgcHJvcHMuc3R5bGUsIHByb3BzKTtcbiAgICAgICAgdmlzdWFsUHJvcHMuc3R5bGUgPSB7IC4uLnJhd1N0eWxlcywgLi4udmlzdWFsUHJvcHMuc3R5bGUgfTtcbiAgICB9XG4gICAgcmV0dXJuIHZpc3VhbFByb3BzO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVVc2VSZW5kZXIoZm9yd2FyZE1vdGlvblByb3BzID0gZmFsc2UpIHtcbiAgICBjb25zdCB1c2VSZW5kZXIgPSAoQ29tcG9uZW50LCBwcm9wcywgcmVmLCB7IGxhdGVzdFZhbHVlcyB9LCBpc1N0YXRpYykgPT4ge1xuICAgICAgICBjb25zdCB1c2VWaXN1YWxQcm9wcyA9IGlzU1ZHQ29tcG9uZW50KENvbXBvbmVudClcbiAgICAgICAgICAgID8gdXNlU1ZHUHJvcHNcbiAgICAgICAgICAgIDogdXNlSFRNTFByb3BzO1xuICAgICAgICBjb25zdCB2aXN1YWxQcm9wcyA9IHVzZVZpc3VhbFByb3BzKHByb3BzLCBsYXRlc3RWYWx1ZXMsIGlzU3RhdGljLCBDb21wb25lbnQpO1xuICAgICAgICBjb25zdCBmaWx0ZXJlZFByb3BzID0gZmlsdGVyUHJvcHMocHJvcHMsIHR5cGVvZiBDb21wb25lbnQgPT09IFwic3RyaW5nXCIsIGZvcndhcmRNb3Rpb25Qcm9wcyk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRQcm9wcyA9IENvbXBvbmVudCAhPT0gUmVhY3QuRnJhZ21lbnRcbiAgICAgICAgICAgID8geyAuLi5maWx0ZXJlZFByb3BzLCAuLi52aXN1YWxQcm9wcywgcmVmIH1cbiAgICAgICAgICAgIDoge307XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBjb21wb25lbnQgaGFzIGJlZW4gaGFuZGVkIGEgbW90aW9uIHZhbHVlIGFzIGl0cyBjaGlsZCxcbiAgICAgICAgICogbWVtb2lzZSBpdHMgaW5pdGlhbCB2YWx1ZSBhbmQgcmVuZGVyIHRoYXQuIFN1YnNlcXVlbnQgdXBkYXRlc1xuICAgICAgICAgKiB3aWxsIGJlIGhhbmRsZWQgYnkgdGhlIG9uQ2hhbmdlIGhhbmRsZXJcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHsgY2hpbGRyZW4gfSA9IHByb3BzO1xuICAgICAgICBjb25zdCByZW5kZXJlZENoaWxkcmVuID0gUmVhY3QudXNlTWVtbygoKSA9PiAoaXNNb3Rpb25WYWx1ZShjaGlsZHJlbikgPyBjaGlsZHJlbi5nZXQoKSA6IGNoaWxkcmVuKSwgW2NoaWxkcmVuXSk7XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwge1xuICAgICAgICAgICAgLi4uZWxlbWVudFByb3BzLFxuICAgICAgICAgICAgY2hpbGRyZW46IHJlbmRlcmVkQ2hpbGRyZW4sXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIHVzZVJlbmRlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTW90aW9uQ29tcG9uZW50RmFjdG9yeShwcmVsb2FkZWRGZWF0dXJlcywgY3JlYXRlVmlzdWFsRWxlbWVudCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBjcmVhdGVNb3Rpb25Db21wb25lbnQoQ29tcG9uZW50LCB7IGZvcndhcmRNb3Rpb25Qcm9wcyB9ID0geyBmb3J3YXJkTW90aW9uUHJvcHM6IGZhbHNlIH0pIHtcbiAgICAgICAgY29uc3QgYmFzZUNvbmZpZyA9IGlzU1ZHQ29tcG9uZW50KENvbXBvbmVudClcbiAgICAgICAgICAgID8gc3ZnTW90aW9uQ29uZmlnXG4gICAgICAgICAgICA6IGh0bWxNb3Rpb25Db25maWc7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgICAgIC4uLmJhc2VDb25maWcsXG4gICAgICAgICAgICBwcmVsb2FkZWRGZWF0dXJlcyxcbiAgICAgICAgICAgIHVzZVJlbmRlcjogY3JlYXRlVXNlUmVuZGVyKGZvcndhcmRNb3Rpb25Qcm9wcyksXG4gICAgICAgICAgICBjcmVhdGVWaXN1YWxFbGVtZW50LFxuICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY3JlYXRlUmVuZGVyZXJNb3Rpb25Db21wb25lbnQoY29uZmlnKTtcbiAgICB9O1xufVxuXG5jb25zdCBjcmVhdGVEb21WaXN1YWxFbGVtZW50ID0gKENvbXBvbmVudCwgb3B0aW9ucykgPT4ge1xuICAgIHJldHVybiBpc1NWR0NvbXBvbmVudChDb21wb25lbnQpXG4gICAgICAgID8gbmV3IFNWR1Zpc3VhbEVsZW1lbnQob3B0aW9ucylcbiAgICAgICAgOiBuZXcgSFRNTFZpc3VhbEVsZW1lbnQob3B0aW9ucywge1xuICAgICAgICAgICAgYWxsb3dQcm9qZWN0aW9uOiBDb21wb25lbnQgIT09IFJlYWN0LkZyYWdtZW50LFxuICAgICAgICB9KTtcbn07XG5cbmNvbnN0IGNyZWF0ZU1vdGlvbkNvbXBvbmVudCA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlTW90aW9uQ29tcG9uZW50RmFjdG9yeSh7XG4gICAgLi4uYW5pbWF0aW9ucyxcbiAgICAuLi5nZXN0dXJlQW5pbWF0aW9ucyxcbiAgICAuLi5kcmFnLFxuICAgIC4uLmxheW91dCxcbn0sIGNyZWF0ZURvbVZpc3VhbEVsZW1lbnQpO1xuXG5jb25zdCBtb3Rpb24gPSAvKkBfX1BVUkVfXyovIGNyZWF0ZURPTU1vdGlvbkNvbXBvbmVudFByb3h5KGNyZWF0ZU1vdGlvbkNvbXBvbmVudCk7XG5cbmNvbnN0IGNyZWF0ZU1pbmltYWxNb3Rpb25Db21wb25lbnQgPSBcbi8qQF9fUFVSRV9fKi8gY3JlYXRlTW90aW9uQ29tcG9uZW50RmFjdG9yeSgpO1xuXG5jb25zdCBtID0gLypAX19QVVJFX18qLyBjcmVhdGVET01Nb3Rpb25Db21wb25lbnRQcm94eShjcmVhdGVNaW5pbWFsTW90aW9uQ29tcG9uZW50KTtcblxuLyoqXG4gKiBNZWFzdXJlbWVudCBmdW5jdGlvbmFsaXR5IGhhcyB0byBiZSB3aXRoaW4gYSBzZXBhcmF0ZSBjb21wb25lbnRcbiAqIHRvIGxldmVyYWdlIHNuYXBzaG90IGxpZmVjeWNsZS5cbiAqL1xuY2xhc3MgUG9wQ2hpbGRNZWFzdXJlIGV4dGVuZHMgUmVhY3RfX25hbWVzcGFjZS5Db21wb25lbnQge1xuICAgIGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5wcm9wcy5jaGlsZFJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoZWxlbWVudCAmJiBwcmV2UHJvcHMuaXNQcmVzZW50ICYmICF0aGlzLnByb3BzLmlzUHJlc2VudCkge1xuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMucHJvcHMuc2l6ZVJlZi5jdXJyZW50O1xuICAgICAgICAgICAgc2l6ZS5oZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodCB8fCAwO1xuICAgICAgICAgICAgc2l6ZS53aWR0aCA9IGVsZW1lbnQub2Zmc2V0V2lkdGggfHwgMDtcbiAgICAgICAgICAgIHNpemUudG9wID0gZWxlbWVudC5vZmZzZXRUb3A7XG4gICAgICAgICAgICBzaXplLmxlZnQgPSBlbGVtZW50Lm9mZnNldExlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcXVpcmVkIHdpdGggZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgdG8gc3RvcCBSZWFjdCBjb21wbGFpbmluZy5cbiAgICAgKi9cbiAgICBjb21wb25lbnREaWRVcGRhdGUoKSB7IH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICAgIH1cbn1cbmZ1bmN0aW9uIFBvcENoaWxkKHsgY2hpbGRyZW4sIGlzUHJlc2VudCB9KSB7XG4gICAgY29uc3QgaWQgPSBSZWFjdC51c2VJZCgpO1xuICAgIGNvbnN0IHJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgICBjb25zdCBzaXplID0gUmVhY3QudXNlUmVmKHtcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICBsZWZ0OiAwLFxuICAgIH0pO1xuICAgIGNvbnN0IHsgbm9uY2UgfSA9IFJlYWN0LnVzZUNvbnRleHQoTW90aW9uQ29uZmlnQ29udGV4dCk7XG4gICAgLyoqXG4gICAgICogV2UgY3JlYXRlIGFuZCBpbmplY3QgYSBzdHlsZSBibG9jayBzbyB3ZSBjYW4gYXBwbHkgdGhpcyBleHBsaWNpdFxuICAgICAqIHNpemluZyBpbiBhIG5vbi1kZXN0cnVjdGl2ZSBtYW5uZXIgYnkganVzdCBkZWxldGluZyB0aGUgc3R5bGUgYmxvY2suXG4gICAgICpcbiAgICAgKiBXZSBjYW4ndCBhcHBseSBzaXplIHZpYSByZW5kZXIgYXMgdGhlIG1lYXN1cmVtZW50IGhhcHBlbnNcbiAgICAgKiBpbiBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSAocG9zdC1yZW5kZXIpLCBsaWtld2lzZSBpZiB3ZSBhcHBseSB0aGVcbiAgICAgKiBzdHlsZXMgZGlyZWN0bHkgb24gdGhlIERPTSBub2RlLCB3ZSBtaWdodCBiZSBvdmVyd3JpdGluZ1xuICAgICAqIHN0eWxlcyBzZXQgdmlhIHRoZSBzdHlsZSBwcm9wLlxuICAgICAqL1xuICAgIFJlYWN0LnVzZUluc2VydGlvbkVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgdG9wLCBsZWZ0IH0gPSBzaXplLmN1cnJlbnQ7XG4gICAgICAgIGlmIChpc1ByZXNlbnQgfHwgIXJlZi5jdXJyZW50IHx8ICF3aWR0aCB8fCAhaGVpZ2h0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICByZWYuY3VycmVudC5kYXRhc2V0Lm1vdGlvblBvcElkID0gaWQ7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgICAgICBpZiAobm9uY2UpXG4gICAgICAgICAgICBzdHlsZS5ub25jZSA9IG5vbmNlO1xuICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICAgICAgaWYgKHN0eWxlLnNoZWV0KSB7XG4gICAgICAgICAgICBzdHlsZS5zaGVldC5pbnNlcnRSdWxlKGBcbiAgICAgICAgICBbZGF0YS1tb3Rpb24tcG9wLWlkPVwiJHtpZH1cIl0ge1xuICAgICAgICAgICAgcG9zaXRpb246IGFic29sdXRlICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICB3aWR0aDogJHt3aWR0aH1weCAhaW1wb3J0YW50O1xuICAgICAgICAgICAgaGVpZ2h0OiAke2hlaWdodH1weCAhaW1wb3J0YW50O1xuICAgICAgICAgICAgdG9wOiAke3RvcH1weCAhaW1wb3J0YW50O1xuICAgICAgICAgICAgbGVmdDogJHtsZWZ0fXB4ICFpbXBvcnRhbnQ7XG4gICAgICAgICAgfVxuICAgICAgICBgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgZG9jdW1lbnQuaGVhZC5yZW1vdmVDaGlsZChzdHlsZSk7XG4gICAgICAgIH07XG4gICAgfSwgW2lzUHJlc2VudF0pO1xuICAgIHJldHVybiAoanN4UnVudGltZS5qc3goUG9wQ2hpbGRNZWFzdXJlLCB7IGlzUHJlc2VudDogaXNQcmVzZW50LCBjaGlsZFJlZjogcmVmLCBzaXplUmVmOiBzaXplLCBjaGlsZHJlbjogUmVhY3RfX25hbWVzcGFjZS5jbG9uZUVsZW1lbnQoY2hpbGRyZW4sIHsgcmVmIH0pIH0pKTtcbn1cblxuY29uc3QgUHJlc2VuY2VDaGlsZCA9ICh7IGNoaWxkcmVuLCBpbml0aWFsLCBpc1ByZXNlbnQsIG9uRXhpdENvbXBsZXRlLCBjdXN0b20sIHByZXNlbmNlQWZmZWN0c0xheW91dCwgbW9kZSwgfSkgPT4ge1xuICAgIGNvbnN0IHByZXNlbmNlQ2hpbGRyZW4gPSB1c2VDb25zdGFudChuZXdDaGlsZHJlbk1hcCk7XG4gICAgY29uc3QgaWQgPSBSZWFjdC51c2VJZCgpO1xuICAgIGNvbnN0IG1lbW9pemVkT25FeGl0Q29tcGxldGUgPSBSZWFjdC51c2VDYWxsYmFjaygoY2hpbGRJZCkgPT4ge1xuICAgICAgICBwcmVzZW5jZUNoaWxkcmVuLnNldChjaGlsZElkLCB0cnVlKTtcbiAgICAgICAgZm9yIChjb25zdCBpc0NvbXBsZXRlIG9mIHByZXNlbmNlQ2hpbGRyZW4udmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGlmICghaXNDb21wbGV0ZSlcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIGNhbiBzdG9wIHNlYXJjaGluZyB3aGVuIGFueSBpcyBpbmNvbXBsZXRlXG4gICAgICAgIH1cbiAgICAgICAgb25FeGl0Q29tcGxldGUgJiYgb25FeGl0Q29tcGxldGUoKTtcbiAgICB9LCBbcHJlc2VuY2VDaGlsZHJlbiwgb25FeGl0Q29tcGxldGVdKTtcbiAgICBjb25zdCBjb250ZXh0ID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgICAgICBpZCxcbiAgICAgICAgaW5pdGlhbCxcbiAgICAgICAgaXNQcmVzZW50LFxuICAgICAgICBjdXN0b20sXG4gICAgICAgIG9uRXhpdENvbXBsZXRlOiBtZW1vaXplZE9uRXhpdENvbXBsZXRlLFxuICAgICAgICByZWdpc3RlcjogKGNoaWxkSWQpID0+IHtcbiAgICAgICAgICAgIHByZXNlbmNlQ2hpbGRyZW4uc2V0KGNoaWxkSWQsIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiBwcmVzZW5jZUNoaWxkcmVuLmRlbGV0ZShjaGlsZElkKTtcbiAgICAgICAgfSxcbiAgICB9KSwgXG4gICAgLyoqXG4gICAgICogSWYgdGhlIHByZXNlbmNlIG9mIGEgY2hpbGQgYWZmZWN0cyB0aGUgbGF5b3V0IG9mIHRoZSBjb21wb25lbnRzIGFyb3VuZCBpdCxcbiAgICAgKiB3ZSB3YW50IHRvIG1ha2UgYSBuZXcgY29udGV4dCB2YWx1ZSB0byBlbnN1cmUgdGhleSBnZXQgcmUtcmVuZGVyZWRcbiAgICAgKiBzbyB0aGV5IGNhbiBkZXRlY3QgdGhhdCBsYXlvdXQgY2hhbmdlLlxuICAgICAqL1xuICAgIHByZXNlbmNlQWZmZWN0c0xheW91dFxuICAgICAgICA/IFtNYXRoLnJhbmRvbSgpLCBtZW1vaXplZE9uRXhpdENvbXBsZXRlXVxuICAgICAgICA6IFtpc1ByZXNlbnQsIG1lbW9pemVkT25FeGl0Q29tcGxldGVdKTtcbiAgICBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcHJlc2VuY2VDaGlsZHJlbi5mb3JFYWNoKChfLCBrZXkpID0+IHByZXNlbmNlQ2hpbGRyZW4uc2V0KGtleSwgZmFsc2UpKTtcbiAgICB9LCBbaXNQcmVzZW50XSk7XG4gICAgLyoqXG4gICAgICogSWYgdGhlcmUncyBubyBgbW90aW9uYCBjb21wb25lbnRzIHRvIGZpcmUgZXhpdCBhbmltYXRpb25zLCB3ZSB3YW50IHRvIHJlbW92ZSB0aGlzXG4gICAgICogY29tcG9uZW50IGltbWVkaWF0ZWx5LlxuICAgICAqL1xuICAgIFJlYWN0X19uYW1lc3BhY2UudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgIWlzUHJlc2VudCAmJlxuICAgICAgICAgICAgIXByZXNlbmNlQ2hpbGRyZW4uc2l6ZSAmJlxuICAgICAgICAgICAgb25FeGl0Q29tcGxldGUgJiZcbiAgICAgICAgICAgIG9uRXhpdENvbXBsZXRlKCk7XG4gICAgfSwgW2lzUHJlc2VudF0pO1xuICAgIGlmIChtb2RlID09PSBcInBvcExheW91dFwiKSB7XG4gICAgICAgIGNoaWxkcmVuID0ganN4UnVudGltZS5qc3goUG9wQ2hpbGQsIHsgaXNQcmVzZW50OiBpc1ByZXNlbnQsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KTtcbiAgICB9XG4gICAgcmV0dXJuIChqc3hSdW50aW1lLmpzeChQcmVzZW5jZUNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGNvbnRleHQsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSk7XG59O1xuZnVuY3Rpb24gbmV3Q2hpbGRyZW5NYXAoKSB7XG4gICAgcmV0dXJuIG5ldyBNYXAoKTtcbn1cblxuZnVuY3Rpb24gdXNlVW5tb3VudEVmZmVjdChjYWxsYmFjaykge1xuICAgIHJldHVybiBSZWFjdC51c2VFZmZlY3QoKCkgPT4gKCkgPT4gY2FsbGJhY2soKSwgW10pO1xufVxuXG5mdW5jdGlvbiB1c2VJc01vdW50ZWQoKSB7XG4gICAgY29uc3QgaXNNb3VudGVkID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgaXNNb3VudGVkLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgaXNNb3VudGVkLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIGlzTW91bnRlZDtcbn1cblxuZnVuY3Rpb24gdXNlRm9yY2VVcGRhdGUoKSB7XG4gICAgY29uc3QgaXNNb3VudGVkID0gdXNlSXNNb3VudGVkKCk7XG4gICAgY29uc3QgW2ZvcmNlZFJlbmRlckNvdW50LCBzZXRGb3JjZWRSZW5kZXJDb3VudF0gPSBSZWFjdC51c2VTdGF0ZSgwKTtcbiAgICBjb25zdCBmb3JjZVJlbmRlciA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgaXNNb3VudGVkLmN1cnJlbnQgJiYgc2V0Rm9yY2VkUmVuZGVyQ291bnQoZm9yY2VkUmVuZGVyQ291bnQgKyAxKTtcbiAgICB9LCBbZm9yY2VkUmVuZGVyQ291bnRdKTtcbiAgICAvKipcbiAgICAgKiBEZWZlciB0aGlzIHRvIHRoZSBlbmQgb2YgdGhlIG5leHQgYW5pbWF0aW9uIGZyYW1lIGluIGNhc2UgdGhlcmUgYXJlIG11bHRpcGxlXG4gICAgICogc3luY2hyb25vdXMgY2FsbHMuXG4gICAgICovXG4gICAgY29uc3QgZGVmZXJyZWRGb3JjZVJlbmRlciA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IGZyYW1lLnBvc3RSZW5kZXIoZm9yY2VSZW5kZXIpLCBbZm9yY2VSZW5kZXJdKTtcbiAgICByZXR1cm4gW2RlZmVycmVkRm9yY2VSZW5kZXIsIGZvcmNlZFJlbmRlckNvdW50XTtcbn1cblxuY29uc3QgZ2V0Q2hpbGRLZXkgPSAoY2hpbGQpID0+IGNoaWxkLmtleSB8fCBcIlwiO1xuZnVuY3Rpb24gb25seUVsZW1lbnRzKGNoaWxkcmVuKSB7XG4gICAgY29uc3QgZmlsdGVyZWQgPSBbXTtcbiAgICAvLyBXZSB1c2UgZm9yRWFjaCBoZXJlIGluc3RlYWQgb2YgbWFwIGFzIG1hcCBtdXRhdGVzIHRoZSBjb21wb25lbnQga2V5IGJ5IHByZXByZW5kaW5nIGAuJGBcbiAgICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCAoY2hpbGQpID0+IHtcbiAgICAgICAgaWYgKFJlYWN0LmlzVmFsaWRFbGVtZW50KGNoaWxkKSlcbiAgICAgICAgICAgIGZpbHRlcmVkLnB1c2goY2hpbGQpO1xuICAgIH0pO1xuICAgIHJldHVybiBmaWx0ZXJlZDtcbn1cblxuLyoqXG4gKiBgQW5pbWF0ZVByZXNlbmNlYCBlbmFibGVzIHRoZSBhbmltYXRpb24gb2YgY29tcG9uZW50cyB0aGF0IGhhdmUgYmVlbiByZW1vdmVkIGZyb20gdGhlIHRyZWUuXG4gKlxuICogV2hlbiBhZGRpbmcvcmVtb3ZpbmcgbW9yZSB0aGFuIGEgc2luZ2xlIGNoaWxkLCBldmVyeSBjaGlsZCAqKm11c3QqKiBiZSBnaXZlbiBhIHVuaXF1ZSBga2V5YCBwcm9wLlxuICpcbiAqIEFueSBgbW90aW9uYCBjb21wb25lbnRzIHRoYXQgaGF2ZSBhbiBgZXhpdGAgcHJvcGVydHkgZGVmaW5lZCB3aWxsIGFuaW1hdGUgb3V0IHdoZW4gcmVtb3ZlZCBmcm9tXG4gKiB0aGUgdHJlZS5cbiAqXG4gKiBgYGBqc3hcbiAqIGltcG9ydCB7IG1vdGlvbiwgQW5pbWF0ZVByZXNlbmNlIH0gZnJvbSAnZnJhbWVyLW1vdGlvbidcbiAqXG4gKiBleHBvcnQgY29uc3QgSXRlbXMgPSAoeyBpdGVtcyB9KSA9PiAoXG4gKiAgIDxBbmltYXRlUHJlc2VuY2U+XG4gKiAgICAge2l0ZW1zLm1hcChpdGVtID0+IChcbiAqICAgICAgIDxtb3Rpb24uZGl2XG4gKiAgICAgICAgIGtleT17aXRlbS5pZH1cbiAqICAgICAgICAgaW5pdGlhbD17eyBvcGFjaXR5OiAwIH19XG4gKiAgICAgICAgIGFuaW1hdGU9e3sgb3BhY2l0eTogMSB9fVxuICogICAgICAgICBleGl0PXt7IG9wYWNpdHk6IDAgfX1cbiAqICAgICAgIC8+XG4gKiAgICAgKSl9XG4gKiAgIDwvQW5pbWF0ZVByZXNlbmNlPlxuICogKVxuICogYGBgXG4gKlxuICogWW91IGNhbiBzZXF1ZW5jZSBleGl0IGFuaW1hdGlvbnMgdGhyb3VnaG91dCBhIHRyZWUgdXNpbmcgdmFyaWFudHMuXG4gKlxuICogSWYgYSBjaGlsZCBjb250YWlucyBtdWx0aXBsZSBgbW90aW9uYCBjb21wb25lbnRzIHdpdGggYGV4aXRgIHByb3BzLCBpdCB3aWxsIG9ubHkgdW5tb3VudCB0aGUgY2hpbGRcbiAqIG9uY2UgYWxsIGBtb3Rpb25gIGNvbXBvbmVudHMgaGF2ZSBmaW5pc2hlZCBhbmltYXRpbmcgb3V0LiBMaWtld2lzZSwgYW55IGNvbXBvbmVudHMgdXNpbmdcbiAqIGB1c2VQcmVzZW5jZWAgYWxsIG5lZWQgdG8gY2FsbCBgc2FmZVRvUmVtb3ZlYC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IEFuaW1hdGVQcmVzZW5jZSA9ICh7IGNoaWxkcmVuLCBleGl0QmVmb3JlRW50ZXIsIGN1c3RvbSwgaW5pdGlhbCA9IHRydWUsIG9uRXhpdENvbXBsZXRlLCBwcmVzZW5jZUFmZmVjdHNMYXlvdXQgPSB0cnVlLCBtb2RlID0gXCJzeW5jXCIsIH0pID0+IHtcbiAgICBtb3Rpb25VdGlscy5pbnZhcmlhbnQoIWV4aXRCZWZvcmVFbnRlciwgXCJSZXBsYWNlIGV4aXRCZWZvcmVFbnRlciB3aXRoIG1vZGU9J3dhaXQnXCIpO1xuICAgIC8qKlxuICAgICAqIEZpbHRlciBhbnkgY2hpbGRyZW4gdGhhdCBhcmVuJ3QgUmVhY3RFbGVtZW50cy4gV2UgY2FuIG9ubHkgdHJhY2sgY29tcG9uZW50c1xuICAgICAqIGJldHdlZW4gcmVuZGVycyB3aXRoIGEgcHJvcHMua2V5LlxuICAgICAqL1xuICAgIGNvbnN0IHByZXNlbnRDaGlsZHJlbiA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gb25seUVsZW1lbnRzKGNoaWxkcmVuKSwgW2NoaWxkcmVuXSk7XG4gICAgLyoqXG4gICAgICogVHJhY2sgdGhlIGtleXMgb2YgdGhlIGN1cnJlbnRseSByZW5kZXJlZCBjaGlsZHJlbi4gVGhpcyBpcyB1c2VkIHRvXG4gICAgICogZGV0ZXJtaW5lIHdoaWNoIGNoaWxkcmVuIGFyZSBleGl0aW5nLlxuICAgICAqL1xuICAgIGNvbnN0IHByZXNlbnRLZXlzID0gcHJlc2VudENoaWxkcmVuLm1hcChnZXRDaGlsZEtleSk7XG4gICAgLyoqXG4gICAgICogSWYgYGluaXRpYWw9e2ZhbHNlfWAgd2Ugb25seSB3YW50IHRvIHBhc3MgdGhpcyB0byBjb21wb25lbnRzIGluIHRoZSBmaXJzdCByZW5kZXIuXG4gICAgICovXG4gICAgY29uc3QgaXNJbml0aWFsUmVuZGVyID0gUmVhY3QudXNlUmVmKHRydWUpO1xuICAgIC8qKlxuICAgICAqIEEgcmVmIGNvbnRhaW5pbmcgdGhlIGN1cnJlbnRseSBwcmVzZW50IGNoaWxkcmVuLiBXaGVuIGFsbCBleGl0IGFuaW1hdGlvbnNcbiAgICAgKiBhcmUgY29tcGxldGUsIHdlIHVzZSB0aGlzIHRvIHJlLXJlbmRlciB0aGUgY29tcG9uZW50IHdpdGggdGhlIGxhdGVzdCBjaGlsZHJlblxuICAgICAqICpjb21taXR0ZWQqIHJhdGhlciB0aGFuIHRoZSBsYXRlc3QgY2hpbGRyZW4gKnJlbmRlcmVkKi5cbiAgICAgKi9cbiAgICBjb25zdCBwZW5kaW5nUHJlc2VudENoaWxkcmVuID0gUmVhY3QudXNlUmVmKHByZXNlbnRDaGlsZHJlbik7XG4gICAgLyoqXG4gICAgICogVHJhY2sgd2hpY2ggZXhpdGluZyBjaGlsZHJlbiBoYXZlIGZpbmlzaGVkIGFuaW1hdGluZyBvdXQuXG4gICAgICovXG4gICAgY29uc3QgZXhpdENvbXBsZXRlID0gdXNlQ29uc3RhbnQoKCkgPT4gbmV3IE1hcCgpKTtcbiAgICAvKipcbiAgICAgKiBTYXZlIGNoaWxkcmVuIHRvIHJlbmRlciBhcyBSZWFjdCBzdGF0ZS4gVG8gZW5zdXJlIHRoaXMgY29tcG9uZW50IGlzIGNvbmN1cnJlbnQtc2FmZSxcbiAgICAgKiB3ZSBjaGVjayBmb3IgZXhpdGluZyBjaGlsZHJlbiB2aWEgYW4gZWZmZWN0LlxuICAgICAqL1xuICAgIGNvbnN0IFtkaWZmZWRDaGlsZHJlbiwgc2V0RGlmZmVkQ2hpbGRyZW5dID0gUmVhY3QudXNlU3RhdGUocHJlc2VudENoaWxkcmVuKTtcbiAgICBjb25zdCBbcmVuZGVyZWRDaGlsZHJlbiwgc2V0UmVuZGVyZWRDaGlsZHJlbl0gPSBSZWFjdC51c2VTdGF0ZShwcmVzZW50Q2hpbGRyZW4pO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpc0luaXRpYWxSZW5kZXIuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICBwZW5kaW5nUHJlc2VudENoaWxkcmVuLmN1cnJlbnQgPSBwcmVzZW50Q2hpbGRyZW47XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgY29tcGxldGUgc3RhdHVzIG9mIGV4aXRpbmcgY2hpbGRyZW4uXG4gICAgICAgICAqL1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbmRlcmVkQ2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGdldENoaWxkS2V5KHJlbmRlcmVkQ2hpbGRyZW5baV0pO1xuICAgICAgICAgICAgaWYgKCFwcmVzZW50S2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4aXRDb21wbGV0ZS5nZXQoa2V5KSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBleGl0Q29tcGxldGUuc2V0KGtleSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGV4aXRDb21wbGV0ZS5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtyZW5kZXJlZENoaWxkcmVuLCBwcmVzZW50S2V5cy5sZW5ndGgsIHByZXNlbnRLZXlzLmpvaW4oXCItXCIpXSk7XG4gICAgY29uc3QgZXhpdGluZ0NoaWxkcmVuID0gW107XG4gICAgaWYgKHByZXNlbnRDaGlsZHJlbiAhPT0gZGlmZmVkQ2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IG5leHRDaGlsZHJlbiA9IFsuLi5wcmVzZW50Q2hpbGRyZW5dO1xuICAgICAgICAvKipcbiAgICAgICAgICogTG9vcCB0aHJvdWdoIGFsbCB0aGUgY3VycmVudGx5IHJlbmRlcmVkIGNvbXBvbmVudHMgYW5kIGRlY2lkZSB3aGljaFxuICAgICAgICAgKiBhcmUgZXhpdGluZy5cbiAgICAgICAgICovXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVuZGVyZWRDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSByZW5kZXJlZENoaWxkcmVuW2ldO1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gZ2V0Q2hpbGRLZXkoY2hpbGQpO1xuICAgICAgICAgICAgaWYgKCFwcmVzZW50S2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgbmV4dENoaWxkcmVuLnNwbGljZShpLCAwLCBjaGlsZCk7XG4gICAgICAgICAgICAgICAgZXhpdGluZ0NoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB3ZSdyZSBpbiBcIndhaXRcIiBtb2RlLCBhbmQgd2UgaGF2ZSBleGl0aW5nIGNoaWxkcmVuLCB3ZSB3YW50IHRvXG4gICAgICAgICAqIG9ubHkgcmVuZGVyIHRoZXNlIHVudGlsIHRoZXkndmUgYWxsIGV4aXRlZC5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChtb2RlID09PSBcIndhaXRcIiAmJiBleGl0aW5nQ2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICBuZXh0Q2hpbGRyZW4gPSBleGl0aW5nQ2hpbGRyZW47XG4gICAgICAgIH1cbiAgICAgICAgc2V0UmVuZGVyZWRDaGlsZHJlbihvbmx5RWxlbWVudHMobmV4dENoaWxkcmVuKSk7XG4gICAgICAgIHNldERpZmZlZENoaWxkcmVuKHByZXNlbnRDaGlsZHJlbik7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFYXJseSByZXR1cm4gdG8gZW5zdXJlIG9uY2Ugd2UndmUgc2V0IHN0YXRlIHdpdGggdGhlIGxhdGVzdCBkaWZmZWRcbiAgICAgICAgICogY2hpbGRyZW4sIHdlIGNhbiBpbW1lZGlhdGVseSByZS1yZW5kZXIuXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiZcbiAgICAgICAgbW9kZSA9PT0gXCJ3YWl0XCIgJiZcbiAgICAgICAgcmVuZGVyZWRDaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgWW91J3JlIGF0dGVtcHRpbmcgdG8gYW5pbWF0ZSBtdWx0aXBsZSBjaGlsZHJlbiB3aXRoaW4gQW5pbWF0ZVByZXNlbmNlLCBidXQgaXRzIG1vZGUgaXMgc2V0IHRvIFwid2FpdFwiLiBUaGlzIHdpbGwgbGVhZCB0byBvZGQgdmlzdWFsIGJlaGF2aW91ci5gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgd2UndmUgYmVlbiBwcm92aWRlZCBhIGZvcmNlUmVuZGVyIGZ1bmN0aW9uIGJ5IHRoZSBMYXlvdXRHcm91cENvbnRleHQsXG4gICAgICogd2UgY2FuIHVzZSBpdCB0byBmb3JjZSBhIHJlLXJlbmRlciBhbW9uZ3N0IGFsbCBzdXJyb3VuZGluZyBjb21wb25lbnRzIG9uY2VcbiAgICAgKiBhbGwgY29tcG9uZW50cyBoYXZlIGZpbmlzaGVkIGFuaW1hdGluZyBvdXQuXG4gICAgICovXG4gICAgY29uc3QgeyBmb3JjZVJlbmRlciB9ID0gUmVhY3QudXNlQ29udGV4dChMYXlvdXRHcm91cENvbnRleHQpO1xuICAgIHJldHVybiAoanN4UnVudGltZS5qc3goanN4UnVudGltZS5GcmFnbWVudCwgeyBjaGlsZHJlbjogcmVuZGVyZWRDaGlsZHJlbi5tYXAoKGNoaWxkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBnZXRDaGlsZEtleShjaGlsZCk7XG4gICAgICAgICAgICBjb25zdCBpc1ByZXNlbnQgPSBwcmVzZW50Q2hpbGRyZW4gPT09IHJlbmRlcmVkQ2hpbGRyZW4gfHxcbiAgICAgICAgICAgICAgICBwcmVzZW50S2V5cy5pbmNsdWRlcyhrZXkpO1xuICAgICAgICAgICAgY29uc3Qgb25FeGl0ID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChleGl0Q29tcGxldGUuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhpdENvbXBsZXRlLnNldChrZXksIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgaXNFdmVyeUV4aXRDb21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgZXhpdENvbXBsZXRlLmZvckVhY2goKGlzRXhpdENvbXBsZXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNFeGl0Q29tcGxldGUpXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0V2ZXJ5RXhpdENvbXBsZXRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzRXZlcnlFeGl0Q29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VSZW5kZXIgPT09IG51bGwgfHwgZm9yY2VSZW5kZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZvcmNlUmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHNldFJlbmRlcmVkQ2hpbGRyZW4ocGVuZGluZ1ByZXNlbnRDaGlsZHJlbi5jdXJyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgb25FeGl0Q29tcGxldGUgJiYgb25FeGl0Q29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIChqc3hSdW50aW1lLmpzeChQcmVzZW5jZUNoaWxkLCB7IGlzUHJlc2VudDogaXNQcmVzZW50LCBpbml0aWFsOiAhaXNJbml0aWFsUmVuZGVyLmN1cnJlbnQgfHwgaW5pdGlhbFxuICAgICAgICAgICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICA6IGZhbHNlLCBjdXN0b206IGlzUHJlc2VudCA/IHVuZGVmaW5lZCA6IGN1c3RvbSwgcHJlc2VuY2VBZmZlY3RzTGF5b3V0OiBwcmVzZW5jZUFmZmVjdHNMYXlvdXQsIG1vZGU6IG1vZGUsIG9uRXhpdENvbXBsZXRlOiBpc1ByZXNlbnQgPyB1bmRlZmluZWQgOiBvbkV4aXQsIGNoaWxkcmVuOiBjaGlsZCB9LCBrZXkpKTtcbiAgICAgICAgfSkgfSkpO1xufTtcblxuLyoqXG4gKiBgTW90aW9uQ29uZmlnYCBpcyB1c2VkIHRvIHNldCBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIGFsbCBjaGlsZHJlbiBgbW90aW9uYCBjb21wb25lbnRzLlxuICpcbiAqIGBgYGpzeFxuICogaW1wb3J0IHsgbW90aW9uLCBNb3Rpb25Db25maWcgfSBmcm9tIFwiZnJhbWVyLW1vdGlvblwiXG4gKlxuICogZXhwb3J0IGZ1bmN0aW9uIEFwcCgpIHtcbiAqICAgcmV0dXJuIChcbiAqICAgICA8TW90aW9uQ29uZmlnIHRyYW5zaXRpb249e3sgdHlwZTogXCJzcHJpbmdcIiB9fT5cbiAqICAgICAgIDxtb3Rpb24uZGl2IGFuaW1hdGU9e3sgeDogMTAwIH19IC8+XG4gKiAgICAgPC9Nb3Rpb25Db25maWc+XG4gKiAgIClcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gTW90aW9uQ29uZmlnKHsgY2hpbGRyZW4sIGlzVmFsaWRQcm9wLCAuLi5jb25maWcgfSkge1xuICAgIGlzVmFsaWRQcm9wICYmIGxvYWRFeHRlcm5hbElzVmFsaWRQcm9wKGlzVmFsaWRQcm9wKTtcbiAgICAvKipcbiAgICAgKiBJbmhlcml0IHByb3BzIGZyb20gYW55IHBhcmVudCBNb3Rpb25Db25maWcgY29tcG9uZW50c1xuICAgICAqL1xuICAgIGNvbmZpZyA9IHsgLi4uUmVhY3QudXNlQ29udGV4dChNb3Rpb25Db25maWdDb250ZXh0KSwgLi4uY29uZmlnIH07XG4gICAgLyoqXG4gICAgICogRG9uJ3QgYWxsb3cgaXNTdGF0aWMgdG8gY2hhbmdlIGJldHdlZW4gcmVuZGVycyBhcyBpdCBhZmZlY3RzIGhvdyBtYW55IGhvb2tzXG4gICAgICogbW90aW9uIGNvbXBvbmVudHMgZmlyZS5cbiAgICAgKi9cbiAgICBjb25maWcuaXNTdGF0aWMgPSB1c2VDb25zdGFudCgoKSA9PiBjb25maWcuaXNTdGF0aWMpO1xuICAgIC8qKlxuICAgICAqIENyZWF0aW5nIGEgbmV3IGNvbmZpZyBjb250ZXh0IG9iamVjdCB3aWxsIHJlLXJlbmRlciBldmVyeSBgbW90aW9uYCBjb21wb25lbnRcbiAgICAgKiBldmVyeSB0aW1lIGl0IHJlbmRlcnMuIFNvIHdlIG9ubHkgd2FudCB0byBjcmVhdGUgYSBuZXcgb25lIHNwYXJpbmdseS5cbiAgICAgKi9cbiAgICBjb25zdCBjb250ZXh0ID0gUmVhY3QudXNlTWVtbygoKSA9PiBjb25maWcsIFtcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkoY29uZmlnLnRyYW5zaXRpb24pLFxuICAgICAgICBjb25maWcudHJhbnNmb3JtUGFnZVBvaW50LFxuICAgICAgICBjb25maWcucmVkdWNlZE1vdGlvbixcbiAgICBdKTtcbiAgICByZXR1cm4gKGpzeFJ1bnRpbWUuanN4KE1vdGlvbkNvbmZpZ0NvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGNvbnRleHQsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSk7XG59XG5cbi8qKlxuICogVXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBgbWAgY29tcG9uZW50IHRvIHJlZHVjZSBidW5kbGUgc2l6ZS5cbiAqXG4gKiBgbWAgaXMgYSB2ZXJzaW9uIG9mIHRoZSBgbW90aW9uYCBjb21wb25lbnQgdGhhdCBvbmx5IGxvYWRzIGZ1bmN0aW9uYWxpdHlcbiAqIGNyaXRpY2FsIGZvciB0aGUgaW5pdGlhbCByZW5kZXIuXG4gKlxuICogYExhenlNb3Rpb25gIGNhbiB0aGVuIGJlIHVzZWQgdG8gZWl0aGVyIHN5bmNocm9ub3VzbHkgb3IgYXN5bmNocm9ub3VzbHlcbiAqIGxvYWQgYW5pbWF0aW9uIGFuZCBnZXN0dXJlIHN1cHBvcnQuXG4gKlxuICogYGBganN4XG4gKiAvLyBTeW5jaHJvbm91cyBsb2FkaW5nXG4gKiBpbXBvcnQgeyBMYXp5TW90aW9uLCBtLCBkb21BbmltYXRpb24gfSBmcm9tIFwiZnJhbWVyLW1vdGlvblwiXG4gKlxuICogZnVuY3Rpb24gQXBwKCkge1xuICogICByZXR1cm4gKFxuICogICAgIDxMYXp5TW90aW9uIGZlYXR1cmVzPXtkb21BbmltYXRpb259PlxuICogICAgICAgPG0uZGl2IGFuaW1hdGU9e3sgc2NhbGU6IDIgfX0gLz5cbiAqICAgICA8L0xhenlNb3Rpb24+XG4gKiAgIClcbiAqIH1cbiAqXG4gKiAvLyBBc3luY2hyb25vdXMgbG9hZGluZ1xuICogaW1wb3J0IHsgTGF6eU1vdGlvbiwgbSB9IGZyb20gXCJmcmFtZXItbW90aW9uXCJcbiAqXG4gKiBmdW5jdGlvbiBBcHAoKSB7XG4gKiAgIHJldHVybiAoXG4gKiAgICAgPExhenlNb3Rpb24gZmVhdHVyZXM9eygpID0+IGltcG9ydCgnLi9wYXRoL3RvL2RvbUFuaW1hdGlvbicpfT5cbiAqICAgICAgIDxtLmRpdiBhbmltYXRlPXt7IHNjYWxlOiAyIH19IC8+XG4gKiAgICAgPC9MYXp5TW90aW9uPlxuICogICApXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIExhenlNb3Rpb24oeyBjaGlsZHJlbiwgZmVhdHVyZXMsIHN0cmljdCA9IGZhbHNlIH0pIHtcbiAgICBjb25zdCBbLCBzZXRJc0xvYWRlZF0gPSBSZWFjdC51c2VTdGF0ZSghaXNMYXp5QnVuZGxlKGZlYXR1cmVzKSk7XG4gICAgY29uc3QgbG9hZGVkUmVuZGVyZXIgPSBSZWFjdC51c2VSZWYodW5kZWZpbmVkKTtcbiAgICAvKipcbiAgICAgKiBJZiB0aGlzIGlzIGEgc3luY2hyb25vdXMgbG9hZCwgbG9hZCBmZWF0dXJlcyBpbW1lZGlhdGVseVxuICAgICAqL1xuICAgIGlmICghaXNMYXp5QnVuZGxlKGZlYXR1cmVzKSkge1xuICAgICAgICBjb25zdCB7IHJlbmRlcmVyLCAuLi5sb2FkZWRGZWF0dXJlcyB9ID0gZmVhdHVyZXM7XG4gICAgICAgIGxvYWRlZFJlbmRlcmVyLmN1cnJlbnQgPSByZW5kZXJlcjtcbiAgICAgICAgbG9hZEZlYXR1cmVzKGxvYWRlZEZlYXR1cmVzKTtcbiAgICB9XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGlzTGF6eUJ1bmRsZShmZWF0dXJlcykpIHtcbiAgICAgICAgICAgIGZlYXR1cmVzKCkudGhlbigoeyByZW5kZXJlciwgLi4ubG9hZGVkRmVhdHVyZXMgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGxvYWRGZWF0dXJlcyhsb2FkZWRGZWF0dXJlcyk7XG4gICAgICAgICAgICAgICAgbG9hZGVkUmVuZGVyZXIuY3VycmVudCA9IHJlbmRlcmVyO1xuICAgICAgICAgICAgICAgIHNldElzTG9hZGVkKHRydWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIChqc3hSdW50aW1lLmpzeChMYXp5Q29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogeyByZW5kZXJlcjogbG9hZGVkUmVuZGVyZXIuY3VycmVudCwgc3RyaWN0IH0sIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSk7XG59XG5mdW5jdGlvbiBpc0xhenlCdW5kbGUoZmVhdHVyZXMpIHtcbiAgICByZXR1cm4gdHlwZW9mIGZlYXR1cmVzID09PSBcImZ1bmN0aW9uXCI7XG59XG5cbi8qKlxuICogTm90ZTogU3RpbGwgdXNlZCBieSBjb21wb25lbnRzIGdlbmVyYXRlZCBieSBvbGQgdmVyc2lvbnMgb2YgRnJhbWVyXG4gKlxuICogQGRlcHJlY2F0ZWRcbiAqL1xuY29uc3QgRGVwcmVjYXRlZExheW91dEdyb3VwQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5cbmNvbnN0IHNob3VsZEluaGVyaXRHcm91cCA9IChpbmhlcml0KSA9PiBpbmhlcml0ID09PSB0cnVlO1xuY29uc3Qgc2hvdWxkSW5oZXJpdElkID0gKGluaGVyaXQpID0+IHNob3VsZEluaGVyaXRHcm91cChpbmhlcml0ID09PSB0cnVlKSB8fCBpbmhlcml0ID09PSBcImlkXCI7XG5jb25zdCBMYXlvdXRHcm91cCA9ICh7IGNoaWxkcmVuLCBpZCwgaW5oZXJpdCA9IHRydWUgfSkgPT4ge1xuICAgIGNvbnN0IGxheW91dEdyb3VwQ29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoTGF5b3V0R3JvdXBDb250ZXh0KTtcbiAgICBjb25zdCBkZXByZWNhdGVkTGF5b3V0R3JvdXBDb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChEZXByZWNhdGVkTGF5b3V0R3JvdXBDb250ZXh0KTtcbiAgICBjb25zdCBbZm9yY2VSZW5kZXIsIGtleV0gPSB1c2VGb3JjZVVwZGF0ZSgpO1xuICAgIGNvbnN0IGNvbnRleHQgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gICAgY29uc3QgdXBzdHJlYW1JZCA9IGxheW91dEdyb3VwQ29udGV4dC5pZCB8fCBkZXByZWNhdGVkTGF5b3V0R3JvdXBDb250ZXh0O1xuICAgIGlmIChjb250ZXh0LmN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKHNob3VsZEluaGVyaXRJZChpbmhlcml0KSAmJiB1cHN0cmVhbUlkKSB7XG4gICAgICAgICAgICBpZCA9IGlkID8gdXBzdHJlYW1JZCArIFwiLVwiICsgaWQgOiB1cHN0cmVhbUlkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuY3VycmVudCA9IHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgZ3JvdXA6IHNob3VsZEluaGVyaXRHcm91cChpbmhlcml0KVxuICAgICAgICAgICAgICAgID8gbGF5b3V0R3JvdXBDb250ZXh0Lmdyb3VwIHx8IG5vZGVHcm91cCgpXG4gICAgICAgICAgICAgICAgOiBub2RlR3JvdXAoKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgbWVtb2l6ZWRDb250ZXh0ID0gUmVhY3QudXNlTWVtbygoKSA9PiAoeyAuLi5jb250ZXh0LmN1cnJlbnQsIGZvcmNlUmVuZGVyIH0pLCBba2V5XSk7XG4gICAgcmV0dXJuIChqc3hSdW50aW1lLmpzeChMYXlvdXRHcm91cENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IG1lbW9pemVkQ29udGV4dCwgY2hpbGRyZW46IGNoaWxkcmVuIH0pKTtcbn07XG5cbmNvbnN0IFJlb3JkZXJDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcblxuZnVuY3Rpb24gY2hlY2tSZW9yZGVyKG9yZGVyLCB2YWx1ZSwgb2Zmc2V0LCB2ZWxvY2l0eSkge1xuICAgIGlmICghdmVsb2NpdHkpXG4gICAgICAgIHJldHVybiBvcmRlcjtcbiAgICBjb25zdCBpbmRleCA9IG9yZGVyLmZpbmRJbmRleCgoaXRlbSkgPT4gaXRlbS52YWx1ZSA9PT0gdmFsdWUpO1xuICAgIGlmIChpbmRleCA9PT0gLTEpXG4gICAgICAgIHJldHVybiBvcmRlcjtcbiAgICBjb25zdCBuZXh0T2Zmc2V0ID0gdmVsb2NpdHkgPiAwID8gMSA6IC0xO1xuICAgIGNvbnN0IG5leHRJdGVtID0gb3JkZXJbaW5kZXggKyBuZXh0T2Zmc2V0XTtcbiAgICBpZiAoIW5leHRJdGVtKVxuICAgICAgICByZXR1cm4gb3JkZXI7XG4gICAgY29uc3QgaXRlbSA9IG9yZGVyW2luZGV4XTtcbiAgICBjb25zdCBuZXh0TGF5b3V0ID0gbmV4dEl0ZW0ubGF5b3V0O1xuICAgIGNvbnN0IG5leHRJdGVtQ2VudGVyID0gbWl4TnVtYmVyJDEobmV4dExheW91dC5taW4sIG5leHRMYXlvdXQubWF4LCAwLjUpO1xuICAgIGlmICgobmV4dE9mZnNldCA9PT0gMSAmJiBpdGVtLmxheW91dC5tYXggKyBvZmZzZXQgPiBuZXh0SXRlbUNlbnRlcikgfHxcbiAgICAgICAgKG5leHRPZmZzZXQgPT09IC0xICYmIGl0ZW0ubGF5b3V0Lm1pbiArIG9mZnNldCA8IG5leHRJdGVtQ2VudGVyKSkge1xuICAgICAgICByZXR1cm4gbW92ZUl0ZW0ob3JkZXIsIGluZGV4LCBpbmRleCArIG5leHRPZmZzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gb3JkZXI7XG59XG5cbmZ1bmN0aW9uIFJlb3JkZXJHcm91cENvbXBvbmVudCh7IGNoaWxkcmVuLCBhcyA9IFwidWxcIiwgYXhpcyA9IFwieVwiLCBvblJlb3JkZXIsIHZhbHVlcywgLi4ucHJvcHMgfSwgZXh0ZXJuYWxSZWYpIHtcbiAgICBjb25zdCBDb21wb25lbnQgPSB1c2VDb25zdGFudCgoKSA9PiBtb3Rpb25bYXNdKTtcbiAgICBjb25zdCBvcmRlciA9IFtdO1xuICAgIGNvbnN0IGlzUmVvcmRlcmluZyA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gICAgbW90aW9uVXRpbHMuaW52YXJpYW50KEJvb2xlYW4odmFsdWVzKSwgXCJSZW9yZGVyLkdyb3VwIG11c3QgYmUgcHJvdmlkZWQgYSB2YWx1ZXMgcHJvcFwiKTtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICBheGlzLFxuICAgICAgICByZWdpc3Rlckl0ZW06ICh2YWx1ZSwgbGF5b3V0KSA9PiB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZW50cnkgd2FzIGFscmVhZHkgYWRkZWQsIHVwZGF0ZSBpdCByYXRoZXIgdGhhbiBhZGRpbmcgaXQgYWdhaW5cbiAgICAgICAgICAgIGNvbnN0IGlkeCA9IG9yZGVyLmZpbmRJbmRleCgoZW50cnkpID0+IHZhbHVlID09PSBlbnRyeS52YWx1ZSk7XG4gICAgICAgICAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIG9yZGVyW2lkeF0ubGF5b3V0ID0gbGF5b3V0W2F4aXNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3JkZXIucHVzaCh7IHZhbHVlOiB2YWx1ZSwgbGF5b3V0OiBsYXlvdXRbYXhpc10gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcmRlci5zb3J0KGNvbXBhcmVNaW4pO1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGVPcmRlcjogKGl0ZW0sIG9mZnNldCwgdmVsb2NpdHkpID0+IHtcbiAgICAgICAgICAgIGlmIChpc1Jlb3JkZXJpbmcuY3VycmVudClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBuZXdPcmRlciA9IGNoZWNrUmVvcmRlcihvcmRlciwgaXRlbSwgb2Zmc2V0LCB2ZWxvY2l0eSk7XG4gICAgICAgICAgICBpZiAob3JkZXIgIT09IG5ld09yZGVyKSB7XG4gICAgICAgICAgICAgICAgaXNSZW9yZGVyaW5nLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIG9uUmVvcmRlcihuZXdPcmRlclxuICAgICAgICAgICAgICAgICAgICAubWFwKGdldFZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKCh2YWx1ZSkgPT4gdmFsdWVzLmluZGV4T2YodmFsdWUpICE9PSAtMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH07XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaXNSZW9yZGVyaW5nLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9KTtcbiAgICByZXR1cm4gKGpzeFJ1bnRpbWUuanN4KENvbXBvbmVudCwgeyAuLi5wcm9wcywgcmVmOiBleHRlcm5hbFJlZiwgaWdub3JlU3RyaWN0OiB0cnVlLCBjaGlsZHJlbjoganN4UnVudGltZS5qc3goUmVvcmRlckNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGNvbnRleHQsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSB9KSk7XG59XG5jb25zdCBSZW9yZGVyR3JvdXAgPSAvKkBfX1BVUkVfXyovIFJlYWN0LmZvcndhcmRSZWYoUmVvcmRlckdyb3VwQ29tcG9uZW50KTtcbmZ1bmN0aW9uIGdldFZhbHVlKGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbS52YWx1ZTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVNaW4oYSwgYikge1xuICAgIHJldHVybiBhLmxheW91dC5taW4gLSBiLmxheW91dC5taW47XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBNb3Rpb25WYWx1ZWAgdG8gdHJhY2sgdGhlIHN0YXRlIGFuZCB2ZWxvY2l0eSBvZiBhIHZhbHVlLlxuICpcbiAqIFVzdWFsbHksIHRoZXNlIGFyZSBjcmVhdGVkIGF1dG9tYXRpY2FsbHkuIEZvciBhZHZhbmNlZCB1c2UtY2FzZXMsIGxpa2UgdXNlIHdpdGggYHVzZVRyYW5zZm9ybWAsIHlvdSBjYW4gY3JlYXRlIGBNb3Rpb25WYWx1ZWBzIGV4dGVybmFsbHkgYW5kIHBhc3MgdGhlbSBpbnRvIHRoZSBhbmltYXRlZCBjb21wb25lbnQgdmlhIHRoZSBgc3R5bGVgIHByb3AuXG4gKlxuICogYGBganN4XG4gKiBleHBvcnQgY29uc3QgTXlDb21wb25lbnQgPSAoKSA9PiB7XG4gKiAgIGNvbnN0IHNjYWxlID0gdXNlTW90aW9uVmFsdWUoMSlcbiAqXG4gKiAgIHJldHVybiA8bW90aW9uLmRpdiBzdHlsZT17eyBzY2FsZSB9fSAvPlxuICogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIGluaXRpYWwgLSBUaGUgaW5pdGlhbCBzdGF0ZS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHVzZU1vdGlvblZhbHVlKGluaXRpYWwpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHVzZUNvbnN0YW50KCgpID0+IG1vdGlvblZhbHVlKGluaXRpYWwpKTtcbiAgICAvKipcbiAgICAgKiBJZiB0aGlzIG1vdGlvbiB2YWx1ZSBpcyBiZWluZyB1c2VkIGluIHN0YXRpYyBtb2RlLCBsaWtlIG9uXG4gICAgICogdGhlIEZyYW1lciBjYW52YXMsIGZvcmNlIGNvbXBvbmVudHMgdG8gcmVyZW5kZXIgd2hlbiB0aGUgbW90aW9uXG4gICAgICogdmFsdWUgaXMgdXBkYXRlZC5cbiAgICAgKi9cbiAgICBjb25zdCB7IGlzU3RhdGljIH0gPSBSZWFjdC51c2VDb250ZXh0KE1vdGlvbkNvbmZpZ0NvbnRleHQpO1xuICAgIGlmIChpc1N0YXRpYykge1xuICAgICAgICBjb25zdCBbLCBzZXRMYXRlc3RdID0gUmVhY3QudXNlU3RhdGUoaW5pdGlhbCk7XG4gICAgICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB2YWx1ZS5vbihcImNoYW5nZVwiLCBzZXRMYXRlc3QpLCBbXSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gdXNlQ29tYmluZU1vdGlvblZhbHVlcyh2YWx1ZXMsIGNvbWJpbmVWYWx1ZXMpIHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXNlIHRoZSByZXR1cm5lZCBtb3Rpb24gdmFsdWUuIFRoaXMgcmVtYWlucyB0aGUgc2FtZSBiZXR3ZWVuIHJlbmRlcnMuXG4gICAgICovXG4gICAgY29uc3QgdmFsdWUgPSB1c2VNb3Rpb25WYWx1ZShjb21iaW5lVmFsdWVzKCkpO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGZ1bmN0aW9uIHRoYXQgd2lsbCB1cGRhdGUgdGhlIHRlbXBsYXRlIG1vdGlvbiB2YWx1ZSB3aXRoIHRoZSBsYXRlc3QgdmFsdWVzLlxuICAgICAqIFRoaXMgaXMgcHJlLWJvdW5kIHNvIHdoZW5ldmVyIGEgbW90aW9uIHZhbHVlIHVwZGF0ZXMgaXQgY2FuIHNjaGVkdWxlIGl0c1xuICAgICAqIGV4ZWN1dGlvbiBpbiBGcmFtZXN5bmMuIElmIGl0J3MgYWxyZWFkeSBiZWVuIHNjaGVkdWxlZCBpdCB3b24ndCBiZSBmaXJlZCB0d2ljZVxuICAgICAqIGluIGEgc2luZ2xlIGZyYW1lLlxuICAgICAqL1xuICAgIGNvbnN0IHVwZGF0ZVZhbHVlID0gKCkgPT4gdmFsdWUuc2V0KGNvbWJpbmVWYWx1ZXMoKSk7XG4gICAgLyoqXG4gICAgICogU3luY2hyb25vdXNseSB1cGRhdGUgdGhlIG1vdGlvbiB2YWx1ZSB3aXRoIHRoZSBsYXRlc3QgdmFsdWVzIGR1cmluZyB0aGUgcmVuZGVyLlxuICAgICAqIFRoaXMgZW5zdXJlcyB0aGF0IHdpdGhpbiBhIFJlYWN0IHJlbmRlciwgdGhlIHN0eWxlcyBhcHBsaWVkIHRvIHRoZSBET00gYXJlIHVwLXRvLWRhdGUuXG4gICAgICovXG4gICAgdXBkYXRlVmFsdWUoKTtcbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmUgdG8gYWxsIG1vdGlvbiB2YWx1ZXMgZm91bmQgd2l0aGluIHRoZSB0ZW1wbGF0ZS4gV2hlbmV2ZXIgYW55IG9mIHRoZW0gY2hhbmdlLFxuICAgICAqIHNjaGVkdWxlIGFuIHVwZGF0ZS5cbiAgICAgKi9cbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3Qgc2NoZWR1bGVVcGRhdGUgPSAoKSA9PiBmcmFtZS5wcmVSZW5kZXIodXBkYXRlVmFsdWUsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9ucyA9IHZhbHVlcy5tYXAoKHYpID0+IHYub24oXCJjaGFuZ2VcIiwgc2NoZWR1bGVVcGRhdGUpKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbnMuZm9yRWFjaCgodW5zdWJzY3JpYmUpID0+IHVuc3Vic2NyaWJlKCkpO1xuICAgICAgICAgICAgY2FuY2VsRnJhbWUodXBkYXRlVmFsdWUpO1xuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gdXNlQ29tcHV0ZWQoY29tcHV0ZSkge1xuICAgIC8qKlxuICAgICAqIE9wZW4gc2Vzc2lvbiBvZiBjb2xsZWN0TW90aW9uVmFsdWVzLiBBbnkgTW90aW9uVmFsdWUgdGhhdCBjYWxscyBnZXQoKVxuICAgICAqIHdpbGwgYmUgc2F2ZWQgaW50byB0aGlzIGFycmF5LlxuICAgICAqL1xuICAgIGNvbGxlY3RNb3Rpb25WYWx1ZXMuY3VycmVudCA9IFtdO1xuICAgIGNvbXB1dGUoKTtcbiAgICBjb25zdCB2YWx1ZSA9IHVzZUNvbWJpbmVNb3Rpb25WYWx1ZXMoY29sbGVjdE1vdGlvblZhbHVlcy5jdXJyZW50LCBjb21wdXRlKTtcbiAgICAvKipcbiAgICAgKiBTeW5jaHJvbm91c2x5IGNsb3NlIHNlc3Npb24gb2YgY29sbGVjdE1vdGlvblZhbHVlcy5cbiAgICAgKi9cbiAgICBjb2xsZWN0TW90aW9uVmFsdWVzLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiB1c2VUcmFuc2Zvcm0oaW5wdXQsIGlucHV0UmFuZ2VPclRyYW5zZm9ybWVyLCBvdXRwdXRSYW5nZSwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gdXNlQ29tcHV0ZWQoaW5wdXQpO1xuICAgIH1cbiAgICBjb25zdCB0cmFuc2Zvcm1lciA9IHR5cGVvZiBpbnB1dFJhbmdlT3JUcmFuc2Zvcm1lciA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgID8gaW5wdXRSYW5nZU9yVHJhbnNmb3JtZXJcbiAgICAgICAgOiB0cmFuc2Zvcm0oaW5wdXRSYW5nZU9yVHJhbnNmb3JtZXIsIG91dHB1dFJhbmdlLCBvcHRpb25zKTtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShpbnB1dClcbiAgICAgICAgPyB1c2VMaXN0VHJhbnNmb3JtKGlucHV0LCB0cmFuc2Zvcm1lcilcbiAgICAgICAgOiB1c2VMaXN0VHJhbnNmb3JtKFtpbnB1dF0sIChbbGF0ZXN0XSkgPT4gdHJhbnNmb3JtZXIobGF0ZXN0KSk7XG59XG5mdW5jdGlvbiB1c2VMaXN0VHJhbnNmb3JtKHZhbHVlcywgdHJhbnNmb3JtZXIpIHtcbiAgICBjb25zdCBsYXRlc3QgPSB1c2VDb25zdGFudCgoKSA9PiBbXSk7XG4gICAgcmV0dXJuIHVzZUNvbWJpbmVNb3Rpb25WYWx1ZXModmFsdWVzLCAoKSA9PiB7XG4gICAgICAgIGxhdGVzdC5sZW5ndGggPSAwO1xuICAgICAgICBjb25zdCBudW1WYWx1ZXMgPSB2YWx1ZXMubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVZhbHVlczsgaSsrKSB7XG4gICAgICAgICAgICBsYXRlc3RbaV0gPSB2YWx1ZXNbaV0uZ2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyKGxhdGVzdCk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHVzZURlZmF1bHRNb3Rpb25WYWx1ZSh2YWx1ZSwgZGVmYXVsdFZhbHVlID0gMCkge1xuICAgIHJldHVybiBpc01vdGlvblZhbHVlKHZhbHVlKSA/IHZhbHVlIDogdXNlTW90aW9uVmFsdWUoZGVmYXVsdFZhbHVlKTtcbn1cbmZ1bmN0aW9uIFJlb3JkZXJJdGVtQ29tcG9uZW50KHsgY2hpbGRyZW4sIHN0eWxlID0ge30sIHZhbHVlLCBhcyA9IFwibGlcIiwgb25EcmFnLCBsYXlvdXQgPSB0cnVlLCAuLi5wcm9wcyB9LCBleHRlcm5hbFJlZikge1xuICAgIGNvbnN0IENvbXBvbmVudCA9IHVzZUNvbnN0YW50KCgpID0+IG1vdGlvblthc10pO1xuICAgIGNvbnN0IGNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KFJlb3JkZXJDb250ZXh0KTtcbiAgICBjb25zdCBwb2ludCA9IHtcbiAgICAgICAgeDogdXNlRGVmYXVsdE1vdGlvblZhbHVlKHN0eWxlLngpLFxuICAgICAgICB5OiB1c2VEZWZhdWx0TW90aW9uVmFsdWUoc3R5bGUueSksXG4gICAgfTtcbiAgICBjb25zdCB6SW5kZXggPSB1c2VUcmFuc2Zvcm0oW3BvaW50LngsIHBvaW50LnldLCAoW2xhdGVzdFgsIGxhdGVzdFldKSA9PiBsYXRlc3RYIHx8IGxhdGVzdFkgPyAxIDogXCJ1bnNldFwiKTtcbiAgICBtb3Rpb25VdGlscy5pbnZhcmlhbnQoQm9vbGVhbihjb250ZXh0KSwgXCJSZW9yZGVyLkl0ZW0gbXVzdCBiZSBhIGNoaWxkIG9mIFJlb3JkZXIuR3JvdXBcIik7XG4gICAgY29uc3QgeyBheGlzLCByZWdpc3Rlckl0ZW0sIHVwZGF0ZU9yZGVyIH0gPSBjb250ZXh0O1xuICAgIHJldHVybiAoanN4UnVudGltZS5qc3goQ29tcG9uZW50LCB7IGRyYWc6IGF4aXMsIC4uLnByb3BzLCBkcmFnU25hcFRvT3JpZ2luOiB0cnVlLCBzdHlsZTogeyAuLi5zdHlsZSwgeDogcG9pbnQueCwgeTogcG9pbnQueSwgekluZGV4IH0sIGxheW91dDogbGF5b3V0LCBvbkRyYWc6IChldmVudCwgZ2VzdHVyZVBvaW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHZlbG9jaXR5IH0gPSBnZXN0dXJlUG9pbnQ7XG4gICAgICAgICAgICB2ZWxvY2l0eVtheGlzXSAmJlxuICAgICAgICAgICAgICAgIHVwZGF0ZU9yZGVyKHZhbHVlLCBwb2ludFtheGlzXS5nZXQoKSwgdmVsb2NpdHlbYXhpc10pO1xuICAgICAgICAgICAgb25EcmFnICYmIG9uRHJhZyhldmVudCwgZ2VzdHVyZVBvaW50KTtcbiAgICAgICAgfSwgb25MYXlvdXRNZWFzdXJlOiAobWVhc3VyZWQpID0+IHJlZ2lzdGVySXRlbSh2YWx1ZSwgbWVhc3VyZWQpLCByZWY6IGV4dGVybmFsUmVmLCBpZ25vcmVTdHJpY3Q6IHRydWUsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSk7XG59XG5jb25zdCBSZW9yZGVySXRlbSA9IC8qQF9fUFVSRV9fKi8gUmVhY3QuZm9yd2FyZFJlZihSZW9yZGVySXRlbUNvbXBvbmVudCk7XG5cbnZhciBuYW1lc3BhY2UgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIEdyb3VwOiBSZW9yZGVyR3JvdXAsXG4gICAgSXRlbTogUmVvcmRlckl0ZW1cbn0pO1xuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgZG9tTWluID0ge1xuICAgIHJlbmRlcmVyOiBjcmVhdGVEb21WaXN1YWxFbGVtZW50LFxuICAgIC4uLmFuaW1hdGlvbnMsXG59O1xuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgZG9tQW5pbWF0aW9uID0ge1xuICAgIHJlbmRlcmVyOiBjcmVhdGVEb21WaXN1YWxFbGVtZW50LFxuICAgIC4uLmFuaW1hdGlvbnMsXG4gICAgLi4uZ2VzdHVyZUFuaW1hdGlvbnMsXG59O1xuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgZG9tTWF4ID0ge1xuICAgIC4uLmRvbUFuaW1hdGlvbixcbiAgICAuLi5kcmFnLFxuICAgIC4uLmxheW91dCxcbn07XG5cbi8qKlxuICogQ29tYmluZSBtdWx0aXBsZSBtb3Rpb24gdmFsdWVzIGludG8gYSBuZXcgb25lIHVzaW5nIGEgc3RyaW5nIHRlbXBsYXRlIGxpdGVyYWwuXG4gKlxuICogYGBganN4XG4gKiBpbXBvcnQge1xuICogICBtb3Rpb24sXG4gKiAgIHVzZVNwcmluZyxcbiAqICAgdXNlTW90aW9uVmFsdWUsXG4gKiAgIHVzZU1vdGlvblRlbXBsYXRlXG4gKiB9IGZyb20gXCJmcmFtZXItbW90aW9uXCJcbiAqXG4gKiBmdW5jdGlvbiBDb21wb25lbnQoKSB7XG4gKiAgIGNvbnN0IHNoYWRvd1ggPSB1c2VTcHJpbmcoMClcbiAqICAgY29uc3Qgc2hhZG93WSA9IHVzZU1vdGlvblZhbHVlKDApXG4gKiAgIGNvbnN0IHNoYWRvdyA9IHVzZU1vdGlvblRlbXBsYXRlYGRyb3Atc2hhZG93KCR7c2hhZG93WH1weCAke3NoYWRvd1l9cHggMjBweCByZ2JhKDAsMCwwLDAuMykpYFxuICpcbiAqICAgcmV0dXJuIDxtb3Rpb24uZGl2IHN0eWxlPXt7IGZpbHRlcjogc2hhZG93IH19IC8+XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHVzZU1vdGlvblRlbXBsYXRlKGZyYWdtZW50cywgLi4udmFsdWVzKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJ1aWxkIGEgc3RyaW5nIGZyb20gdGhlIGxhdGVzdCBtb3Rpb24gdmFsdWVzLlxuICAgICAqL1xuICAgIGNvbnN0IG51bUZyYWdtZW50cyA9IGZyYWdtZW50cy5sZW5ndGg7XG4gICAgZnVuY3Rpb24gYnVpbGRWYWx1ZSgpIHtcbiAgICAgICAgbGV0IG91dHB1dCA9IGBgO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUZyYWdtZW50czsgaSsrKSB7XG4gICAgICAgICAgICBvdXRwdXQgKz0gZnJhZ21lbnRzW2ldO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gaXNNb3Rpb25WYWx1ZSh2YWx1ZSkgPyB2YWx1ZS5nZXQoKSA6IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIHJldHVybiB1c2VDb21iaW5lTW90aW9uVmFsdWVzKHZhbHVlcy5maWx0ZXIoaXNNb3Rpb25WYWx1ZSksIGJ1aWxkVmFsdWUpO1xufVxuXG5mdW5jdGlvbiB0b051bWJlcih2KSB7XG4gICAgaWYgKHR5cGVvZiB2ID09PSBcIm51bWJlclwiKVxuICAgICAgICByZXR1cm4gdjtcbiAgICByZXR1cm4gcGFyc2VGbG9hdCh2KTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGBNb3Rpb25WYWx1ZWAgdGhhdCwgd2hlbiBgc2V0YCwgd2lsbCB1c2UgYSBzcHJpbmcgYW5pbWF0aW9uIHRvIGFuaW1hdGUgdG8gaXRzIG5ldyBzdGF0ZS5cbiAqXG4gKiBJdCBjYW4gZWl0aGVyIHdvcmsgYXMgYSBzdGFuZC1hbG9uZSBgTW90aW9uVmFsdWVgIGJ5IGluaXRpYWxpc2luZyBpdCB3aXRoIGEgdmFsdWUsIG9yIGFzIGEgc3Vic2NyaWJlclxuICogdG8gYW5vdGhlciBgTW90aW9uVmFsdWVgLlxuICpcbiAqIEByZW1hcmtzXG4gKlxuICogYGBganN4XG4gKiBjb25zdCB4ID0gdXNlU3ByaW5nKDAsIHsgc3RpZmZuZXNzOiAzMDAgfSlcbiAqIGNvbnN0IHkgPSB1c2VTcHJpbmcoeCwgeyBkYW1waW5nOiAxMCB9KVxuICogYGBgXG4gKlxuICogQHBhcmFtIGlucHV0VmFsdWUgLSBgTW90aW9uVmFsdWVgIG9yIG51bWJlci4gSWYgcHJvdmlkZWQgYSBgTW90aW9uVmFsdWVgLCB3aGVuIHRoZSBpbnB1dCBgTW90aW9uVmFsdWVgIGNoYW5nZXMsIHRoZSBjcmVhdGVkIGBNb3Rpb25WYWx1ZWAgd2lsbCBzcHJpbmcgdG93YXJkcyB0aGF0IHZhbHVlLlxuICogQHBhcmFtIHNwcmluZ0NvbmZpZyAtIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIHNwcmluZy5cbiAqIEByZXR1cm5zIGBNb3Rpb25WYWx1ZWBcbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHVzZVNwcmluZyhzb3VyY2UsIGNvbmZpZyA9IHt9KSB7XG4gICAgY29uc3QgeyBpc1N0YXRpYyB9ID0gUmVhY3QudXNlQ29udGV4dChNb3Rpb25Db25maWdDb250ZXh0KTtcbiAgICBjb25zdCBhY3RpdmVTcHJpbmdBbmltYXRpb24gPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gICAgY29uc3QgdmFsdWUgPSB1c2VNb3Rpb25WYWx1ZShpc01vdGlvblZhbHVlKHNvdXJjZSkgPyB0b051bWJlcihzb3VyY2UuZ2V0KCkpIDogc291cmNlKTtcbiAgICBjb25zdCBsYXRlc3RWYWx1ZSA9IFJlYWN0LnVzZVJlZih2YWx1ZS5nZXQoKSk7XG4gICAgY29uc3QgbGF0ZXN0U2V0dGVyID0gUmVhY3QudXNlUmVmKCgpID0+IHsgfSk7XG4gICAgY29uc3Qgc3RhcnRBbmltYXRpb24gPSAoKSA9PiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGUgcHJldmlvdXMgYW5pbWF0aW9uIGhhc24ndCBoYWQgdGhlIGNoYW5jZSB0byBldmVuIHJlbmRlciBhIGZyYW1lLCByZW5kZXIgaXQgbm93LlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgYW5pbWF0aW9uID0gYWN0aXZlU3ByaW5nQW5pbWF0aW9uLmN1cnJlbnQ7XG4gICAgICAgIGlmIChhbmltYXRpb24gJiYgYW5pbWF0aW9uLnRpbWUgPT09IDApIHtcbiAgICAgICAgICAgIGFuaW1hdGlvbi5zYW1wbGUoZnJhbWVEYXRhLmRlbHRhKTtcbiAgICAgICAgfVxuICAgICAgICBzdG9wQW5pbWF0aW9uKCk7XG4gICAgICAgIGFjdGl2ZVNwcmluZ0FuaW1hdGlvbi5jdXJyZW50ID0gYW5pbWF0ZVZhbHVlKHtcbiAgICAgICAgICAgIGtleWZyYW1lczogW3ZhbHVlLmdldCgpLCBsYXRlc3RWYWx1ZS5jdXJyZW50XSxcbiAgICAgICAgICAgIHZlbG9jaXR5OiB2YWx1ZS5nZXRWZWxvY2l0eSgpLFxuICAgICAgICAgICAgdHlwZTogXCJzcHJpbmdcIixcbiAgICAgICAgICAgIHJlc3REZWx0YTogMC4wMDEsXG4gICAgICAgICAgICByZXN0U3BlZWQ6IDAuMDEsXG4gICAgICAgICAgICAuLi5jb25maWcsXG4gICAgICAgICAgICBvblVwZGF0ZTogbGF0ZXN0U2V0dGVyLmN1cnJlbnQsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3Qgc3RvcEFuaW1hdGlvbiA9ICgpID0+IHtcbiAgICAgICAgaWYgKGFjdGl2ZVNwcmluZ0FuaW1hdGlvbi5jdXJyZW50KSB7XG4gICAgICAgICAgICBhY3RpdmVTcHJpbmdBbmltYXRpb24uY3VycmVudC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlYWN0LnVzZUluc2VydGlvbkVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5hdHRhY2goKHYsIHNldCkgPT4ge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBIG1vcmUgaG9sbGlzdGljIGFwcHJvYWNoIHRvIHRoaXMgbWlnaHQgYmUgdG8gdXNlIGlzU3RhdGljIHRvIGZpeCBWaXN1YWxFbGVtZW50IGFuaW1hdGlvbnNcbiAgICAgICAgICAgICAqIGF0IHRoYXQgbGV2ZWwsIGJ1dCB0aGlzIHdpbGwgd29yayBmb3Igbm93XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChpc1N0YXRpYylcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0KHYpO1xuICAgICAgICAgICAgbGF0ZXN0VmFsdWUuY3VycmVudCA9IHY7XG4gICAgICAgICAgICBsYXRlc3RTZXR0ZXIuY3VycmVudCA9IHNldDtcbiAgICAgICAgICAgIGZyYW1lLnVwZGF0ZShzdGFydEFuaW1hdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuZ2V0KCk7XG4gICAgICAgIH0sIHN0b3BBbmltYXRpb24pO1xuICAgIH0sIFtKU09OLnN0cmluZ2lmeShjb25maWcpXSk7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChpc01vdGlvblZhbHVlKHNvdXJjZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2Uub24oXCJjaGFuZ2VcIiwgKHYpID0+IHZhbHVlLnNldCh0b051bWJlcih2KSkpO1xuICAgICAgICB9XG4gICAgfSwgW3ZhbHVlXSk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiB1c2VNb3Rpb25WYWx1ZUV2ZW50KHZhbHVlLCBldmVudCwgY2FsbGJhY2spIHtcbiAgICAvKipcbiAgICAgKiB1c2VJbnNlcnRpb25FZmZlY3Qgd2lsbCBjcmVhdGUgc3Vic2NyaXB0aW9ucyBiZWZvcmUgYW55IG90aGVyXG4gICAgICogZWZmZWN0cyB3aWxsIHJ1bi4gRWZmZWN0cyBydW4gdXB3YXJkcyB0aHJvdWdoIHRoZSB0cmVlIHNvIGl0XG4gICAgICogY2FuIGJlIHRoYXQgYmluZGluZyBhIHVzZUxheW91dEVmZmVjdCBoaWdoZXIgdXAgdGhlIHRyZWUgY2FuXG4gICAgICogbWlzcyBjaGFuZ2VzIGZyb20gbG93ZXIgZG93biB0aGUgdHJlZS5cbiAgICAgKi9cbiAgICBSZWFjdC51c2VJbnNlcnRpb25FZmZlY3QoKCkgPT4gdmFsdWUub24oZXZlbnQsIGNhbGxiYWNrKSwgW3ZhbHVlLCBldmVudCwgY2FsbGJhY2tdKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgYE1vdGlvblZhbHVlYCB0aGF0IHVwZGF0ZXMgd2hlbiB0aGUgdmVsb2NpdHkgb2YgdGhlIHByb3ZpZGVkIGBNb3Rpb25WYWx1ZWAgY2hhbmdlcy5cbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCB4ID0gdXNlTW90aW9uVmFsdWUoMClcbiAqIGNvbnN0IHhWZWxvY2l0eSA9IHVzZVZlbG9jaXR5KHgpXG4gKiBjb25zdCB4QWNjZWxlcmF0aW9uID0gdXNlVmVsb2NpdHkoeFZlbG9jaXR5KVxuICogYGBgXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB1c2VWZWxvY2l0eSh2YWx1ZSkge1xuICAgIGNvbnN0IHZlbG9jaXR5ID0gdXNlTW90aW9uVmFsdWUodmFsdWUuZ2V0VmVsb2NpdHkoKSk7XG4gICAgY29uc3QgdXBkYXRlVmVsb2NpdHkgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGxhdGVzdCA9IHZhbHVlLmdldFZlbG9jaXR5KCk7XG4gICAgICAgIHZlbG9jaXR5LnNldChsYXRlc3QpO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgd2Ugc3RpbGwgaGF2ZSB2ZWxvY2l0eSwgc2NoZWR1bGUgYW4gdXBkYXRlIGZvciB0aGUgbmV4dCBmcmFtZVxuICAgICAgICAgKiB0byBrZWVwIGNoZWNraW5nIHVudGlsIGl0IGlzIHplcm8uXG4gICAgICAgICAqL1xuICAgICAgICBpZiAobGF0ZXN0KVxuICAgICAgICAgICAgZnJhbWUudXBkYXRlKHVwZGF0ZVZlbG9jaXR5KTtcbiAgICB9O1xuICAgIHVzZU1vdGlvblZhbHVlRXZlbnQodmFsdWUsIFwiY2hhbmdlXCIsICgpID0+IHtcbiAgICAgICAgLy8gU2NoZWR1bGUgYW4gdXBkYXRlIHRvIHRoaXMgdmFsdWUgYXQgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBmcmFtZS5cbiAgICAgICAgZnJhbWUudXBkYXRlKHVwZGF0ZVZlbG9jaXR5LCBmYWxzZSwgdHJ1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHZlbG9jaXR5O1xufVxuXG5mdW5jdGlvbiByZWZXYXJuaW5nKG5hbWUsIHJlZikge1xuICAgIG1vdGlvblV0aWxzLndhcm5pbmcoQm9vbGVhbighcmVmIHx8IHJlZi5jdXJyZW50KSwgYFlvdSBoYXZlIGRlZmluZWQgYSAke25hbWV9IG9wdGlvbnMgYnV0IHRoZSBwcm92aWRlZCByZWYgaXMgbm90IHlldCBoeWRyYXRlZCwgcHJvYmFibHkgYmVjYXVzZSBpdCdzIGRlZmluZWQgaGlnaGVyIHVwIHRoZSB0cmVlLiBUcnkgY2FsbGluZyB1c2VTY3JvbGwoKSBpbiB0aGUgc2FtZSBjb21wb25lbnQgYXMgdGhlIHJlZiwgb3Igc2V0dGluZyBpdHMgXFxgbGF5b3V0RWZmZWN0OiBmYWxzZVxcYCBvcHRpb24uYCk7XG59XG5jb25zdCBjcmVhdGVTY3JvbGxNb3Rpb25WYWx1ZXMgPSAoKSA9PiAoe1xuICAgIHNjcm9sbFg6IG1vdGlvblZhbHVlKDApLFxuICAgIHNjcm9sbFk6IG1vdGlvblZhbHVlKDApLFxuICAgIHNjcm9sbFhQcm9ncmVzczogbW90aW9uVmFsdWUoMCksXG4gICAgc2Nyb2xsWVByb2dyZXNzOiBtb3Rpb25WYWx1ZSgwKSxcbn0pO1xuZnVuY3Rpb24gdXNlU2Nyb2xsKHsgY29udGFpbmVyLCB0YXJnZXQsIGxheW91dEVmZmVjdCA9IHRydWUsIC4uLm9wdGlvbnMgfSA9IHt9KSB7XG4gICAgY29uc3QgdmFsdWVzID0gdXNlQ29uc3RhbnQoY3JlYXRlU2Nyb2xsTW90aW9uVmFsdWVzKTtcbiAgICBjb25zdCB1c2VMaWZlY3ljbGVFZmZlY3QgPSBsYXlvdXRFZmZlY3RcbiAgICAgICAgPyB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0XG4gICAgICAgIDogUmVhY3QudXNlRWZmZWN0O1xuICAgIHVzZUxpZmVjeWNsZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHJlZldhcm5pbmcoXCJ0YXJnZXRcIiwgdGFyZ2V0KTtcbiAgICAgICAgcmVmV2FybmluZyhcImNvbnRhaW5lclwiLCBjb250YWluZXIpO1xuICAgICAgICByZXR1cm4gc2Nyb2xsKChfcHJvZ3Jlc3MsIHsgeCwgeSB9KSA9PiB7XG4gICAgICAgICAgICB2YWx1ZXMuc2Nyb2xsWC5zZXQoeC5jdXJyZW50KTtcbiAgICAgICAgICAgIHZhbHVlcy5zY3JvbGxYUHJvZ3Jlc3Muc2V0KHgucHJvZ3Jlc3MpO1xuICAgICAgICAgICAgdmFsdWVzLnNjcm9sbFkuc2V0KHkuY3VycmVudCk7XG4gICAgICAgICAgICB2YWx1ZXMuc2Nyb2xsWVByb2dyZXNzLnNldCh5LnByb2dyZXNzKTtcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGNvbnRhaW5lcjogKGNvbnRhaW5lciA9PT0gbnVsbCB8fCBjb250YWluZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnRhaW5lci5jdXJyZW50KSB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICB0YXJnZXQ6ICh0YXJnZXQgPT09IG51bGwgfHwgdGFyZ2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0YXJnZXQuY3VycmVudCkgfHwgdW5kZWZpbmVkLFxuICAgICAgICB9KTtcbiAgICB9LCBbY29udGFpbmVyLCB0YXJnZXQsIEpTT04uc3RyaW5naWZ5KG9wdGlvbnMub2Zmc2V0KV0pO1xuICAgIHJldHVybiB2YWx1ZXM7XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgdXNlRWxlbWVudFNjcm9sbCBpcyBkZXByZWNhdGVkLiBDb252ZXJ0IHRvIHVzZVNjcm9sbCh7IGNvbnRhaW5lcjogcmVmIH0pXG4gKi9cbmZ1bmN0aW9uIHVzZUVsZW1lbnRTY3JvbGwocmVmKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpIHtcbiAgICAgICAgd2Fybk9uY2UoZmFsc2UsIFwidXNlRWxlbWVudFNjcm9sbCBpcyBkZXByZWNhdGVkLiBDb252ZXJ0IHRvIHVzZVNjcm9sbCh7IGNvbnRhaW5lcjogcmVmIH0pLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHVzZVNjcm9sbCh7IGNvbnRhaW5lcjogcmVmIH0pO1xufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkIHVzZVZpZXdwb3J0U2Nyb2xsIGlzIGRlcHJlY2F0ZWQuIENvbnZlcnQgdG8gdXNlU2Nyb2xsKClcbiAqL1xuZnVuY3Rpb24gdXNlVmlld3BvcnRTY3JvbGwoKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICB3YXJuT25jZShmYWxzZSwgXCJ1c2VWaWV3cG9ydFNjcm9sbCBpcyBkZXByZWNhdGVkLiBDb252ZXJ0IHRvIHVzZVNjcm9sbCgpLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHVzZVNjcm9sbCgpO1xufVxuXG5mdW5jdGlvbiB1c2VBbmltYXRpb25GcmFtZShjYWxsYmFjaykge1xuICAgIGNvbnN0IGluaXRpYWxUaW1lc3RhbXAgPSBSZWFjdC51c2VSZWYoMCk7XG4gICAgY29uc3QgeyBpc1N0YXRpYyB9ID0gUmVhY3QudXNlQ29udGV4dChNb3Rpb25Db25maWdDb250ZXh0KTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoaXNTdGF0aWMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHByb3ZpZGVUaW1lU2luY2VTdGFydCA9ICh7IHRpbWVzdGFtcCwgZGVsdGEgfSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFpbml0aWFsVGltZXN0YW1wLmN1cnJlbnQpXG4gICAgICAgICAgICAgICAgaW5pdGlhbFRpbWVzdGFtcC5jdXJyZW50ID0gdGltZXN0YW1wO1xuICAgICAgICAgICAgY2FsbGJhY2sodGltZXN0YW1wIC0gaW5pdGlhbFRpbWVzdGFtcC5jdXJyZW50LCBkZWx0YSk7XG4gICAgICAgIH07XG4gICAgICAgIGZyYW1lLnVwZGF0ZShwcm92aWRlVGltZVNpbmNlU3RhcnQsIHRydWUpO1xuICAgICAgICByZXR1cm4gKCkgPT4gY2FuY2VsRnJhbWUocHJvdmlkZVRpbWVTaW5jZVN0YXJ0KTtcbiAgICB9LCBbY2FsbGJhY2tdKTtcbn1cblxuZnVuY3Rpb24gdXNlVGltZSgpIHtcbiAgICBjb25zdCB0aW1lID0gdXNlTW90aW9uVmFsdWUoMCk7XG4gICAgdXNlQW5pbWF0aW9uRnJhbWUoKHQpID0+IHRpbWUuc2V0KHQpKTtcbiAgICByZXR1cm4gdGltZTtcbn1cblxuZnVuY3Rpb24gZ2V0V2lsbENoYW5nZU5hbWUobmFtZSkge1xuICAgIGlmICh0cmFuc2Zvcm1Qcm9wcy5oYXMobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIFwidHJhbnNmb3JtXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFjY2VsZXJhdGVkVmFsdWVzLmhhcyhuYW1lKSkge1xuICAgICAgICByZXR1cm4gY2FtZWxUb0Rhc2gobmFtZSk7XG4gICAgfVxufVxuXG5jbGFzcyBXaWxsQ2hhbmdlTW90aW9uVmFsdWUgZXh0ZW5kcyBNb3Rpb25WYWx1ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0gW107XG4gICAgfVxuICAgIGFkZChuYW1lKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlTmFtZSA9IGdldFdpbGxDaGFuZ2VOYW1lKG5hbWUpO1xuICAgICAgICBpZiAoc3R5bGVOYW1lKSB7XG4gICAgICAgICAgICBhZGRVbmlxdWVJdGVtKHRoaXMudmFsdWVzLCBzdHlsZU5hbWUpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIHRoaXMuc2V0KHRoaXMudmFsdWVzLmxlbmd0aCA/IHRoaXMudmFsdWVzLmpvaW4oXCIsIFwiKSA6IFwiYXV0b1wiKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHVzZVdpbGxDaGFuZ2UoKSB7XG4gICAgcmV0dXJuIHVzZUNvbnN0YW50KCgpID0+IG5ldyBXaWxsQ2hhbmdlTW90aW9uVmFsdWUoXCJhdXRvXCIpKTtcbn1cblxuLyoqXG4gKiBBIGhvb2sgdGhhdCByZXR1cm5zIGB0cnVlYCBpZiB3ZSBzaG91bGQgYmUgdXNpbmcgcmVkdWNlZCBtb3Rpb24gYmFzZWQgb24gdGhlIGN1cnJlbnQgZGV2aWNlJ3MgUmVkdWNlZCBNb3Rpb24gc2V0dGluZy5cbiAqXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGltcGxlbWVudCBjaGFuZ2VzIHRvIHlvdXIgVUkgYmFzZWQgb24gUmVkdWNlZCBNb3Rpb24uIEZvciBpbnN0YW5jZSwgcmVwbGFjaW5nIG1vdGlvbi1zaWNrbmVzcyBpbmR1Y2luZ1xuICogYHhgL2B5YCBhbmltYXRpb25zIHdpdGggYG9wYWNpdHlgLCBkaXNhYmxpbmcgdGhlIGF1dG9wbGF5IG9mIGJhY2tncm91bmQgdmlkZW9zLCBvciB0dXJuaW5nIG9mZiBwYXJhbGxheCBtb3Rpb24uXG4gKlxuICogSXQgd2lsbCBhY3RpdmVseSByZXNwb25kIHRvIGNoYW5nZXMgYW5kIHJlLXJlbmRlciB5b3VyIGNvbXBvbmVudHMgd2l0aCB0aGUgbGF0ZXN0IHNldHRpbmcuXG4gKlxuICogYGBganN4XG4gKiBleHBvcnQgZnVuY3Rpb24gU2lkZWJhcih7IGlzT3BlbiB9KSB7XG4gKiAgIGNvbnN0IHNob3VsZFJlZHVjZU1vdGlvbiA9IHVzZVJlZHVjZWRNb3Rpb24oKVxuICogICBjb25zdCBjbG9zZWRYID0gc2hvdWxkUmVkdWNlTW90aW9uID8gMCA6IFwiLTEwMCVcIlxuICpcbiAqICAgcmV0dXJuIChcbiAqICAgICA8bW90aW9uLmRpdiBhbmltYXRlPXt7XG4gKiAgICAgICBvcGFjaXR5OiBpc09wZW4gPyAxIDogMCxcbiAqICAgICAgIHg6IGlzT3BlbiA/IDAgOiBjbG9zZWRYXG4gKiAgICAgfX0gLz5cbiAqICAgKVxuICogfVxuICogYGBgXG4gKlxuICogQHJldHVybiBib29sZWFuXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB1c2VSZWR1Y2VkTW90aW9uKCkge1xuICAgIC8qKlxuICAgICAqIExhenkgaW5pdGlhbGlzYXRpb24gb2YgcHJlZmVyc1JlZHVjZWRNb3Rpb25cbiAgICAgKi9cbiAgICAhaGFzUmVkdWNlZE1vdGlvbkxpc3RlbmVyLmN1cnJlbnQgJiYgaW5pdFByZWZlcnNSZWR1Y2VkTW90aW9uKCk7XG4gICAgY29uc3QgW3Nob3VsZFJlZHVjZU1vdGlvbl0gPSBSZWFjdC51c2VTdGF0ZShwcmVmZXJzUmVkdWNlZE1vdGlvbi5jdXJyZW50KTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIHdhcm5PbmNlKHNob3VsZFJlZHVjZU1vdGlvbiAhPT0gdHJ1ZSwgXCJZb3UgaGF2ZSBSZWR1Y2VkIE1vdGlvbiBlbmFibGVkIG9uIHlvdXIgZGV2aWNlLiBBbmltYXRpb25zIG1heSBub3QgYXBwZWFyIGFzIGV4cGVjdGVkLlwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVE9ETyBTZWUgaWYgcGVvcGxlIG1pc3MgYXV0b21hdGljYWxseSB1cGRhdGluZyBzaG91bGRSZWR1Y2VNb3Rpb24gc2V0dGluZ1xuICAgICAqL1xuICAgIHJldHVybiBzaG91bGRSZWR1Y2VNb3Rpb247XG59XG5cbmZ1bmN0aW9uIHVzZVJlZHVjZWRNb3Rpb25Db25maWcoKSB7XG4gICAgY29uc3QgcmVkdWNlZE1vdGlvblByZWZlcmVuY2UgPSB1c2VSZWR1Y2VkTW90aW9uKCk7XG4gICAgY29uc3QgeyByZWR1Y2VkTW90aW9uIH0gPSBSZWFjdC51c2VDb250ZXh0KE1vdGlvbkNvbmZpZ0NvbnRleHQpO1xuICAgIGlmIChyZWR1Y2VkTW90aW9uID09PSBcIm5ldmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIGlmIChyZWR1Y2VkTW90aW9uID09PSBcImFsd2F5c1wiKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlZHVjZWRNb3Rpb25QcmVmZXJlbmNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc3RvcEFuaW1hdGlvbih2aXN1YWxFbGVtZW50KSB7XG4gICAgdmlzdWFsRWxlbWVudC52YWx1ZXMuZm9yRWFjaCgodmFsdWUpID0+IHZhbHVlLnN0b3AoKSk7XG59XG5mdW5jdGlvbiBzZXRWYXJpYW50cyh2aXN1YWxFbGVtZW50LCB2YXJpYW50TGFiZWxzKSB7XG4gICAgY29uc3QgcmV2ZXJzZWRMYWJlbHMgPSBbLi4udmFyaWFudExhYmVsc10ucmV2ZXJzZSgpO1xuICAgIHJldmVyc2VkTGFiZWxzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBjb25zdCB2YXJpYW50ID0gdmlzdWFsRWxlbWVudC5nZXRWYXJpYW50KGtleSk7XG4gICAgICAgIHZhcmlhbnQgJiYgc2V0VGFyZ2V0KHZpc3VhbEVsZW1lbnQsIHZhcmlhbnQpO1xuICAgICAgICBpZiAodmlzdWFsRWxlbWVudC52YXJpYW50Q2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHZpc3VhbEVsZW1lbnQudmFyaWFudENoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICAgICAgICAgICAgc2V0VmFyaWFudHMoY2hpbGQsIHZhcmlhbnRMYWJlbHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHNldFZhbHVlcyh2aXN1YWxFbGVtZW50LCBkZWZpbml0aW9uKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGVmaW5pdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIHNldFZhcmlhbnRzKHZpc3VhbEVsZW1lbnQsIGRlZmluaXRpb24pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5pdGlvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gc2V0VmFyaWFudHModmlzdWFsRWxlbWVudCwgW2RlZmluaXRpb25dKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHNldFRhcmdldCh2aXN1YWxFbGVtZW50LCBkZWZpbml0aW9uKTtcbiAgICB9XG59XG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gYW5pbWF0aW9uQ29udHJvbHMoKSB7XG4gICAgLyoqXG4gICAgICogVHJhY2sgd2hldGhlciB0aGUgaG9zdCBjb21wb25lbnQgaGFzIG1vdW50ZWQuXG4gICAgICovXG4gICAgbGV0IGhhc01vdW50ZWQgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBBIGNvbGxlY3Rpb24gb2YgbGlua2VkIGNvbXBvbmVudCBhbmltYXRpb24gY29udHJvbHMuXG4gICAgICovXG4gICAgY29uc3Qgc3Vic2NyaWJlcnMgPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgY29udHJvbHMgPSB7XG4gICAgICAgIHN1YnNjcmliZSh2aXN1YWxFbGVtZW50KSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVycy5hZGQodmlzdWFsRWxlbWVudCk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gdm9pZCBzdWJzY3JpYmVycy5kZWxldGUodmlzdWFsRWxlbWVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIHN0YXJ0KGRlZmluaXRpb24sIHRyYW5zaXRpb25PdmVycmlkZSkge1xuICAgICAgICAgICAgbW90aW9uVXRpbHMuaW52YXJpYW50KGhhc01vdW50ZWQsIFwiY29udHJvbHMuc3RhcnQoKSBzaG91bGQgb25seSBiZSBjYWxsZWQgYWZ0ZXIgYSBjb21wb25lbnQgaGFzIG1vdW50ZWQuIENvbnNpZGVyIGNhbGxpbmcgd2l0aGluIGEgdXNlRWZmZWN0IGhvb2suXCIpO1xuICAgICAgICAgICAgY29uc3QgYW5pbWF0aW9ucyA9IFtdO1xuICAgICAgICAgICAgc3Vic2NyaWJlcnMuZm9yRWFjaCgodmlzdWFsRWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGFuaW1hdGlvbnMucHVzaChhbmltYXRlVmlzdWFsRWxlbWVudCh2aXN1YWxFbGVtZW50LCBkZWZpbml0aW9uLCB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb25PdmVycmlkZSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChhbmltYXRpb25zKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KGRlZmluaXRpb24pIHtcbiAgICAgICAgICAgIG1vdGlvblV0aWxzLmludmFyaWFudChoYXNNb3VudGVkLCBcImNvbnRyb2xzLnNldCgpIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBhZnRlciBhIGNvbXBvbmVudCBoYXMgbW91bnRlZC4gQ29uc2lkZXIgY2FsbGluZyB3aXRoaW4gYSB1c2VFZmZlY3QgaG9vay5cIik7XG4gICAgICAgICAgICByZXR1cm4gc3Vic2NyaWJlcnMuZm9yRWFjaCgodmlzdWFsRWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHNldFZhbHVlcyh2aXN1YWxFbGVtZW50LCBkZWZpbml0aW9uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBzdG9wKCkge1xuICAgICAgICAgICAgc3Vic2NyaWJlcnMuZm9yRWFjaCgodmlzdWFsRWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHN0b3BBbmltYXRpb24odmlzdWFsRWxlbWVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgbW91bnQoKSB7XG4gICAgICAgICAgICBoYXNNb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaGFzTW91bnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnRyb2xzLnN0b3AoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICByZXR1cm4gY29udHJvbHM7XG59XG5cbmZ1bmN0aW9uIHVzZUFuaW1hdGUoKSB7XG4gICAgY29uc3Qgc2NvcGUgPSB1c2VDb25zdGFudCgoKSA9PiAoe1xuICAgICAgICBjdXJyZW50OiBudWxsLCAvLyBXaWxsIGJlIGh5ZHJhdGVkIGJ5IFJlYWN0XG4gICAgICAgIGFuaW1hdGlvbnM6IFtdLFxuICAgIH0pKTtcbiAgICBjb25zdCBhbmltYXRlID0gdXNlQ29uc3RhbnQoKCkgPT4gY3JlYXRlU2NvcGVkQW5pbWF0ZShzY29wZSkpO1xuICAgIHVzZVVubW91bnRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBzY29wZS5hbmltYXRpb25zLmZvckVhY2goKGFuaW1hdGlvbikgPT4gYW5pbWF0aW9uLnN0b3AoKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtzY29wZSwgYW5pbWF0ZV07XG59XG5cbmZ1bmN0aW9uIHVzZUFuaW1hdGVNaW5pKCkge1xuICAgIGNvbnN0IHNjb3BlID0gdXNlQ29uc3RhbnQoKCkgPT4gKHtcbiAgICAgICAgY3VycmVudDogbnVsbCwgLy8gV2lsbCBiZSBoeWRyYXRlZCBieSBSZWFjdFxuICAgICAgICBhbmltYXRpb25zOiBbXSxcbiAgICB9KSk7XG4gICAgY29uc3QgYW5pbWF0ZSA9IHVzZUNvbnN0YW50KCgpID0+IGNyZWF0ZVNjb3BlZFdhYXBpQW5pbWF0ZShzY29wZSkpO1xuICAgIHVzZVVubW91bnRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBzY29wZS5hbmltYXRpb25zLmZvckVhY2goKGFuaW1hdGlvbikgPT4gYW5pbWF0aW9uLnN0b3AoKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtzY29wZSwgYW5pbWF0ZV07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBgQW5pbWF0aW9uQ29udHJvbHNgLCB3aGljaCBjYW4gYmUgdXNlZCB0byBtYW51YWxseSBzdGFydCwgc3RvcFxuICogYW5kIHNlcXVlbmNlIGFuaW1hdGlvbnMgb24gb25lIG9yIG1vcmUgY29tcG9uZW50cy5cbiAqXG4gKiBUaGUgcmV0dXJuZWQgYEFuaW1hdGlvbkNvbnRyb2xzYCBzaG91bGQgYmUgcGFzc2VkIHRvIHRoZSBgYW5pbWF0ZWAgcHJvcGVydHlcbiAqIG9mIHRoZSBjb21wb25lbnRzIHlvdSB3YW50IHRvIGFuaW1hdGUuXG4gKlxuICogVGhlc2UgY29tcG9uZW50cyBjYW4gdGhlbiBiZSBhbmltYXRlZCB3aXRoIHRoZSBgc3RhcnRgIG1ldGhvZC5cbiAqXG4gKiBgYGBqc3hcbiAqIGltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0J1xuICogaW1wb3J0IHsgbW90aW9uLCB1c2VBbmltYXRpb24gfSBmcm9tICdmcmFtZXItbW90aW9uJ1xuICpcbiAqIGV4cG9ydCBmdW5jdGlvbiBNeUNvbXBvbmVudChwcm9wcykge1xuICogICAgY29uc3QgY29udHJvbHMgPSB1c2VBbmltYXRpb24oKVxuICpcbiAqICAgIGNvbnRyb2xzLnN0YXJ0KHtcbiAqICAgICAgICB4OiAxMDAsXG4gKiAgICAgICAgdHJhbnNpdGlvbjogeyBkdXJhdGlvbjogMC41IH0sXG4gKiAgICB9KVxuICpcbiAqICAgIHJldHVybiA8bW90aW9uLmRpdiBhbmltYXRlPXtjb250cm9sc30gLz5cbiAqIH1cbiAqIGBgYFxuICpcbiAqIEByZXR1cm5zIEFuaW1hdGlvbiBjb250cm9sbGVyIHdpdGggYHN0YXJ0YCBhbmQgYHN0b3BgIG1ldGhvZHNcbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHVzZUFuaW1hdGlvbkNvbnRyb2xzKCkge1xuICAgIGNvbnN0IGNvbnRyb2xzID0gdXNlQ29uc3RhbnQoYW5pbWF0aW9uQ29udHJvbHMpO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoY29udHJvbHMubW91bnQsIFtdKTtcbiAgICByZXR1cm4gY29udHJvbHM7XG59XG5jb25zdCB1c2VBbmltYXRpb24gPSB1c2VBbmltYXRpb25Db250cm9scztcblxuLyoqXG4gKiBDeWNsZXMgdGhyb3VnaCBhIHNlcmllcyBvZiB2aXN1YWwgcHJvcGVydGllcy4gQ2FuIGJlIHVzZWQgdG8gdG9nZ2xlIGJldHdlZW4gb3IgY3ljbGUgdGhyb3VnaCBhbmltYXRpb25zLiBJdCB3b3JrcyBzaW1pbGFyIHRvIGB1c2VTdGF0ZWAgaW4gUmVhY3QuIEl0IGlzIHByb3ZpZGVkIGFuIGluaXRpYWwgYXJyYXkgb2YgcG9zc2libGUgc3RhdGVzLCBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiB0d28gYXJndW1lbnRzLlxuICpcbiAqIEFuIGluZGV4IHZhbHVlIGNhbiBiZSBwYXNzZWQgdG8gdGhlIHJldHVybmVkIGBjeWNsZWAgZnVuY3Rpb24gdG8gY3ljbGUgdG8gYSBzcGVjaWZpYyBpbmRleC5cbiAqXG4gKiBgYGBqc3hcbiAqIGltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiXG4gKiBpbXBvcnQgeyBtb3Rpb24sIHVzZUN5Y2xlIH0gZnJvbSBcImZyYW1lci1tb3Rpb25cIlxuICpcbiAqIGV4cG9ydCBjb25zdCBNeUNvbXBvbmVudCA9ICgpID0+IHtcbiAqICAgY29uc3QgW3gsIGN5Y2xlWF0gPSB1c2VDeWNsZSgwLCA1MCwgMTAwKVxuICpcbiAqICAgcmV0dXJuIChcbiAqICAgICA8bW90aW9uLmRpdlxuICogICAgICAgYW5pbWF0ZT17eyB4OiB4IH19XG4gKiAgICAgICBvblRhcD17KCkgPT4gY3ljbGVYKCl9XG4gKiAgICAgIC8+XG4gKiAgICApXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gaXRlbXMgLSBpdGVtcyB0byBjeWNsZSB0aHJvdWdoXG4gKiBAcmV0dXJucyBbY3VycmVudFN0YXRlLCBjeWNsZVN0YXRlXVxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdXNlQ3ljbGUoLi4uaXRlbXMpIHtcbiAgICBjb25zdCBpbmRleCA9IFJlYWN0LnVzZVJlZigwKTtcbiAgICBjb25zdCBbaXRlbSwgc2V0SXRlbV0gPSBSZWFjdC51c2VTdGF0ZShpdGVtc1tpbmRleC5jdXJyZW50XSk7XG4gICAgY29uc3QgcnVuQ3ljbGUgPSBSZWFjdC51c2VDYWxsYmFjaygobmV4dCkgPT4ge1xuICAgICAgICBpbmRleC5jdXJyZW50ID1cbiAgICAgICAgICAgIHR5cGVvZiBuZXh0ICE9PSBcIm51bWJlclwiXG4gICAgICAgICAgICAgICAgPyB3cmFwKDAsIGl0ZW1zLmxlbmd0aCwgaW5kZXguY3VycmVudCArIDEpXG4gICAgICAgICAgICAgICAgOiBuZXh0O1xuICAgICAgICBzZXRJdGVtKGl0ZW1zW2luZGV4LmN1cnJlbnRdKTtcbiAgICB9LCBcbiAgICAvLyBUaGUgYXJyYXkgd2lsbCBjaGFuZ2Ugb24gZWFjaCBjYWxsLCBidXQgYnkgcHV0dGluZyBpdGVtcy5sZW5ndGggYXRcbiAgICAvLyB0aGUgZnJvbnQgb2YgdGhpcyBhcnJheSwgd2UgZ3VhcmFudGVlIHRoZSBkZXBlbmRlbmN5IGNvbXBhcmlzb24gd2lsbCBtYXRjaCB1cFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICBbaXRlbXMubGVuZ3RoLCAuLi5pdGVtc10pO1xuICAgIHJldHVybiBbaXRlbSwgcnVuQ3ljbGVdO1xufVxuXG5mdW5jdGlvbiB1c2VJblZpZXcocmVmLCB7IHJvb3QsIG1hcmdpbiwgYW1vdW50LCBvbmNlID0gZmFsc2UgfSA9IHt9KSB7XG4gICAgY29uc3QgW2lzSW5WaWV3LCBzZXRJblZpZXddID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghcmVmLmN1cnJlbnQgfHwgKG9uY2UgJiYgaXNJblZpZXcpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBvbkVudGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgc2V0SW5WaWV3KHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIG9uY2UgPyB1bmRlZmluZWQgOiAoKSA9PiBzZXRJblZpZXcoZmFsc2UpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgcm9vdDogKHJvb3QgJiYgcm9vdC5jdXJyZW50KSB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICBtYXJnaW4sXG4gICAgICAgICAgICBhbW91bnQsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBpblZpZXcocmVmLmN1cnJlbnQsIG9uRW50ZXIsIG9wdGlvbnMpO1xuICAgIH0sIFtyb290LCByZWYsIG1hcmdpbiwgb25jZSwgYW1vdW50XSk7XG4gICAgcmV0dXJuIGlzSW5WaWV3O1xufVxuXG4vKipcbiAqIENhbiBtYW51YWxseSB0cmlnZ2VyIGEgZHJhZyBnZXN0dXJlIG9uIG9uZSBvciBtb3JlIGBkcmFnYC1lbmFibGVkIGBtb3Rpb25gIGNvbXBvbmVudHMuXG4gKlxuICogYGBganN4XG4gKiBjb25zdCBkcmFnQ29udHJvbHMgPSB1c2VEcmFnQ29udHJvbHMoKVxuICpcbiAqIGZ1bmN0aW9uIHN0YXJ0RHJhZyhldmVudCkge1xuICogICBkcmFnQ29udHJvbHMuc3RhcnQoZXZlbnQsIHsgc25hcFRvQ3Vyc29yOiB0cnVlIH0pXG4gKiB9XG4gKlxuICogcmV0dXJuIChcbiAqICAgPD5cbiAqICAgICA8ZGl2IG9uUG9pbnRlckRvd249e3N0YXJ0RHJhZ30gLz5cbiAqICAgICA8bW90aW9uLmRpdiBkcmFnPVwieFwiIGRyYWdDb250cm9scz17ZHJhZ0NvbnRyb2xzfSAvPlxuICogICA8Lz5cbiAqIClcbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgRHJhZ0NvbnRyb2xzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnRDb250cm9scyA9IG5ldyBTZXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlIGEgY29tcG9uZW50J3MgaW50ZXJuYWwgYFZpc3VhbEVsZW1lbnREcmFnQ29udHJvbHNgIHRvIHRoZSB1c2VyLWZhY2luZyBBUEkuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzdWJzY3JpYmUoY29udHJvbHMpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnRDb250cm9scy5hZGQoY29udHJvbHMpO1xuICAgICAgICByZXR1cm4gKCkgPT4gdGhpcy5jb21wb25lbnRDb250cm9scy5kZWxldGUoY29udHJvbHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydCBhIGRyYWcgZ2VzdHVyZSBvbiBldmVyeSBgbW90aW9uYCBjb21wb25lbnQgdGhhdCBoYXMgdGhpcyBzZXQgb2YgZHJhZyBjb250cm9sc1xuICAgICAqIHBhc3NlZCBpbnRvIGl0IHZpYSB0aGUgYGRyYWdDb250cm9sc2AgcHJvcC5cbiAgICAgKlxuICAgICAqIGBgYGpzeFxuICAgICAqIGRyYWdDb250cm9scy5zdGFydChlLCB7XG4gICAgICogICBzbmFwVG9DdXJzb3I6IHRydWVcbiAgICAgKiB9KVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50IC0gUG9pbnRlckV2ZW50XG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgc3RhcnQoZXZlbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnRDb250cm9scy5mb3JFYWNoKChjb250cm9scykgPT4ge1xuICAgICAgICAgICAgY29udHJvbHMuc3RhcnQoZXZlbnQubmF0aXZlRXZlbnQgfHwgZXZlbnQsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5jb25zdCBjcmVhdGVEcmFnQ29udHJvbHMgPSAoKSA9PiBuZXcgRHJhZ0NvbnRyb2xzKCk7XG4vKipcbiAqIFVzdWFsbHksIGRyYWdnaW5nIGlzIGluaXRpYXRlZCBieSBwcmVzc2luZyBkb3duIG9uIGEgYG1vdGlvbmAgY29tcG9uZW50IHdpdGggYSBgZHJhZ2AgcHJvcFxuICogYW5kIG1vdmluZyBpdC4gRm9yIHNvbWUgdXNlLWNhc2VzLCBmb3IgaW5zdGFuY2UgY2xpY2tpbmcgYXQgYW4gYXJiaXRyYXJ5IHBvaW50IG9uIGEgdmlkZW8gc2NydWJiZXIsIHdlXG4gKiBtaWdodCB3YW50IHRvIGluaXRpYXRlIHRoYXQgZHJhZ2dpbmcgZnJvbSBhIGRpZmZlcmVudCBjb21wb25lbnQgdGhhbiB0aGUgZHJhZ2dhYmxlIG9uZS5cbiAqXG4gKiBCeSBjcmVhdGluZyBhIGBkcmFnQ29udHJvbHNgIHVzaW5nIHRoZSBgdXNlRHJhZ0NvbnRyb2xzYCBob29rLCB3ZSBjYW4gcGFzcyB0aGlzIGludG9cbiAqIHRoZSBkcmFnZ2FibGUgY29tcG9uZW50J3MgYGRyYWdDb250cm9sc2AgcHJvcC4gSXQgZXhwb3NlcyBhIGBzdGFydGAgbWV0aG9kXG4gKiB0aGF0IGNhbiBzdGFydCBkcmFnZ2luZyBmcm9tIHBvaW50ZXIgZXZlbnRzIG9uIG90aGVyIGNvbXBvbmVudHMuXG4gKlxuICogYGBganN4XG4gKiBjb25zdCBkcmFnQ29udHJvbHMgPSB1c2VEcmFnQ29udHJvbHMoKVxuICpcbiAqIGZ1bmN0aW9uIHN0YXJ0RHJhZyhldmVudCkge1xuICogICBkcmFnQ29udHJvbHMuc3RhcnQoZXZlbnQsIHsgc25hcFRvQ3Vyc29yOiB0cnVlIH0pXG4gKiB9XG4gKlxuICogcmV0dXJuIChcbiAqICAgPD5cbiAqICAgICA8ZGl2IG9uUG9pbnRlckRvd249e3N0YXJ0RHJhZ30gLz5cbiAqICAgICA8bW90aW9uLmRpdiBkcmFnPVwieFwiIGRyYWdDb250cm9scz17ZHJhZ0NvbnRyb2xzfSAvPlxuICogICA8Lz5cbiAqIClcbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdXNlRHJhZ0NvbnRyb2xzKCkge1xuICAgIHJldHVybiB1c2VDb25zdGFudChjcmVhdGVEcmFnQ29udHJvbHMpO1xufVxuXG4vKipcbiAqIEF0dGFjaGVzIGFuIGV2ZW50IGxpc3RlbmVyIGRpcmVjdGx5IHRvIHRoZSBwcm92aWRlZCBET00gZWxlbWVudC5cbiAqXG4gKiBCeXBhc3NpbmcgUmVhY3QncyBldmVudCBzeXN0ZW0gY2FuIGJlIGRlc2lyYWJsZSwgZm9yIGluc3RhbmNlIHdoZW4gYXR0YWNoaW5nIG5vbi1wYXNzaXZlXG4gKiBldmVudCBoYW5kbGVycy5cbiAqXG4gKiBgYGBqc3hcbiAqIGNvbnN0IHJlZiA9IHVzZVJlZihudWxsKVxuICpcbiAqIHVzZURvbUV2ZW50KHJlZiwgJ3doZWVsJywgb25XaGVlbCwgeyBwYXNzaXZlOiBmYWxzZSB9KVxuICpcbiAqIHJldHVybiA8ZGl2IHJlZj17cmVmfSAvPlxuICogYGBgXG4gKlxuICogQHBhcmFtIHJlZiAtIFJlYWN0LlJlZk9iamVjdCB0aGF0J3MgYmVlbiBwcm92aWRlZCB0byB0aGUgZWxlbWVudCB5b3Ugd2FudCB0byBiaW5kIHRoZSBsaXN0ZW5lciB0by5cbiAqIEBwYXJhbSBldmVudE5hbWUgLSBOYW1lIG9mIHRoZSBldmVudCB5b3Ugd2FudCBsaXN0ZW4gZm9yLlxuICogQHBhcmFtIGhhbmRsZXIgLSBGdW5jdGlvbiB0byBmaXJlIHdoZW4gcmVjZWl2aW5nIHRoZSBldmVudC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyB0byBwYXNzIHRvIGBFdmVudC5hZGRFdmVudExpc3RlbmVyYC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHVzZURvbUV2ZW50KHJlZiwgZXZlbnROYW1lLCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoaGFuZGxlciAmJiBlbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gYWRkRG9tRXZlbnQoZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0sIFtyZWYsIGV2ZW50TmFtZSwgaGFuZGxlciwgb3B0aW9uc10pO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGNvbXBvbmVudCBpcyBhIGBtb3Rpb25gIGNvbXBvbmVudC5cbiAqL1xuZnVuY3Rpb24gaXNNb3Rpb25Db21wb25lbnQoY29tcG9uZW50KSB7XG4gICAgcmV0dXJuIChjb21wb25lbnQgIT09IG51bGwgJiZcbiAgICAgICAgdHlwZW9mIGNvbXBvbmVudCA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICBtb3Rpb25Db21wb25lbnRTeW1ib2wgaW4gY29tcG9uZW50KTtcbn1cblxuLyoqXG4gKiBVbndyYXBzIGEgYG1vdGlvbmAgY29tcG9uZW50IGFuZCByZXR1cm5zIGVpdGhlciBhIHN0cmluZyBmb3IgYG1vdGlvbi5kaXZgIG9yXG4gKiB0aGUgUmVhY3QgY29tcG9uZW50IGZvciBgbW90aW9uKENvbXBvbmVudClgLlxuICpcbiAqIElmIHRoZSBjb21wb25lbnQgaXMgbm90IGEgYG1vdGlvbmAgY29tcG9uZW50IGl0IHJldHVybnMgdW5kZWZpbmVkLlxuICovXG5mdW5jdGlvbiB1bndyYXBNb3Rpb25Db21wb25lbnQoY29tcG9uZW50KSB7XG4gICAgaWYgKGlzTW90aW9uQ29tcG9uZW50KGNvbXBvbmVudCkpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudFttb3Rpb25Db21wb25lbnRTeW1ib2xdO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiB1c2VJbnN0YW50TGF5b3V0VHJhbnNpdGlvbigpIHtcbiAgICByZXR1cm4gc3RhcnRUcmFuc2l0aW9uO1xufVxuZnVuY3Rpb24gc3RhcnRUcmFuc2l0aW9uKGNhbGxiYWNrKSB7XG4gICAgaWYgKCFyb290UHJvamVjdGlvbk5vZGUuY3VycmVudClcbiAgICAgICAgcmV0dXJuO1xuICAgIHJvb3RQcm9qZWN0aW9uTm9kZS5jdXJyZW50LmlzVXBkYXRpbmcgPSBmYWxzZTtcbiAgICByb290UHJvamVjdGlvbk5vZGUuY3VycmVudC5ibG9ja1VwZGF0ZSgpO1xuICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG59XG5cbmZ1bmN0aW9uIHVzZUluc3RhbnRUcmFuc2l0aW9uKCkge1xuICAgIGNvbnN0IFtmb3JjZVVwZGF0ZSwgZm9yY2VkUmVuZGVyQ291bnRdID0gdXNlRm9yY2VVcGRhdGUoKTtcbiAgICBjb25zdCBzdGFydEluc3RhbnRMYXlvdXRUcmFuc2l0aW9uID0gdXNlSW5zdGFudExheW91dFRyYW5zaXRpb24oKTtcbiAgICBjb25zdCB1bmxvY2tPbkZyYW1lUmVmID0gUmVhY3QudXNlUmVmKC0xKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogVW5ibG9jayBhZnRlciB0d28gYW5pbWF0aW9uIGZyYW1lcywgb3RoZXJ3aXNlIHRoaXMgd2lsbCB1bmJsb2NrIHRvbyBzb29uLlxuICAgICAgICAgKi9cbiAgICAgICAgZnJhbWUucG9zdFJlbmRlcigoKSA9PiBmcmFtZS5wb3N0UmVuZGVyKCgpID0+IHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgdGhlIGNhbGxiYWNrIGhhcyBiZWVuIGNhbGxlZCBhZ2FpbiBhZnRlciB0aGUgZWZmZWN0XG4gICAgICAgICAgICAgKiB0cmlnZ2VyZWQgdGhpcyAyIGZyYW1lIGRlbGF5LCBkb24ndCB1bmJsb2NrIGFuaW1hdGlvbnMuIFRoaXNcbiAgICAgICAgICAgICAqIHByZXZlbnRzIHRoZSBwcmV2aW91cyBlZmZlY3QgZnJvbSB1bmJsb2NraW5nIHRoZSBjdXJyZW50XG4gICAgICAgICAgICAgKiBpbnN0YW50IHRyYW5zaXRpb24gdG9vIHNvb24uIFRoaXMgYmVjb21lcyBtb3JlIGxpa2VseSB3aGVuXG4gICAgICAgICAgICAgKiB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggUmVhY3Quc3RhcnRUcmFuc2l0aW9uKCkuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChmb3JjZWRSZW5kZXJDb3VudCAhPT0gdW5sb2NrT25GcmFtZVJlZi5jdXJyZW50KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGluc3RhbnRBbmltYXRpb25TdGF0ZS5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIH0pKTtcbiAgICB9LCBbZm9yY2VkUmVuZGVyQ291bnRdKTtcbiAgICByZXR1cm4gKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIHN0YXJ0SW5zdGFudExheW91dFRyYW5zaXRpb24oKCkgPT4ge1xuICAgICAgICAgICAgaW5zdGFudEFuaW1hdGlvblN0YXRlLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB1bmxvY2tPbkZyYW1lUmVmLmN1cnJlbnQgPSBmb3JjZWRSZW5kZXJDb3VudCArIDE7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5mdW5jdGlvbiBkaXNhYmxlSW5zdGFudFRyYW5zaXRpb25zKCkge1xuICAgIGluc3RhbnRBbmltYXRpb25TdGF0ZS5jdXJyZW50ID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHVzZVJlc2V0UHJvamVjdGlvbigpIHtcbiAgICBjb25zdCByZXNldCA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgY29uc3Qgcm9vdCA9IHJvb3RQcm9qZWN0aW9uTm9kZS5jdXJyZW50O1xuICAgICAgICBpZiAoIXJvb3QpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHJvb3QucmVzZXRUcmVlKCk7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiByZXNldDtcbn1cblxuY29uc3QgYXBwZWFyU3RvcmVJZCA9IChlbGVtZW50SWQsIHZhbHVlTmFtZSkgPT4ge1xuICAgIGNvbnN0IGtleSA9IHRyYW5zZm9ybVByb3BzLmhhcyh2YWx1ZU5hbWUpID8gXCJ0cmFuc2Zvcm1cIiA6IHZhbHVlTmFtZTtcbiAgICByZXR1cm4gYCR7ZWxlbWVudElkfTogJHtrZXl9YDtcbn07XG5cbmNvbnN0IGFwcGVhckFuaW1hdGlvblN0b3JlID0gbmV3IE1hcCgpO1xuY29uc3QgYXBwZWFyQ29tcGxldGUgPSBuZXcgTWFwKCk7XG5cbmZ1bmN0aW9uIGhhbmRvZmZPcHRpbWl6ZWRBcHBlYXJBbmltYXRpb24oZWxlbWVudElkLCB2YWx1ZU5hbWUsIGZyYW1lKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHN0b3JlSWQgPSBhcHBlYXJTdG9yZUlkKGVsZW1lbnRJZCwgdmFsdWVOYW1lKTtcbiAgICBjb25zdCBvcHRpbWlzZWRBbmltYXRpb24gPSBhcHBlYXJBbmltYXRpb25TdG9yZS5nZXQoc3RvcmVJZCk7XG4gICAgaWYgKCFvcHRpbWlzZWRBbmltYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHsgYW5pbWF0aW9uLCBzdGFydFRpbWUgfSA9IG9wdGltaXNlZEFuaW1hdGlvbjtcbiAgICBmdW5jdGlvbiBjYW5jZWxBbmltYXRpb24oKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gd2luZG93Lk1vdGlvbkNhbmNlbE9wdGltaXNlZEFuaW1hdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwod2luZG93LCBlbGVtZW50SWQsIHZhbHVlTmFtZSwgZnJhbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXZSBjYW4gY2FuY2VsIHRoZSBhbmltYXRpb24gb25jZSBpdCdzIGZpbmlzaGVkIG5vdyB0aGF0IHdlJ3ZlIHN5bmNlZFxuICAgICAqIHdpdGggTW90aW9uLlxuICAgICAqXG4gICAgICogUHJlZmVyIG9uZmluaXNoIG92ZXIgZmluaXNoZWQgYXMgb25maW5pc2ggaXMgYmFja3dhcmRzIGNvbXBhdGlibGUgd2l0aFxuICAgICAqIG9sZGVyIGJyb3dzZXJzLlxuICAgICAqL1xuICAgIGFuaW1hdGlvbi5vbmZpbmlzaCA9IGNhbmNlbEFuaW1hdGlvbjtcbiAgICBpZiAoc3RhcnRUaW1lID09PSBudWxsIHx8ICgoX2EgPSB3aW5kb3cuTW90aW9uSGFuZG9mZklzQ29tcGxldGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHdpbmRvdywgZWxlbWVudElkKSkpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZSBzdGFydFRpbWUgaXMgbnVsbCwgdGhpcyBhbmltYXRpb24gaXMgdGhlIFBhaW50IFJlYWR5IGRldGVjdGlvbiBhbmltYXRpb25cbiAgICAgICAgICogYW5kIHdlIGNhbiBjYW5jZWwgaXQgaW1tZWRpYXRlbHkgd2l0aG91dCBoYW5kb2ZmLlxuICAgICAgICAgKlxuICAgICAgICAgKiBPciBpZiB3ZSd2ZSBhbHJlYWR5IGhhbmRlZCBvZmYgdGhlIGFuaW1hdGlvbiB0aGVuIHdlJ3JlIG5vdyBpbnRlcnJ1cHRpbmcgaXQuXG4gICAgICAgICAqIEluIHdoaWNoIGNhc2Ugd2UgbmVlZCB0byBjYW5jZWwgaXQuXG4gICAgICAgICAqL1xuICAgICAgICBjYW5jZWxBbmltYXRpb24oKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gc3RhcnRUaW1lO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBIHNpbmdsZSB0aW1lIHRvIHVzZSBhY3Jvc3MgYWxsIGFuaW1hdGlvbnMgdG8gbWFudWFsbHkgc2V0IHN0YXJ0VGltZVxuICogYW5kIGVuc3VyZSB0aGV5J3JlIGFsbCBpbiBzeW5jLlxuICovXG5sZXQgc3RhcnRGcmFtZVRpbWU7XG4vKipcbiAqIEEgZHVtbXkgYW5pbWF0aW9uIHRvIGRldGVjdCB3aGVuIENocm9tZSBpcyByZWFkeSB0byBzdGFydFxuICogcGFpbnRpbmcgdGhlIHBhZ2UgYW5kIGhvbGQgb2ZmIGZyb20gdHJpZ2dlcmluZyB0aGUgcmVhbCBhbmltYXRpb25cbiAqIHVudGlsIHRoZW4uIFdlIG9ubHkgbmVlZCBvbmUgYW5pbWF0aW9uIHRvIGRldGVjdCBwYWludCByZWFkeS5cbiAqXG4gKiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xNDA2ODUwXG4gKi9cbmxldCByZWFkeUFuaW1hdGlvbjtcbi8qKlxuICogS2VlcCB0cmFjayBvZiBhbmltYXRpb25zIHRoYXQgd2VyZSBzdXNwZW5kZWQgdnMgY2FuY2VsbGVkIHNvIHdlXG4gKiBjYW4gZWFzaWx5IHJlc3VtZSB0aGVtIHdoZW4gd2UncmUgZG9uZSBtZWFzdXJpbmcgbGF5b3V0LlxuICovXG5jb25zdCBzdXNwZW5kZWRBbmltYXRpb25zID0gbmV3IFNldCgpO1xuZnVuY3Rpb24gcmVzdW1lU3VzcGVuZGVkQW5pbWF0aW9ucygpIHtcbiAgICBzdXNwZW5kZWRBbmltYXRpb25zLmZvckVhY2goKGRhdGEpID0+IHtcbiAgICAgICAgZGF0YS5hbmltYXRpb24ucGxheSgpO1xuICAgICAgICBkYXRhLmFuaW1hdGlvbi5zdGFydFRpbWUgPSBkYXRhLnN0YXJ0VGltZTtcbiAgICB9KTtcbiAgICBzdXNwZW5kZWRBbmltYXRpb25zLmNsZWFyKCk7XG59XG5mdW5jdGlvbiBzdGFydE9wdGltaXplZEFwcGVhckFuaW1hdGlvbihlbGVtZW50LCBuYW1lLCBrZXlmcmFtZXMsIG9wdGlvbnMsIG9uUmVhZHkpIHtcbiAgICAvLyBQcmV2ZW50IG9wdGltaXNlZCBhcHBlYXIgYW5pbWF0aW9ucyBpZiBNb3Rpb24gaGFzIGFscmVhZHkgc3RhcnRlZCBhbmltYXRpbmcuXG4gICAgaWYgKHdpbmRvdy5Nb3Rpb25Jc01vdW50ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpZCA9IGVsZW1lbnQuZGF0YXNldFtvcHRpbWl6ZWRBcHBlYXJEYXRhSWRdO1xuICAgIGlmICghaWQpXG4gICAgICAgIHJldHVybjtcbiAgICB3aW5kb3cuTW90aW9uSGFuZG9mZkFuaW1hdGlvbiA9IGhhbmRvZmZPcHRpbWl6ZWRBcHBlYXJBbmltYXRpb247XG4gICAgY29uc3Qgc3RvcmVJZCA9IGFwcGVhclN0b3JlSWQoaWQsIG5hbWUpO1xuICAgIGlmICghcmVhZHlBbmltYXRpb24pIHtcbiAgICAgICAgcmVhZHlBbmltYXRpb24gPSBzdGFydFdhYXBpQW5pbWF0aW9uKGVsZW1lbnQsIG5hbWUsIFtrZXlmcmFtZXNbMF0sIGtleWZyYW1lc1swXV0sIFxuICAgICAgICAvKipcbiAgICAgICAgICogMTAgc2VjcyBpcyBiYXNpY2FsbHkganVzdCBhIHN1cGVyLXNhZmUgZHVyYXRpb24gdG8gZ2l2ZSBDaHJvbWVcbiAgICAgICAgICogbG9uZyBlbm91Z2ggdG8gZ2V0IHRoZSBhbmltYXRpb24gcmVhZHkuXG4gICAgICAgICAqL1xuICAgICAgICB7IGR1cmF0aW9uOiAxMDAwMCwgZWFzZTogXCJsaW5lYXJcIiB9KTtcbiAgICAgICAgYXBwZWFyQW5pbWF0aW9uU3RvcmUuc2V0KHN0b3JlSWQsIHtcbiAgICAgICAgICAgIGFuaW1hdGlvbjogcmVhZHlBbmltYXRpb24sXG4gICAgICAgICAgICBzdGFydFRpbWU6IG51bGwsXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlcmUncyBubyByZWFkeUFuaW1hdGlvbiB0aGVuIHRoZXJlJ3MgYmVlbiBubyBpbnN0YW50aWF0aW9uXG4gICAgICAgICAqIG9mIGhhbmRvZmYgYW5pbWF0aW9ucy5cbiAgICAgICAgICovXG4gICAgICAgIHdpbmRvdy5Nb3Rpb25IYW5kb2ZmQW5pbWF0aW9uID0gaGFuZG9mZk9wdGltaXplZEFwcGVhckFuaW1hdGlvbjtcbiAgICAgICAgd2luZG93Lk1vdGlvbkhhc09wdGltaXNlZEFuaW1hdGlvbiA9IChlbGVtZW50SWQsIHZhbHVlTmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFlbGVtZW50SWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBLZWVwIGEgbWFwIG9mIGVsZW1lbnRJZHMgdGhhdCBoYXZlIHN0YXJ0ZWQgYW5pbWF0aW5nLiBXZSBjaGVja1xuICAgICAgICAgICAgICogdmlhIElEIGluc3RlYWQgb2YgRWxlbWVudCBiZWNhdXNlIG9mIGh5ZHJhdGlvbiBlcnJvcnMgYW5kXG4gICAgICAgICAgICAgKiBwcmUtaHlkcmF0aW9uIGNoZWNrcy4gV2UgYWxzbyBhY3RpdmVseSByZWNvcmQgSURzIGFzIHRoZXkgc3RhcnRcbiAgICAgICAgICAgICAqIGFuaW1hdGluZyByYXRoZXIgdGhhbiBzaW1wbHkgY2hlY2tpbmcgZm9yIGRhdGEtYXBwZWFyLWlkIGFzXG4gICAgICAgICAgICAgKiB0aGlzIGF0dHJidXRlIG1pZ2h0IGJlIHByZXNlbnQgYnV0IG5vdCBsZWFkIHRvIGFuIGFuaW1hdGlvbiwgZm9yXG4gICAgICAgICAgICAgKiBpbnN0YW5jZSBpZiB0aGUgZWxlbWVudCdzIGFwcGVhciBhbmltYXRpb24gaXMgb24gYSBkaWZmZXJlbnRcbiAgICAgICAgICAgICAqIGJyZWFrcG9pbnQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICghdmFsdWVOYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcGVhckNvbXBsZXRlLmhhcyhlbGVtZW50SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYW5pbWF0aW9uSWQgPSBhcHBlYXJTdG9yZUlkKGVsZW1lbnRJZCwgdmFsdWVOYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBCb29sZWFuKGFwcGVhckFuaW1hdGlvblN0b3JlLmdldChhbmltYXRpb25JZCkpO1xuICAgICAgICB9O1xuICAgICAgICB3aW5kb3cuTW90aW9uSGFuZG9mZk1hcmtBc0NvbXBsZXRlID0gKGVsZW1lbnRJZCkgPT4ge1xuICAgICAgICAgICAgaWYgKGFwcGVhckNvbXBsZXRlLmhhcyhlbGVtZW50SWQpKSB7XG4gICAgICAgICAgICAgICAgYXBwZWFyQ29tcGxldGUuc2V0KGVsZW1lbnRJZCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHdpbmRvdy5Nb3Rpb25IYW5kb2ZmSXNDb21wbGV0ZSA9IChlbGVtZW50SWQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhcHBlYXJDb21wbGV0ZS5nZXQoZWxlbWVudElkKSA9PT0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdlIG9ubHkgbmVlZCB0byBjYW5jZWwgdHJhbnNmb3JtIGFuaW1hdGlvbnMgYXNcbiAgICAgICAgICogdGhleSdyZSB0aGUgb25lcyB0aGF0IHdpbGwgaW50ZXJmZXJlIHdpdGggdGhlXG4gICAgICAgICAqIGxheW91dCBhbmltYXRpb24gbWVhc3VyZW1lbnRzLlxuICAgICAgICAgKi9cbiAgICAgICAgd2luZG93Lk1vdGlvbkNhbmNlbE9wdGltaXNlZEFuaW1hdGlvbiA9IChlbGVtZW50SWQsIHZhbHVlTmFtZSwgZnJhbWUsIGNhblJlc3VtZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYW5pbWF0aW9uSWQgPSBhcHBlYXJTdG9yZUlkKGVsZW1lbnRJZCwgdmFsdWVOYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhcHBlYXJBbmltYXRpb25TdG9yZS5nZXQoYW5pbWF0aW9uSWQpO1xuICAgICAgICAgICAgaWYgKCFkYXRhKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChmcmFtZSAmJiBjYW5SZXN1bWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFdhaXQgdW50aWwgdGhlIGVuZCBvZiB0aGUgc3Vic2VxdWVudCBmcmFtZSB0byBjYW5jZWwgdGhlIGFuaW1hdGlvblxuICAgICAgICAgICAgICAgICAqIHRvIGVuc3VyZSB3ZSBkb24ndCByZW1vdmUgdGhlIGFuaW1hdGlvbiBiZWZvcmUgdGhlIG1haW4gdGhyZWFkIGhhc1xuICAgICAgICAgICAgICAgICAqIGhhZCBhIGNoYW5jZSB0byByZXNvbHZlIGtleWZyYW1lcyBhbmQgcmVuZGVyLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGZyYW1lLnBvc3RSZW5kZXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBmcmFtZS5wb3N0UmVuZGVyKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuYW5pbWF0aW9uLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGEuYW5pbWF0aW9uLmNhbmNlbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZyYW1lICYmIGNhblJlc3VtZSkge1xuICAgICAgICAgICAgICAgIHN1c3BlbmRlZEFuaW1hdGlvbnMuYWRkKGRhdGEpO1xuICAgICAgICAgICAgICAgIGZyYW1lLnJlbmRlcihyZXN1bWVTdXNwZW5kZWRBbmltYXRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFwcGVhckFuaW1hdGlvblN0b3JlLmRlbGV0ZShhbmltYXRpb25JZCk7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogSWYgdGhlcmUgYXJlIG5vIG1vcmUgYW5pbWF0aW9ucyBsZWZ0LCB3ZSBjYW4gcmVtb3ZlIHRoZSBjYW5jZWwgZnVuY3Rpb24uXG4gICAgICAgICAgICAgICAgICogVGhpcyB3aWxsIGxldCB1cyBrbm93IHdoZW4gd2UgY2FuIHN0b3AgY2hlY2tpbmcgZm9yIGNvbmZsaWN0aW5nIGxheW91dCBhbmltYXRpb25zLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmICghYXBwZWFyQW5pbWF0aW9uU3RvcmUuc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuTW90aW9uQ2FuY2VsT3B0aW1pc2VkQW5pbWF0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgd2luZG93Lk1vdGlvbkNoZWNrQXBwZWFyU3luYyA9ICh2aXN1YWxFbGVtZW50LCB2YWx1ZU5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgY29uc3QgYXBwZWFySWQgPSBnZXRPcHRpbWlzZWRBcHBlYXJJZCh2aXN1YWxFbGVtZW50KTtcbiAgICAgICAgICAgIGlmICghYXBwZWFySWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgdmFsdWVJc09wdGltaXNlZCA9IChfYSA9IHdpbmRvdy5Nb3Rpb25IYXNPcHRpbWlzZWRBbmltYXRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHdpbmRvdywgYXBwZWFySWQsIHZhbHVlTmFtZSk7XG4gICAgICAgICAgICBjb25zdCBleHRlcm5hbEFuaW1hdGlvblZhbHVlID0gKF9iID0gdmlzdWFsRWxlbWVudC5wcm9wcy52YWx1ZXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYlt2YWx1ZU5hbWVdO1xuICAgICAgICAgICAgaWYgKCF2YWx1ZUlzT3B0aW1pc2VkIHx8ICFleHRlcm5hbEFuaW1hdGlvblZhbHVlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZVN5bmNDaGVjayA9IHZhbHVlLm9uKFwiY2hhbmdlXCIsIChsYXRlc3RWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBpZiAoZXh0ZXJuYWxBbmltYXRpb25WYWx1ZS5nZXQoKSAhPT0gbGF0ZXN0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gd2luZG93Lk1vdGlvbkNhbmNlbE9wdGltaXNlZEFuaW1hdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwod2luZG93LCBhcHBlYXJJZCwgdmFsdWVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlU3luY0NoZWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVtb3ZlU3luY0NoZWNrO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBzdGFydEFuaW1hdGlvbiA9ICgpID0+IHtcbiAgICAgICAgcmVhZHlBbmltYXRpb24uY2FuY2VsKCk7XG4gICAgICAgIGNvbnN0IGFwcGVhckFuaW1hdGlvbiA9IHN0YXJ0V2FhcGlBbmltYXRpb24oZWxlbWVudCwgbmFtZSwga2V5ZnJhbWVzLCBvcHRpb25zKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlY29yZCB0aGUgdGltZSBvZiB0aGUgZmlyc3Qgc3RhcnRlZCBhbmltYXRpb24uIFdlIGNhbGwgcGVyZm9ybWFuY2Uubm93KCkgb25jZVxuICAgICAgICAgKiBoZXJlIGFuZCBvbmNlIGluIGhhbmRvZmYgdG8gZW5zdXJlIHdlJ3JlIGdldHRpbmdcbiAgICAgICAgICogY2xvc2UgdG8gYSBmcmFtZS1sb2NrZWQgdGltZS4gVGhpcyBrZWVwcyBhbGwgYW5pbWF0aW9ucyBpbiBzeW5jLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHN0YXJ0RnJhbWVUaW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0YXJ0RnJhbWVUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIH1cbiAgICAgICAgYXBwZWFyQW5pbWF0aW9uLnN0YXJ0VGltZSA9IHN0YXJ0RnJhbWVUaW1lO1xuICAgICAgICBhcHBlYXJBbmltYXRpb25TdG9yZS5zZXQoc3RvcmVJZCwge1xuICAgICAgICAgICAgYW5pbWF0aW9uOiBhcHBlYXJBbmltYXRpb24sXG4gICAgICAgICAgICBzdGFydFRpbWU6IHN0YXJ0RnJhbWVUaW1lLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG9uUmVhZHkpXG4gICAgICAgICAgICBvblJlYWR5KGFwcGVhckFuaW1hdGlvbik7XG4gICAgfTtcbiAgICBhcHBlYXJDb21wbGV0ZS5zZXQoaWQsIGZhbHNlKTtcbiAgICBpZiAocmVhZHlBbmltYXRpb24ucmVhZHkpIHtcbiAgICAgICAgcmVhZHlBbmltYXRpb24ucmVhZHkudGhlbihzdGFydEFuaW1hdGlvbikuY2F0Y2gobW90aW9uVXRpbHMubm9vcCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzdGFydEFuaW1hdGlvbigpO1xuICAgIH1cbn1cblxuY29uc3QgY3JlYXRlT2JqZWN0ID0gKCkgPT4gKHt9KTtcbmNsYXNzIFN0YXRlVmlzdWFsRWxlbWVudCBleHRlbmRzIFZpc3VhbEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm1lYXN1cmVJbnN0YW5jZVZpZXdwb3J0Qm94ID0gY3JlYXRlQm94O1xuICAgIH1cbiAgICBidWlsZCgpIHsgfVxuICAgIHJlc2V0VHJhbnNmb3JtKCkgeyB9XG4gICAgcmVzdG9yZVRyYW5zZm9ybSgpIHsgfVxuICAgIHJlbW92ZVZhbHVlRnJvbVJlbmRlclN0YXRlKCkgeyB9XG4gICAgcmVuZGVySW5zdGFuY2UoKSB7IH1cbiAgICBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVPYmplY3QoKTtcbiAgICB9XG4gICAgZ2V0QmFzZVRhcmdldEZyb21Qcm9wcygpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmVhZFZhbHVlRnJvbUluc3RhbmNlKF9zdGF0ZSwga2V5LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLmluaXRpYWxTdGF0ZVtrZXldIHx8IDA7XG4gICAgfVxuICAgIHNvcnRJbnN0YW5jZU5vZGVQb3NpdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxufVxuY29uc3QgdXNlVmlzdWFsU3RhdGUgPSBtYWtlVXNlVmlzdWFsU3RhdGUoe1xuICAgIHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wczogY3JlYXRlT2JqZWN0LFxuICAgIGNyZWF0ZVJlbmRlclN0YXRlOiBjcmVhdGVPYmplY3QsXG59KTtcbi8qKlxuICogVGhpcyBpcyBub3QgYW4gb2ZmaWNpYWxseSBzdXBwb3J0ZWQgQVBJIGFuZCBtYXkgYmUgcmVtb3ZlZFxuICogb24gYW55IHZlcnNpb24uXG4gKi9cbmZ1bmN0aW9uIHVzZUFuaW1hdGVkU3RhdGUoaW5pdGlhbFN0YXRlKSB7XG4gICAgY29uc3QgW2FuaW1hdGlvblN0YXRlLCBzZXRBbmltYXRpb25TdGF0ZV0gPSBSZWFjdC51c2VTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgIGNvbnN0IHZpc3VhbFN0YXRlID0gdXNlVmlzdWFsU3RhdGUoe30sIGZhbHNlKTtcbiAgICBjb25zdCBlbGVtZW50ID0gdXNlQ29uc3RhbnQoKCkgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IFN0YXRlVmlzdWFsRWxlbWVudCh7XG4gICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgIG9uVXBkYXRlOiAodikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzZXRBbmltYXRpb25TdGF0ZSh7IC4uLnYgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXN1YWxTdGF0ZSxcbiAgICAgICAgICAgIHByZXNlbmNlQ29udGV4dDogbnVsbCxcbiAgICAgICAgfSwgeyBpbml0aWFsU3RhdGUgfSk7XG4gICAgfSk7XG4gICAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgZWxlbWVudC5tb3VudCh7fSk7XG4gICAgICAgIHJldHVybiAoKSA9PiBlbGVtZW50LnVubW91bnQoKTtcbiAgICB9LCBbZWxlbWVudF0pO1xuICAgIGNvbnN0IHN0YXJ0QW5pbWF0aW9uID0gdXNlQ29uc3RhbnQoKCkgPT4gKGFuaW1hdGlvbkRlZmluaXRpb24pID0+IHtcbiAgICAgICAgcmV0dXJuIGFuaW1hdGVWaXN1YWxFbGVtZW50KGVsZW1lbnQsIGFuaW1hdGlvbkRlZmluaXRpb24pO1xuICAgIH0pO1xuICAgIHJldHVybiBbYW5pbWF0aW9uU3RhdGUsIHN0YXJ0QW5pbWF0aW9uXTtcbn1cblxuLy8gS2VlcCB0aGluZ3MgcmVhc29uYWJsZSBhbmQgYXZvaWQgc2NhbGU6IEluZmluaXR5LiBJbiBwcmFjdGlzZSB3ZSBtaWdodCBuZWVkXG4vLyB0byBhZGQgYW5vdGhlciB2YWx1ZSwgb3BhY2l0eSwgdGhhdCBjb3VsZCBpbnRlcnBvbGF0ZSBzY2FsZVgvWSBbMCwwLjAxXSA9PiBbMCwxXVxuLy8gdG8gc2ltcGx5IGhpZGUgY29udGVudCBhdCB1bnJlYXNvbmFibGUgc2NhbGVzLlxuY29uc3QgbWF4U2NhbGUgPSAxMDAwMDA7XG5jb25zdCBpbnZlcnRTY2FsZSA9IChzY2FsZSkgPT4gc2NhbGUgPiAwLjAwMSA/IDEgLyBzY2FsZSA6IG1heFNjYWxlO1xubGV0IGhhc1dhcm5lZCA9IGZhbHNlO1xuLyoqXG4gKiBSZXR1cm5zIGEgYE1vdGlvblZhbHVlYCBlYWNoIGZvciBgc2NhbGVYYCBhbmQgYHNjYWxlWWAgdGhhdCB1cGRhdGUgd2l0aCB0aGUgaW52ZXJzZVxuICogb2YgdGhlaXIgcmVzcGVjdGl2ZSBwYXJlbnQgc2NhbGVzLlxuICpcbiAqIFRoaXMgaXMgdXNlZnVsIGZvciB1bmRvaW5nIHRoZSBkaXN0b3J0aW9uIG9mIGNvbnRlbnQgd2hlbiBzY2FsaW5nIGEgcGFyZW50IGNvbXBvbmVudC5cbiAqXG4gKiBCeSBkZWZhdWx0LCBgdXNlSW52ZXJ0ZWRTY2FsZWAgd2lsbCBhdXRvbWF0aWNhbGx5IGZldGNoIGBzY2FsZVhgIGFuZCBgc2NhbGVZYCBmcm9tIHRoZSBuZWFyZXN0IHBhcmVudC5cbiAqIEJ5IHBhc3Npbmcgb3RoZXIgYE1vdGlvblZhbHVlYHMgaW4gYXMgYHVzZUludmVydGVkU2NhbGUoeyBzY2FsZVgsIHNjYWxlWSB9KWAsIGl0IHdpbGwgaW52ZXJ0IHRoZSBvdXRwdXRcbiAqIG9mIHRob3NlIGluc3RlYWQuXG4gKlxuICogYGBganN4XG4gKiBjb25zdCBNeUNvbXBvbmVudCA9ICgpID0+IHtcbiAqICAgY29uc3QgeyBzY2FsZVgsIHNjYWxlWSB9ID0gdXNlSW52ZXJ0ZWRTY2FsZSgpXG4gKiAgIHJldHVybiA8bW90aW9uLmRpdiBzdHlsZT17eyBzY2FsZVgsIHNjYWxlWSB9fSAvPlxuICogfVxuICogYGBgXG4gKlxuICogQGRlcHJlY2F0ZWRcbiAqL1xuZnVuY3Rpb24gdXNlSW52ZXJ0ZWRTY2FsZShzY2FsZSkge1xuICAgIGxldCBwYXJlbnRTY2FsZVggPSB1c2VNb3Rpb25WYWx1ZSgxKTtcbiAgICBsZXQgcGFyZW50U2NhbGVZID0gdXNlTW90aW9uVmFsdWUoMSk7XG4gICAgY29uc3QgeyB2aXN1YWxFbGVtZW50IH0gPSBSZWFjdC51c2VDb250ZXh0KE1vdGlvbkNvbnRleHQpO1xuICAgIG1vdGlvblV0aWxzLmludmFyaWFudCghIShzY2FsZSB8fCB2aXN1YWxFbGVtZW50KSwgXCJJZiBubyBzY2FsZSB2YWx1ZXMgYXJlIHByb3ZpZGVkLCB1c2VJbnZlcnRlZFNjYWxlIG11c3QgYmUgdXNlZCB3aXRoaW4gYSBjaGlsZCBvZiBhbm90aGVyIG1vdGlvbiBjb21wb25lbnQuXCIpO1xuICAgIG1vdGlvblV0aWxzLndhcm5pbmcoaGFzV2FybmVkLCBcInVzZUludmVydGVkU2NhbGUgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIDMuMC4gVXNlIHRoZSBsYXlvdXQgcHJvcCBpbnN0ZWFkLlwiKTtcbiAgICBoYXNXYXJuZWQgPSB0cnVlO1xuICAgIGlmIChzY2FsZSkge1xuICAgICAgICBwYXJlbnRTY2FsZVggPSBzY2FsZS5zY2FsZVggfHwgcGFyZW50U2NhbGVYO1xuICAgICAgICBwYXJlbnRTY2FsZVkgPSBzY2FsZS5zY2FsZVkgfHwgcGFyZW50U2NhbGVZO1xuICAgIH1cbiAgICBlbHNlIGlmICh2aXN1YWxFbGVtZW50KSB7XG4gICAgICAgIHBhcmVudFNjYWxlWCA9IHZpc3VhbEVsZW1lbnQuZ2V0VmFsdWUoXCJzY2FsZVhcIiwgMSk7XG4gICAgICAgIHBhcmVudFNjYWxlWSA9IHZpc3VhbEVsZW1lbnQuZ2V0VmFsdWUoXCJzY2FsZVlcIiwgMSk7XG4gICAgfVxuICAgIGNvbnN0IHNjYWxlWCA9IHVzZVRyYW5zZm9ybShwYXJlbnRTY2FsZVgsIGludmVydFNjYWxlKTtcbiAgICBjb25zdCBzY2FsZVkgPSB1c2VUcmFuc2Zvcm0ocGFyZW50U2NhbGVZLCBpbnZlcnRTY2FsZSk7XG4gICAgcmV0dXJuIHsgc2NhbGVYLCBzY2FsZVkgfTtcbn1cblxubGV0IGlkID0gMDtcbmNvbnN0IEFuaW1hdGVTaGFyZWRMYXlvdXQgPSAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gICAgUmVhY3RfX25hbWVzcGFjZS51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBtb3Rpb25VdGlscy5pbnZhcmlhbnQoZmFsc2UsIFwiQW5pbWF0ZVNoYXJlZExheW91dCBpcyBkZXByZWNhdGVkOiBodHRwczovL3d3dy5mcmFtZXIuY29tL2RvY3MvZ3VpZGUtdXBncmFkZS8jI3NoYXJlZC1sYXlvdXQtYW5pbWF0aW9uc1wiKTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIChqc3hSdW50aW1lLmpzeChMYXlvdXRHcm91cCwgeyBpZDogdXNlQ29uc3RhbnQoKCkgPT4gYGFzbC0ke2lkKyt9YCksIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSk7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpbnZhcmlhbnRcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtb3Rpb25VdGlscy5pbnZhcmlhbnQ7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibm9vcFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1vdGlvblV0aWxzLm5vb3A7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNEcmFnQWN0aXZlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbW90aW9uRG9tLmlzRHJhZ0FjdGl2ZTsgfVxufSk7XG5leHBvcnRzLkFjY2VsZXJhdGVkQW5pbWF0aW9uID0gQWNjZWxlcmF0ZWRBbmltYXRpb247XG5leHBvcnRzLkFuaW1hdGVQcmVzZW5jZSA9IEFuaW1hdGVQcmVzZW5jZTtcbmV4cG9ydHMuQW5pbWF0ZVNoYXJlZExheW91dCA9IEFuaW1hdGVTaGFyZWRMYXlvdXQ7XG5leHBvcnRzLkRlcHJlY2F0ZWRMYXlvdXRHcm91cENvbnRleHQgPSBEZXByZWNhdGVkTGF5b3V0R3JvdXBDb250ZXh0O1xuZXhwb3J0cy5EcmFnQ29udHJvbHMgPSBEcmFnQ29udHJvbHM7XG5leHBvcnRzLkZsYXRUcmVlID0gRmxhdFRyZWU7XG5leHBvcnRzLkxheW91dEdyb3VwID0gTGF5b3V0R3JvdXA7XG5leHBvcnRzLkxheW91dEdyb3VwQ29udGV4dCA9IExheW91dEdyb3VwQ29udGV4dDtcbmV4cG9ydHMuTGF6eU1vdGlvbiA9IExhenlNb3Rpb247XG5leHBvcnRzLk1vdGlvbkNvbmZpZyA9IE1vdGlvbkNvbmZpZztcbmV4cG9ydHMuTW90aW9uQ29uZmlnQ29udGV4dCA9IE1vdGlvbkNvbmZpZ0NvbnRleHQ7XG5leHBvcnRzLk1vdGlvbkNvbnRleHQgPSBNb3Rpb25Db250ZXh0O1xuZXhwb3J0cy5Nb3Rpb25HbG9iYWxDb25maWcgPSBNb3Rpb25HbG9iYWxDb25maWc7XG5leHBvcnRzLk1vdGlvblZhbHVlID0gTW90aW9uVmFsdWU7XG5leHBvcnRzLlByZXNlbmNlQ29udGV4dCA9IFByZXNlbmNlQ29udGV4dDtcbmV4cG9ydHMuUmVvcmRlciA9IG5hbWVzcGFjZTtcbmV4cG9ydHMuU3dpdGNoTGF5b3V0R3JvdXBDb250ZXh0ID0gU3dpdGNoTGF5b3V0R3JvdXBDb250ZXh0O1xuZXhwb3J0cy5WaXN1YWxFbGVtZW50ID0gVmlzdWFsRWxlbWVudDtcbmV4cG9ydHMuYWRkUG9pbnRlckV2ZW50ID0gYWRkUG9pbnRlckV2ZW50O1xuZXhwb3J0cy5hZGRQb2ludGVySW5mbyA9IGFkZFBvaW50ZXJJbmZvO1xuZXhwb3J0cy5hZGRTY2FsZUNvcnJlY3RvciA9IGFkZFNjYWxlQ29ycmVjdG9yO1xuZXhwb3J0cy5hbmltYXRlID0gYW5pbWF0ZTtcbmV4cG9ydHMuYW5pbWF0ZU1pbmkgPSBhbmltYXRlTWluaTtcbmV4cG9ydHMuYW5pbWF0ZVZhbHVlID0gYW5pbWF0ZVZhbHVlO1xuZXhwb3J0cy5hbmltYXRlVmlzdWFsRWxlbWVudCA9IGFuaW1hdGVWaXN1YWxFbGVtZW50O1xuZXhwb3J0cy5hbmltYXRpb25Db250cm9scyA9IGFuaW1hdGlvbkNvbnRyb2xzO1xuZXhwb3J0cy5hbmltYXRpb25zID0gYW5pbWF0aW9ucztcbmV4cG9ydHMuYW50aWNpcGF0ZSA9IGFudGljaXBhdGU7XG5leHBvcnRzLmJhY2tJbiA9IGJhY2tJbjtcbmV4cG9ydHMuYmFja0luT3V0ID0gYmFja0luT3V0O1xuZXhwb3J0cy5iYWNrT3V0ID0gYmFja091dDtcbmV4cG9ydHMuYnVpbGRUcmFuc2Zvcm0gPSBidWlsZFRyYW5zZm9ybTtcbmV4cG9ydHMuY2FsY0xlbmd0aCA9IGNhbGNMZW5ndGg7XG5leHBvcnRzLmNhbmNlbEZyYW1lID0gY2FuY2VsRnJhbWU7XG5leHBvcnRzLmNhbmNlbFN5bmMgPSBjYW5jZWxTeW5jO1xuZXhwb3J0cy5jaXJjSW4gPSBjaXJjSW47XG5leHBvcnRzLmNpcmNJbk91dCA9IGNpcmNJbk91dDtcbmV4cG9ydHMuY2lyY091dCA9IGNpcmNPdXQ7XG5leHBvcnRzLmNsYW1wID0gY2xhbXA7XG5leHBvcnRzLmNvbG9yID0gY29sb3I7XG5leHBvcnRzLmNvbXBsZXggPSBjb21wbGV4O1xuZXhwb3J0cy5jcmVhdGVCb3ggPSBjcmVhdGVCb3g7XG5leHBvcnRzLmNyZWF0ZVJlbmRlcmVyTW90aW9uQ29tcG9uZW50ID0gY3JlYXRlUmVuZGVyZXJNb3Rpb25Db21wb25lbnQ7XG5leHBvcnRzLmNyZWF0ZVNjb3BlZEFuaW1hdGUgPSBjcmVhdGVTY29wZWRBbmltYXRlO1xuZXhwb3J0cy5jdWJpY0JlemllciA9IGN1YmljQmV6aWVyO1xuZXhwb3J0cy5kZWxheSA9IGRlbGF5O1xuZXhwb3J0cy5kaXNhYmxlSW5zdGFudFRyYW5zaXRpb25zID0gZGlzYWJsZUluc3RhbnRUcmFuc2l0aW9ucztcbmV4cG9ydHMuZGlzdGFuY2UgPSBkaXN0YW5jZTtcbmV4cG9ydHMuZGlzdGFuY2UyRCA9IGRpc3RhbmNlMkQ7XG5leHBvcnRzLmRvbUFuaW1hdGlvbiA9IGRvbUFuaW1hdGlvbjtcbmV4cG9ydHMuZG9tTWF4ID0gZG9tTWF4O1xuZXhwb3J0cy5kb21NaW4gPSBkb21NaW47XG5leHBvcnRzLmVhc2VJbiA9IGVhc2VJbjtcbmV4cG9ydHMuZWFzZUluT3V0ID0gZWFzZUluT3V0O1xuZXhwb3J0cy5lYXNlT3V0ID0gZWFzZU91dDtcbmV4cG9ydHMuZmlsdGVyUHJvcHMgPSBmaWx0ZXJQcm9wcztcbmV4cG9ydHMuZmluZFNwcmluZyA9IGZpbmRTcHJpbmc7XG5leHBvcnRzLmZyYW1lID0gZnJhbWU7XG5leHBvcnRzLmZyYW1lRGF0YSA9IGZyYW1lRGF0YTtcbmV4cG9ydHMuZnJhbWVTdGVwcyA9IGZyYW1lU3RlcHM7XG5leHBvcnRzLmluVmlldyA9IGluVmlldztcbmV4cG9ydHMuaW5lcnRpYSA9IGluZXJ0aWE7XG5leHBvcnRzLmludGVycG9sYXRlID0gaW50ZXJwb2xhdGU7XG5leHBvcnRzLmlzQnJvd3NlciA9IGlzQnJvd3NlcjtcbmV4cG9ydHMuaXNNb3Rpb25Db21wb25lbnQgPSBpc01vdGlvbkNvbXBvbmVudDtcbmV4cG9ydHMuaXNNb3Rpb25WYWx1ZSA9IGlzTW90aW9uVmFsdWU7XG5leHBvcnRzLmlzVmFsaWRNb3Rpb25Qcm9wID0gaXNWYWxpZE1vdGlvblByb3A7XG5leHBvcnRzLmtleWZyYW1lcyA9IGtleWZyYW1lcztcbmV4cG9ydHMubSA9IG07XG5leHBvcnRzLm1ha2VVc2VWaXN1YWxTdGF0ZSA9IG1ha2VVc2VWaXN1YWxTdGF0ZTtcbmV4cG9ydHMubWlycm9yRWFzaW5nID0gbWlycm9yRWFzaW5nO1xuZXhwb3J0cy5taXggPSBtaXg7XG5leHBvcnRzLm1vdGlvbiA9IG1vdGlvbjtcbmV4cG9ydHMubW90aW9uVmFsdWUgPSBtb3Rpb25WYWx1ZTtcbmV4cG9ydHMub3B0aW1pemVkQXBwZWFyRGF0YUF0dHJpYnV0ZSA9IG9wdGltaXplZEFwcGVhckRhdGFBdHRyaWJ1dGU7XG5leHBvcnRzLnBpcGUgPSBwaXBlO1xuZXhwb3J0cy5wcm9ncmVzcyA9IHByb2dyZXNzO1xuZXhwb3J0cy5weCA9IHB4O1xuZXhwb3J0cy5yZXNvbHZlTW90aW9uVmFsdWUgPSByZXNvbHZlTW90aW9uVmFsdWU7XG5leHBvcnRzLnJldmVyc2VFYXNpbmcgPSByZXZlcnNlRWFzaW5nO1xuZXhwb3J0cy5zY3JvbGwgPSBzY3JvbGw7XG5leHBvcnRzLnNjcm9sbEluZm8gPSBzY3JvbGxJbmZvO1xuZXhwb3J0cy5zcHJpbmcgPSBzcHJpbmc7XG5leHBvcnRzLnN0YWdnZXIgPSBzdGFnZ2VyO1xuZXhwb3J0cy5zdGFydE9wdGltaXplZEFwcGVhckFuaW1hdGlvbiA9IHN0YXJ0T3B0aW1pemVkQXBwZWFyQW5pbWF0aW9uO1xuZXhwb3J0cy5zdGVwcyA9IHN0ZXBzO1xuZXhwb3J0cy5zeW5jID0gc3luYztcbmV4cG9ydHMudGltZSA9IHRpbWU7XG5leHBvcnRzLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbmV4cG9ydHMudW53cmFwTW90aW9uQ29tcG9uZW50ID0gdW53cmFwTW90aW9uQ29tcG9uZW50O1xuZXhwb3J0cy51c2VBbmltYXRlID0gdXNlQW5pbWF0ZTtcbmV4cG9ydHMudXNlQW5pbWF0ZU1pbmkgPSB1c2VBbmltYXRlTWluaTtcbmV4cG9ydHMudXNlQW5pbWF0aW9uID0gdXNlQW5pbWF0aW9uO1xuZXhwb3J0cy51c2VBbmltYXRpb25Db250cm9scyA9IHVzZUFuaW1hdGlvbkNvbnRyb2xzO1xuZXhwb3J0cy51c2VBbmltYXRpb25GcmFtZSA9IHVzZUFuaW1hdGlvbkZyYW1lO1xuZXhwb3J0cy51c2VDeWNsZSA9IHVzZUN5Y2xlO1xuZXhwb3J0cy51c2VEZXByZWNhdGVkQW5pbWF0ZWRTdGF0ZSA9IHVzZUFuaW1hdGVkU3RhdGU7XG5leHBvcnRzLnVzZURlcHJlY2F0ZWRJbnZlcnRlZFNjYWxlID0gdXNlSW52ZXJ0ZWRTY2FsZTtcbmV4cG9ydHMudXNlRG9tRXZlbnQgPSB1c2VEb21FdmVudDtcbmV4cG9ydHMudXNlRHJhZ0NvbnRyb2xzID0gdXNlRHJhZ0NvbnRyb2xzO1xuZXhwb3J0cy51c2VFbGVtZW50U2Nyb2xsID0gdXNlRWxlbWVudFNjcm9sbDtcbmV4cG9ydHMudXNlRm9yY2VVcGRhdGUgPSB1c2VGb3JjZVVwZGF0ZTtcbmV4cG9ydHMudXNlSW5WaWV3ID0gdXNlSW5WaWV3O1xuZXhwb3J0cy51c2VJbnN0YW50TGF5b3V0VHJhbnNpdGlvbiA9IHVzZUluc3RhbnRMYXlvdXRUcmFuc2l0aW9uO1xuZXhwb3J0cy51c2VJbnN0YW50VHJhbnNpdGlvbiA9IHVzZUluc3RhbnRUcmFuc2l0aW9uO1xuZXhwb3J0cy51c2VJc1ByZXNlbnQgPSB1c2VJc1ByZXNlbnQ7XG5leHBvcnRzLnVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0O1xuZXhwb3J0cy51c2VNb3Rpb25UZW1wbGF0ZSA9IHVzZU1vdGlvblRlbXBsYXRlO1xuZXhwb3J0cy51c2VNb3Rpb25WYWx1ZSA9IHVzZU1vdGlvblZhbHVlO1xuZXhwb3J0cy51c2VNb3Rpb25WYWx1ZUV2ZW50ID0gdXNlTW90aW9uVmFsdWVFdmVudDtcbmV4cG9ydHMudXNlUHJlc2VuY2UgPSB1c2VQcmVzZW5jZTtcbmV4cG9ydHMudXNlUmVkdWNlZE1vdGlvbiA9IHVzZVJlZHVjZWRNb3Rpb247XG5leHBvcnRzLnVzZVJlZHVjZWRNb3Rpb25Db25maWcgPSB1c2VSZWR1Y2VkTW90aW9uQ29uZmlnO1xuZXhwb3J0cy51c2VSZXNldFByb2plY3Rpb24gPSB1c2VSZXNldFByb2plY3Rpb247XG5leHBvcnRzLnVzZVNjcm9sbCA9IHVzZVNjcm9sbDtcbmV4cG9ydHMudXNlU3ByaW5nID0gdXNlU3ByaW5nO1xuZXhwb3J0cy51c2VUaW1lID0gdXNlVGltZTtcbmV4cG9ydHMudXNlVHJhbnNmb3JtID0gdXNlVHJhbnNmb3JtO1xuZXhwb3J0cy51c2VVbm1vdW50RWZmZWN0ID0gdXNlVW5tb3VudEVmZmVjdDtcbmV4cG9ydHMudXNlVmVsb2NpdHkgPSB1c2VWZWxvY2l0eTtcbmV4cG9ydHMudXNlVmlld3BvcnRTY3JvbGwgPSB1c2VWaWV3cG9ydFNjcm9sbDtcbmV4cG9ydHMudXNlV2lsbENoYW5nZSA9IHVzZVdpbGxDaGFuZ2U7XG5leHBvcnRzLnZpc3VhbEVsZW1lbnRTdG9yZSA9IHZpc3VhbEVsZW1lbnRTdG9yZTtcbmV4cG9ydHMud3JhcCA9IHdyYXA7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb3Rpb25VdGlscyIsInJlcXVpcmUiLCJtb3Rpb25Eb20iLCJqc3hSdW50aW1lIiwiUmVhY3QiLCJfaW50ZXJvcE5hbWVzcGFjZURlZmF1bHQiLCJlIiwibiIsImNyZWF0ZSIsImtleXMiLCJmb3JFYWNoIiwiayIsImQiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJnZXQiLCJlbnVtZXJhYmxlIiwiZGVmYXVsdCIsImZyZWV6ZSIsIlJlYWN0X19uYW1lc3BhY2UiLCJ3YXJuZWQiLCJTZXQiLCJ3YXJuT25jZSIsImNvbmRpdGlvbiIsIm1lc3NhZ2UiLCJlbGVtZW50IiwiaGFzIiwiY29uc29sZSIsIndhcm4iLCJhZGQiLCJjcmVhdGVET01Nb3Rpb25Db21wb25lbnRQcm94eSIsImNvbXBvbmVudEZhY3RvcnkiLCJQcm94eSIsImNvbXBvbmVudENhY2hlIiwiTWFwIiwiZGVwcmVjYXRlZEZhY3RvcnlGdW5jdGlvbiIsImFyZ3MiLCJwcm9jZXNzIiwiX3RhcmdldCIsImtleSIsInNldCIsImlzQW5pbWF0aW9uQ29udHJvbHMiLCJ2Iiwic3RhcnQiLCJpc0tleWZyYW1lc1RhcmdldCIsIkFycmF5IiwiaXNBcnJheSIsInNoYWxsb3dDb21wYXJlIiwibmV4dCIsInByZXYiLCJwcmV2TGVuZ3RoIiwibGVuZ3RoIiwiaSIsImlzVmFyaWFudExhYmVsIiwiZ2V0VmFsdWVTdGF0ZSIsInZpc3VhbEVsZW1lbnQiLCJzdGF0ZSIsInZhbHVlcyIsImdldFZlbG9jaXR5IiwicmVzb2x2ZVZhcmlhbnRGcm9tUHJvcHMiLCJwcm9wcyIsImRlZmluaXRpb24iLCJjdXN0b20iLCJjdXJyZW50IiwidmVsb2NpdHkiLCJ1bmRlZmluZWQiLCJ2YXJpYW50cyIsInJlc29sdmVWYXJpYW50IiwiZ2V0UHJvcHMiLCJ2YXJpYW50UHJpb3JpdHlPcmRlciIsInZhcmlhbnRQcm9wcyIsInRyYW5zZm9ybVByb3BPcmRlciIsInRyYW5zZm9ybVByb3BzIiwic2Vjb25kc1RvTWlsbGlzZWNvbmRzIiwic2Vjb25kcyIsIm1pbGxpc2Vjb25kc1RvU2Vjb25kcyIsIm1pbGxpc2Vjb25kcyIsInVuZGVyRGFtcGVkU3ByaW5nIiwidHlwZSIsInN0aWZmbmVzcyIsImRhbXBpbmciLCJyZXN0U3BlZWQiLCJjcml0aWNhbGx5RGFtcGVkU3ByaW5nIiwidGFyZ2V0IiwiTWF0aCIsInNxcnQiLCJrZXlmcmFtZXNUcmFuc2l0aW9uIiwiZHVyYXRpb24iLCJlYXNlIiwiZ2V0RGVmYXVsdFRyYW5zaXRpb24iLCJ2YWx1ZUtleSIsImtleWZyYW1lcyIsInN0YXJ0c1dpdGgiLCJnZXRWYWx1ZVRyYW5zaXRpb24kMSIsInRyYW5zaXRpb24iLCJNb3Rpb25HbG9iYWxDb25maWciLCJza2lwQW5pbWF0aW9ucyIsInVzZU1hbnVhbFRpbWluZyIsImluc3RhbnRBbmltYXRpb25TdGF0ZSIsImlzTm90TnVsbCIsImdldEZpbmFsS2V5ZnJhbWUiLCJyZXBlYXQiLCJyZXBlYXRUeXBlIiwiZmluYWxLZXlmcmFtZSIsInJlc29sdmVkS2V5ZnJhbWVzIiwiZmlsdGVyIiwiaW5kZXgiLCJjcmVhdGVSZW5kZXJTdGVwIiwicnVuTmV4dEZyYW1lIiwidGhpc0ZyYW1lIiwibmV4dEZyYW1lIiwiaXNQcm9jZXNzaW5nIiwiZmx1c2hOZXh0RnJhbWUiLCJ0b0tlZXBBbGl2ZSIsIldlYWtTZXQiLCJsYXRlc3RGcmFtZURhdGEiLCJkZWx0YSIsInRpbWVzdGFtcCIsInRyaWdnZXJDYWxsYmFjayIsImNhbGxiYWNrIiwic3RlcCIsInNjaGVkdWxlIiwia2VlcEFsaXZlIiwiaW1tZWRpYXRlIiwiYWRkVG9DdXJyZW50RnJhbWUiLCJxdWV1ZSIsImNhbmNlbCIsImRlbGV0ZSIsImZyYW1lRGF0YSIsImNsZWFyIiwic3RlcHNPcmRlciIsIm1heEVsYXBzZWQkMSIsImNyZWF0ZVJlbmRlckJhdGNoZXIiLCJzY2hlZHVsZU5leHRCYXRjaCIsImFsbG93S2VlcEFsaXZlIiwidXNlRGVmYXVsdEVsYXBzZWQiLCJmbGFnUnVuTmV4dEZyYW1lIiwic3RlcHMiLCJyZWR1Y2UiLCJhY2MiLCJyZWFkIiwicmVzb2x2ZUtleWZyYW1lcyIsInVwZGF0ZSIsInByZVJlbmRlciIsInJlbmRlciIsInBvc3RSZW5kZXIiLCJwcm9jZXNzQmF0Y2giLCJwZXJmb3JtYW5jZSIsIm5vdyIsIm1heCIsIm1pbiIsIndha2UiLCJmcmFtZSIsImNhbmNlbEZyYW1lIiwiZnJhbWVTdGVwcyIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm5vb3AiLCJjYWxjQmV6aWVyIiwidCIsImExIiwiYTIiLCJzdWJkaXZpc2lvblByZWNpc2lvbiIsInN1YmRpdmlzaW9uTWF4SXRlcmF0aW9ucyIsImJpbmFyeVN1YmRpdmlkZSIsIngiLCJsb3dlckJvdW5kIiwidXBwZXJCb3VuZCIsIm1YMSIsIm1YMiIsImN1cnJlbnRYIiwiY3VycmVudFQiLCJhYnMiLCJjdWJpY0JlemllciIsIm1ZMSIsIm1ZMiIsImdldFRGb3JYIiwiYVgiLCJtaXJyb3JFYXNpbmciLCJlYXNpbmciLCJwIiwicmV2ZXJzZUVhc2luZyIsImJhY2tPdXQiLCJiYWNrSW4iLCJiYWNrSW5PdXQiLCJhbnRpY2lwYXRlIiwicG93IiwiY2lyY0luIiwic2luIiwiYWNvcyIsImNpcmNPdXQiLCJjaXJjSW5PdXQiLCJpc1plcm9WYWx1ZVN0cmluZyIsInRlc3QiLCJpc05vbmUiLCJpc051bWVyaWNhbFN0cmluZyIsImNoZWNrU3RyaW5nU3RhcnRzV2l0aCIsInRva2VuIiwiaXNDU1NWYXJpYWJsZU5hbWUiLCJzdGFydHNBc1ZhcmlhYmxlVG9rZW4iLCJpc0NTU1ZhcmlhYmxlVG9rZW4iLCJzdGFydHNXaXRoVG9rZW4iLCJzaW5nbGVDc3NWYXJpYWJsZVJlZ2V4Iiwic3BsaXQiLCJ0cmltIiwic3BsaXRDU1NWYXJpYWJsZVJlZ2V4IiwicGFyc2VDU1NWYXJpYWJsZSIsIm1hdGNoIiwiZXhlYyIsInRva2VuMSIsInRva2VuMiIsImZhbGxiYWNrIiwibWF4RGVwdGgiLCJnZXRWYXJpYWJsZVZhbHVlIiwiZGVwdGgiLCJpbnZhcmlhbnQiLCJyZXNvbHZlZCIsIndpbmRvdyIsImdldENvbXB1dGVkU3R5bGUiLCJnZXRQcm9wZXJ0eVZhbHVlIiwidHJpbW1lZCIsInBhcnNlRmxvYXQiLCJjbGFtcCIsIm51bWJlciIsInBhcnNlIiwidHJhbnNmb3JtIiwiYWxwaGEiLCJzY2FsZSIsImNyZWF0ZVVuaXRUeXBlIiwidW5pdCIsImVuZHNXaXRoIiwiZGVncmVlcyIsInBlcmNlbnQiLCJweCIsInZoIiwidnciLCJwcm9ncmVzc1BlcmNlbnRhZ2UiLCJwb3NpdGlvbmFsS2V5cyIsImlzTnVtT3JQeFR5cGUiLCJnZXRQb3NGcm9tTWF0cml4IiwibWF0cml4IiwicG9zIiwiZ2V0VHJhbnNsYXRlRnJvbU1hdHJpeCIsInBvczIiLCJwb3MzIiwiX2Jib3giLCJtYXRyaXgzZCIsInRyYW5zZm9ybUtleXMiLCJub25UcmFuc2xhdGlvbmFsVHJhbnNmb3JtS2V5cyIsInJlbW92ZU5vblRyYW5zbGF0aW9uYWxUcmFuc2Zvcm0iLCJyZW1vdmVkVHJhbnNmb3JtcyIsImdldFZhbHVlIiwicHVzaCIsInBvc2l0aW9uYWxWYWx1ZXMiLCJ3aWR0aCIsInBhZGRpbmdMZWZ0IiwicGFkZGluZ1JpZ2h0IiwiaGVpZ2h0IiwieSIsInBhZGRpbmdUb3AiLCJwYWRkaW5nQm90dG9tIiwidG9wIiwibGVmdCIsImJvdHRvbSIsInJpZ2h0IiwidHJhbnNsYXRlWCIsInRyYW5zbGF0ZVkiLCJ0ZXN0VmFsdWVUeXBlIiwiYXV0byIsImRpbWVuc2lvblZhbHVlVHlwZXMiLCJmaW5kRGltZW5zaW9uVmFsdWVUeXBlIiwiZmluZCIsInRvUmVzb2x2ZSIsImlzU2NoZWR1bGVkIiwiYW55TmVlZHNNZWFzdXJlbWVudCIsIm1lYXN1cmVBbGxLZXlmcmFtZXMiLCJyZXNvbHZlcnNUb01lYXN1cmUiLCJmcm9tIiwicmVzb2x2ZXIiLCJuZWVkc01lYXN1cmVtZW50IiwiZWxlbWVudHNUb01lYXN1cmUiLCJtYXAiLCJ0cmFuc2Zvcm1zVG9SZXN0b3JlIiwibWVhc3VyZUluaXRpYWxTdGF0ZSIsInJlc3RvcmUiLCJfYSIsIm1lYXN1cmVFbmRTdGF0ZSIsInN1c3BlbmRlZFNjcm9sbFkiLCJzY3JvbGxUbyIsImNvbXBsZXRlIiwicmVhZEFsbEtleWZyYW1lcyIsInJlYWRLZXlmcmFtZXMiLCJmbHVzaEtleWZyYW1lUmVzb2x2ZXJzIiwiS2V5ZnJhbWVSZXNvbHZlciIsImNvbnN0cnVjdG9yIiwidW5yZXNvbHZlZEtleWZyYW1lcyIsIm9uQ29tcGxldGUiLCJuYW1lIiwibW90aW9uVmFsdWUiLCJpc0FzeW5jIiwiaXNDb21wbGV0ZSIsInNjaGVkdWxlUmVzb2x2ZSIsImN1cnJlbnRWYWx1ZSIsInZhbHVlQXNSZWFkIiwicmVhZFZhbHVlIiwic2V0RmluYWxLZXlmcmFtZSIsInJlbmRlckVuZFN0eWxlcyIsInJlc3VtZSIsInNhbml0aXplIiwicm91bmQiLCJmbG9hdFJlZ2V4IiwiaXNOdWxsaXNoIiwic2luZ2xlQ29sb3JSZWdleCIsImlzQ29sb3JTdHJpbmciLCJ0ZXN0UHJvcCIsIkJvb2xlYW4iLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJzcGxpdENvbG9yIiwiYU5hbWUiLCJiTmFtZSIsImNOYW1lIiwiYSIsImIiLCJjIiwiY2xhbXBSZ2JVbml0IiwicmdiVW5pdCIsInJnYmEiLCJyZWQiLCJncmVlbiIsImJsdWUiLCJhbHBoYSQxIiwicGFyc2VIZXgiLCJyIiwiZyIsInN1YnN0cmluZyIsInBhcnNlSW50IiwiaGV4IiwiaHNsYSIsImh1ZSIsInNhdHVyYXRpb24iLCJsaWdodG5lc3MiLCJjb2xvciIsImNvbG9yUmVnZXgiLCJfYiIsImlzTmFOIiwiTlVNQkVSX1RPS0VOIiwiQ09MT1JfVE9LRU4iLCJWQVJfVE9LRU4iLCJWQVJfRlVOQ1RJT05fVE9LRU4iLCJTUExJVF9UT0tFTiIsImNvbXBsZXhSZWdleCIsImFuYWx5c2VDb21wbGV4VmFsdWUiLCJvcmlnaW5hbFZhbHVlIiwidG9TdHJpbmciLCJpbmRleGVzIiwidmFyIiwidHlwZXMiLCJ0b2tlbmlzZWQiLCJyZXBsYWNlIiwicGFyc2VkVmFsdWUiLCJwYXJzZUNvbXBsZXhWYWx1ZSIsImNyZWF0ZVRyYW5zZm9ybWVyIiwic291cmNlIiwibnVtU2VjdGlvbnMiLCJvdXRwdXQiLCJjb252ZXJ0TnVtYmVyc1RvWmVybyIsImdldEFuaW1hdGFibGVOb25lJDEiLCJwYXJzZWQiLCJ0cmFuc2Zvcm1lciIsImNvbXBsZXgiLCJnZXRBbmltYXRhYmxlTm9uZSIsIm1heERlZmF1bHRzIiwiYXBwbHlEZWZhdWx0RmlsdGVyIiwic2xpY2UiLCJkZWZhdWx0VmFsdWUiLCJmdW5jdGlvblJlZ2V4IiwiZnVuY3Rpb25zIiwiam9pbiIsImJyb3dzZXJOdW1iZXJWYWx1ZVR5cGVzIiwiYm9yZGVyV2lkdGgiLCJib3JkZXJUb3BXaWR0aCIsImJvcmRlclJpZ2h0V2lkdGgiLCJib3JkZXJCb3R0b21XaWR0aCIsImJvcmRlckxlZnRXaWR0aCIsImJvcmRlclJhZGl1cyIsInJhZGl1cyIsImJvcmRlclRvcExlZnRSYWRpdXMiLCJib3JkZXJUb3BSaWdodFJhZGl1cyIsImJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzIiwiYm9yZGVyQm90dG9tTGVmdFJhZGl1cyIsIm1heFdpZHRoIiwibWF4SGVpZ2h0IiwicGFkZGluZyIsIm1hcmdpbiIsIm1hcmdpblRvcCIsIm1hcmdpblJpZ2h0IiwibWFyZ2luQm90dG9tIiwibWFyZ2luTGVmdCIsImJhY2tncm91bmRQb3NpdGlvblgiLCJiYWNrZ3JvdW5kUG9zaXRpb25ZIiwidHJhbnNmb3JtVmFsdWVUeXBlcyIsInJvdGF0ZSIsInJvdGF0ZVgiLCJyb3RhdGVZIiwicm90YXRlWiIsInNjYWxlWCIsInNjYWxlWSIsInNjYWxlWiIsInNrZXciLCJza2V3WCIsInNrZXdZIiwiZGlzdGFuY2UiLCJ0cmFuc2xhdGVaIiwieiIsInBlcnNwZWN0aXZlIiwidHJhbnNmb3JtUGVyc3BlY3RpdmUiLCJvcGFjaXR5Iiwib3JpZ2luWCIsIm9yaWdpblkiLCJvcmlnaW5aIiwiaW50IiwibnVtYmVyVmFsdWVUeXBlcyIsInpJbmRleCIsInNpemUiLCJmaWxsT3BhY2l0eSIsInN0cm9rZU9wYWNpdHkiLCJudW1PY3RhdmVzIiwiZGVmYXVsdFZhbHVlVHlwZXMiLCJiYWNrZ3JvdW5kQ29sb3IiLCJvdXRsaW5lQ29sb3IiLCJmaWxsIiwic3Ryb2tlIiwiYm9yZGVyQ29sb3IiLCJib3JkZXJUb3BDb2xvciIsImJvcmRlclJpZ2h0Q29sb3IiLCJib3JkZXJCb3R0b21Db2xvciIsImJvcmRlckxlZnRDb2xvciIsIldlYmtpdEZpbHRlciIsImdldERlZmF1bHRWYWx1ZVR5cGUiLCJkZWZhdWx0VmFsdWVUeXBlIiwiaW52YWxpZFRlbXBsYXRlcyIsIm1ha2VOb25lS2V5ZnJhbWVzQW5pbWF0YWJsZSIsIm5vbmVLZXlmcmFtZUluZGV4ZXMiLCJhbmltYXRhYmxlVGVtcGxhdGUiLCJrZXlmcmFtZSIsIm5vbmVJbmRleCIsIkRPTUtleWZyYW1lc1Jlc29sdmVyIiwicmVzb2x2ZU5vbmVLZXlmcmFtZXMiLCJvcmlnaW4iLCJvcmlnaW5UeXBlIiwidGFyZ2V0VHlwZSIsInBhZ2VZT2Zmc2V0IiwibWVhc3VyZWRPcmlnaW4iLCJtZWFzdXJlVmlld3BvcnRCb3giLCJtZWFzdXJlS2V5ZnJhbWUiLCJqdW1wIiwiZmluYWxLZXlmcmFtZUluZGV4IiwidW5zZXRUcmFuc2Zvcm1OYW1lIiwidW5zZXRUcmFuc2Zvcm1WYWx1ZSIsImlzR2VuZXJhdG9yIiwiY2xlYXJUaW1lIiwidGltZSIsIm5ld1RpbWUiLCJxdWV1ZU1pY3JvdGFzayIsImlzQW5pbWF0YWJsZSIsImhhc0tleWZyYW1lc0NoYW5nZWQiLCJjYW5BbmltYXRlIiwib3JpZ2luS2V5ZnJhbWUiLCJ0YXJnZXRLZXlmcmFtZSIsImlzT3JpZ2luQW5pbWF0YWJsZSIsImlzVGFyZ2V0QW5pbWF0YWJsZSIsIndhcm5pbmciLCJNQVhfUkVTT0xWRV9ERUxBWSIsIkJhc2VBbmltYXRpb24iLCJhdXRvcGxheSIsImRlbGF5IiwicmVwZWF0RGVsYXkiLCJvcHRpb25zIiwiaXNTdG9wcGVkIiwiaGFzQXR0ZW1wdGVkUmVzb2x2ZSIsImNyZWF0ZWRBdCIsInVwZGF0ZUZpbmlzaGVkUHJvbWlzZSIsImNhbGNTdGFydFRpbWUiLCJyZXNvbHZlZEF0IiwiX3Jlc29sdmVkIiwib25LZXlmcmFtZXNSZXNvbHZlZCIsIm9uVXBkYXRlIiwicmVzb2x2ZUZpbmlzaGVkUHJvbWlzZSIsInJlc29sdmVkQW5pbWF0aW9uIiwiaW5pdFBsYXliYWNrIiwib25Qb3N0UmVzb2x2ZWQiLCJ0aGVuIiwicmVzb2x2ZSIsInJlamVjdCIsImN1cnJlbnRGaW5pc2hlZFByb21pc2UiLCJmbGF0dGVuIiwiUHJvbWlzZSIsInByb2dyZXNzIiwidG8iLCJ0b0Zyb21EaWZmZXJlbmNlIiwiZ2VuZXJhdGVMaW5lYXJFYXNpbmciLCJyZXNvbHV0aW9uIiwicG9pbnRzIiwibnVtUG9pbnRzIiwidmVsb2NpdHlQZXJTZWNvbmQiLCJmcmFtZUR1cmF0aW9uIiwidmVsb2NpdHlTYW1wbGVEdXJhdGlvbiIsImNhbGNHZW5lcmF0b3JWZWxvY2l0eSIsInJlc29sdmVWYWx1ZSIsInByZXZUIiwic3ByaW5nRGVmYXVsdHMiLCJtYXNzIiwiYm91bmNlIiwidmlzdWFsRHVyYXRpb24iLCJncmFudWxhciIsInJlc3REZWx0YSIsIm1pbkR1cmF0aW9uIiwibWF4RHVyYXRpb24iLCJtaW5EYW1waW5nIiwibWF4RGFtcGluZyIsInNhZmVNaW4iLCJmaW5kU3ByaW5nIiwiZW52ZWxvcGUiLCJkZXJpdmF0aXZlIiwiZGFtcGluZ1JhdGlvIiwidW5kYW1wZWRGcmVxIiwiZXhwb25lbnRpYWxEZWNheSIsImNhbGNBbmd1bGFyRnJlcSIsImV4cCIsImYiLCJmYWN0b3IiLCJpbml0aWFsR3Vlc3MiLCJhcHByb3hpbWF0ZVJvb3QiLCJyb290SXRlcmF0aW9ucyIsInJlc3VsdCIsIm1heEdlbmVyYXRvckR1cmF0aW9uIiwiY2FsY0dlbmVyYXRvckR1cmF0aW9uIiwiZ2VuZXJhdG9yIiwidGltZVN0ZXAiLCJkb25lIiwiSW5maW5pdHkiLCJkdXJhdGlvbktleXMiLCJwaHlzaWNzS2V5cyIsImlzU3ByaW5nVHlwZSIsInNvbWUiLCJnZXRTcHJpbmdPcHRpb25zIiwic3ByaW5nT3B0aW9ucyIsImlzUmVzb2x2ZWRGcm9tRHVyYXRpb24iLCJyb290IiwiUEkiLCJkZXJpdmVkIiwic3ByaW5nIiwib3B0aW9uc09yVmlzdWFsRHVyYXRpb24iLCJpbml0aWFsVmVsb2NpdHkiLCJpbml0aWFsRGVsdGEiLCJ1bmRhbXBlZEFuZ3VsYXJGcmVxIiwiaXNHcmFudWxhclNjYWxlIiwicmVzb2x2ZVNwcmluZyIsImFuZ3VsYXJGcmVxIiwiY29zIiwiZGFtcGVkQW5ndWxhckZyZXEiLCJmcmVxRm9yVCIsInNpbmgiLCJjb3NoIiwiY2FsY3VsYXRlZER1cmF0aW9uIiwiY3VycmVudFZlbG9jaXR5IiwiaXNCZWxvd1ZlbG9jaXR5VGhyZXNob2xkIiwiaXNCZWxvd0Rpc3BsYWNlbWVudFRocmVzaG9sZCIsImluZXJ0aWEiLCJwb3dlciIsInRpbWVDb25zdGFudCIsImJvdW5jZURhbXBpbmciLCJib3VuY2VTdGlmZm5lc3MiLCJtb2RpZnlUYXJnZXQiLCJpc091dE9mQm91bmRzIiwibmVhcmVzdEJvdW5kYXJ5IiwiYW1wbGl0dWRlIiwiaWRlYWwiLCJjYWxjRGVsdGEiLCJjYWxjTGF0ZXN0IiwiYXBwbHlGcmljdGlvbiIsImxhdGVzdCIsInRpbWVSZWFjaGVkQm91bmRhcnkiLCJzcHJpbmckMSIsImNoZWNrQ2F0Y2hCb3VuZGFyeSIsImhhc1VwZGF0ZWRGcmFtZSIsImVhc2VJbiIsImVhc2VPdXQiLCJlYXNlSW5PdXQiLCJpc0Vhc2luZ0FycmF5IiwiaXNCZXppZXJEZWZpbml0aW9uIiwiZWFzaW5nTG9va3VwIiwibGluZWFyIiwiZWFzaW5nRGVmaW5pdGlvblRvRnVuY3Rpb24iLCJ4MSIsInkxIiwieDIiLCJ5MiIsImNvbWJpbmVGdW5jdGlvbnMiLCJwaXBlIiwidHJhbnNmb3JtZXJzIiwibWl4TnVtYmVyJDEiLCJodWVUb1JnYiIsInEiLCJoc2xhVG9SZ2JhIiwibWl4SW1tZWRpYXRlIiwibWl4TGluZWFyQ29sb3IiLCJmcm9tRXhwbyIsImV4cG8iLCJjb2xvclR5cGVzIiwiZ2V0Q29sb3JUeXBlIiwiYXNSR0JBIiwibW9kZWwiLCJtaXhDb2xvciIsImZyb21SR0JBIiwidG9SR0JBIiwiYmxlbmRlZCIsImludmlzaWJsZVZhbHVlcyIsIm1peFZpc2liaWxpdHkiLCJtaXhOdW1iZXIiLCJnZXRNaXhlciQxIiwibWl4Q29tcGxleCIsIm1peEFycmF5IiwibWl4T2JqZWN0IiwibnVtVmFsdWVzIiwiYmxlbmRWYWx1ZSIsIm1hdGNoT3JkZXIiLCJvcmRlcmVkT3JpZ2luIiwicG9pbnRlcnMiLCJvcmlnaW5JbmRleCIsIm9yaWdpblZhbHVlIiwidGVtcGxhdGUiLCJvcmlnaW5TdGF0cyIsInRhcmdldFN0YXRzIiwiY2FuSW50ZXJwb2xhdGUiLCJtaXgiLCJtaXhlciIsImNyZWF0ZU1peGVycyIsImN1c3RvbU1peGVyIiwibWl4ZXJzIiwibWl4ZXJGYWN0b3J5IiwibnVtTWl4ZXJzIiwiZWFzaW5nRnVuY3Rpb24iLCJpbnRlcnBvbGF0ZSIsImlucHV0IiwiaXNDbGFtcCIsImlucHV0TGVuZ3RoIiwicmV2ZXJzZSIsImludGVycG9sYXRvciIsInByb2dyZXNzSW5SYW5nZSIsImZpbGxPZmZzZXQiLCJvZmZzZXQiLCJyZW1haW5pbmciLCJvZmZzZXRQcm9ncmVzcyIsImRlZmF1bHRPZmZzZXQkMSIsImFyciIsImNvbnZlcnRPZmZzZXRUb1RpbWVzIiwibyIsImRlZmF1bHRFYXNpbmckMSIsInNwbGljZSIsImtleWZyYW1lVmFsdWVzIiwidGltZXMiLCJlYXNpbmdGdW5jdGlvbnMiLCJhYnNvbHV0ZVRpbWVzIiwibWFwVGltZVRvS2V5ZnJhbWUiLCJmcmFtZWxvb3BEcml2ZXIiLCJwYXNzVGltZXN0YW1wIiwic3RvcCIsImdlbmVyYXRvcnMiLCJkZWNheSIsInR3ZWVuIiwicGVyY2VudFRvUHJvZ3Jlc3MiLCJNYWluVGhyZWFkQW5pbWF0aW9uIiwiaG9sZFRpbWUiLCJjYW5jZWxUaW1lIiwiY3VycmVudFRpbWUiLCJwbGF5YmFja1NwZWVkIiwicGVuZGluZ1BsYXlTdGF0ZSIsInN0YXJ0VGltZSIsInRlYXJkb3duIiwib25TdG9wIiwiS2V5ZnJhbWVSZXNvbHZlciQxIiwib25SZXNvbHZlZCIsImFzc2lnbiIsImtleWZyYW1lcyQxIiwiZ2VuZXJhdG9yRmFjdG9yeSIsIm1hcFBlcmNlbnRUb0tleWZyYW1lcyIsIm1pcnJvcmVkR2VuZXJhdG9yIiwicmVzb2x2ZWREdXJhdGlvbiIsInRvdGFsRHVyYXRpb24iLCJwbGF5IiwicGF1c2UiLCJ0aWNrIiwic2FtcGxlIiwic3BlZWQiLCJ0aW1lV2l0aG91dERlbGF5IiwiaXNJbkRlbGF5UGhhc2UiLCJlbGFwc2VkIiwiZnJhbWVHZW5lcmF0b3IiLCJjdXJyZW50SXRlcmF0aW9uIiwiZmxvb3IiLCJpdGVyYXRpb25Qcm9ncmVzcyIsImlzT2RkSXRlcmF0aW9uIiwiaXNBbmltYXRpb25GaW5pc2hlZCIsImZpbmlzaCIsImRyaXZlciIsIm5ld1NwZWVkIiwiaGFzQ2hhbmdlZCIsIm9uUGxheSIsInN0b3BEcml2ZXIiLCJhbmltYXRlVmFsdWUiLCJhY2NlbGVyYXRlZFZhbHVlcyIsIm1lbW8iLCJzdXBwb3J0c0ZsYWdzIiwibGluZWFyRWFzaW5nIiwibWVtb1N1cHBvcnRzIiwic3VwcG9ydHNGbGFnIiwibWVtb2l6ZWQiLCJzdXBwb3J0c0xpbmVhckVhc2luZyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImFuaW1hdGUiLCJpc1dhYXBpU3VwcG9ydGVkRWFzaW5nIiwic3VwcG9ydGVkV2FhcGlFYXNpbmciLCJldmVyeSIsImN1YmljQmV6aWVyQXNTdHJpbmciLCJtYXBFYXNpbmdUb05hdGl2ZUVhc2luZyIsInNlZ21lbnRFYXNpbmciLCJzdGFydFdhYXBpQW5pbWF0aW9uIiwidmFsdWVOYW1lIiwia2V5ZnJhbWVPcHRpb25zIiwiaXRlcmF0aW9ucyIsImRpcmVjdGlvbiIsImF0dGFjaFRpbWVsaW5lIiwiYW5pbWF0aW9uIiwidGltZWxpbmUiLCJvbmZpbmlzaCIsInN1cHBvcnRzV2FhcGkiLCJFbGVtZW50Iiwic2FtcGxlRGVsdGEiLCJyZXF1aXJlc1ByZWdlbmVyYXRlZEtleWZyYW1lcyIsInByZWdlbmVyYXRlS2V5ZnJhbWVzIiwic2FtcGxlQW5pbWF0aW9uIiwicHJlZ2VuZXJhdGVkS2V5ZnJhbWVzIiwidW5zdXBwb3J0ZWRFYXNpbmdGdW5jdGlvbnMiLCJpc1Vuc3VwcG9ydGVkRWFzZSIsIkFjY2VsZXJhdGVkQW5pbWF0aW9uIiwib3duZXIiLCJwcmVnZW5lcmF0ZWRBbmltYXRpb24iLCJwZW5kaW5nVGltZWxpbmUiLCJwbGF5YmFja1JhdGUiLCJwbGF5U3RhdGUiLCJzYW1wbGVUaW1lIiwic2V0V2l0aFZlbG9jaXR5Iiwic3VwcG9ydHMiLCJIVE1MRWxlbWVudCIsInN1cHBvcnRzU2Nyb2xsVGltZWxpbmUiLCJTY3JvbGxUaW1lbGluZSIsIkdyb3VwUGxheWJhY2tDb250cm9scyIsImFuaW1hdGlvbnMiLCJydW5BbGwiLCJvblJlc29sdmUiLCJvblJlamVjdCIsImFsbCIsImNhdGNoIiwiZ2V0QWxsIiwicHJvcE5hbWUiLCJzZXRBbGwiLCJuZXdWYWx1ZSIsInN1YnNjcmlwdGlvbnMiLCJtZXRob2ROYW1lIiwiY29udHJvbHMiLCJpc1RyYW5zaXRpb25EZWZpbmVkIiwid2hlbiIsIl9kZWxheSIsImRlbGF5Q2hpbGRyZW4iLCJzdGFnZ2VyQ2hpbGRyZW4iLCJzdGFnZ2VyRGlyZWN0aW9uIiwiYW5pbWF0ZU1vdGlvblZhbHVlIiwiaXNIYW5kb2ZmIiwidmFsdWVUcmFuc2l0aW9uIiwic2hvdWxkU2tpcCIsImlzQ3VzdG9tVmFsdWUiLCJ0b1ZhbHVlIiwicmVzb2x2ZUZpbmFsVmFsdWVJbktleWZyYW1lcyIsImFkZFVuaXF1ZUl0ZW0iLCJpdGVtIiwiaW5kZXhPZiIsInJlbW92ZUl0ZW0iLCJtb3ZlSXRlbSIsImZyb21JbmRleCIsInRvSW5kZXgiLCJzdGFydEluZGV4IiwiZW5kSW5kZXgiLCJTdWJzY3JpcHRpb25NYW5hZ2VyIiwiaGFuZGxlciIsIm5vdGlmeSIsIm51bVN1YnNjcmlwdGlvbnMiLCJnZXRTaXplIiwiTUFYX1ZFTE9DSVRZX0RFTFRBIiwiaXNGbG9hdCIsImNvbGxlY3RNb3Rpb25WYWx1ZXMiLCJNb3Rpb25WYWx1ZSIsImluaXQiLCJ2ZXJzaW9uIiwiY2FuVHJhY2tWZWxvY2l0eSIsImV2ZW50cyIsInVwZGF0ZUFuZE5vdGlmeSIsInVwZGF0ZWRBdCIsInNldFByZXZGcmFtZVZhbHVlIiwic2V0Q3VycmVudCIsImNoYW5nZSIsInJlbmRlclJlcXVlc3QiLCJoYXNBbmltYXRlZCIsInByZXZGcmFtZVZhbHVlIiwicHJldlVwZGF0ZWRBdCIsIm9uQ2hhbmdlIiwic3Vic2NyaXB0aW9uIiwib24iLCJldmVudE5hbWUiLCJ1bnN1YnNjcmliZSIsImNsZWFyTGlzdGVuZXJzIiwiZXZlbnRNYW5hZ2VycyIsImF0dGFjaCIsInBhc3NpdmVFZmZlY3QiLCJzdG9wUGFzc2l2ZUVmZmVjdCIsImVuZEFuaW1hdGlvbiIsImdldFByZXZpb3VzIiwic3RhcnRBbmltYXRpb24iLCJhbmltYXRpb25TdGFydCIsImFuaW1hdGlvbkNvbXBsZXRlIiwiY2xlYXJBbmltYXRpb24iLCJhbmltYXRpb25DYW5jZWwiLCJpc0FuaW1hdGluZyIsImRlc3Ryb3kiLCJzZXRNb3Rpb25WYWx1ZSIsImhhc1ZhbHVlIiwiYWRkVmFsdWUiLCJzZXRUYXJnZXQiLCJ0cmFuc2l0aW9uRW5kIiwiY2FtZWxUb0Rhc2giLCJzdHIiLCJ0b0xvd2VyQ2FzZSIsIm9wdGltaXplZEFwcGVhckRhdGFJZCIsIm9wdGltaXplZEFwcGVhckRhdGFBdHRyaWJ1dGUiLCJnZXRPcHRpbWlzZWRBcHBlYXJJZCIsImlzTW90aW9uVmFsdWUiLCJpc1dpbGxDaGFuZ2VNb3Rpb25WYWx1ZSIsImFkZFZhbHVlVG9XaWxsQ2hhbmdlIiwid2lsbENoYW5nZSIsInNob3VsZEJsb2NrQW5pbWF0aW9uIiwicHJvdGVjdGVkS2V5cyIsIm5lZWRzQW5pbWF0aW5nIiwic2hvdWxkQmxvY2siLCJhbmltYXRlVGFyZ2V0IiwidGFyZ2V0QW5kVHJhbnNpdGlvbiIsInRyYW5zaXRpb25PdmVycmlkZSIsImFuaW1hdGlvblR5cGVTdGF0ZSIsImFuaW1hdGlvblN0YXRlIiwiZ2V0U3RhdGUiLCJsYXRlc3RWYWx1ZXMiLCJ2YWx1ZVRhcmdldCIsIk1vdGlvbkhhbmRvZmZBbmltYXRpb24iLCJhcHBlYXJJZCIsInNob3VsZFJlZHVjZU1vdGlvbiIsImFuaW1hdGVWYXJpYW50IiwidmFyaWFudCIsInByZXNlbmNlQ29udGV4dCIsImdldEFuaW1hdGlvbiIsImdldENoaWxkQW5pbWF0aW9ucyIsInZhcmlhbnRDaGlsZHJlbiIsImZvcndhcmREZWxheSIsImFuaW1hdGVDaGlsZHJlbiIsImZpcnN0IiwibGFzdCIsIm1heFN0YWdnZXJEdXJhdGlvbiIsImdlbmVyYXRlU3RhZ2dlckR1cmF0aW9uIiwic29ydCIsInNvcnRCeVRyZWVPcmRlciIsImNoaWxkIiwic29ydE5vZGVQb3NpdGlvbiIsImFuaW1hdGVWaXN1YWxFbGVtZW50IiwicmVzb2x2ZWREZWZpbml0aW9uIiwibnVtVmFyaWFudFByb3BzIiwiZ2V0VmFyaWFudENvbnRleHQiLCJpc0NvbnRyb2xsaW5nVmFyaWFudHMiLCJjb250ZXh0IiwicGFyZW50IiwiaW5pdGlhbCIsInByb3AiLCJyZXZlcnNlUHJpb3JpdHlPcmRlciIsIm51bUFuaW1hdGlvblR5cGVzIiwiYW5pbWF0ZUxpc3QiLCJjcmVhdGVBbmltYXRpb25TdGF0ZSIsImNyZWF0ZVN0YXRlIiwiaXNJbml0aWFsUmVuZGVyIiwiYnVpbGRSZXNvbHZlZFR5cGVWYWx1ZXMiLCJzZXRBbmltYXRlRnVuY3Rpb24iLCJtYWtlQW5pbWF0b3IiLCJhbmltYXRlQ2hhbmdlcyIsImNoYW5nZWRBY3RpdmVUeXBlIiwicmVtb3ZlZEtleXMiLCJlbmNvdW50ZXJlZEtleXMiLCJyZW1vdmVkVmFyaWFudEluZGV4IiwidHlwZVN0YXRlIiwicHJvcElzVmFyaWFudCIsImFjdGl2ZURlbHRhIiwiaXNBY3RpdmUiLCJpc0luaGVyaXRlZCIsIm1hbnVhbGx5QW5pbWF0ZU9uTW91bnQiLCJwcmV2UHJvcCIsInZhcmlhbnREaWRDaGFuZ2UiLCJjaGVja1ZhcmlhbnRzRGlkQ2hhbmdlIiwic2hvdWxkQW5pbWF0ZVR5cGUiLCJoYW5kbGVkUmVtb3ZlZFZhbHVlcyIsImRlZmluaXRpb25MaXN0IiwicmVzb2x2ZWRWYWx1ZXMiLCJwcmV2UmVzb2x2ZWRWYWx1ZXMiLCJhbGxLZXlzIiwibWFya1RvQW5pbWF0ZSIsImxpdmVTdHlsZSIsInZhbHVlSGFzQ2hhbmdlZCIsImJsb2NrSW5pdGlhbEFuaW1hdGlvbiIsIndpbGxBbmltYXRlVmlhUGFyZW50IiwiZmFsbGJhY2tBbmltYXRpb24iLCJmYWxsYmFja1RhcmdldCIsImdldEJhc2VUYXJnZXQiLCJzaG91bGRBbmltYXRlIiwic2V0QWN0aXZlIiwicmVzZXQiLCJjcmVhdGVUeXBlU3RhdGUiLCJ3aGlsZUluVmlldyIsIndoaWxlSG92ZXIiLCJ3aGlsZVRhcCIsIndoaWxlRHJhZyIsIndoaWxlRm9jdXMiLCJleGl0IiwiRmVhdHVyZSIsIm5vZGUiLCJpc01vdW50ZWQiLCJBbmltYXRpb25GZWF0dXJlIiwidXBkYXRlQW5pbWF0aW9uQ29udHJvbHNTdWJzY3JpcHRpb24iLCJ1bm1vdW50Q29udHJvbHMiLCJzdWJzY3JpYmUiLCJtb3VudCIsInByZXZBbmltYXRlIiwicHJldlByb3BzIiwidW5tb3VudCIsImlkJDIiLCJFeGl0QW5pbWF0aW9uRmVhdHVyZSIsImFyZ3VtZW50cyIsImlkIiwiaXNQcmVzZW50Iiwib25FeGl0Q29tcGxldGUiLCJwcmV2SXNQcmVzZW50IiwicHJldlByZXNlbmNlQ29udGV4dCIsImV4aXRBbmltYXRpb24iLCJyZWdpc3RlciIsImV4dHJhY3RFdmVudEluZm8iLCJldmVudCIsInBvaW50IiwicGFnZVgiLCJwYWdlWSIsImFkZFBvaW50ZXJJbmZvIiwiaXNQcmltYXJ5UG9pbnRlciIsImFkZERvbUV2ZW50IiwicGFzc2l2ZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiYWRkUG9pbnRlckV2ZW50IiwiZGlzdGFuY2UyRCIsInhEZWx0YSIsInlEZWx0YSIsIlBhblNlc3Npb24iLCJoYW5kbGVycyIsInRyYW5zZm9ybVBhZ2VQb2ludCIsImNvbnRleHRXaW5kb3ciLCJkcmFnU25hcFRvT3JpZ2luIiwic3RhcnRFdmVudCIsImxhc3RNb3ZlRXZlbnQiLCJsYXN0TW92ZUV2ZW50SW5mbyIsInVwZGF0ZVBvaW50IiwiaW5mbyIsImdldFBhbkluZm8iLCJoaXN0b3J5IiwiaXNQYW5TdGFydGVkIiwiaXNEaXN0YW5jZVBhc3RUaHJlc2hvbGQiLCJvblN0YXJ0Iiwib25Nb3ZlIiwiaGFuZGxlUG9pbnRlck1vdmUiLCJ0cmFuc2Zvcm1Qb2ludCIsImhhbmRsZVBvaW50ZXJVcCIsImVuZCIsIm9uRW5kIiwib25TZXNzaW9uRW5kIiwicmVzdW1lQW5pbWF0aW9uIiwicGFuSW5mbyIsImluaXRpYWxJbmZvIiwib25TZXNzaW9uU3RhcnQiLCJyZW1vdmVMaXN0ZW5lcnMiLCJ1cGRhdGVIYW5kbGVycyIsInN1YnRyYWN0UG9pbnQiLCJsYXN0RGV2aWNlUG9pbnQiLCJzdGFydERldmljZVBvaW50IiwidGltZURlbHRhIiwidGltZXN0YW1wZWRQb2ludCIsImxhc3RQb2ludCIsImlzUmVmT2JqZWN0IiwicmVmIiwiU0NBTEVfUFJFQ0lTSU9OIiwiU0NBTEVfTUlOIiwiU0NBTEVfTUFYIiwiVFJBTlNMQVRFX1BSRUNJU0lPTiIsIlRSQU5TTEFURV9NSU4iLCJUUkFOU0xBVEVfTUFYIiwiY2FsY0xlbmd0aCIsImF4aXMiLCJpc05lYXIiLCJtYXhEaXN0YW5jZSIsImNhbGNBeGlzRGVsdGEiLCJvcmlnaW5Qb2ludCIsInRyYW5zbGF0ZSIsImNhbGNCb3hEZWx0YSIsImNhbGNSZWxhdGl2ZUF4aXMiLCJyZWxhdGl2ZSIsImNhbGNSZWxhdGl2ZUJveCIsImNhbGNSZWxhdGl2ZUF4aXNQb3NpdGlvbiIsImxheW91dCIsImNhbGNSZWxhdGl2ZVBvc2l0aW9uIiwiYXBwbHlDb25zdHJhaW50cyIsImVsYXN0aWMiLCJjYWxjUmVsYXRpdmVBeGlzQ29uc3RyYWludHMiLCJjYWxjUmVsYXRpdmVDb25zdHJhaW50cyIsImxheW91dEJveCIsImNhbGNWaWV3cG9ydEF4aXNDb25zdHJhaW50cyIsImxheW91dEF4aXMiLCJjb25zdHJhaW50c0F4aXMiLCJjYWxjVmlld3BvcnRDb25zdHJhaW50cyIsImNvbnN0cmFpbnRzQm94IiwiY2FsY09yaWdpbiQxIiwic291cmNlTGVuZ3RoIiwidGFyZ2V0TGVuZ3RoIiwicmViYXNlQXhpc0NvbnN0cmFpbnRzIiwiY29uc3RyYWludHMiLCJyZWxhdGl2ZUNvbnN0cmFpbnRzIiwiZGVmYXVsdEVsYXN0aWMiLCJyZXNvbHZlRHJhZ0VsYXN0aWMiLCJkcmFnRWxhc3RpYyIsInJlc29sdmVBeGlzRWxhc3RpYyIsIm1pbkxhYmVsIiwibWF4TGFiZWwiLCJyZXNvbHZlUG9pbnRFbGFzdGljIiwibGFiZWwiLCJjcmVhdGVBeGlzRGVsdGEiLCJjcmVhdGVEZWx0YSIsImNyZWF0ZUF4aXMiLCJjcmVhdGVCb3giLCJlYWNoQXhpcyIsImNvbnZlcnRCb3VuZGluZ0JveFRvQm94IiwiY29udmVydEJveFRvQm91bmRpbmdCb3giLCJ0cmFuc2Zvcm1Cb3hQb2ludHMiLCJ0b3BMZWZ0IiwiYm90dG9tUmlnaHQiLCJpc0lkZW50aXR5U2NhbGUiLCJoYXNTY2FsZSIsImhhc1RyYW5zZm9ybSIsImhhczJEVHJhbnNsYXRlIiwiaXMyRFRyYW5zbGF0ZSIsInNjYWxlUG9pbnQiLCJkaXN0YW5jZUZyb21PcmlnaW4iLCJzY2FsZWQiLCJhcHBseVBvaW50RGVsdGEiLCJib3hTY2FsZSIsImFwcGx5QXhpc0RlbHRhIiwiYXBwbHlCb3hEZWx0YSIsImJveCIsIlRSRUVfU0NBTEVfU05BUF9NSU4iLCJUUkVFX1NDQUxFX1NOQVBfTUFYIiwiYXBwbHlUcmVlRGVsdGFzIiwidHJlZVNjYWxlIiwidHJlZVBhdGgiLCJpc1NoYXJlZFRyYW5zaXRpb24iLCJ0cmVlTGVuZ3RoIiwicHJvamVjdGlvbkRlbHRhIiwic3R5bGUiLCJkaXNwbGF5IiwibGF5b3V0U2Nyb2xsIiwic2Nyb2xsIiwidHJhbnNmb3JtQm94IiwidHJhbnNsYXRlQXhpcyIsInRyYW5zZm9ybUF4aXMiLCJheGlzVHJhbnNsYXRlIiwiYXhpc1NjYWxlIiwiYXhpc09yaWdpbiIsImluc3RhbmNlIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwibWVhc3VyZVBhZ2VCb3giLCJyb290UHJvamVjdGlvbk5vZGUiLCJ2aWV3cG9ydEJveCIsImdldENvbnRleHRXaW5kb3ciLCJvd25lckRvY3VtZW50IiwiZGVmYXVsdFZpZXciLCJlbGVtZW50RHJhZ0NvbnRyb2xzIiwiV2Vha01hcCIsIlZpc3VhbEVsZW1lbnREcmFnQ29udHJvbHMiLCJvcGVuRHJhZ0xvY2siLCJpc0RyYWdnaW5nIiwiY3VycmVudERpcmVjdGlvbiIsImhhc011dGF0ZWRDb25zdHJhaW50cyIsIm9yaWdpbkV2ZW50Iiwic25hcFRvQ3Vyc29yIiwicGF1c2VBbmltYXRpb24iLCJzdG9wQW5pbWF0aW9uIiwiZHJhZyIsImRyYWdQcm9wYWdhdGlvbiIsIm9uRHJhZ1N0YXJ0Iiwic2V0RHJhZ0xvY2siLCJyZXNvbHZlQ29uc3RyYWludHMiLCJwcm9qZWN0aW9uIiwiaXNBbmltYXRpb25CbG9ja2VkIiwiZ2V0QXhpc01vdGlvblZhbHVlIiwibWVhc3VyZWRBeGlzIiwiZHJhZ0RpcmVjdGlvbkxvY2siLCJvbkRpcmVjdGlvbkxvY2siLCJvbkRyYWciLCJnZXRDdXJyZW50RGlyZWN0aW9uIiwidXBkYXRlQXhpcyIsImdldEFuaW1hdGlvblN0YXRlIiwicGFuU2Vzc2lvbiIsImdldFRyYW5zZm9ybVBhZ2VQb2ludCIsIm9uRHJhZ0VuZCIsIl9wb2ludCIsInNob3VsZERyYWciLCJheGlzVmFsdWUiLCJkcmFnQ29uc3RyYWludHMiLCJtZWFzdXJlIiwicHJldkNvbnN0cmFpbnRzIiwicmVzb2x2ZVJlZkNvbnN0cmFpbnRzIiwib25NZWFzdXJlRHJhZ0NvbnN0cmFpbnRzIiwiY29uc3RyYWludHNFbGVtZW50IiwibWVhc3VyZWRDb25zdHJhaW50cyIsInVzZXJDb25zdHJhaW50cyIsImRyYWdNb21lbnR1bSIsImRyYWdUcmFuc2l0aW9uIiwib25EcmFnVHJhbnNpdGlvbkVuZCIsIm1vbWVudHVtQW5pbWF0aW9ucyIsInN0YXJ0QXhpc1ZhbHVlQW5pbWF0aW9uIiwiZHJhZ0tleSIsInRvVXBwZXJDYXNlIiwiZXh0ZXJuYWxNb3Rpb25WYWx1ZSIsInNjYWxlUG9zaXRpb25XaXRoaW5Db25zdHJhaW50cyIsImJveFByb2dyZXNzIiwidHJhbnNmb3JtVGVtcGxhdGUiLCJ1cGRhdGVTY3JvbGwiLCJ1cGRhdGVMYXlvdXQiLCJhZGRMaXN0ZW5lcnMiLCJzdG9wUG9pbnRlckxpc3RlbmVyIiwiZHJhZ0xpc3RlbmVyIiwibWVhc3VyZURyYWdDb25zdHJhaW50cyIsInN0b3BNZWFzdXJlTGF5b3V0TGlzdGVuZXIiLCJzdG9wUmVzaXplTGlzdGVuZXIiLCJzdG9wTGF5b3V0VXBkYXRlTGlzdGVuZXIiLCJoYXNMYXlvdXRDaGFuZ2VkIiwibG9ja1RocmVzaG9sZCIsIkRyYWdHZXN0dXJlIiwicmVtb3ZlR3JvdXBDb250cm9scyIsImRyYWdDb250cm9scyIsImFzeW5jSGFuZGxlciIsIlBhbkdlc3R1cmUiLCJyZW1vdmVQb2ludGVyRG93bkxpc3RlbmVyIiwib25Qb2ludGVyRG93biIsInBvaW50ZXJEb3duRXZlbnQiLCJzZXNzaW9uIiwiY3JlYXRlUGFuSGFuZGxlcnMiLCJvblBhblNlc3Npb25TdGFydCIsIm9uUGFuU3RhcnQiLCJvblBhbiIsIm9uUGFuRW5kIiwiYm9yZGVycyIsIm51bUJvcmRlcnMiLCJhc051bWJlciIsImlzUHgiLCJtaXhWYWx1ZXMiLCJmb2xsb3ciLCJsZWFkIiwic2hvdWxkQ3Jvc3NmYWRlT3BhY2l0eSIsImlzT25seU1lbWJlciIsImVhc2VDcm9zc2ZhZGVJbiIsIm9wYWNpdHlFeGl0IiwiZWFzZUNyb3NzZmFkZU91dCIsImJvcmRlckxhYmVsIiwiZm9sbG93UmFkaXVzIiwiZ2V0UmFkaXVzIiwibGVhZFJhZGl1cyIsImNhbk1peCIsInJhZGl1c05hbWUiLCJjb21wcmVzcyIsImNvcHlBeGlzSW50byIsIm9yaWdpbkF4aXMiLCJjb3B5Qm94SW50byIsIm9yaWdpbkJveCIsImNvcHlBeGlzRGVsdGFJbnRvIiwib3JpZ2luRGVsdGEiLCJyZW1vdmVQb2ludERlbHRhIiwicmVtb3ZlQXhpc0RlbHRhIiwic291cmNlQXhpcyIsInJlbGF0aXZlUHJvZ3Jlc3MiLCJyZW1vdmVBeGlzVHJhbnNmb3JtcyIsInRyYW5zZm9ybXMiLCJzY2FsZUtleSIsIm9yaWdpbktleSIsInhLZXlzIiwieUtleXMiLCJyZW1vdmVCb3hUcmFuc2Zvcm1zIiwic291cmNlQm94IiwiaXNBeGlzRGVsdGFaZXJvIiwiaXNEZWx0YVplcm8iLCJheGlzRXF1YWxzIiwiYm94RXF1YWxzIiwiYXhpc0VxdWFsc1JvdW5kZWQiLCJib3hFcXVhbHNSb3VuZGVkIiwiYXNwZWN0UmF0aW8iLCJheGlzRGVsdGFFcXVhbHMiLCJOb2RlU3RhY2siLCJtZW1iZXJzIiwic2NoZWR1bGVSZW5kZXIiLCJyZW1vdmUiLCJwcmV2TGVhZCIsInByb21vdGUiLCJyZWxlZ2F0ZSIsImluZGV4T2ZOb2RlIiwiZmluZEluZGV4IiwibWVtYmVyIiwicHJlc2VydmVGb2xsb3dPcGFjaXR5Iiwic2hvdyIsInJlc3VtZUZyb20iLCJwcmVzZXJ2ZU9wYWNpdHkiLCJzbmFwc2hvdCIsImFuaW1hdGlvblZhbHVlcyIsImlzVXBkYXRpbmciLCJpc0xheW91dERpcnR5IiwiY3Jvc3NmYWRlIiwiaGlkZSIsImV4aXRBbmltYXRpb25Db21wbGV0ZSIsInJlc3VtaW5nRnJvbSIsInJlbW92ZUxlYWRTbmFwc2hvdCIsInNjYWxlQ29ycmVjdG9ycyIsImFkZFNjYWxlQ29ycmVjdG9yIiwiY29ycmVjdG9ycyIsImJ1aWxkUHJvamVjdGlvblRyYW5zZm9ybSIsImxhdGVzdFRyYW5zZm9ybSIsInhUcmFuc2xhdGUiLCJ5VHJhbnNsYXRlIiwielRyYW5zbGF0ZSIsImVsZW1lbnRTY2FsZVgiLCJlbGVtZW50U2NhbGVZIiwiY29tcGFyZUJ5RGVwdGgiLCJGbGF0VHJlZSIsImNoaWxkcmVuIiwiaXNEaXJ0eSIsInJlc29sdmVNb3Rpb25WYWx1ZSIsInVud3JhcHBlZFZhbHVlIiwiZ2xvYmFsUHJvamVjdGlvblN0YXRlIiwiaGFzQW5pbWF0ZWRTaW5jZVJlc2l6ZSIsImhhc0V2ZXJVcGRhdGVkIiwidGltZW91dCIsImNoZWNrRWxhcHNlZCIsImNyZWF0ZUdlbmVyYXRvckVhc2luZyIsImNyZWF0ZUdlbmVyYXRvciIsImlzRE9NS2V5ZnJhbWVzIiwicmVzb2x2ZVN1YmplY3RzIiwic3ViamVjdCIsInNjb3BlIiwic2VsZWN0b3JDYWNoZSIsInJlc29sdmVFbGVtZW50cyIsIk5vZGVMaXN0IiwiY2FsY05leHRUaW1lIiwibGFiZWxzIiwid3JhcCIsInJhbmdlU2l6ZSIsImdldEVhc2luZ0ZvclNlZ21lbnQiLCJlcmFzZUtleWZyYW1lcyIsInNlcXVlbmNlIiwiZW5kVGltZSIsImF0IiwiYWRkS2V5ZnJhbWVzIiwiY29tcGFyZUJ5VGltZSIsIm5vcm1hbGl6ZVRpbWVzIiwiY2FsY3VsYXRlUmVwZWF0RHVyYXRpb24iLCJfcmVwZWF0RGVsYXkiLCJkZWZhdWx0U2VnbWVudEVhc2luZyIsIk1BWF9SRVBFQVQiLCJjcmVhdGVBbmltYXRpb25zRnJvbVNlcXVlbmNlIiwiZGVmYXVsdFRyYW5zaXRpb24iLCJzZXF1ZW5jZVRyYW5zaXRpb24iLCJkZWZhdWx0RHVyYXRpb24iLCJhbmltYXRpb25EZWZpbml0aW9ucyIsInNlcXVlbmNlcyIsImVsZW1lbnRDYWNoZSIsInRpbWVMYWJlbHMiLCJwcmV2VGltZSIsInNlZ21lbnQiLCJyZXNvbHZlVmFsdWVTZXF1ZW5jZSIsInZhbHVlS2V5ZnJhbWVzIiwidmFsdWVTZXF1ZW5jZSIsImVsZW1lbnRJbmRleCIsIm51bVN1YmplY3RzIiwidmFsdWVLZXlmcmFtZXNBc0xpc3QiLCJrZXlmcmFtZXNBc0xpc3QiLCJyZW1haW5pbmdUcmFuc2l0aW9uIiwiY2FsY3VsYXRlZERlbGF5IiwibnVtS2V5ZnJhbWVzIiwiYWJzb2x1dGVEZWx0YSIsImlzTnVtYmVyS2V5ZnJhbWVzQXJyYXkiLCJzcHJpbmdUcmFuc2l0aW9uIiwic3ByaW5nRWFzaW5nIiwicmVtYWluZGVyIiwidW5zaGlmdCIsIm9yaWdpbmFsS2V5ZnJhbWVzIiwib3JpZ2luYWxUaW1lcyIsIm9yaWdpbmFsRWFzZSIsInJlcGVhdEluZGV4Iiwia2V5ZnJhbWVJbmRleCIsInRhcmdldFRpbWUiLCJzdWJqZWN0U2VxdWVuY2UiLCJnZXRTdWJqZWN0U2VxdWVuY2UiLCJnZXRWYWx1ZVNlcXVlbmNlIiwic3ViamVjdHMiLCJzdWJqZWN0SW5kZXgiLCJ0aGlzU3ViamVjdCIsImdldFZhbHVlVHJhbnNpdGlvbiIsInZhbHVlU2VxdWVuY2VzIiwidmFsdWVPZmZzZXQiLCJ2YWx1ZUVhc2luZyIsImlzTnVtYmVyIiwidmlzdWFsRWxlbWVudFN0b3JlIiwiaXNTVkdFbGVtZW50IiwiU1ZHRWxlbWVudCIsInRhZ05hbWUiLCJpc0ZvcmNlZE1vdGlvblZhbHVlIiwibGF5b3V0SWQiLCJzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMkMSIsIm5ld1ZhbHVlcyIsInNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyIsInRhcmdldEtleSIsImNoYXJBdCIsImlzQnJvd3NlciIsInByZWZlcnNSZWR1Y2VkTW90aW9uIiwiaGFzUmVkdWNlZE1vdGlvbkxpc3RlbmVyIiwiaW5pdFByZWZlcnNSZWR1Y2VkTW90aW9uIiwibWF0Y2hNZWRpYSIsIm1vdGlvbk1lZGlhUXVlcnkiLCJzZXRSZWR1Y2VkTW90aW9uUHJlZmVyZW5jZXMiLCJtYXRjaGVzIiwiYWRkTGlzdGVuZXIiLCJpc1ZhcmlhbnROb2RlIiwidXBkYXRlTW90aW9uVmFsdWVzRnJvbVByb3BzIiwibmV4dFZhbHVlIiwicHJldlZhbHVlIiwiZXhpc3RpbmdWYWx1ZSIsImxhdGVzdFZhbHVlIiwiZ2V0U3RhdGljVmFsdWUiLCJyZW1vdmVWYWx1ZSIsImZlYXR1cmVQcm9wcyIsImZvY3VzIiwiaG92ZXIiLCJ0YXAiLCJwYW4iLCJpblZpZXciLCJmZWF0dXJlRGVmaW5pdGlvbnMiLCJpc0VuYWJsZWQiLCJ2YWx1ZVR5cGVzIiwiZmluZFZhbHVlVHlwZSIsInByb3BFdmVudEhhbmRsZXJzIiwiVmlzdWFsRWxlbWVudCIsIl9wcm9wcyIsIl9wcmV2UHJvcHMiLCJfdmlzdWFsRWxlbWVudCIsInJlZHVjZWRNb3Rpb25Db25maWciLCJ2aXN1YWxTdGF0ZSIsImZlYXR1cmVzIiwidmFsdWVTdWJzY3JpcHRpb25zIiwicHJldk1vdGlvblZhbHVlcyIsInByb3BFdmVudFN1YnNjcmlwdGlvbnMiLCJub3RpZnlVcGRhdGUiLCJ0cmlnZ2VyQnVpbGQiLCJyZW5kZXJJbnN0YW5jZSIsInJlbmRlclN0YXRlIiwicmVuZGVyU2NoZWR1bGVkQXQiLCJiYXNlVGFyZ2V0IiwiaW5pdGlhbFZhbHVlcyIsImluaXRpYWxNb3Rpb25WYWx1ZXMiLCJyZW1vdmVGcm9tVmFyaWFudFRyZWUiLCJhZGRWYXJpYW50Q2hpbGQiLCJiaW5kVG9Nb3Rpb25WYWx1ZSIsImZlYXR1cmUiLCJ2YWx1ZUlzVHJhbnNmb3JtIiwicmVtb3ZlT25DaGFuZ2UiLCJpc1RyYW5zZm9ybURpcnR5IiwicmVtb3ZlT25SZW5kZXJSZXF1ZXN0IiwicmVtb3ZlU3luY0NoZWNrIiwiTW90aW9uQ2hlY2tBcHBlYXJTeW5jIiwib3RoZXIiLCJzb3J0SW5zdGFuY2VOb2RlUG9zaXRpb24iLCJ1cGRhdGVGZWF0dXJlcyIsImZlYXR1cmVEZWZpbml0aW9uIiwiRmVhdHVyZUNvbnN0cnVjdG9yIiwiYnVpbGQiLCJtZWFzdXJlSW5zdGFuY2VWaWV3cG9ydEJveCIsInNldFN0YXRpY1ZhbHVlIiwibGlzdGVuZXJOYW1lIiwibGlzdGVuZXIiLCJoYW5kbGVDaGlsZE1vdGlvblZhbHVlIiwiZ2V0VmFyaWFudCIsImdldENsb3Nlc3RWYXJpYW50Tm9kZSIsImNsb3Nlc3RWYXJpYW50Tm9kZSIsInJlbW92ZVZhbHVlRnJvbVJlbmRlclN0YXRlIiwiZ2V0QmFzZVRhcmdldEZyb21Qcm9wcyIsInJlYWRWYWx1ZUZyb21JbnN0YW5jZSIsInNldEJhc2VUYXJnZXQiLCJ2YWx1ZUZyb21Jbml0aWFsIiwiRE9NVmlzdWFsRWxlbWVudCIsImNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIiwidmFycyIsImNoaWxkU3Vic2NyaXB0aW9uIiwidGV4dENvbnRlbnQiLCJnZXRWYWx1ZUFzVHlwZSIsInRyYW5zbGF0ZUFsaWFzIiwibnVtVHJhbnNmb3JtcyIsImJ1aWxkVHJhbnNmb3JtIiwidHJhbnNmb3JtU3RyaW5nIiwidHJhbnNmb3JtSXNEZWZhdWx0IiwidmFsdWVJc0RlZmF1bHQiLCJ2YWx1ZUFzVHlwZSIsInRyYW5zZm9ybU5hbWUiLCJidWlsZEhUTUxTdHlsZXMiLCJ0cmFuc2Zvcm1PcmlnaW4iLCJoYXNUcmFuc2Zvcm1PcmlnaW4iLCJjYWxjT3JpZ2luIiwiY2FsY1NWR1RyYW5zZm9ybU9yaWdpbiIsImRpbWVuc2lvbnMiLCJweE9yaWdpblgiLCJweE9yaWdpblkiLCJkYXNoS2V5cyIsImFycmF5IiwiY2FtZWxLZXlzIiwiYnVpbGRTVkdQYXRoIiwiYXR0cnMiLCJzcGFjaW5nIiwidXNlRGFzaENhc2UiLCJwYXRoTGVuZ3RoIiwicGF0aFNwYWNpbmciLCJidWlsZFNWR0F0dHJzIiwiYXR0clgiLCJhdHRyWSIsImF0dHJTY2FsZSIsInBhdGhPZmZzZXQiLCJpc1NWR1RhZyIsInZpZXdCb3giLCJjYW1lbENhc2VBdHRyaWJ1dGVzIiwicmVuZGVySFRNTCIsInN0eWxlUHJvcCIsImdldFByb2plY3Rpb25TdHlsZXMiLCJzZXRQcm9wZXJ0eSIsInJlbmRlclNWRyIsIl9zdHlsZVByb3AiLCJzZXRBdHRyaWJ1dGUiLCJ0YWciLCJTVkdWaXN1YWxFbGVtZW50IiwiZGVmYXVsdFR5cGUiLCJnZXRBdHRyaWJ1dGUiLCJnZXRDb21wdXRlZFN0eWxlJDEiLCJIVE1MVmlzdWFsRWxlbWVudCIsImNvbXB1dGVkU3R5bGUiLCJpc09iamVjdEtleSIsIm9iamVjdCIsIk9iamVjdFZpc3VhbEVsZW1lbnQiLCJjcmVhdGVET01WaXN1YWxFbGVtZW50IiwiY3JlYXRlT2JqZWN0VmlzdWFsRWxlbWVudCIsImFuaW1hdGVTaW5nbGVWYWx1ZSIsIm1vdGlvblZhbHVlJDEiLCJpc1NpbmdsZVZhbHVlIiwiYW5pbWF0ZVN1YmplY3QiLCJjcmVhdGVWaXN1YWxFbGVtZW50IiwiYW5pbWF0ZVNlcXVlbmNlIiwiaXNTZXF1ZW5jZSIsImNyZWF0ZVNjb3BlZEFuaW1hdGUiLCJzY29wZWRBbmltYXRlIiwic3ViamVjdE9yU2VxdWVuY2UiLCJvcHRpb25zT3JLZXlmcmFtZXMiLCJzZXRDU1NWYXIiLCJzZXRTdHlsZSIsInN1cHBvcnRzUGFydGlhbEtleWZyYW1lcyIsImh5ZHJhdGVLZXlmcmFtZXMiLCJkZWZhdWx0RWFzaW5nIiwiZ2V0RWxlbWVudEFuaW1hdGlvblN0YXRlIiwiTmF0aXZlQW5pbWF0aW9uIiwiaXNDU1NWYXIiLCJzZXRWYWx1ZSIsImV4aXN0aW5nQW5pbWF0aW9uIiwicmVhZEluaXRpYWxLZXlmcmFtZSIsImdlbmVyYXRvck9wdGlvbnMiLCJyZW1vdmVBbmltYXRpb24iLCJvbkZpbmlzaCIsImVmZmVjdCIsInVwZGF0ZVRpbWluZyIsImNvbW1pdFN0eWxlcyIsImFuaW1hdGVFbGVtZW50cyIsImVsZW1lbnRPclNlbGVjdG9yIiwiZWxlbWVudHMiLCJudW1FbGVtZW50cyIsImVsZW1lbnRUcmFuc2l0aW9uIiwidmFsdWVPcHRpb25zIiwiY3JlYXRlU2NvcGVkV2FhcGlBbmltYXRlIiwiYW5pbWF0ZU1pbmkiLCJyZXNpemVIYW5kbGVycyIsIm9ic2VydmVyIiwiZ2V0RWxlbWVudFNpemUiLCJib3JkZXJCb3hTaXplIiwiaW5saW5lU2l6ZSIsImJsb2NrU2l6ZSIsImdldEJCb3giLCJvZmZzZXRXaWR0aCIsIm9mZnNldEhlaWdodCIsIm5vdGlmeVRhcmdldCIsImNvbnRlbnRSZWN0IiwiY29udGVudFNpemUiLCJub3RpZnlBbGwiLCJlbnRyaWVzIiwiY3JlYXRlUmVzaXplT2JzZXJ2ZXIiLCJSZXNpemVPYnNlcnZlciIsInJlc2l6ZUVsZW1lbnQiLCJlbGVtZW50SGFuZGxlcnMiLCJvYnNlcnZlIiwidW5vYnNlcnZlIiwid2luZG93Q2FsbGJhY2tzIiwid2luZG93UmVzaXplSGFuZGxlciIsImNyZWF0ZVdpbmRvd1Jlc2l6ZUhhbmRsZXIiLCJpbm5lcldpZHRoIiwiaW5uZXJIZWlnaHQiLCJyZXNpemVXaW5kb3ciLCJyZXNpemUiLCJtYXhFbGFwc2VkIiwiY3JlYXRlQXhpc0luZm8iLCJzY3JvbGxMZW5ndGgiLCJ0YXJnZXRPZmZzZXQiLCJjb250YWluZXJMZW5ndGgiLCJjcmVhdGVTY3JvbGxJbmZvIiwicG9zaXRpb24iLCJ1cGRhdGVBeGlzSW5mbyIsImF4aXNOYW1lIiwidXBkYXRlU2Nyb2xsSW5mbyIsImNhbGNJbnNldCIsImNvbnRhaW5lciIsImluc2V0Iiwib2Zmc2V0TGVmdCIsIm9mZnNldFRvcCIsIm9mZnNldFBhcmVudCIsInN2Z0JvdW5kaW5nQm94IiwicGFyZW50RWxlbWVudCIsInBhcmVudEJvdW5kaW5nQm94IiwiU1ZHR3JhcGhpY3NFbGVtZW50Iiwic3ZnIiwicGFyZW50Tm9kZSIsIlNjcm9sbE9mZnNldCIsIkVudGVyIiwiRXhpdCIsIkFueSIsIkFsbCIsIm5hbWVkRWRnZXMiLCJjZW50ZXIiLCJyZXNvbHZlRWRnZSIsImVkZ2UiLCJkb2N1bWVudEVsZW1lbnQiLCJjbGllbnRXaWR0aCIsImNsaWVudEhlaWdodCIsImRlZmF1bHRPZmZzZXQiLCJyZXNvbHZlT2Zmc2V0IiwidGFyZ2V0SW5zZXQiLCJvZmZzZXREZWZpbml0aW9uIiwidGFyZ2V0UG9pbnQiLCJjb250YWluZXJQb2ludCIsImluY2x1ZGVzIiwiZ2V0VGFyZ2V0U2l6ZSIsInJlc29sdmVPZmZzZXRzIiwibGVuZ3RoTGFiZWwiLCJ0YXJnZXRTaXplIiwic2Nyb2xsV2lkdGgiLCJzY3JvbGxIZWlnaHQiLCJjb250YWluZXJTaXplIiwibnVtT2Zmc2V0cyIsImludGVycG9sYXRvck9mZnNldHMiLCJjcmVhdGVPblNjcm9sbEhhbmRsZXIiLCJvblNjcm9sbCIsInNjcm9sbExpc3RlbmVycyIsInJlc2l6ZUxpc3RlbmVycyIsIm9uU2Nyb2xsSGFuZGxlcnMiLCJnZXRFdmVudFRhcmdldCIsInNjcm9sbEluZm8iLCJjb250YWluZXJIYW5kbGVycyIsImNvbnRhaW5lckhhbmRsZXIiLCJtZWFzdXJlQWxsIiwidXBkYXRlQWxsIiwiY3VycmVudEhhbmRsZXJzIiwic2Nyb2xsTGlzdGVuZXIiLCJvYnNlcnZlVGltZWxpbmUiLCJwcmV2UHJvZ3Jlc3MiLCJvbkZyYW1lIiwicGVyY2VudGFnZSIsInNjcm9sbFRpbWVsaW5lRmFsbGJhY2siLCJ0aW1lbGluZUNhY2hlIiwiZ2V0VGltZWxpbmUiLCJpc09uU2Nyb2xsV2l0aEluZm8iLCJuZWVkc0VsZW1lbnRUcmFja2luZyIsInNjcm9sbEZ1bmN0aW9uIiwic2Nyb2xsQW5pbWF0aW9uIiwidmFsdWVBbmltYXRpb24iLCJvcHRpb25zV2l0aERlZmF1bHRzIiwidGhyZXNob2xkcyIsInJvb3RNYXJnaW4iLCJhbW91bnQiLCJhY3RpdmVJbnRlcnNlY3Rpb25zIiwib25JbnRlcnNlY3Rpb25DaGFuZ2UiLCJlbnRyeSIsImlzSW50ZXJzZWN0aW5nIiwibmV3T25FbmQiLCJJbnRlcnNlY3Rpb25PYnNlcnZlciIsInRocmVzaG9sZCIsImRpc2Nvbm5lY3QiLCJudW1TdGVwcyIsImV4cGFuZGVkIiwicm91bmRlZCIsImNlaWwiLCJnZXRPcmlnaW5JbmRleCIsInRvdGFsIiwibGFzdEluZGV4Iiwic3RhZ2dlciIsInN0YXJ0RGVsYXkiLCJtYXhEZWxheSIsImlzQ3VzdG9tVmFsdWVUeXBlIiwiZ2V0TWl4ZXIiLCJ1c2VJbW1lZGlhdGUiLCJhcmdPZmZzZXQiLCJpbnB1dFZhbHVlIiwiaW5wdXRSYW5nZSIsIm91dHB1dFJhbmdlIiwic3luYyIsImNhbmNlbFN5bmMiLCJtaWNyb3Rhc2siLCJjYW5jZWxNaWNyb3Rhc2siLCJtZXRyaWNzIiwidG90YWxOb2RlcyIsInJlc29sdmVkVGFyZ2V0RGVsdGFzIiwicmVjYWxjdWxhdGVkUHJvamVjdGlvbiIsImlzRGVidWciLCJNb3Rpb25EZWJ1ZyIsInRyYW5zZm9ybUF4ZXMiLCJoaWRkZW5WaXNpYmlsaXR5IiwidmlzaWJpbGl0eSIsImFuaW1hdGlvblRhcmdldCIsImlkJDEiLCJyZXNldERpc3RvcnRpbmdUcmFuc2Zvcm0iLCJzaGFyZWRBbmltYXRpb25WYWx1ZXMiLCJjYW5jZWxUcmVlT3B0aW1pc2VkVHJhbnNmb3JtQW5pbWF0aW9ucyIsInByb2plY3Rpb25Ob2RlIiwiaGFzQ2hlY2tlZE9wdGltaXNlZEFwcGVhciIsIk1vdGlvbkhhc09wdGltaXNlZEFuaW1hdGlvbiIsIk1vdGlvbkNhbmNlbE9wdGltaXNlZEFuaW1hdGlvbiIsImNyZWF0ZVByb2plY3Rpb25Ob2RlJDEiLCJhdHRhY2hSZXNpemVMaXN0ZW5lciIsImRlZmF1bHRQYXJlbnQiLCJtZWFzdXJlU2Nyb2xsIiwiY2hlY2tJc1Njcm9sbFJvb3QiLCJyZXNldFRyYW5zZm9ybSIsIlByb2plY3Rpb25Ob2RlIiwiYW5pbWF0aW9uSWQiLCJpc1RyZWVBbmltYXRpbmciLCJpc1Byb2plY3Rpb25EaXJ0eSIsImlzU2hhcmVkUHJvamVjdGlvbkRpcnR5IiwidXBkYXRlTWFudWFsbHlCbG9ja2VkIiwidXBkYXRlQmxvY2tlZEJ5UmVzaXplIiwiaXNTVkciLCJuZWVkc1Jlc2V0Iiwic2hvdWxkUmVzZXRUcmFuc2Zvcm0iLCJldmVudEhhbmRsZXJzIiwiaGFzVHJlZUFuaW1hdGVkIiwidXBkYXRlU2NoZWR1bGVkIiwic2NoZWR1bGVVcGRhdGUiLCJwcm9qZWN0aW9uVXBkYXRlU2NoZWR1bGVkIiwiY2hlY2tVcGRhdGVGYWlsZWQiLCJjbGVhckFsbFNuYXBzaG90cyIsInVwZGF0ZVByb2plY3Rpb24iLCJub2RlcyIsInByb3BhZ2F0ZURpcnR5Tm9kZXMiLCJyZXNvbHZlVGFyZ2V0RGVsdGEiLCJjYWxjUHJvamVjdGlvbiIsImNsZWFuRGlydHlOb2RlcyIsInJlY29yZCIsInJlc29sdmVkUmVsYXRpdmVUYXJnZXRBdCIsImhhc1Byb2plY3RlZCIsImlzVmlzaWJsZSIsImFuaW1hdGlvblByb2dyZXNzIiwic2hhcmVkTm9kZXMiLCJwYXRoIiwibm90aWZ5TGlzdGVuZXJzIiwic3Vic2NyaXB0aW9uTWFuYWdlciIsImhhc0xpc3RlbmVycyIsImNhbmNlbERlbGF5IiwicmVzaXplVW5ibG9ja1VwZGF0ZSIsImZpbmlzaEFuaW1hdGlvbiIsInJlZ2lzdGVyU2hhcmVkTm9kZSIsImhhc1JlbGF0aXZlVGFyZ2V0Q2hhbmdlZCIsIm5ld0xheW91dCIsImlzVHJlZUFuaW1hdGlvbkJsb2NrZWQiLCJyZWxhdGl2ZVRhcmdldCIsImxheW91dFRyYW5zaXRpb24iLCJkZWZhdWx0TGF5b3V0VHJhbnNpdGlvbiIsIm9uTGF5b3V0QW5pbWF0aW9uU3RhcnQiLCJvbkxheW91dEFuaW1hdGlvbkNvbXBsZXRlIiwidGFyZ2V0Q2hhbmdlZCIsInRhcmdldExheW91dCIsImhhc09ubHlSZWxhdGl2ZVRhcmdldENoYW5nZWQiLCJsYXlvdXRSb290IiwiY3VycmVudEFuaW1hdGlvbiIsInNldEFuaW1hdGlvbk9yaWdpbiIsImFuaW1hdGlvbk9wdGlvbnMiLCJpc0xlYWQiLCJ3aWxsVXBkYXRlIiwic3RhY2siLCJnZXRTdGFjayIsImJsb2NrVXBkYXRlIiwidW5ibG9ja1VwZGF0ZSIsImlzVXBkYXRlQmxvY2tlZCIsInN0YXJ0VXBkYXRlIiwicmVzZXRTa2V3QW5kUm90YXRpb24iLCJnZXRUcmFuc2Zvcm1UZW1wbGF0ZSIsInNob3VsZE5vdGlmeUxpc3RlbmVycyIsInByZXZUcmFuc2Zvcm1UZW1wbGF0ZVZhbHVlIiwidXBkYXRlU25hcHNob3QiLCJ1cGRhdGVXYXNCbG9ja2VkIiwiY2xlYXJNZWFzdXJlbWVudHMiLCJjbGVhcklzTGF5b3V0RGlydHkiLCJyZXNldFRyYW5zZm9ybVN0eWxlIiwibm90aWZ5TGF5b3V0VXBkYXRlIiwiZGlkVXBkYXRlIiwiY2xlYXJTbmFwc2hvdCIsInJlbW92ZUxlYWRTbmFwc2hvdHMiLCJzY2hlZHVsZVVwZGF0ZVByb2plY3Rpb24iLCJzY2hlZHVsZUNoZWNrQWZ0ZXJVbm1vdW50IiwiYWx3YXlzTWVhc3VyZUxheW91dCIsInByZXZMYXlvdXQiLCJsYXlvdXRDb3JyZWN0ZWQiLCJwaGFzZSIsImlzUm9vdCIsIndhc1Jvb3QiLCJpc1Jlc2V0UmVxdWVzdGVkIiwiaGFzUHJvamVjdGlvbiIsInRyYW5zZm9ybVRlbXBsYXRlVmFsdWUiLCJ0cmFuc2Zvcm1UZW1wbGF0ZUhhc0NoYW5nZWQiLCJyZW1vdmVUcmFuc2Zvcm0iLCJwYWdlQm94IiwicmVtb3ZlRWxlbWVudFNjcm9sbCIsInJvdW5kQm94IiwibWVhc3VyZWRCb3giLCJ3YXNJblNjcm9sbFJvb3QiLCJjaGVja05vZGVXYXNTY3JvbGxSb290IiwiYm94V2l0aG91dFNjcm9sbCIsImFwcGx5VHJhbnNmb3JtIiwidHJhbnNmb3JtT25seSIsIndpdGhUcmFuc2Zvcm1zIiwiYm94V2l0aG91dFRyYW5zZm9ybSIsIm5vZGVCb3giLCJzZXRUYXJnZXREZWx0YSIsInRhcmdldERlbHRhIiwic2V0T3B0aW9ucyIsImZvcmNlUmVsYXRpdmVQYXJlbnRUb1Jlc29sdmVUYXJnZXQiLCJyZWxhdGl2ZVBhcmVudCIsImZvcmNlUmVjYWxjdWxhdGlvbiIsImdldExlYWQiLCJpc1NoYXJlZCIsImNhblNraXAiLCJhdHRlbXB0VG9SZXNvbHZlUmVsYXRpdmVUYXJnZXQiLCJnZXRDbG9zZXN0UHJvamVjdGluZ1BhcmVudCIsInJlbGF0aXZlVGFyZ2V0T3JpZ2luIiwidGFyZ2V0V2l0aFRyYW5zZm9ybXMiLCJpc1Byb2plY3RpbmciLCJwZW5kaW5nQW5pbWF0aW9uIiwicHJldlRyZWVTY2FsZVgiLCJwcmV2VHJlZVNjYWxlWSIsInByZXZQcm9qZWN0aW9uRGVsdGEiLCJjcmVhdGVQcm9qZWN0aW9uRGVsdGFzIiwicHJvamVjdGlvbkRlbHRhV2l0aFRyYW5zZm9ybSIsInNuYXBzaG90TGF0ZXN0VmFsdWVzIiwibWl4ZWRWYWx1ZXMiLCJyZWxhdGl2ZUxheW91dCIsInNuYXBzaG90U291cmNlIiwibGF5b3V0U291cmNlIiwiaXNTaGFyZWRMYXlvdXRBbmltYXRpb24iLCJoYXNPcGFjaXR5Q3Jvc3NmYWRlIiwicHJldlJlbGF0aXZlVGFyZ2V0IiwibWl4VGFyZ2V0RGVsdGEiLCJtaXhBeGlzRGVsdGEiLCJtaXhCb3giLCJjb21wbGV0ZUFuaW1hdGlvbiIsImFwcGx5VHJhbnNmb3Jtc1RvVGFyZ2V0Iiwic2hvdWxkQW5pbWF0ZVBvc2l0aW9uT25seSIsImFuaW1hdGlvblR5cGUiLCJ4TGVuZ3RoIiwieUxlbmd0aCIsImNvbmZpZyIsImluaXRpYWxQcm9tb3Rpb25Db25maWciLCJzaG91bGRQcmVzZXJ2ZUZvbGxvd09wYWNpdHkiLCJnZXRQcmV2TGVhZCIsImhhc0Rpc3RvcnRpbmdUcmFuc2Zvcm0iLCJyZXNldFZhbHVlcyIsInN0eWxlcyIsInBvaW50ZXJFdmVudHMiLCJlbXB0eVN0eWxlcyIsInZhbHVlc1RvUmVuZGVyIiwiY29ycmVjdCIsImFwcGx5VG8iLCJjb3JyZWN0ZWQiLCJudW0iLCJyZXNldFRyZWUiLCJtZWFzdXJlZExheW91dCIsImF4aXNTbmFwc2hvdCIsImxheW91dERlbHRhIiwidmlzdWFsRGVsdGEiLCJwYXJlbnRTbmFwc2hvdCIsInBhcmVudExheW91dCIsInJlbGF0aXZlU25hcHNob3QiLCJvbkJlZm9yZUxheW91dE1lYXN1cmUiLCJtaXhBeGlzIiwidXNlckFnZW50Q29udGFpbnMiLCJzdHJpbmciLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJyb3VuZFBvaW50Iiwicm91bmRBeGlzIiwiRG9jdW1lbnRQcm9qZWN0aW9uTm9kZSIsInNjcm9sbExlZnQiLCJib2R5Iiwic2Nyb2xsVG9wIiwiSFRNTFByb2plY3Rpb25Ob2RlIiwiZG9jdW1lbnROb2RlIiwibm9kZUdyb3VwIiwiZGlydHlBbGwiLCJkaXJ0eSIsInBpeGVsc1RvUGVyY2VudCIsInBpeGVscyIsImNvcnJlY3RCb3JkZXJSYWRpdXMiLCJjb3JyZWN0Qm94U2hhZG93Iiwib3JpZ2luYWwiLCJzaGFkb3ciLCJ4U2NhbGUiLCJ5U2NhbGUiLCJhdmVyYWdlU2NhbGUiLCJQcmVzZW5jZUNvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwidXNlUHJlc2VuY2UiLCJ1c2VDb250ZXh0IiwidXNlSWQiLCJ1c2VFZmZlY3QiLCJzYWZlVG9SZW1vdmUiLCJ1c2VDYWxsYmFjayIsInVzZUlzUHJlc2VudCIsIkxheW91dEdyb3VwQ29udGV4dCIsIlN3aXRjaExheW91dEdyb3VwQ29udGV4dCIsIk1lYXN1cmVMYXlvdXRXaXRoQ29udGV4dCIsIkNvbXBvbmVudCIsImNvbXBvbmVudERpZE1vdW50IiwibGF5b3V0R3JvdXAiLCJzd2l0Y2hMYXlvdXRHcm91cCIsImRlZmF1bHRTY2FsZUNvcnJlY3RvcnMiLCJncm91cCIsImdldFNuYXBzaG90QmVmb3JlVXBkYXRlIiwibGF5b3V0RGVwZW5kZW5jeSIsImNvbXBvbmVudERpZFVwZGF0ZSIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwicHJvbW90ZUNvbnRleHQiLCJkZXJlZ2lzdGVyIiwiTWVhc3VyZUxheW91dCIsImpzeCIsImJveFNoYWRvdyIsImhhbmRsZUhvdmVyRXZlbnQiLCJsaWZlY3ljbGUiLCJIb3Zlckdlc3R1cmUiLCJlbmRFdmVudCIsIkZvY3VzR2VzdHVyZSIsIm9uRm9jdXMiLCJpc0ZvY3VzVmlzaWJsZSIsIm9uQmx1ciIsImhhbmRsZVByZXNzRXZlbnQiLCJQcmVzc0dlc3R1cmUiLCJwcmVzcyIsInN1Y2Nlc3MiLCJ1c2VHbG9iYWxUYXJnZXQiLCJnbG9iYWxUYXBUYXJnZXQiLCJvYnNlcnZlckNhbGxiYWNrcyIsIm9ic2VydmVycyIsImZpcmVPYnNlcnZlckNhbGxiYWNrIiwiZmlyZUFsbE9ic2VydmVyQ2FsbGJhY2tzIiwiaW5pdEludGVyc2VjdGlvbk9ic2VydmVyIiwibG9va3VwUm9vdCIsInJvb3RPYnNlcnZlcnMiLCJKU09OIiwic3RyaW5naWZ5Iiwib2JzZXJ2ZUludGVyc2VjdGlvbiIsInJvb3RJbnRlcmVzZWN0aW9uT2JzZXJ2ZXIiLCJ0aHJlc2hvbGROYW1lcyIsIkluVmlld0ZlYXR1cmUiLCJoYXNFbnRlcmVkVmlldyIsImlzSW5WaWV3Iiwic3RhcnRPYnNlcnZlciIsInZpZXdwb3J0Iiwib25jZSIsIm9uSW50ZXJzZWN0aW9uVXBkYXRlIiwib25WaWV3cG9ydEVudGVyIiwib25WaWV3cG9ydExlYXZlIiwiaGFzT3B0aW9uc0NoYW5nZWQiLCJoYXNWaWV3cG9ydE9wdGlvbkNoYW5nZWQiLCJwcmV2Vmlld3BvcnQiLCJnZXN0dXJlQW5pbWF0aW9ucyIsIk1vdGlvbkNvbmZpZ0NvbnRleHQiLCJpc1N0YXRpYyIsInJlZHVjZWRNb3Rpb24iLCJNb3Rpb25Db250ZXh0IiwidXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCIsInVzZUxheW91dEVmZmVjdCIsIkxhenlDb250ZXh0Iiwic3RyaWN0IiwidXNlVmlzdWFsRWxlbWVudCIsIlByb2plY3Rpb25Ob2RlQ29uc3RydWN0b3IiLCJsYXp5Q29udGV4dCIsInZpc3VhbEVsZW1lbnRSZWYiLCJ1c2VSZWYiLCJyZW5kZXJlciIsImluaXRpYWxMYXlvdXRHcm91cENvbmZpZyIsImNyZWF0ZVByb2plY3Rpb25Ob2RlIiwidXNlSW5zZXJ0aW9uRWZmZWN0Iiwib3B0aW1pc2VkQXBwZWFySWQiLCJ3YW50c0hhbmRvZmYiLCJNb3Rpb25IYW5kb2ZmSXNDb21wbGV0ZSIsIk1vdGlvbklzTW91bnRlZCIsIk1vdGlvbkhhbmRvZmZNYXJrQXNDb21wbGV0ZSIsImdldENsb3Nlc3RQcm9qZWN0aW5nTm9kZSIsImFsbG93UHJvamVjdGlvbiIsInVzZU1vdGlvblJlZiIsImV4dGVybmFsUmVmIiwiZ2V0Q3VycmVudFRyZWVWYXJpYW50cyIsImluaGVyaXQiLCJ1c2VDcmVhdGVNb3Rpb25Db250ZXh0IiwidXNlTWVtbyIsInZhcmlhbnRMYWJlbHNBc0RlcGVuZGVuY3kiLCJsb2FkRmVhdHVyZXMiLCJtb3Rpb25Db21wb25lbnRTeW1ib2wiLCJTeW1ib2wiLCJmb3IiLCJjcmVhdGVSZW5kZXJlck1vdGlvbkNvbXBvbmVudCIsInByZWxvYWRlZEZlYXR1cmVzIiwidXNlUmVuZGVyIiwidXNlVmlzdWFsU3RhdGUiLCJNb3Rpb25Db21wb25lbnQiLCJjb25maWdBbmRQcm9wcyIsInVzZUxheW91dElkIiwidXNlU3RyaWN0TW9kZSIsImxheW91dFByb2plY3Rpb24iLCJnZXRQcm9qZWN0aW9uRnVuY3Rpb25hbGl0eSIsImpzeHMiLCJQcm92aWRlciIsIkZvcndhcmRSZWZNb3Rpb25Db21wb25lbnQiLCJmb3J3YXJkUmVmIiwibGF5b3V0R3JvdXBJZCIsImlzU3RyaWN0Iiwic3RyaWN0TWVzc2FnZSIsImlnbm9yZVN0cmljdCIsImNvbWJpbmVkIiwibG93ZXJjYXNlU1ZHRWxlbWVudHMiLCJpc1NWR0NvbXBvbmVudCIsInVzZUNvbnN0YW50IiwibWFrZVN0YXRlIiwiY3JlYXRlUmVuZGVyU3RhdGUiLCJvbk1vdW50IiwibWFrZUxhdGVzdFZhbHVlcyIsIm1ha2VVc2VWaXN1YWxTdGF0ZSIsIm1ha2UiLCJzY3JhcGVNb3Rpb25WYWx1ZXMiLCJtb3Rpb25WYWx1ZXMiLCJpc0NvbnRyb2xsaW5nVmFyaWFudHMkMSIsImlzVmFyaWFudE5vZGUkMSIsImlzSW5pdGlhbEFuaW1hdGlvbkJsb2NrZWQiLCJ2YXJpYW50VG9TZXQiLCJsaXN0IiwiY3JlYXRlSHRtbFJlbmRlclN0YXRlIiwiY3JlYXRlU3ZnUmVuZGVyU3RhdGUiLCJzdmdNb3Rpb25Db25maWciLCJodG1sTW90aW9uQ29uZmlnIiwiY29weVJhd1ZhbHVlc09ubHkiLCJ1c2VJbml0aWFsTW90aW9uVmFsdWVzIiwidXNlU3R5bGUiLCJ1c2VIVE1MUHJvcHMiLCJodG1sUHJvcHMiLCJkcmFnZ2FibGUiLCJ1c2VyU2VsZWN0IiwiV2Via2l0VXNlclNlbGVjdCIsIldlYmtpdFRvdWNoQ2FsbG91dCIsInRvdWNoQWN0aW9uIiwidGFiSW5kZXgiLCJvblRhcCIsIm9uVGFwU3RhcnQiLCJ2YWxpZE1vdGlvblByb3BzIiwiaXNWYWxpZE1vdGlvblByb3AiLCJzaG91bGRGb3J3YXJkIiwibG9hZEV4dGVybmFsSXNWYWxpZFByb3AiLCJpc1ZhbGlkUHJvcCIsImZpbHRlclByb3BzIiwiaXNEb20iLCJmb3J3YXJkTW90aW9uUHJvcHMiLCJmaWx0ZXJlZFByb3BzIiwidXNlU1ZHUHJvcHMiLCJfaXNTdGF0aWMiLCJ2aXN1YWxQcm9wcyIsInJhd1N0eWxlcyIsImNyZWF0ZVVzZVJlbmRlciIsInVzZVZpc3VhbFByb3BzIiwiZWxlbWVudFByb3BzIiwiRnJhZ21lbnQiLCJyZW5kZXJlZENoaWxkcmVuIiwiY3JlYXRlTW90aW9uQ29tcG9uZW50RmFjdG9yeSIsImNyZWF0ZU1vdGlvbkNvbXBvbmVudCIsImJhc2VDb25maWciLCJjcmVhdGVEb21WaXN1YWxFbGVtZW50IiwibW90aW9uIiwiY3JlYXRlTWluaW1hbE1vdGlvbkNvbXBvbmVudCIsIm0iLCJQb3BDaGlsZE1lYXN1cmUiLCJjaGlsZFJlZiIsInNpemVSZWYiLCJQb3BDaGlsZCIsIm5vbmNlIiwiZGF0YXNldCIsIm1vdGlvblBvcElkIiwiaGVhZCIsImFwcGVuZENoaWxkIiwic2hlZXQiLCJpbnNlcnRSdWxlIiwicmVtb3ZlQ2hpbGQiLCJjbG9uZUVsZW1lbnQiLCJQcmVzZW5jZUNoaWxkIiwicHJlc2VuY2VBZmZlY3RzTGF5b3V0IiwibW9kZSIsInByZXNlbmNlQ2hpbGRyZW4iLCJuZXdDaGlsZHJlbk1hcCIsIm1lbW9pemVkT25FeGl0Q29tcGxldGUiLCJjaGlsZElkIiwicmFuZG9tIiwiXyIsInVzZVVubW91bnRFZmZlY3QiLCJ1c2VJc01vdW50ZWQiLCJ1c2VGb3JjZVVwZGF0ZSIsImZvcmNlZFJlbmRlckNvdW50Iiwic2V0Rm9yY2VkUmVuZGVyQ291bnQiLCJ1c2VTdGF0ZSIsImZvcmNlUmVuZGVyIiwiZGVmZXJyZWRGb3JjZVJlbmRlciIsImdldENoaWxkS2V5Iiwib25seUVsZW1lbnRzIiwiZmlsdGVyZWQiLCJDaGlsZHJlbiIsImlzVmFsaWRFbGVtZW50IiwiQW5pbWF0ZVByZXNlbmNlIiwiZXhpdEJlZm9yZUVudGVyIiwicHJlc2VudENoaWxkcmVuIiwicHJlc2VudEtleXMiLCJwZW5kaW5nUHJlc2VudENoaWxkcmVuIiwiZXhpdENvbXBsZXRlIiwiZGlmZmVkQ2hpbGRyZW4iLCJzZXREaWZmZWRDaGlsZHJlbiIsInNldFJlbmRlcmVkQ2hpbGRyZW4iLCJleGl0aW5nQ2hpbGRyZW4iLCJuZXh0Q2hpbGRyZW4iLCJvbkV4aXQiLCJpc0V2ZXJ5RXhpdENvbXBsZXRlIiwiaXNFeGl0Q29tcGxldGUiLCJNb3Rpb25Db25maWciLCJMYXp5TW90aW9uIiwic2V0SXNMb2FkZWQiLCJpc0xhenlCdW5kbGUiLCJsb2FkZWRSZW5kZXJlciIsImxvYWRlZEZlYXR1cmVzIiwiRGVwcmVjYXRlZExheW91dEdyb3VwQ29udGV4dCIsInNob3VsZEluaGVyaXRHcm91cCIsInNob3VsZEluaGVyaXRJZCIsIkxheW91dEdyb3VwIiwibGF5b3V0R3JvdXBDb250ZXh0IiwiZGVwcmVjYXRlZExheW91dEdyb3VwQ29udGV4dCIsInVwc3RyZWFtSWQiLCJtZW1vaXplZENvbnRleHQiLCJSZW9yZGVyQ29udGV4dCIsImNoZWNrUmVvcmRlciIsIm9yZGVyIiwibmV4dE9mZnNldCIsIm5leHRJdGVtIiwibmV4dExheW91dCIsIm5leHRJdGVtQ2VudGVyIiwiUmVvcmRlckdyb3VwQ29tcG9uZW50IiwiYXMiLCJvblJlb3JkZXIiLCJpc1Jlb3JkZXJpbmciLCJyZWdpc3Rlckl0ZW0iLCJpZHgiLCJjb21wYXJlTWluIiwidXBkYXRlT3JkZXIiLCJuZXdPcmRlciIsIlJlb3JkZXJHcm91cCIsInVzZU1vdGlvblZhbHVlIiwic2V0TGF0ZXN0IiwidXNlQ29tYmluZU1vdGlvblZhbHVlcyIsImNvbWJpbmVWYWx1ZXMiLCJ1cGRhdGVWYWx1ZSIsInVzZUNvbXB1dGVkIiwiY29tcHV0ZSIsInVzZVRyYW5zZm9ybSIsImlucHV0UmFuZ2VPclRyYW5zZm9ybWVyIiwidXNlTGlzdFRyYW5zZm9ybSIsInVzZURlZmF1bHRNb3Rpb25WYWx1ZSIsIlJlb3JkZXJJdGVtQ29tcG9uZW50IiwibGF0ZXN0WCIsImxhdGVzdFkiLCJnZXN0dXJlUG9pbnQiLCJvbkxheW91dE1lYXN1cmUiLCJtZWFzdXJlZCIsIlJlb3JkZXJJdGVtIiwibmFtZXNwYWNlIiwiX19wcm90b19fIiwiR3JvdXAiLCJJdGVtIiwiZG9tTWluIiwiZG9tQW5pbWF0aW9uIiwiZG9tTWF4IiwidXNlTW90aW9uVGVtcGxhdGUiLCJmcmFnbWVudHMiLCJudW1GcmFnbWVudHMiLCJidWlsZFZhbHVlIiwidG9OdW1iZXIiLCJ1c2VTcHJpbmciLCJhY3RpdmVTcHJpbmdBbmltYXRpb24iLCJsYXRlc3RTZXR0ZXIiLCJ1c2VNb3Rpb25WYWx1ZUV2ZW50IiwidXNlVmVsb2NpdHkiLCJ1cGRhdGVWZWxvY2l0eSIsInJlZldhcm5pbmciLCJjcmVhdGVTY3JvbGxNb3Rpb25WYWx1ZXMiLCJzY3JvbGxYIiwic2Nyb2xsWSIsInNjcm9sbFhQcm9ncmVzcyIsInNjcm9sbFlQcm9ncmVzcyIsInVzZVNjcm9sbCIsImxheW91dEVmZmVjdCIsInVzZUxpZmVjeWNsZUVmZmVjdCIsIl9wcm9ncmVzcyIsInVzZUVsZW1lbnRTY3JvbGwiLCJ1c2VWaWV3cG9ydFNjcm9sbCIsInVzZUFuaW1hdGlvbkZyYW1lIiwiaW5pdGlhbFRpbWVzdGFtcCIsInByb3ZpZGVUaW1lU2luY2VTdGFydCIsInVzZVRpbWUiLCJnZXRXaWxsQ2hhbmdlTmFtZSIsIldpbGxDaGFuZ2VNb3Rpb25WYWx1ZSIsInN0eWxlTmFtZSIsInVzZVdpbGxDaGFuZ2UiLCJ1c2VSZWR1Y2VkTW90aW9uIiwidXNlUmVkdWNlZE1vdGlvbkNvbmZpZyIsInJlZHVjZWRNb3Rpb25QcmVmZXJlbmNlIiwic2V0VmFyaWFudHMiLCJ2YXJpYW50TGFiZWxzIiwicmV2ZXJzZWRMYWJlbHMiLCJzZXRWYWx1ZXMiLCJhbmltYXRpb25Db250cm9scyIsImhhc01vdW50ZWQiLCJzdWJzY3JpYmVycyIsInVzZUFuaW1hdGUiLCJ1c2VBbmltYXRlTWluaSIsInVzZUFuaW1hdGlvbkNvbnRyb2xzIiwidXNlQW5pbWF0aW9uIiwidXNlQ3ljbGUiLCJpdGVtcyIsInNldEl0ZW0iLCJydW5DeWNsZSIsInVzZUluVmlldyIsInNldEluVmlldyIsIm9uRW50ZXIiLCJEcmFnQ29udHJvbHMiLCJjb21wb25lbnRDb250cm9scyIsIm5hdGl2ZUV2ZW50IiwiY3JlYXRlRHJhZ0NvbnRyb2xzIiwidXNlRHJhZ0NvbnRyb2xzIiwidXNlRG9tRXZlbnQiLCJpc01vdGlvbkNvbXBvbmVudCIsImNvbXBvbmVudCIsInVud3JhcE1vdGlvbkNvbXBvbmVudCIsInVzZUluc3RhbnRMYXlvdXRUcmFuc2l0aW9uIiwic3RhcnRUcmFuc2l0aW9uIiwidXNlSW5zdGFudFRyYW5zaXRpb24iLCJmb3JjZVVwZGF0ZSIsInN0YXJ0SW5zdGFudExheW91dFRyYW5zaXRpb24iLCJ1bmxvY2tPbkZyYW1lUmVmIiwiZGlzYWJsZUluc3RhbnRUcmFuc2l0aW9ucyIsInVzZVJlc2V0UHJvamVjdGlvbiIsImFwcGVhclN0b3JlSWQiLCJlbGVtZW50SWQiLCJhcHBlYXJBbmltYXRpb25TdG9yZSIsImFwcGVhckNvbXBsZXRlIiwiaGFuZG9mZk9wdGltaXplZEFwcGVhckFuaW1hdGlvbiIsInN0b3JlSWQiLCJvcHRpbWlzZWRBbmltYXRpb24iLCJjYW5jZWxBbmltYXRpb24iLCJzdGFydEZyYW1lVGltZSIsInJlYWR5QW5pbWF0aW9uIiwic3VzcGVuZGVkQW5pbWF0aW9ucyIsInJlc3VtZVN1c3BlbmRlZEFuaW1hdGlvbnMiLCJkYXRhIiwic3RhcnRPcHRpbWl6ZWRBcHBlYXJBbmltYXRpb24iLCJvblJlYWR5IiwiY2FuUmVzdW1lIiwidmFsdWVJc09wdGltaXNlZCIsImV4dGVybmFsQW5pbWF0aW9uVmFsdWUiLCJhcHBlYXJBbmltYXRpb24iLCJyZWFkeSIsImNyZWF0ZU9iamVjdCIsIlN0YXRlVmlzdWFsRWxlbWVudCIsInJlc3RvcmVUcmFuc2Zvcm0iLCJfc3RhdGUiLCJpbml0aWFsU3RhdGUiLCJ1c2VBbmltYXRlZFN0YXRlIiwic2V0QW5pbWF0aW9uU3RhdGUiLCJhbmltYXRpb25EZWZpbml0aW9uIiwibWF4U2NhbGUiLCJpbnZlcnRTY2FsZSIsImhhc1dhcm5lZCIsInVzZUludmVydGVkU2NhbGUiLCJwYXJlbnRTY2FsZVgiLCJwYXJlbnRTY2FsZVkiLCJBbmltYXRlU2hhcmVkTGF5b3V0IiwiaXNEcmFnQWN0aXZlIiwiUmVvcmRlciIsInVzZURlcHJlY2F0ZWRBbmltYXRlZFN0YXRlIiwidXNlRGVwcmVjYXRlZEludmVydGVkU2NhbGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/framer-motion/dist/cjs/index.js\n");

/***/ })

};
;